/* Generated code for Python module 'ipaddress'
 * created by Nuitka version 0.6.1.1
 *
 * This code is in part copyright 2018 Kay Hayen.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "nuitka/prelude.h"

#include "__helpers.h"

/* The "_module_ipaddress" is a Python object pointer of module type.
 *
 * Note: For full compatibility with CPython, every module variable access
 * needs to go through it except for cases where the module cannot possibly
 * have changed in the mean time.
 */

PyObject *module_ipaddress;
PyDictObject *moduledict_ipaddress;

/* The declarations of module constants used, if any. */
static PyObject *const_unicode_digest_98e0e324ddb3d7c17b2d051bf721997b;
static PyObject *const_unicode_digest_566097bb8b2b191c9db35f0ec86b0f33;
extern PyObject *const_str_plain_get;
extern PyObject *const_str_plain_details;
static PyObject *const_tuple_unicode_digest_4e68733735a043f5abfd5c4521f17847_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_reverse_chars_tuple;
static PyObject *const_unicode_digest_f639d7203410adb553caafbcf683161e;
static PyObject *const_str_plain_less;
extern PyObject *const_tuple_str_plain_self_str_plain_other_tuple;
static PyObject *const_unicode_digest_55950b0245a58fcb76cb0333c18a4a6a;
static PyObject *const_tuple_unicode_digest_ecd03ef7f28ff15afa162f4a843d1037_tuple;
static PyObject *const_str_plain_ip_interface;
static PyObject *const_unicode_digest_b53e8ff97e86469747c016cbda8b6b82;
extern PyObject *const_str_plain___add__;
static PyObject *const_unicode_digest_ab75335520e250f0caebe75ed640b3fc;
extern PyObject *const_str_plain_IPv4Address;
static PyObject *const_unicode_digest_5b7f2e4a3310487a05cd73dbdc2ec2d9;
extern PyObject *const_str_plain_IPv6Network;
extern PyObject *const_tuple_type_int_tuple;
static PyObject *const_str_plain__explode_shorthand_ip_string;
static PyObject *const_str_plain_overlaps;
extern PyObject *const_int_pos_192;
static PyObject *const_unicode_digest_6439cf0468d27650b3db2b06ff3a5dd1;
extern PyObject *const_str_plain_n;
static PyObject *const_str_plain_trailing_zeroes;
static PyObject *const_tuple_unicode_digest_58df9bee7efa43c9df04a29b6b187894_tuple;
static PyObject *const_str_plain_is_unspecified;
static PyObject *const_str_plain__get_address_key;
static PyObject *const_tuple_str_plain_cls_str_plain_ip_int_tuple;
static PyObject *const_str_plain__compat_range;
static PyObject *const_str_plain_nbits;
extern PyObject *const_str_plain_int;
static PyObject *const_tuple_c95f92ffec2b139e3f927147ab9edcbd_tuple;
static PyObject *const_unicode_digest_dd933a225f1d557f2f9048900cc16f9b;
static PyObject *const_tuple_b99252a717af406174a953ceba374cca_tuple;
static PyObject *const_str_plain_addr_str;
static PyObject *const_str_plain_prefixlen_str;
static PyObject *const_tuple_str_plain_self_str_plain_address_tuple;
static PyObject *const_str_plain_to_merge;
extern PyObject *const_int_pos_128;
static PyObject *const_str_plain_is_multicast;
static PyObject *const_unicode_digest_2972f45afa340c1d13e07950dc835f22;
extern PyObject *const_str_plain_hex_str;
extern PyObject *const_int_neg_1;
extern PyObject *const_str_plain_long;
extern PyObject *const_str_plain_sorted;
static PyObject *const_str_plain__parse_octet;
static PyObject *const_unicode_digest_f4190d022dc40f14076f71730abf2fd3;
static PyObject *const_unicode_digest_a334f37feab916326bca0b7fe2402491;
static PyObject *const_tuple_str_plain_cls_str_plain_prefixlen_tuple;
static PyObject *const_unicode_digest_6621db75e8d93f052f1819be23d20ce6;
static PyObject *const_str_plain__reserved_networks;
static PyObject *const_str_plain_with_netmask;
static PyObject *const_unicode_digest_eff0de065ad1be8ff8f4264ecac2dcba;
static PyObject *const_unicode_digest_32c5b15b8e2cae0f60549ea8196894b5;
static PyObject *const_str_digest_1dd9203bd723ff4d2badc10887999eb8;
static PyObject *const_str_plain_IPV6LENGTH;
extern PyObject *const_str_plain_x;
static PyObject *const_unicode_digest_8b0c900fbdeea9771930f9c584b257a2;
static PyObject *const_unicode_digest_289cab06588645bfabb37c3778356771;
static PyObject *const_unicode_digest_e987769ab2a30dcd5958c4d8a8f94f4e;
static PyObject *const_unicode_digest_53d80a3eb0c1ac5fe323045fd90a38ac;
static PyObject *const_unicode_plain___weakref__;
static PyObject *const_str_plain_byteslen;
static PyObject *const_unicode_digest_db0e07051873ab67bfbeddf5326d1061;
extern PyObject *const_long_pos_4294967295;
extern PyObject *const_long_pos_4294967296;
static PyObject *const_tuple_unicode_digest_59b4c80820858f6425abaee2308ec366_tuple;
static PyObject *const_tuple_unicode_digest_2e6e3f3d6b32093f8fc77c323d7c6fb9_tuple;
static PyObject *const_str_plain_is_reserved;
static PyObject *const_tuple_unicode_digest_194dc6db10ba74e52f6ef24612e5a44f_tuple;
static PyObject *const_tuple_str_plain_start_str_plain_end_str_plain_step_str_plain_i_tuple;
extern PyObject *const_str_plain___slots__;
static PyObject *const_unicode_digest_ab9c76df45bc1dd7612ee4e57cee2742;
extern PyObject *const_str_plain_unicode_literals;
static PyObject *const_unicode_plain_8;
static PyObject *const_unicode_plain_9;
static PyObject *const_unicode_digest_efc16551a4ac6506a616591ae7a04018;
static PyObject *const_str_plain__address_class;
static PyObject *const_unicode_plain_6;
static PyObject *const_unicode_digest_fad41d1e4e853f25a53f8ca47aca44ae;
extern PyObject *const_unicode_plain_0;
static PyObject *const_unicode_digest_7945ccf9bf2a22958263bad0bfe452b2;
static PyObject *const_unicode_plain_2;
static PyObject *const_unicode_plain_3;
static PyObject *const_unicode_plain_hostmask;
static PyObject *const_str_plain_hextets;
static PyObject *const_str_plain___sub__;
static PyObject *const_tuple_f41119394ac30f2d0b96be932770c04a_tuple;
static PyObject *const_str_plain__reverse_pointer;
extern PyObject *const_str_plain_net;
static PyObject *const_tuple_int_pos_1_none_tuple;
static PyObject *const_tuple_str_plain_address_str_plain_strict_tuple;
static PyObject *const_tuple_unicode_digest_d557365be24b3a7215b6d3030b88908b_tuple;
static PyObject *const_list_unicode_empty_list;
static PyObject *const_tuple_df9bcb1b25e9c82423695469b9a4a37f_tuple;
static PyObject *const_unicode_digest_745ce1754600cbf1b6a077d5f3024b91;
extern PyObject *const_str_angle_genexpr;
extern PyObject *const_str_plain___name__;
static PyObject *const_tuple_unicode_digest_22dfacc211498343b7c4f5bc77b1999e_tuple;
extern PyObject *const_int_pos_32;
static PyObject *const_unicode_digest_3feec7dafafbe9a5e0ca70f8d344b308;
extern PyObject *const_tuple_str_plain_self_str_plain_x_tuple;
static PyObject *const_unicode_digest_3254e3c725f90e44e7995b9143540a57;
static PyObject *const_unicode_digest_b72048f1b66f9fdd2e7e82925d13c1d2;
static PyObject *const_tuple_unicode_digest_2a285cd7527a5c5b855f32dfb8bbe6c3_tuple;
static PyObject *const_str_plain__valid_mask_octets;
static PyObject *const_tuple_str_plain_self_str_plain_address_str_plain_msg_tuple;
static PyObject *const_tuple_unicode_digest_76b74f1a00da7c59fff7c9438dba7f09_tuple;
extern PyObject *const_str_plain_res;
static PyObject *const_unicode_digest_4fad13736690efbbfb886f1de29a5548;
static PyObject *const_tuple_ff4a526b5a6a1ed69c55d5f6a48b9762_tuple;
static PyObject *const_unicode_digest_d3e4ae64d5b27931433edd93be5fc695;
extern PyObject *const_str_plain_arg;
static PyObject *const_unicode_digest_de2bfe1831dccdb3c6a1c35e78a8cfff;
static PyObject *const_str_plain__is_hostmask;
static PyObject *const_str_plain_supernet;
static PyObject *const_str_plain__compat_bit_length;
static PyObject *const_unicode_digest_cd26fcb2639894908f2563203d484a92;
static PyObject *const_unicode_digest_fc69aaef3eb8f00317a1c6cf63cf6f1e;
static PyObject *const_unicode_digest_8de571133ab8b9176c149e4e2555e2e4;
static PyObject *const_str_plain__constants;
static PyObject *const_str_plain__linklocal_network;
static PyObject *const_str_plain_last_int;
static PyObject *const_unicode_digest_59b4c80820858f6425abaee2308ec366;
static PyObject *const_str_plain_address_exclude;
static PyObject *const_tuple_unicode_digest_320cdcbfee5f1bed6142c1ec68d8d1b4_tuple;
static PyObject *const_str_plain_with_hostmask;
extern PyObject *const_str_plain_False;
static PyObject *const_str_plain_all_ones;
static PyObject *const_str_plain__cache;
static PyObject *const_unicode_digest_c9ae6211eac82f0120b847f4c6f27bb3;
static PyObject *const_unicode_plain_bit_length;
static PyObject *const_unicode_digest_ce28e1a0d596488778adc7f428c3ab1f;
static PyObject *const_unicode_digest_3b09fa45074f4957f7f10686b054a8ec;
extern PyObject *const_unicode_plain_big;
static PyObject *const_str_plain__make_netmask;
static PyObject *const_unicode_digest_2c28e42f0eba3d090f3252a34ee21d01;
static PyObject *const_tuple_61c8af5e7aa68d9f21df00511cc97c77_tuple;
static PyObject *const_unicode_digest_dc01540d6d8926dde62d972412f10f57;
static PyObject *const_str_plain_ip_bits;
static PyObject *const_unicode_digest_29df0a9c7866e00435cc16fa8f0aec14;
static PyObject *const_str_plain_parts_skipped;
static PyObject *const_str_plain__parse_hextet;
static PyObject *const_str_plain__prefix_from_prefix_string;
static PyObject *const_unicode_digest_25403b7f1a1d82d5241e55405508207f;
static PyObject *const_unicode_digest_c18094a902653dc9c8bc33f8a5603fb5;
static PyObject *const_str_plain__public_network;
static PyObject *const_str_plain__prefix_from_ip_string;
static PyObject *const_unicode_digest_9d31f3ec37b1a08172a39ca753627f89;
extern PyObject *const_str_plain_length;
extern PyObject *const_tuple_type_ValueError_tuple;
static PyObject *const_str_plain_max_prefixlen;
static PyObject *const_unicode_digest_509911ef653d68dc2d9e8bf72450b69f;
static PyObject *const_str_plain__split_optional_netmask;
static PyObject *const_unicode_digest_fbf09f2b8368dad5ab4255c739a502ac;
extern PyObject *const_tuple_unicode_dot_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_reverse_octets_tuple;
extern PyObject *const_tuple_str_plain_self_str_plain_msg_tuple;
static PyObject *const_unicode_digest_32cd97b7f60de6dc3859a99c1b5562c5;
static PyObject *const_str_plain_ips;
static PyObject *const_unicode_digest_e05179e2703db9ae8abe267335566873;
static PyObject *const_unicode_digest_adc545fc78271f8a7bba433d2d4f8995;
static PyObject *const_str_plain__ip_int_from_prefix;
static PyObject *const_str_plain__ip_int_from_string;
static PyObject *const_unicode_digest_572d7cc1bd08b37563d1969e4898e12a;
static PyObject *const_unicode_digest_8ae547298da00f3e03c0a262558b355e;
static PyObject *const_str_plain_compressed;
static PyObject *const_str_plain_supernet_of;
extern PyObject *const_str_plain_None;
extern PyObject *const_int_pos_254;
static PyObject *const_str_plain_reverse_pointer;
static PyObject *const_str_plain_AddressValueError;
static PyObject *const_str_plain__BaseNetwork;
static PyObject *const_str_plain_NetmaskValueError;
static PyObject *const_unicode_digest_19653372c9d87d543bd1a3a25c524778;
extern PyObject *const_str_plain___reduce__;
static PyObject *const_str_plain__get_networks_key;
static PyObject *const_str_plain_endianess;
static PyObject *const_tuple_unicode_digest_f96a90c13f1d84402c514b6ee611aea1_tuple;
extern PyObject *const_int_pos_96;
static PyObject *const_unicode_digest_d34b52cbd25eb67200141aed7e8a5928;
static PyObject *const_str_plain__report_invalid_netmask;
static PyObject *const_str_plain__ALL_ONES;
extern PyObject *const_tuple_empty;
static PyObject *const_unicode_digest_320cdcbfee5f1bed6142c1ec68d8d1b4;
static PyObject *const_unicode_digest_57ad7c388c09157d6398d6e4e29b2ea6;
static PyObject *const_unicode_digest_82f1741cd06220f67668319322d6ad23;
static PyObject *const_tuple_str_plain_intval_str_plain_length_str_plain_endianess_tuple;
static PyObject *const_unicode_digest_5bbe393519c9f8f834b0e4362b7f4892;
static PyObject *const_str_digest_11a7e09c00a35df5b21f6600c68e78d8;
static PyObject *const_unicode_digest_283a86aa738f016354d4630f6f9478f9;
extern PyObject *const_str_plain_strict;
static PyObject *const_unicode_plain_broadcast_address;
static PyObject *const_str_plain__max_parts;
extern PyObject *const_str_plain_first;
static PyObject *const_str_plain_hextet;
static PyObject *const_str_plain_new_prefix;
static PyObject *const_str_plain_best_doublecolon_len;
extern PyObject *const_str_plain___iter__;
extern PyObject *const_str_plain_netmask;
static PyObject *const_tuple_unicode_digest_d3e4ae64d5b27931433edd93be5fc695_tuple;
static PyObject *const_str_plain_best_doublecolon_end;
extern PyObject *const_str_plain___debug__;
static PyObject *const_unicode_digest_24de17cd9f039f640eb11d2c2ddbd04c;
static PyObject *const_str_plain_expected_len;
static PyObject *const_unicode_digest_7f00060466647c49fa48da2be5e497c8;
static PyObject *const_str_plain__HEX_DIGITS;
static PyObject *const_tuple_9ff79281bff64fe91204cce2984dfc9d_tuple;
static PyObject *const_long_pos_18446744073709551615;
extern PyObject *const_str_plain_addr;
static PyObject *const_unicode_digest_6fd026f58df80ebafc0af41197edbd33;
static PyObject *const_tuple_unicode_plain__ip_unicode_plain___weakref___tuple;
static PyObject *const_str_plain_hextet_str;
static PyObject *const_unicode_digest_582de6307aaf0806e961bc838a12ef52;
static PyObject *const_unicode_digest_87af500436080f92b2724f59f56f083f;
static PyObject *const_str_plain__private_networks;
extern PyObject *const_str_plain_map;
static PyObject *const_unicode_digest_23a8e74f4b615fbfc9e5a160a861c61a;
static PyObject *const_unicode_digest_f9bc333483c82191ecd263b25cbcf60d;
static PyObject *const_unicode_digest_58df9bee7efa43c9df04a29b6b187894;
static PyObject *const_str_plain__check_int_address;
static PyObject *const_str_plain_parts_lo;
static PyObject *const_unicode_digest_faf8e5c5460d2a31764ac224ef24fa52;
static PyObject *const_tuple_1d39f04be793fb75107492e9cda65f46_tuple;
static PyObject *const_str_plain__BaseAddress;
extern PyObject *const_str_plain___file__;
static PyObject *const_unicode_digest_c844160122a9f5474c7a0c0184598e9b;
static PyObject *const_unicode_digest_780f01a2ac4ecdb58e54af04ef9a0303;
extern PyObject *const_str_plain_last;
static PyObject *const_str_plain__HEXTET_COUNT;
extern PyObject *const_str_plain_str;
extern PyObject *const_str_plain___getitem__;
static PyObject *const_str_plain_new_addr;
static PyObject *const_str_plain_subnets;
extern PyObject *const_str_plain__version;
static PyObject *const_unicode_digest_0b68f1d1670be58439f575ba680b882d;
static PyObject *const_unicode_digest_a903554c9d4eb1e89ecedb79be4218d2;
extern PyObject *const_str_plain___metaclass__;
extern PyObject *const_str_plain_number;
static PyObject *const_unicode_digest_101ebce5f61c0ce299ab3ac572b746e7;
static PyObject *const_dict_23947da529d495c5b5d02e68c2d46c17;
static PyObject *const_str_plain__IPv6Constants;
static PyObject *const_tuple_f3db2b00dcab6aff87703f38eede988a_tuple;
static PyObject *const_unicode_digest_6bc44a3bd13949ad6cfa5e1484201995;
extern PyObject *const_int_pos_255;
static PyObject *const_tuple_unicode_digest_b6c766f070c655516752216bf2bdd0c4_tuple;
static PyObject *const_unicode_digest_24e54315d820212332afec6f6ec23e9d;
static PyObject *const_unicode_digest_ecd03ef7f28ff15afa162f4a843d1037;
extern PyObject *const_str_plain_replace;
extern PyObject *const_int_pos_252;
static PyObject *const_unicode_digest_1c66251700e583bec5e8354f1f3817f8;
static PyObject *const_tuple_f8d906ece65b18c6af8aaf87035aebfe_tuple;
static PyObject *const_str_plain_sixtofour;
extern PyObject *const_int_pos_24;
extern PyObject *const_str_plain___lt__;
static PyObject *const_tuple_unicode_digest_6bc44a3bd13949ad6cfa5e1484201995_tuple;
static PyObject *const_unicode_digest_91f907426d1690d534d93dfdd7289bce;
static PyObject *const_str_plain__unspecified_address;
static PyObject *const_str_digest_1ab9d69575e4bd45bb288b6bd05cd8cc;
extern PyObject *const_unicode_digest_1cfaa7410665eaa83a33dc9c2b2ef5a2;
extern PyObject *const_unicode_empty;
static PyObject *const_str_plain_existing;
static PyObject *const_str_plain__DECIMAL_DIGITS;
static PyObject *const_unicode_digest_fce80ade8999b448027d3bc78b9fd2e2;
static PyObject *const_unicode_digest_405ec5ff1c943cd273b0a0932b950391;
static PyObject *const_tuple_be53fac8911619da3fa3e231a9b3c752_tuple;
static PyObject *const_str_plain__compat_str;
static PyObject *const_tuple_str_plain_cls_str_plain_netmask_str_str_plain_msg_tuple;
static PyObject *const_str_plain__compat_bytes_to_byte_vals;
static PyObject *const_str_plain_prefixlen;
static PyObject *const_str_plain_ip_str;
static PyObject *const_unicode_digest_9462791757a5ac738cf1ca2dd1f09e95;
static PyObject *const_unicode_plain__ip;
extern PyObject *const_str_plain_msg;
static PyObject *const_tuple_str_plain_self_str_plain_address_str_plain_addr_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_other_str_plain_s2_str_plain_s1_tuple;
static PyObject *const_str_plain_subnet_of;
extern PyObject *const_tuple_unicode_chr_58_tuple;
static PyObject *const_unicode_digest_6a98397c0892ba5e9c29046762cbb9d8;
static PyObject *const_unicode_digest_caccb9a882e33dc7cad6440d3039a297;
static PyObject *const_tuple_unicode_digest_5685a0dd95ca231c7a311dcc298d847e_tuple;
static PyObject *const_unicode_digest_43b2afee270b7a4815a53cb0c30479ad;
static PyObject *const_dict_b84735d462e535bfd6f6cd43e07133d4;
static PyObject *const_str_digest_8060bd90928781385c4bd80fdfcf370e;
extern PyObject *const_int_pos_28;
static PyObject *const_dict_722093ea3cb4d742ab031ea9dda12a84;
static PyObject *const_unicode_digest_6d039f42f7b89c8dc0c9eb3f203555ab;
static PyObject *const_int_pos_536936448;
static PyObject *const_unicode_digest_f70fd07d18881f54cf18de3ff6348c33;
static PyObject *const_tuple_unicode_digest_d399497e3404869de2f90bc4536c2cea_tuple;
static PyObject *const_unicode_digest_98c89e98d08dd7d28bf0635a719bf24d;
extern PyObject *const_str_plain_struct;
static PyObject *const_str_plain__count_righthand_zero_bits;
static PyObject *const_str_plain_summarize_address_range;
static PyObject *const_unicode_digest_5685a0dd95ca231c7a311dcc298d847e;
static PyObject *const_unicode_digest_10cfd1ff9fa2b2c1de094f0f58ee69fd;
static PyObject *const_str_plain_byt;
static PyObject *const_unicode_digest_59e693b3e55c03cdfbf51d3bfd2ecbbe;
extern PyObject *const_str_plain_itertools;
extern PyObject *const_tuple_int_pos_1_tuple;
static PyObject *const_unicode_digest_d557365be24b3a7215b6d3030b88908b;
static PyObject *const_unicode_digest_0210282788da1a1bc7085fe52fd6486f;
static PyObject *const_str_plain_bvs;
static PyObject *const_unicode_digest_aaa8df82589e3fcc3c5dc300a83c6345;
static PyObject *const_tuple_unicode_plain_broadcast_address_tuple;
static PyObject *const_unicode_digest_2a285cd7527a5c5b855f32dfb8bbe6c3;
static PyObject *const_unicode_digest_bd8ac84a857b4ed91963d33543ce504a;
static PyObject *const_unicode_digest_f5f271ff00e96b68abb5b126c6b3f130;
static PyObject *const_str_digest_a25a001858b466f6be5039bbd12f63ef;
static PyObject *const_unicode_digest_fcd0b976a07f817f01888853a28920d5;
static PyObject *const_str_plain_v6_int_to_packed;
extern PyObject *const_int_pos_65535;
extern PyObject *const_str_plain_pop;
static PyObject *const_unicode_digest_74272e9e6b29f827a4600cd9d4bfe9d6;
static PyObject *const_unicode_plain_5;
static PyObject *const_tuple_str_plain_cls_str_plain_ip_str_str_plain_ip_int_tuple;
static PyObject *const_unicode_digest_4e11e045f071f5745153d71dc21282d3;
static PyObject *const_unicode_digest_12c0ce2344269ec0369906c845e61853;
extern PyObject *const_str_plain_IPv4Network;
static PyObject *const_unicode_digest_e387280a229c9db974e6c776d288bba6;
static PyObject *const_unicode_digest_786511cd0da76607fa48edaa91095b3b;
extern PyObject *const_tuple_type_object_tuple;
static PyObject *const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_b_tuple;
static PyObject *const_str_plain__netmask_cache;
extern PyObject *const_unicode_chr_47;
static PyObject *const_str_plain__string_from_ip_int;
static PyObject *const_str_plain_leading_ones;
static PyObject *const_tuple_unicode_digest_e9b7b96fb2ce3038ca93557a305aee61_tuple;
extern PyObject *const_str_plain_type;
static PyObject *const_str_plain_ipv4_int;
static PyObject *const_str_plain__TotalOrderingMixin;
static PyObject *const_unicode_digest_04311a35f70305eb6ef19122d29249c2;
static PyObject *const_str_plain_prefixlen_diff;
static PyObject *const_str_plain__prefixlen;
extern PyObject *const_str_plain_cls;
static PyObject *const_unicode_digest_e4b0d176f96493dd1d5d8cbd14cab77e;
static PyObject *const_unicode_digest_5eb59a83c37d07a28c39bc523d9a7e7b;
static PyObject *const_tuple_str_plain_self_str_plain_other_str_plain_less_tuple;
static PyObject *const_unicode_digest_d5a1201fe07f6f7e80d19f19f44f0cfb;
static PyObject *const_str_plain_octet_str;
static PyObject *const_unicode_digest_4e68733735a043f5abfd5c4521f17847;
static PyObject *const_unicode_digest_6525f1cc4fe3bcdb3c861d0842343832;
static PyObject *const_tuple_str_plain_cls_str_plain_hextet_str_str_plain_msg_tuple;
static PyObject *const_str_plain__sitelocal_network;
static PyObject *const_tuple_unicode_digest_9462791757a5ac738cf1ca2dd1f09e95_tuple;
static PyObject *const_tuple_unicode_digest_5eb59a83c37d07a28c39bc523d9a7e7b_tuple;
extern PyObject *const_str_plain_object;
static PyObject *const_tuple_unicode_digest_101ebce5f61c0ce299ab3ac572b746e7_tuple;
static PyObject *const_str_plain__compat_to_bytes;
extern PyObject *const_str_plain___ne__;
static PyObject *const_str_plain_best_doublecolon_start;
extern PyObject *const_str_plain_pack;
static PyObject *const_unicode_digest_713ebfce2d10e63958e8edc4d67a9c94;
static PyObject *const_unicode_digest_c50e4b7ca59e04bf8bf40c8c074f23f7;
extern PyObject *const_str_plain_self;
extern PyObject *const_str_plain_enumerate;
static PyObject *const_int_pos_8194;
extern PyObject *const_str_plain_obj;
static PyObject *const_str_plain_nets;
static PyObject *const_unicode_digest_fdc180e651f53b5645d6e63208353e99;
static PyObject *const_unicode_digest_92c107dbe635b4b79a97075dcd49ce3d;
static PyObject *const_unicode_digest_7322ea8f60136157d13c0a45146fd35a;
static PyObject *const_frozenset_66c1acb9d1286c78b6365c163e59bc78;
static PyObject *const_tuple_unicode_digest_ed7b60fe5be95741a2db22da8e4c1100_tuple;
static PyObject *const_unicode_digest_194dc6db10ba74e52f6ef24612e5a44f;
extern PyObject *const_int_pos_64;
static PyObject *const_unicode_digest_76b74f1a00da7c59fff7c9438dba7f09;
static PyObject *const_str_plain__compat_int_from_byte_vals;
static PyObject *const_str_plain_is_site_local;
static PyObject *const_unicode_digest_0d4549e3c9ba6b05a7194583ebe788ee;
static PyObject *const_tuple_str_plain_self_str_plain_other_str_plain_address_equal_tuple;
static PyObject *const_str_plain_broadcast;
extern PyObject *const_int_pos_80;
extern PyObject *const_str_plain_min;
static PyObject *const_tuple_unicode_chr_58_unicode_empty_tuple;
static PyObject *const_str_plain__compress_hextets;
extern PyObject *const_int_pos_20;
extern PyObject *const_int_pos_10;
extern PyObject *const_int_pos_12;
extern PyObject *const_tuple_str_plain_self_tuple;
static PyObject *const_frozenset_bcfae996d3e8c0199d3734036089d854;
static PyObject *const_str_plain_skip_index;
extern PyObject *const_int_pos_16;
extern PyObject *const_str_plain_error;
static PyObject *const_unicode_plain_7;
extern PyObject *const_str_digest_b1ef207a7bd9f620d0198dc6c7356419;
static PyObject *const_str_plain_equal;
static PyObject *const_unicode_digest_da1818644dfbad301b75eda6d440ddac;
static PyObject *const_unicode_digest_f46719d0b0a4fb0eb47fa9ca9304fff5;
extern PyObject *const_tuple_type_int_type_long_tuple;
extern PyObject *const_int_pos_224;
static PyObject *const_tuple_str_plain_number_str_plain_bits_tuple;
static PyObject *const_unicode_digest_b75fb6a47d7489ff4ba1e06eb56d2178;
extern PyObject *const_int_pos_6;
extern PyObject *const_int_pos_7;
extern PyObject *const_int_pos_4;
extern PyObject *const_int_pos_2;
extern PyObject *const_int_pos_3;
extern PyObject *const_int_pos_1;
extern PyObject *const_int_pos_8;
static PyObject *const_tuple_str_plain_i_str_plain_res_tuple;
extern PyObject *const_str_plain_current;
static PyObject *const_str_plain_IPv4Interface;
static PyObject *const_unicode_digest_9cdf3b748ac1a53affbd72eda589ecda;
extern PyObject *const_slice_none_none_int_neg_1;
extern PyObject *const_tuple_true_tuple;
static PyObject *const_str_plain__compat_int_types;
static PyObject *const_str_plain_is_link_local;
static PyObject *const_tuple_ebba5bcca06086e920bc53fbfdc7c8df_tuple;
extern PyObject *const_str_plain_unpack;
static PyObject *const_unicode_digest_b6c766f070c655516752216bf2bdd0c4;
static PyObject *const_unicode_digest_11db8dad0fdf85c306f5f6455601667d;
static PyObject *const_unicode_digest_d399497e3404869de2f90bc4536c2cea;
static PyObject *const_tuple_unicode_digest_405ec5ff1c943cd273b0a0932b950391_tuple;
static PyObject *const_str_plain_intval;
static PyObject *const_str_plain_reverse_chars;
static PyObject *const_unicode_digest_4a4ec0bacc4ed8ebd5a4ce6c53c46388;
static PyObject *const_str_plain_doublecolon_start;
static PyObject *const_str_plain__reserved_network;
static PyObject *const_unicode_digest_187d30b5b2f1b6be67346bce62c4882f;
static PyObject *const_unicode_digest_c4c97910d07aba163465ecf409f4030a;
static PyObject *const_tuple_unicode_digest_97a8ca337c0108210bc28d6fe8f8ec60_tuple;
extern PyObject *const_str_plain___hash__;
static PyObject *const_unicode_digest_d44bacc2290b5d18e632348ff9d94d65;
static PyObject *const_unicode_digest_dec03ab398d5a59037dd890fd3350705;
static PyObject *const_str_plain__min_parts;
static PyObject *const_unicode_digest_ac7f50929eae86b4966b77df5788b37d;
extern PyObject *const_str_plain_it;
static PyObject *const_unicode_plain_network_address;
extern PyObject *const_str_plain_ip;
extern PyObject *const_str_plain___eq__;
extern PyObject *const_str_plain___le__;
static PyObject *const_int_pos_248;
extern PyObject *const_str_plain_extend;
extern PyObject *const_int_pos_240;
static PyObject *const_tuple_unicode_digest_9b517c1b35c5efe37b498ee36f2a46c2_tuple;
static PyObject *const_unicode_digest_f96a90c13f1d84402c514b6ee611aea1;
static PyObject *const_str_plain_teredo;
static PyObject *const_tuple_9098f7d838724863c7318ae87cb1bc40_tuple;
static PyObject *const_str_plain_address_less;
extern PyObject *const_str_plain_i;
static PyObject *const_unicode_digest_22dfacc211498343b7c4f5bc77b1999e;
static PyObject *const_str_plain_is_private;
extern PyObject *const_str_plain_b;
static PyObject *const_tuple_unicode_digest_5bbe393519c9f8f834b0e4362b7f4892_tuple;
static PyObject *const_str_plain_address_equal;
extern PyObject *const_str_plain___contains__;
extern PyObject *const_str_plain_num_addresses;
static PyObject *const_str_plain__IPAddressBase;
static PyObject *const_unicode_digest_72c7247958606980b87c9cb8a19ea8a1;
extern PyObject *const_str_plain_address;
static PyObject *const_str_plain_is_global;
static PyObject *const_tuple_unicode_digest_ab9c76df45bc1dd7612ee4e57cee2742_tuple;
static PyObject *const_unicode_digest_2bc0198930fe74059a20349326880c0a;
static PyObject *const_unicode_digest_e117cb895af56362aabb03455887d34f;
static PyObject *const_str_plain_octet_int;
static PyObject *const_tuple_3c4458665ec97984dbef4c959f27790d_tuple;
static PyObject *const_tuple_unicode_digest_8de571133ab8b9176c149e4e2555e2e4_tuple;
static PyObject *const_str_plain_compare_networks;
extern PyObject *const_unicode_dot;
static PyObject *const_tuple_unicode_digest_25403b7f1a1d82d5241e55405508207f_tuple;
static PyObject *const_str_plain_doublecolon_len;
extern PyObject *const_str_plain_start;
static PyObject *const_str_plain_collapse_addresses;
static PyObject *const_unicode_digest_dddb1f670b53dd4bfeade670d60a460f;
static PyObject *const_str_plain_broadcast_address;
extern PyObject *const_int_0;
static PyObject *const_str_plain_first_int;
static PyObject *const_tuple_unicode_digest_aaa8df82589e3fcc3c5dc300a83c6345_tuple;
static PyObject *const_str_plain_is_loopback;
static PyObject *const_tuple_unicode_digest_8f4a5718a9f7024daab1c7cbc36c9839_tuple;
static PyObject *const_tuple_unicode_digest_509911ef653d68dc2d9e8bf72450b69f_tuple;
extern PyObject *const_str_plain___version__;
extern PyObject *const_str_plain_IPv6Address;
static PyObject *const_str_plain_IPv6Interface;
static PyObject *const_unicode_plain_4;
static PyObject *const_str_plain__BaseV4;
static PyObject *const_str_plain__BaseV6;
extern PyObject *const_str_plain___init__;
static PyObject *const_unicode_digest_7ed15216d64208508e99692b4f3b95c2;
extern PyObject *const_str_plain_exploded;
static PyObject *const_unicode_digest_2cede8cd7bf3896918371527eb9b7688;
extern PyObject *const_str_plain___gt__;
extern PyObject *const_str_plain_append;
static PyObject *const_frozenset_92edb4f75c5f6d7fbad23f3049445af9;
static PyObject *const_unicode_digest_4d7919668db95bf4651353bc6dceea2a;
static PyObject *const_str_plain__max_prefixlen;
extern PyObject *const_unicode_plain_1;
static PyObject *const_tuple_str_plain_byt_str_plain_b_tuple;
static PyObject *const_tuple_unicode_digest_e387280a229c9db974e6c776d288bba6_tuple;
extern PyObject *const_str_plain_bits;
static PyObject *const_unicode_digest_b42e9aabcda64e41c569cb9a106baed7;
static PyObject *const_str_plain_get_mixed_type_key;
static PyObject *const_str_plain_parts_hi;
extern PyObject *const_b17c9d41053ae43805ed23be533f361d;
static PyObject *const_tuple_unicode_digest_e4b0d176f96493dd1d5d8cbd14cab77e_tuple;
static PyObject *const_unicode_digest_07222984af8a611c2d56ff1f58bcbed2;
static PyObject *const_unicode_digest_9ccf09593a54d4a7dcc17d246e4f9cea;
static PyObject *const_str_plain_addresses;
static PyObject *const_tuple_unicode_digest_dd933a225f1d557f2f9048900cc16f9b_tuple;
extern PyObject *const_str_plain_network_address;
static PyObject *const_unicode_digest_90bd5c6e55bae17fe8d70044d13f64fa;
extern PyObject *const_str_plain_property;
static PyObject *const_str_plain_IPV4LENGTH;
static PyObject *const_str_plain__ip;
extern PyObject *const_str_plain_count;
extern PyObject *const_str_plain_version;
static PyObject *const_str_plain_bytvals;
extern PyObject *const_str_plain_step;
static PyObject *const_unicode_digest_e44f916e3d7ef9d976f7d25c6c24f69c;
extern PyObject *const_str_plain_exc;
static PyObject *const_unicode_digest_93b62600511a380f0935203a9df4765e;
static PyObject *const_unicode_digest_97a8ca337c0108210bc28d6fe8f8ec60;
extern PyObject *const_str_plain___repr__;
extern PyObject *const_unicode_chr_58;
extern PyObject *const_int_pos_112;
static PyObject *const_unicode_digest_edea999b5d5c2e617dee49e550687c1b;
extern PyObject *const_str_plain_unicode;
static PyObject *const_tuple_eb9d897fb9f331042703df74e8349709_tuple;
static PyObject *const_str_plain__collapse_addresses_internal;
static PyObject *const_str_plain_bv;
static PyObject *const_unicode_digest_9b517c1b35c5efe37b498ee36f2a46c2;
static PyObject *const_unicode_digest_e9b7b96fb2ce3038ca93557a305aee61;
extern PyObject *const_tuple_str_plain_i_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_other_str_plain_equal_tuple;
static PyObject *const_unicode_digest_e58d37c1cbee6b52618f84115bc05cfc;
static PyObject *const_str_plain__IPv4Constants;
extern PyObject *const_str_plain_parts;
static PyObject *const_tuple_unicode_digest_5b7f2e4a3310487a05cd73dbdc2ec2d9_tuple;
static PyObject *const_tuple_f0912223de68829e67499bcb23f9060a_tuple;
static PyObject *const_tuple_unicode_plain_hostmask_tuple;
static PyObject *const_tuple_unicode_digest_07222984af8a611c2d56ff1f58bcbed2_tuple;
extern PyObject *const_str_plain___str__;
static PyObject *const_unicode_digest_a8976dae4f4cb6a171c90676e02e7864;
static PyObject *const_unicode_digest_d83a1159969df2ac8ecaadc60ffc52aa;
static PyObject *const_unicode_digest_87736fe902d897d977541c59e5443d08;
static PyObject *const_unicode_digest_8f4a5718a9f7024daab1c7cbc36c9839;
static PyObject *const_unicode_digest_3f6240938cc8b4c3691344def7c310a8;
static PyObject *const_str_plain_address_len;
static PyObject *const_tuple_unicode_digest_93b62600511a380f0935203a9df4765e_tuple;
static PyObject *const_str_plain_issuperset;
static PyObject *const_str_plain_v4_int_to_packed;
extern PyObject *const_str_plain_split;
static PyObject *const_str_plain__multicast_network;
static PyObject *const_str_plain_ip_int;
static PyObject *const_str_plain_hosts;
extern PyObject *const_str_digest_b9c4baf879ebd882d40843df3a4dead7;
static PyObject *const_str_plain_ipv4_mapped;
static PyObject *const_tuple_unicode_digest_dadff6dd3651f30e8cbbdd26cdbce215_tuple;
static PyObject *const_unicode_digest_54697220435798be94259c75534ddc2b;
static PyObject *const_unicode_digest_a2d4646a8cc0fa37c20d1bd32a19571f;
extern PyObject *const_str_plain_join;
static PyObject *const_tuple_50559fec2f469c57aa556ccd83f2df71_tuple;
static PyObject *const_unicode_digest_47216010aeed65d4a29c64ed034fbfdb;
static PyObject *const_tuple_unicode_digest_eabcf4377ca85e7b53b572d3d3177fe1_tuple;
static PyObject *const_tuple_unicode_digest_fce80ade8999b448027d3bc78b9fd2e2_tuple;
static PyObject *const_unicode_digest_f77aa8bd91c4bb866a3ac2b2f1ae555f;
static PyObject *const_str_plain_reverse_octets;
static PyObject *const_tuple_20590e930689906083ade7009277cd69_tuple;
static PyObject *const_str_plain_netmask_str;
extern PyObject *const_str_plain___module__;
static PyObject *const_unicode_digest_5381a247d80f448053c8b52e061aecc0;
static PyObject *const_tuple_a0fcb231785a6904cd1cb11afbf3073f_tuple;
static PyObject *const_unicode_digest_eabcf4377ca85e7b53b572d3d3177fe1;
static PyObject *const_str_plain_hostmask;
static PyObject *const_tuple_f71b17521653e2cdc027d93583942731_tuple;
static PyObject *const_str_plain__check_packed_address;
static PyObject *const_unicode_digest_a6071b8f181f3ae395076bdc2a3c343f;
extern PyObject *const_str_plain_network;
static PyObject *const_unicode_digest_7034ed78731a4da5e33c8be78a50d678;
static PyObject *const_tuple_str_plain_address_tuple;
static PyObject *const_unicode_digest_e922c2e07060bd895f3f403962951e84;
static PyObject *const_tuple_afca6ebc709d3fc175a5c8a3ab536908_tuple;
static PyObject *const_unicode_digest_a6ef81b4dc8d6ca51bcc72d4b8e50fda;
static PyObject *const_unicode_digest_fd94faa8eb259b55b9c302cc8ca594ce;
extern PyObject *const_str_plain_octets;
static PyObject *const_tuple_str_plain_self_str_plain_other_str_plain_address_less_tuple;
static PyObject *const_tuple_unicode_digest_1c66251700e583bec5e8354f1f3817f8_tuple;
static PyObject *const_unicode_digest_5efcd38faf89c403a070f9e85430b29c;
static PyObject *const_tuple_unicode_digest_f639d7203410adb553caafbcf683161e_tuple;
extern PyObject *const_str_plain_values;
static PyObject *const_unicode_digest_307b618e8fe3dea44ed44b7622abf36e;
static PyObject *const_unicode_digest_2d8623d8a6589c5a67c27cdfbfcf46e3;
static PyObject *const_tuple_unicode_digest_fdc180e651f53b5645d6e63208353e99_tuple;
extern PyObject *const_str_plain_ip_network;
static PyObject *const_unicode_digest_748251f41c9803a0c044ac91f17a32ea;
static PyObject *const_tuple_str_plain_cls_str_plain_prefixlen_str_str_plain_prefixlen_tuple;
extern PyObject *const_str_plain_ip_address;
static PyObject *const_tuple_unicode_digest_6439cf0468d27650b3db2b06ff3a5dd1_tuple;
extern PyObject *const_str_plain_other;
static PyObject *const_unicode_digest_2e6e3f3d6b32093f8fc77c323d7c6fb9;
static PyObject *const_unicode_digest_dce79371adf00f5e6de2f2d426c56f59;
static PyObject *const_unicode_digest_7e2f39ab56e1398f630fda41c7d495e6;
extern PyObject *const_str_plain_ipaddress;
static PyObject *const_tuple_unicode_digest_307b618e8fe3dea44ed44b7622abf36e_tuple;
static PyObject *const_tuple_4cc0ec93b988fc0a4ad89cdb6c285e41_tuple;
extern PyObject *const_str_plain_bit_length;
extern PyObject *const_str_plain___ge__;
static PyObject *const_unicode_digest_577627ae9fd0ef6e23ffee5af41f536a;
extern PyObject *const_tuple_str_plain_obj_tuple;
extern PyObject *const_str_plain_s1;
static PyObject *const_tuple_3447faa1dbe297d65e63446bccca6976_tuple;
static PyObject *const_unicode_digest_dadff6dd3651f30e8cbbdd26cdbce215;
static PyObject *const_unicode_digest_eddf7f22fedb80dd2c5a5c8cec1a1c87;
static PyObject *const_unicode_digest_3d11cbcbf80fa8d2b7c658c556c6918d;
static PyObject *const_unicode_digest_ed7b60fe5be95741a2db22da8e4c1100;
extern PyObject *const_str_plain___int__;
static PyObject *const_unicode_digest_da5f25ffc686d67b336b34206396de7f;
static PyObject *const_unicode_digest_40b73348e084c4c5959abc33f03bc16b;
extern PyObject *const_str_plain_any;
extern PyObject *const_tuple_unicode_chr_47_tuple;
static PyObject *const_tuple_unicode_digest_55950b0245a58fcb76cb0333c18a4a6a_tuple;
static PyObject *const_unicode_digest_2ad4c551e3bacbb3a65998acbd70fdf9;
static PyObject *const_str_plain_new_prefixlen;
extern PyObject *const_str_plain_index;
extern PyObject *const_str_plain___doc__;
static PyObject *const_unicode_digest_e9ecc59b2023c50be0d8f9a9c8aa42f1;
static PyObject *const_str_plain__prefix_from_ip_int;
static PyObject *const_str_plain_addrs;
static PyObject *const_str_plain__find_address_range;
extern PyObject *const_str_plain_tuple;
static PyObject *const_tuple_d399ac830896faf254f71a17c228dc91_tuple;
extern PyObject *const_str_plain_end;
extern PyObject *const_tuple_15847381bc67e44c74cc6010c7c7f848_tuple;
extern PyObject *const_str_plain_s2;
static PyObject *const_tuple_str_plain_address_str_plain_addr_tuple;
extern PyObject *const_str_plain_packed;
static PyObject *const_unicode_digest_b3a9fa271b1ea846799383360611cf70;
static PyObject *const_str_plain_with_prefixlen;
extern PyObject *const_tuple_none_tuple;
static PyObject *const_str_plain__loopback_network;
static PyObject *module_filename_obj;

/* Indicator if this modules private constants were created yet. */
static bool constants_created = false;

/* Function to create module private constants. */
static void createModuleConstants( void )
{
    const_unicode_digest_98e0e324ddb3d7c17b2d051bf721997b = UNSTREAM_UNICODE( &constant_bin[ 896706 ], 51 );
    const_unicode_digest_566097bb8b2b191c9db35f0ec86b0f33 = UNSTREAM_UNICODE( &constant_bin[ 896757 ], 182 );
    const_tuple_unicode_digest_4e68733735a043f5abfd5c4521f17847_tuple = PyTuple_New( 1 );
    const_unicode_digest_4e68733735a043f5abfd5c4521f17847 = UNSTREAM_UNICODE( &constant_bin[ 896939 ], 9 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_4e68733735a043f5abfd5c4521f17847_tuple, 0, const_unicode_digest_4e68733735a043f5abfd5c4521f17847 ); Py_INCREF( const_unicode_digest_4e68733735a043f5abfd5c4521f17847 );
    const_tuple_str_plain_self_str_plain_reverse_chars_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_reverse_chars_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_reverse_chars = UNSTREAM_STRING( &constant_bin[ 896948 ], 13, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_reverse_chars_tuple, 1, const_str_plain_reverse_chars ); Py_INCREF( const_str_plain_reverse_chars );
    const_unicode_digest_f639d7203410adb553caafbcf683161e = UNSTREAM_UNICODE( &constant_bin[ 896961 ], 6 );
    const_str_plain_less = UNSTREAM_STRING( &constant_bin[ 58466 ], 4, 1 );
    const_unicode_digest_55950b0245a58fcb76cb0333c18a4a6a = UNSTREAM_UNICODE( &constant_bin[ 896967 ], 7 );
    const_tuple_unicode_digest_ecd03ef7f28ff15afa162f4a843d1037_tuple = PyTuple_New( 1 );
    const_unicode_digest_ecd03ef7f28ff15afa162f4a843d1037 = UNSTREAM_UNICODE( &constant_bin[ 896974 ], 8 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_ecd03ef7f28ff15afa162f4a843d1037_tuple, 0, const_unicode_digest_ecd03ef7f28ff15afa162f4a843d1037 ); Py_INCREF( const_unicode_digest_ecd03ef7f28ff15afa162f4a843d1037 );
    const_str_plain_ip_interface = UNSTREAM_STRING( &constant_bin[ 896982 ], 12, 1 );
    const_unicode_digest_b53e8ff97e86469747c016cbda8b6b82 = UNSTREAM_UNICODE( &constant_bin[ 896994 ], 715 );
    const_unicode_digest_ab75335520e250f0caebe75ed640b3fc = UNSTREAM_UNICODE( &constant_bin[ 897709 ], 166 );
    const_unicode_digest_5b7f2e4a3310487a05cd73dbdc2ec2d9 = UNSTREAM_UNICODE( &constant_bin[ 897875 ], 8 );
    const_str_plain__explode_shorthand_ip_string = UNSTREAM_STRING( &constant_bin[ 897883 ], 28, 1 );
    const_str_plain_overlaps = UNSTREAM_STRING( &constant_bin[ 897911 ], 8, 1 );
    const_unicode_digest_6439cf0468d27650b3db2b06ff3a5dd1 = UNSTREAM_UNICODE( &constant_bin[ 897919 ], 13 );
    const_str_plain_trailing_zeroes = UNSTREAM_STRING( &constant_bin[ 897932 ], 15, 1 );
    const_tuple_unicode_digest_58df9bee7efa43c9df04a29b6b187894_tuple = PyTuple_New( 1 );
    const_unicode_digest_58df9bee7efa43c9df04a29b6b187894 = UNSTREAM_UNICODE( &constant_bin[ 897947 ], 12 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_58df9bee7efa43c9df04a29b6b187894_tuple, 0, const_unicode_digest_58df9bee7efa43c9df04a29b6b187894 ); Py_INCREF( const_unicode_digest_58df9bee7efa43c9df04a29b6b187894 );
    const_str_plain_is_unspecified = UNSTREAM_STRING( &constant_bin[ 897959 ], 14, 1 );
    const_str_plain__get_address_key = UNSTREAM_STRING( &constant_bin[ 897973 ], 16, 1 );
    const_tuple_str_plain_cls_str_plain_ip_int_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_ip_int_tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    const_str_plain_ip_int = UNSTREAM_STRING( &constant_bin[ 896982 ], 6, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_ip_int_tuple, 1, const_str_plain_ip_int ); Py_INCREF( const_str_plain_ip_int );
    const_str_plain__compat_range = UNSTREAM_STRING( &constant_bin[ 897989 ], 13, 1 );
    const_str_plain_nbits = UNSTREAM_STRING( &constant_bin[ 898002 ], 5, 1 );
    const_tuple_c95f92ffec2b139e3f927147ab9edcbd_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_c95f92ffec2b139e3f927147ab9edcbd_tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    PyTuple_SET_ITEM( const_tuple_c95f92ffec2b139e3f927147ab9edcbd_tuple, 1, const_str_plain_arg ); Py_INCREF( const_str_plain_arg );
    const_str_plain_prefixlen = UNSTREAM_STRING( &constant_bin[ 897066 ], 9, 1 );
    PyTuple_SET_ITEM( const_tuple_c95f92ffec2b139e3f927147ab9edcbd_tuple, 2, const_str_plain_prefixlen ); Py_INCREF( const_str_plain_prefixlen );
    PyTuple_SET_ITEM( const_tuple_c95f92ffec2b139e3f927147ab9edcbd_tuple, 3, const_str_plain_netmask ); Py_INCREF( const_str_plain_netmask );
    const_unicode_digest_dd933a225f1d557f2f9048900cc16f9b = UNSTREAM_UNICODE( &constant_bin[ 898007 ], 9 );
    const_tuple_b99252a717af406174a953ceba374cca_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_b99252a717af406174a953ceba374cca_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_b99252a717af406174a953ceba374cca_tuple, 1, const_str_plain_address ); Py_INCREF( const_str_plain_address );
    const_str_plain_bvs = UNSTREAM_STRING( &constant_bin[ 898016 ], 3, 1 );
    PyTuple_SET_ITEM( const_tuple_b99252a717af406174a953ceba374cca_tuple, 2, const_str_plain_bvs ); Py_INCREF( const_str_plain_bvs );
    const_str_plain_addr_str = UNSTREAM_STRING( &constant_bin[ 898019 ], 8, 1 );
    PyTuple_SET_ITEM( const_tuple_b99252a717af406174a953ceba374cca_tuple, 3, const_str_plain_addr_str ); Py_INCREF( const_str_plain_addr_str );
    const_str_plain_prefixlen_str = UNSTREAM_STRING( &constant_bin[ 898027 ], 13, 1 );
    const_tuple_str_plain_self_str_plain_address_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_address_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_address_tuple, 1, const_str_plain_address ); Py_INCREF( const_str_plain_address );
    const_str_plain_to_merge = UNSTREAM_STRING( &constant_bin[ 898040 ], 8, 1 );
    const_str_plain_is_multicast = UNSTREAM_STRING( &constant_bin[ 898048 ], 12, 1 );
    const_unicode_digest_2972f45afa340c1d13e07950dc835f22 = UNSTREAM_UNICODE( &constant_bin[ 898060 ], 9 );
    const_str_plain__parse_octet = UNSTREAM_STRING( &constant_bin[ 898069 ], 12, 1 );
    const_unicode_digest_f4190d022dc40f14076f71730abf2fd3 = UNSTREAM_UNICODE( &constant_bin[ 898081 ], 182 );
    const_unicode_digest_a334f37feab916326bca0b7fe2402491 = UNSTREAM_UNICODE( &constant_bin[ 898263 ], 979 );
    const_tuple_str_plain_cls_str_plain_prefixlen_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_prefixlen_tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_prefixlen_tuple, 1, const_str_plain_prefixlen ); Py_INCREF( const_str_plain_prefixlen );
    const_unicode_digest_6621db75e8d93f052f1819be23d20ce6 = UNSTREAM_UNICODE( &constant_bin[ 899242 ], 48 );
    const_str_plain__reserved_networks = UNSTREAM_STRING( &constant_bin[ 899290 ], 18, 1 );
    const_str_plain_with_netmask = UNSTREAM_STRING( &constant_bin[ 899308 ], 12, 1 );
    const_unicode_digest_eff0de065ad1be8ff8f4264ecac2dcba = UNSTREAM_UNICODE( &constant_bin[ 899320 ], 20 );
    const_unicode_digest_32c5b15b8e2cae0f60549ea8196894b5 = UNSTREAM_UNICODE( &constant_bin[ 899340 ], 283 );
    const_str_digest_1dd9203bd723ff4d2badc10887999eb8 = UNSTREAM_STRING( &constant_bin[ 899623 ], 3, 0 );
    const_str_plain_IPV6LENGTH = UNSTREAM_STRING( &constant_bin[ 899626 ], 10, 1 );
    const_unicode_digest_8b0c900fbdeea9771930f9c584b257a2 = UNSTREAM_UNICODE( &constant_bin[ 899636 ], 42 );
    const_unicode_digest_289cab06588645bfabb37c3778356771 = UNSTREAM_UNICODE( &constant_bin[ 899678 ], 459 );
    const_unicode_digest_e987769ab2a30dcd5958c4d8a8f94f4e = UNSTREAM_UNICODE( &constant_bin[ 900137 ], 57 );
    const_unicode_digest_53d80a3eb0c1ac5fe323045fd90a38ac = UNSTREAM_UNICODE( &constant_bin[ 900194 ], 149 );
    const_unicode_plain___weakref__ = UNSTREAM_UNICODE( &constant_bin[ 900343 ], 11 );
    const_str_plain_byteslen = UNSTREAM_STRING( &constant_bin[ 900354 ], 8, 1 );
    const_unicode_digest_db0e07051873ab67bfbeddf5326d1061 = UNSTREAM_UNICODE( &constant_bin[ 900362 ], 6 );
    const_tuple_unicode_digest_59b4c80820858f6425abaee2308ec366_tuple = PyTuple_New( 1 );
    const_unicode_digest_59b4c80820858f6425abaee2308ec366 = UNSTREAM_UNICODE( &constant_bin[ 900368 ], 8 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_59b4c80820858f6425abaee2308ec366_tuple, 0, const_unicode_digest_59b4c80820858f6425abaee2308ec366 ); Py_INCREF( const_unicode_digest_59b4c80820858f6425abaee2308ec366 );
    const_tuple_unicode_digest_2e6e3f3d6b32093f8fc77c323d7c6fb9_tuple = PyTuple_New( 1 );
    const_unicode_digest_2e6e3f3d6b32093f8fc77c323d7c6fb9 = UNSTREAM_UNICODE( &constant_bin[ 900376 ], 8 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_2e6e3f3d6b32093f8fc77c323d7c6fb9_tuple, 0, const_unicode_digest_2e6e3f3d6b32093f8fc77c323d7c6fb9 ); Py_INCREF( const_unicode_digest_2e6e3f3d6b32093f8fc77c323d7c6fb9 );
    const_str_plain_is_reserved = UNSTREAM_STRING( &constant_bin[ 900384 ], 11, 1 );
    const_tuple_unicode_digest_194dc6db10ba74e52f6ef24612e5a44f_tuple = PyTuple_New( 1 );
    const_unicode_digest_194dc6db10ba74e52f6ef24612e5a44f = UNSTREAM_UNICODE( &constant_bin[ 900395 ], 13 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_194dc6db10ba74e52f6ef24612e5a44f_tuple, 0, const_unicode_digest_194dc6db10ba74e52f6ef24612e5a44f ); Py_INCREF( const_unicode_digest_194dc6db10ba74e52f6ef24612e5a44f );
    const_tuple_str_plain_start_str_plain_end_str_plain_step_str_plain_i_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_str_plain_start_str_plain_end_str_plain_step_str_plain_i_tuple, 0, const_str_plain_start ); Py_INCREF( const_str_plain_start );
    PyTuple_SET_ITEM( const_tuple_str_plain_start_str_plain_end_str_plain_step_str_plain_i_tuple, 1, const_str_plain_end ); Py_INCREF( const_str_plain_end );
    PyTuple_SET_ITEM( const_tuple_str_plain_start_str_plain_end_str_plain_step_str_plain_i_tuple, 2, const_str_plain_step ); Py_INCREF( const_str_plain_step );
    PyTuple_SET_ITEM( const_tuple_str_plain_start_str_plain_end_str_plain_step_str_plain_i_tuple, 3, const_str_plain_i ); Py_INCREF( const_str_plain_i );
    const_unicode_digest_ab9c76df45bc1dd7612ee4e57cee2742 = UNSTREAM_UNICODE( &constant_bin[ 900408 ], 11 );
    const_unicode_plain_8 = UNSTREAM_UNICODE( &constant_bin[ 1428 ], 1 );
    const_unicode_plain_9 = UNSTREAM_UNICODE( &constant_bin[ 2461 ], 1 );
    const_unicode_digest_efc16551a4ac6506a616591ae7a04018 = UNSTREAM_UNICODE( &constant_bin[ 900419 ], 25 );
    const_str_plain__address_class = UNSTREAM_STRING( &constant_bin[ 900444 ], 14, 1 );
    const_unicode_plain_6 = UNSTREAM_UNICODE( &constant_bin[ 9092 ], 1 );
    const_unicode_digest_fad41d1e4e853f25a53f8ca47aca44ae = UNSTREAM_UNICODE( &constant_bin[ 900458 ], 120 );
    const_unicode_digest_7945ccf9bf2a22958263bad0bfe452b2 = UNSTREAM_UNICODE( &constant_bin[ 900578 ], 20 );
    const_unicode_plain_2 = UNSTREAM_UNICODE( &constant_bin[ 15 ], 1 );
    const_unicode_plain_3 = UNSTREAM_UNICODE( &constant_bin[ 959 ], 1 );
    const_unicode_plain_hostmask = UNSTREAM_UNICODE( &constant_bin[ 900598 ], 8 );
    const_str_plain_hextets = UNSTREAM_STRING( &constant_bin[ 900606 ], 7, 1 );
    const_str_plain___sub__ = UNSTREAM_STRING( &constant_bin[ 900613 ], 7, 1 );
    const_tuple_f41119394ac30f2d0b96be932770c04a_tuple = PyTuple_New( 9 );
    PyTuple_SET_ITEM( const_tuple_f41119394ac30f2d0b96be932770c04a_tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    PyTuple_SET_ITEM( const_tuple_f41119394ac30f2d0b96be932770c04a_tuple, 1, const_str_plain_hextets ); Py_INCREF( const_str_plain_hextets );
    PyTuple_SET_ITEM( const_tuple_f41119394ac30f2d0b96be932770c04a_tuple, 2, const_str_plain_index ); Py_INCREF( const_str_plain_index );
    const_str_plain_best_doublecolon_len = UNSTREAM_STRING( &constant_bin[ 900620 ], 20, 1 );
    PyTuple_SET_ITEM( const_tuple_f41119394ac30f2d0b96be932770c04a_tuple, 3, const_str_plain_best_doublecolon_len ); Py_INCREF( const_str_plain_best_doublecolon_len );
    const_str_plain_doublecolon_len = UNSTREAM_STRING( &constant_bin[ 900625 ], 15, 1 );
    PyTuple_SET_ITEM( const_tuple_f41119394ac30f2d0b96be932770c04a_tuple, 4, const_str_plain_doublecolon_len ); Py_INCREF( const_str_plain_doublecolon_len );
    const_str_plain_best_doublecolon_start = UNSTREAM_STRING( &constant_bin[ 900640 ], 22, 1 );
    PyTuple_SET_ITEM( const_tuple_f41119394ac30f2d0b96be932770c04a_tuple, 5, const_str_plain_best_doublecolon_start ); Py_INCREF( const_str_plain_best_doublecolon_start );
    const_str_plain_best_doublecolon_end = UNSTREAM_STRING( &constant_bin[ 900662 ], 20, 1 );
    PyTuple_SET_ITEM( const_tuple_f41119394ac30f2d0b96be932770c04a_tuple, 6, const_str_plain_best_doublecolon_end ); Py_INCREF( const_str_plain_best_doublecolon_end );
    const_str_plain_doublecolon_start = UNSTREAM_STRING( &constant_bin[ 900645 ], 17, 1 );
    PyTuple_SET_ITEM( const_tuple_f41119394ac30f2d0b96be932770c04a_tuple, 7, const_str_plain_doublecolon_start ); Py_INCREF( const_str_plain_doublecolon_start );
    const_str_plain_hextet = UNSTREAM_STRING( &constant_bin[ 900606 ], 6, 1 );
    PyTuple_SET_ITEM( const_tuple_f41119394ac30f2d0b96be932770c04a_tuple, 8, const_str_plain_hextet ); Py_INCREF( const_str_plain_hextet );
    const_str_plain__reverse_pointer = UNSTREAM_STRING( &constant_bin[ 900682 ], 16, 1 );
    const_tuple_int_pos_1_none_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_int_pos_1_none_tuple, 0, const_int_pos_1 ); Py_INCREF( const_int_pos_1 );
    PyTuple_SET_ITEM( const_tuple_int_pos_1_none_tuple, 1, Py_None ); Py_INCREF( Py_None );
    const_tuple_str_plain_address_str_plain_strict_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_address_str_plain_strict_tuple, 0, const_str_plain_address ); Py_INCREF( const_str_plain_address );
    PyTuple_SET_ITEM( const_tuple_str_plain_address_str_plain_strict_tuple, 1, const_str_plain_strict ); Py_INCREF( const_str_plain_strict );
    const_tuple_unicode_digest_d557365be24b3a7215b6d3030b88908b_tuple = PyTuple_New( 1 );
    const_unicode_digest_d557365be24b3a7215b6d3030b88908b = UNSTREAM_UNICODE( &constant_bin[ 900698 ], 40 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_d557365be24b3a7215b6d3030b88908b_tuple, 0, const_unicode_digest_d557365be24b3a7215b6d3030b88908b ); Py_INCREF( const_unicode_digest_d557365be24b3a7215b6d3030b88908b );
    const_list_unicode_empty_list = PyList_New( 1 );
    PyList_SET_ITEM( const_list_unicode_empty_list, 0, const_unicode_empty ); Py_INCREF( const_unicode_empty );
    const_tuple_df9bcb1b25e9c82423695469b9a4a37f_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_df9bcb1b25e9c82423695469b9a4a37f_tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    const_str_plain_octet_str = UNSTREAM_STRING( &constant_bin[ 101021 ], 9, 1 );
    PyTuple_SET_ITEM( const_tuple_df9bcb1b25e9c82423695469b9a4a37f_tuple, 1, const_str_plain_octet_str ); Py_INCREF( const_str_plain_octet_str );
    PyTuple_SET_ITEM( const_tuple_df9bcb1b25e9c82423695469b9a4a37f_tuple, 2, const_str_plain_msg ); Py_INCREF( const_str_plain_msg );
    const_str_plain_octet_int = UNSTREAM_STRING( &constant_bin[ 900738 ], 9, 1 );
    PyTuple_SET_ITEM( const_tuple_df9bcb1b25e9c82423695469b9a4a37f_tuple, 3, const_str_plain_octet_int ); Py_INCREF( const_str_plain_octet_int );
    const_unicode_digest_745ce1754600cbf1b6a077d5f3024b91 = UNSTREAM_UNICODE( &constant_bin[ 900747 ], 36 );
    const_tuple_unicode_digest_22dfacc211498343b7c4f5bc77b1999e_tuple = PyTuple_New( 1 );
    const_unicode_digest_22dfacc211498343b7c4f5bc77b1999e = UNSTREAM_UNICODE( &constant_bin[ 900783 ], 9 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_22dfacc211498343b7c4f5bc77b1999e_tuple, 0, const_unicode_digest_22dfacc211498343b7c4f5bc77b1999e ); Py_INCREF( const_unicode_digest_22dfacc211498343b7c4f5bc77b1999e );
    const_unicode_digest_3feec7dafafbe9a5e0ca70f8d344b308 = UNSTREAM_UNICODE( &constant_bin[ 900792 ], 58 );
    const_unicode_digest_3254e3c725f90e44e7995b9143540a57 = UNSTREAM_UNICODE( &constant_bin[ 900850 ], 28 );
    const_unicode_digest_b72048f1b66f9fdd2e7e82925d13c1d2 = UNSTREAM_UNICODE( &constant_bin[ 900878 ], 176 );
    const_tuple_unicode_digest_2a285cd7527a5c5b855f32dfb8bbe6c3_tuple = PyTuple_New( 1 );
    const_unicode_digest_2a285cd7527a5c5b855f32dfb8bbe6c3 = UNSTREAM_UNICODE( &constant_bin[ 899884 ], 12 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_2a285cd7527a5c5b855f32dfb8bbe6c3_tuple, 0, const_unicode_digest_2a285cd7527a5c5b855f32dfb8bbe6c3 ); Py_INCREF( const_unicode_digest_2a285cd7527a5c5b855f32dfb8bbe6c3 );
    const_str_plain__valid_mask_octets = UNSTREAM_STRING( &constant_bin[ 901054 ], 18, 1 );
    const_tuple_str_plain_self_str_plain_address_str_plain_msg_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_address_str_plain_msg_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_address_str_plain_msg_tuple, 1, const_str_plain_address ); Py_INCREF( const_str_plain_address );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_address_str_plain_msg_tuple, 2, const_str_plain_msg ); Py_INCREF( const_str_plain_msg );
    const_tuple_unicode_digest_76b74f1a00da7c59fff7c9438dba7f09_tuple = PyTuple_New( 1 );
    const_unicode_digest_76b74f1a00da7c59fff7c9438dba7f09 = UNSTREAM_UNICODE( &constant_bin[ 901072 ], 12 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_76b74f1a00da7c59fff7c9438dba7f09_tuple, 0, const_unicode_digest_76b74f1a00da7c59fff7c9438dba7f09 ); Py_INCREF( const_unicode_digest_76b74f1a00da7c59fff7c9438dba7f09 );
    const_unicode_digest_4fad13736690efbbfb886f1de29a5548 = UNSTREAM_UNICODE( &constant_bin[ 901084 ], 207 );
    const_tuple_ff4a526b5a6a1ed69c55d5f6a48b9762_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_ff4a526b5a6a1ed69c55d5f6a48b9762_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_prefixlen_diff = UNSTREAM_STRING( &constant_bin[ 897066 ], 14, 1 );
    PyTuple_SET_ITEM( const_tuple_ff4a526b5a6a1ed69c55d5f6a48b9762_tuple, 1, const_str_plain_prefixlen_diff ); Py_INCREF( const_str_plain_prefixlen_diff );
    const_str_plain_new_prefix = UNSTREAM_STRING( &constant_bin[ 897551 ], 10, 1 );
    PyTuple_SET_ITEM( const_tuple_ff4a526b5a6a1ed69c55d5f6a48b9762_tuple, 2, const_str_plain_new_prefix ); Py_INCREF( const_str_plain_new_prefix );
    const_str_plain_new_prefixlen = UNSTREAM_STRING( &constant_bin[ 901291 ], 13, 1 );
    PyTuple_SET_ITEM( const_tuple_ff4a526b5a6a1ed69c55d5f6a48b9762_tuple, 3, const_str_plain_new_prefixlen ); Py_INCREF( const_str_plain_new_prefixlen );
    const_unicode_digest_d3e4ae64d5b27931433edd93be5fc695 = UNSTREAM_UNICODE( &constant_bin[ 901304 ], 10 );
    const_unicode_digest_de2bfe1831dccdb3c6a1c35e78a8cfff = UNSTREAM_UNICODE( &constant_bin[ 901314 ], 141 );
    const_str_plain__is_hostmask = UNSTREAM_STRING( &constant_bin[ 901455 ], 12, 1 );
    const_str_plain_supernet = UNSTREAM_STRING( &constant_bin[ 896998 ], 8, 1 );
    const_str_plain__compat_bit_length = UNSTREAM_STRING( &constant_bin[ 901467 ], 18, 1 );
    const_unicode_digest_cd26fcb2639894908f2563203d484a92 = UNSTREAM_UNICODE( &constant_bin[ 901485 ], 352 );
    const_unicode_digest_fc69aaef3eb8f00317a1c6cf63cf6f1e = UNSTREAM_UNICODE( &constant_bin[ 901837 ], 615 );
    const_unicode_digest_8de571133ab8b9176c149e4e2555e2e4 = UNSTREAM_UNICODE( &constant_bin[ 902452 ], 14 );
    const_str_plain__constants = UNSTREAM_STRING( &constant_bin[ 902466 ], 10, 1 );
    const_str_plain__linklocal_network = UNSTREAM_STRING( &constant_bin[ 902476 ], 18, 1 );
    const_str_plain_last_int = UNSTREAM_STRING( &constant_bin[ 902494 ], 8, 1 );
    const_str_plain_address_exclude = UNSTREAM_STRING( &constant_bin[ 902502 ], 15, 1 );
    const_tuple_unicode_digest_320cdcbfee5f1bed6142c1ec68d8d1b4_tuple = PyTuple_New( 1 );
    const_unicode_digest_320cdcbfee5f1bed6142c1ec68d8d1b4 = UNSTREAM_UNICODE( &constant_bin[ 902517 ], 8 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_320cdcbfee5f1bed6142c1ec68d8d1b4_tuple, 0, const_unicode_digest_320cdcbfee5f1bed6142c1ec68d8d1b4 ); Py_INCREF( const_unicode_digest_320cdcbfee5f1bed6142c1ec68d8d1b4 );
    const_str_plain_with_hostmask = UNSTREAM_STRING( &constant_bin[ 902525 ], 13, 1 );
    const_str_plain_all_ones = UNSTREAM_STRING( &constant_bin[ 902538 ], 8, 1 );
    const_str_plain__cache = UNSTREAM_STRING( &constant_bin[ 12640 ], 6, 1 );
    const_unicode_digest_c9ae6211eac82f0120b847f4c6f27bb3 = UNSTREAM_UNICODE( &constant_bin[ 902546 ], 30 );
    const_unicode_plain_bit_length = UNSTREAM_UNICODE( &constant_bin[ 569515 ], 10 );
    const_unicode_digest_ce28e1a0d596488778adc7f428c3ab1f = UNSTREAM_UNICODE( &constant_bin[ 902576 ], 34 );
    const_unicode_digest_3b09fa45074f4957f7f10686b054a8ec = UNSTREAM_UNICODE( &constant_bin[ 902610 ], 36 );
    const_str_plain__make_netmask = UNSTREAM_STRING( &constant_bin[ 902646 ], 13, 1 );
    const_unicode_digest_2c28e42f0eba3d090f3252a34ee21d01 = UNSTREAM_UNICODE( &constant_bin[ 902659 ], 357 );
    const_tuple_61c8af5e7aa68d9f21df00511cc97c77_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_61c8af5e7aa68d9f21df00511cc97c77_tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    PyTuple_SET_ITEM( const_tuple_61c8af5e7aa68d9f21df00511cc97c77_tuple, 1, const_str_plain_ip_int ); Py_INCREF( const_str_plain_ip_int );
    PyTuple_SET_ITEM( const_tuple_61c8af5e7aa68d9f21df00511cc97c77_tuple, 2, const_str_plain_x ); Py_INCREF( const_str_plain_x );
    PyTuple_SET_ITEM( const_tuple_61c8af5e7aa68d9f21df00511cc97c77_tuple, 3, const_str_plain_hex_str ); Py_INCREF( const_str_plain_hex_str );
    PyTuple_SET_ITEM( const_tuple_61c8af5e7aa68d9f21df00511cc97c77_tuple, 4, const_str_plain_hextets ); Py_INCREF( const_str_plain_hextets );
    const_unicode_digest_dc01540d6d8926dde62d972412f10f57 = UNSTREAM_UNICODE( &constant_bin[ 903016 ], 47 );
    const_str_plain_ip_bits = UNSTREAM_STRING( &constant_bin[ 903063 ], 7, 1 );
    const_unicode_digest_29df0a9c7866e00435cc16fa8f0aec14 = UNSTREAM_UNICODE( &constant_bin[ 903070 ], 294 );
    const_str_plain_parts_skipped = UNSTREAM_STRING( &constant_bin[ 903364 ], 13, 1 );
    const_str_plain__parse_hextet = UNSTREAM_STRING( &constant_bin[ 903377 ], 13, 1 );
    const_str_plain__prefix_from_prefix_string = UNSTREAM_STRING( &constant_bin[ 903390 ], 26, 1 );
    const_unicode_digest_25403b7f1a1d82d5241e55405508207f = UNSTREAM_UNICODE( &constant_bin[ 903416 ], 7 );
    const_unicode_digest_c18094a902653dc9c8bc33f8a5603fb5 = UNSTREAM_UNICODE( &constant_bin[ 903423 ], 49 );
    const_str_plain__public_network = UNSTREAM_STRING( &constant_bin[ 903472 ], 15, 1 );
    const_str_plain__prefix_from_ip_string = UNSTREAM_STRING( &constant_bin[ 903487 ], 22, 1 );
    const_unicode_digest_9d31f3ec37b1a08172a39ca753627f89 = UNSTREAM_UNICODE( &constant_bin[ 903509 ], 146 );
    const_str_plain_max_prefixlen = UNSTREAM_STRING( &constant_bin[ 903655 ], 13, 1 );
    const_unicode_digest_509911ef653d68dc2d9e8bf72450b69f = UNSTREAM_UNICODE( &constant_bin[ 903668 ], 4 );
    const_str_plain__split_optional_netmask = UNSTREAM_STRING( &constant_bin[ 903672 ], 23, 1 );
    const_unicode_digest_fbf09f2b8368dad5ab4255c739a502ac = UNSTREAM_UNICODE( &constant_bin[ 903695 ], 464 );
    const_tuple_str_plain_self_str_plain_reverse_octets_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_reverse_octets_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_reverse_octets = UNSTREAM_STRING( &constant_bin[ 904159 ], 14, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_reverse_octets_tuple, 1, const_str_plain_reverse_octets ); Py_INCREF( const_str_plain_reverse_octets );
    const_unicode_digest_32cd97b7f60de6dc3859a99c1b5562c5 = UNSTREAM_UNICODE( &constant_bin[ 904173 ], 271 );
    const_str_plain_ips = UNSTREAM_STRING( &constant_bin[ 30184 ], 3, 1 );
    const_unicode_digest_e05179e2703db9ae8abe267335566873 = UNSTREAM_UNICODE( &constant_bin[ 904444 ], 185 );
    const_unicode_digest_adc545fc78271f8a7bba433d2d4f8995 = UNSTREAM_UNICODE( &constant_bin[ 904629 ], 26 );
    const_str_plain__ip_int_from_prefix = UNSTREAM_STRING( &constant_bin[ 904655 ], 19, 1 );
    const_str_plain__ip_int_from_string = UNSTREAM_STRING( &constant_bin[ 904674 ], 19, 1 );
    const_unicode_digest_572d7cc1bd08b37563d1969e4898e12a = UNSTREAM_UNICODE( &constant_bin[ 904693 ], 245 );
    const_unicode_digest_8ae547298da00f3e03c0a262558b355e = UNSTREAM_UNICODE( &constant_bin[ 904938 ], 168 );
    const_str_plain_compressed = UNSTREAM_STRING( &constant_bin[ 547054 ], 10, 1 );
    const_str_plain_supernet_of = UNSTREAM_STRING( &constant_bin[ 905106 ], 11, 1 );
    const_str_plain_reverse_pointer = UNSTREAM_STRING( &constant_bin[ 900683 ], 15, 1 );
    const_str_plain_AddressValueError = UNSTREAM_STRING( &constant_bin[ 904378 ], 17, 1 );
    const_str_plain__BaseNetwork = UNSTREAM_STRING( &constant_bin[ 905117 ], 12, 1 );
    const_str_plain_NetmaskValueError = UNSTREAM_STRING( &constant_bin[ 905129 ], 17, 1 );
    const_unicode_digest_19653372c9d87d543bd1a3a25c524778 = UNSTREAM_UNICODE( &constant_bin[ 905146 ], 159 );
    const_str_plain__get_networks_key = UNSTREAM_STRING( &constant_bin[ 905305 ], 17, 1 );
    const_str_plain_endianess = UNSTREAM_STRING( &constant_bin[ 905322 ], 9, 1 );
    const_tuple_unicode_digest_f96a90c13f1d84402c514b6ee611aea1_tuple = PyTuple_New( 1 );
    const_unicode_digest_f96a90c13f1d84402c514b6ee611aea1 = UNSTREAM_UNICODE( &constant_bin[ 905331 ], 14 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_f96a90c13f1d84402c514b6ee611aea1_tuple, 0, const_unicode_digest_f96a90c13f1d84402c514b6ee611aea1 ); Py_INCREF( const_unicode_digest_f96a90c13f1d84402c514b6ee611aea1 );
    const_unicode_digest_d34b52cbd25eb67200141aed7e8a5928 = UNSTREAM_UNICODE( &constant_bin[ 905345 ], 430 );
    const_str_plain__report_invalid_netmask = UNSTREAM_STRING( &constant_bin[ 905775 ], 23, 1 );
    const_str_plain__ALL_ONES = UNSTREAM_STRING( &constant_bin[ 905798 ], 9, 1 );
    const_unicode_digest_57ad7c388c09157d6398d6e4e29b2ea6 = UNSTREAM_UNICODE( &constant_bin[ 905807 ], 126 );
    const_unicode_digest_82f1741cd06220f67668319322d6ad23 = UNSTREAM_UNICODE( &constant_bin[ 900458 ], 48 );
    const_tuple_str_plain_intval_str_plain_length_str_plain_endianess_tuple = PyTuple_New( 3 );
    const_str_plain_intval = UNSTREAM_STRING( &constant_bin[ 905933 ], 6, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_intval_str_plain_length_str_plain_endianess_tuple, 0, const_str_plain_intval ); Py_INCREF( const_str_plain_intval );
    PyTuple_SET_ITEM( const_tuple_str_plain_intval_str_plain_length_str_plain_endianess_tuple, 1, const_str_plain_length ); Py_INCREF( const_str_plain_length );
    PyTuple_SET_ITEM( const_tuple_str_plain_intval_str_plain_length_str_plain_endianess_tuple, 2, const_str_plain_endianess ); Py_INCREF( const_str_plain_endianess );
    const_unicode_digest_5bbe393519c9f8f834b0e4362b7f4892 = UNSTREAM_UNICODE( &constant_bin[ 905939 ], 7 );
    const_str_digest_11a7e09c00a35df5b21f6600c68e78d8 = UNSTREAM_STRING( &constant_bin[ 92044 ], 2, 0 );
    const_unicode_digest_283a86aa738f016354d4630f6f9478f9 = UNSTREAM_UNICODE( &constant_bin[ 905946 ], 42 );
    const_unicode_plain_broadcast_address = UNSTREAM_UNICODE( &constant_bin[ 902894 ], 17 );
    const_str_plain__max_parts = UNSTREAM_STRING( &constant_bin[ 905988 ], 10, 1 );
    const_tuple_unicode_digest_d3e4ae64d5b27931433edd93be5fc695_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_d3e4ae64d5b27931433edd93be5fc695_tuple, 0, const_unicode_digest_d3e4ae64d5b27931433edd93be5fc695 ); Py_INCREF( const_unicode_digest_d3e4ae64d5b27931433edd93be5fc695 );
    const_unicode_digest_24de17cd9f039f640eb11d2c2ddbd04c = UNSTREAM_UNICODE( &constant_bin[ 905998 ], 286 );
    const_str_plain_expected_len = UNSTREAM_STRING( &constant_bin[ 906284 ], 12, 1 );
    const_unicode_digest_7f00060466647c49fa48da2be5e497c8 = UNSTREAM_UNICODE( &constant_bin[ 906296 ], 5 );
    const_str_plain__HEX_DIGITS = UNSTREAM_STRING( &constant_bin[ 906301 ], 11, 1 );
    const_tuple_9ff79281bff64fe91204cce2984dfc9d_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_9ff79281bff64fe91204cce2984dfc9d_tuple, 0, const_str_digest_b9c4baf879ebd882d40843df3a4dead7 ); Py_INCREF( const_str_digest_b9c4baf879ebd882d40843df3a4dead7 );
    PyTuple_SET_ITEM( const_tuple_9ff79281bff64fe91204cce2984dfc9d_tuple, 1, const_str_plain_net ); Py_INCREF( const_str_plain_net );
    PyTuple_SET_ITEM( const_tuple_9ff79281bff64fe91204cce2984dfc9d_tuple, 2, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_long_pos_18446744073709551615 = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 906312 ], 15 );
    const_unicode_digest_6fd026f58df80ebafc0af41197edbd33 = UNSTREAM_UNICODE( &constant_bin[ 906327 ], 45 );
    const_tuple_unicode_plain__ip_unicode_plain___weakref___tuple = PyTuple_New( 2 );
    const_unicode_plain__ip = UNSTREAM_UNICODE( &constant_bin[ 92078 ], 3 );
    PyTuple_SET_ITEM( const_tuple_unicode_plain__ip_unicode_plain___weakref___tuple, 0, const_unicode_plain__ip ); Py_INCREF( const_unicode_plain__ip );
    PyTuple_SET_ITEM( const_tuple_unicode_plain__ip_unicode_plain___weakref___tuple, 1, const_unicode_plain___weakref__ ); Py_INCREF( const_unicode_plain___weakref__ );
    const_str_plain_hextet_str = UNSTREAM_STRING( &constant_bin[ 903144 ], 10, 1 );
    const_unicode_digest_582de6307aaf0806e961bc838a12ef52 = UNSTREAM_UNICODE( &constant_bin[ 906372 ], 48 );
    const_unicode_digest_87af500436080f92b2724f59f56f083f = UNSTREAM_UNICODE( &constant_bin[ 906420 ], 215 );
    const_str_plain__private_networks = UNSTREAM_STRING( &constant_bin[ 906635 ], 17, 1 );
    const_unicode_digest_23a8e74f4b615fbfc9e5a160a861c61a = UNSTREAM_UNICODE( &constant_bin[ 906652 ], 17 );
    const_unicode_digest_f9bc333483c82191ecd263b25cbcf60d = UNSTREAM_UNICODE( &constant_bin[ 906669 ], 203 );
    const_str_plain__check_int_address = UNSTREAM_STRING( &constant_bin[ 906872 ], 18, 1 );
    const_str_plain_parts_lo = UNSTREAM_STRING( &constant_bin[ 906890 ], 8, 1 );
    const_unicode_digest_faf8e5c5460d2a31764ac224ef24fa52 = UNSTREAM_UNICODE( &constant_bin[ 906898 ], 30 );
    const_tuple_1d39f04be793fb75107492e9cda65f46_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_1d39f04be793fb75107492e9cda65f46_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_1d39f04be793fb75107492e9cda65f46_tuple, 1, const_str_plain_n ); Py_INCREF( const_str_plain_n );
    const_str_plain_broadcast = UNSTREAM_STRING( &constant_bin[ 902894 ], 9, 1 );
    PyTuple_SET_ITEM( const_tuple_1d39f04be793fb75107492e9cda65f46_tuple, 2, const_str_plain_broadcast ); Py_INCREF( const_str_plain_broadcast );
    PyTuple_SET_ITEM( const_tuple_1d39f04be793fb75107492e9cda65f46_tuple, 3, const_str_plain_network ); Py_INCREF( const_str_plain_network );
    const_str_plain__BaseAddress = UNSTREAM_STRING( &constant_bin[ 906928 ], 12, 1 );
    const_unicode_digest_c844160122a9f5474c7a0c0184598e9b = UNSTREAM_UNICODE( &constant_bin[ 906940 ], 562 );
    const_unicode_digest_780f01a2ac4ecdb58e54af04ef9a0303 = UNSTREAM_UNICODE( &constant_bin[ 907502 ], 38 );
    const_str_plain__HEXTET_COUNT = UNSTREAM_STRING( &constant_bin[ 907540 ], 13, 1 );
    const_str_plain_new_addr = UNSTREAM_STRING( &constant_bin[ 907553 ], 8, 1 );
    const_str_plain_subnets = UNSTREAM_STRING( &constant_bin[ 898267 ], 7, 1 );
    const_unicode_digest_0b68f1d1670be58439f575ba680b882d = UNSTREAM_UNICODE( &constant_bin[ 907561 ], 30 );
    const_unicode_digest_a903554c9d4eb1e89ecedb79be4218d2 = UNSTREAM_UNICODE( &constant_bin[ 907591 ], 182 );
    const_unicode_digest_101ebce5f61c0ce299ab3ac572b746e7 = UNSTREAM_UNICODE( &constant_bin[ 907773 ], 11 );
    const_dict_23947da529d495c5b5d02e68c2d46c17 = _PyDict_NewPresized( 1 );
    PyDict_SetItem( const_dict_23947da529d495c5b5d02e68c2d46c17, const_str_plain_strict, Py_False );
    assert( PyDict_Size( const_dict_23947da529d495c5b5d02e68c2d46c17 ) == 1 );
    const_str_plain__IPv6Constants = UNSTREAM_STRING( &constant_bin[ 907784 ], 14, 1 );
    const_tuple_f3db2b00dcab6aff87703f38eede988a_tuple = PyTuple_New( 7 );
    const_str_plain_addresses = UNSTREAM_STRING( &constant_bin[ 899740 ], 9, 1 );
    PyTuple_SET_ITEM( const_tuple_f3db2b00dcab6aff87703f38eede988a_tuple, 0, const_str_plain_addresses ); Py_INCREF( const_str_plain_addresses );
    PyTuple_SET_ITEM( const_tuple_f3db2b00dcab6aff87703f38eede988a_tuple, 1, const_str_plain_subnets ); Py_INCREF( const_str_plain_subnets );
    PyTuple_SET_ITEM( const_tuple_f3db2b00dcab6aff87703f38eede988a_tuple, 2, const_str_plain_supernet ); Py_INCREF( const_str_plain_supernet );
    PyTuple_SET_ITEM( const_tuple_f3db2b00dcab6aff87703f38eede988a_tuple, 3, const_str_plain_last ); Py_INCREF( const_str_plain_last );
    const_str_plain_existing = UNSTREAM_STRING( &constant_bin[ 132671 ], 8, 1 );
    PyTuple_SET_ITEM( const_tuple_f3db2b00dcab6aff87703f38eede988a_tuple, 4, const_str_plain_existing ); Py_INCREF( const_str_plain_existing );
    PyTuple_SET_ITEM( const_tuple_f3db2b00dcab6aff87703f38eede988a_tuple, 5, const_str_plain_to_merge ); Py_INCREF( const_str_plain_to_merge );
    PyTuple_SET_ITEM( const_tuple_f3db2b00dcab6aff87703f38eede988a_tuple, 6, const_str_plain_net ); Py_INCREF( const_str_plain_net );
    const_unicode_digest_6bc44a3bd13949ad6cfa5e1484201995 = UNSTREAM_UNICODE( &constant_bin[ 907798 ], 23 );
    const_tuple_unicode_digest_b6c766f070c655516752216bf2bdd0c4_tuple = PyTuple_New( 1 );
    const_unicode_digest_b6c766f070c655516752216bf2bdd0c4 = UNSTREAM_UNICODE( &constant_bin[ 907821 ], 13 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_b6c766f070c655516752216bf2bdd0c4_tuple, 0, const_unicode_digest_b6c766f070c655516752216bf2bdd0c4 ); Py_INCREF( const_unicode_digest_b6c766f070c655516752216bf2bdd0c4 );
    const_unicode_digest_24e54315d820212332afec6f6ec23e9d = UNSTREAM_UNICODE( &constant_bin[ 907834 ], 32 );
    const_unicode_digest_1c66251700e583bec5e8354f1f3817f8 = UNSTREAM_UNICODE( &constant_bin[ 907866 ], 15 );
    const_tuple_f8d906ece65b18c6af8aaf87035aebfe_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_f8d906ece65b18c6af8aaf87035aebfe_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_f8d906ece65b18c6af8aaf87035aebfe_tuple, 1, const_str_plain_address ); Py_INCREF( const_str_plain_address );
    PyTuple_SET_ITEM( const_tuple_f8d906ece65b18c6af8aaf87035aebfe_tuple, 2, const_str_plain_strict ); Py_INCREF( const_str_plain_strict );
    PyTuple_SET_ITEM( const_tuple_f8d906ece65b18c6af8aaf87035aebfe_tuple, 3, const_str_plain_addr ); Py_INCREF( const_str_plain_addr );
    PyTuple_SET_ITEM( const_tuple_f8d906ece65b18c6af8aaf87035aebfe_tuple, 4, const_str_plain_arg ); Py_INCREF( const_str_plain_arg );
    PyTuple_SET_ITEM( const_tuple_f8d906ece65b18c6af8aaf87035aebfe_tuple, 5, const_str_plain_packed ); Py_INCREF( const_str_plain_packed );
    const_str_plain_sixtofour = UNSTREAM_STRING( &constant_bin[ 907881 ], 9, 1 );
    const_tuple_unicode_digest_6bc44a3bd13949ad6cfa5e1484201995_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_6bc44a3bd13949ad6cfa5e1484201995_tuple, 0, const_unicode_digest_6bc44a3bd13949ad6cfa5e1484201995 ); Py_INCREF( const_unicode_digest_6bc44a3bd13949ad6cfa5e1484201995 );
    const_unicode_digest_91f907426d1690d534d93dfdd7289bce = UNSTREAM_UNICODE( &constant_bin[ 907890 ], 121 );
    const_str_plain__unspecified_address = UNSTREAM_STRING( &constant_bin[ 908011 ], 20, 1 );
    const_str_digest_1ab9d69575e4bd45bb288b6bd05cd8cc = UNSTREAM_STRING( &constant_bin[ 908031 ], 18, 0 );
    const_str_plain__DECIMAL_DIGITS = UNSTREAM_STRING( &constant_bin[ 908049 ], 15, 1 );
    const_unicode_digest_fce80ade8999b448027d3bc78b9fd2e2 = UNSTREAM_UNICODE( &constant_bin[ 908064 ], 11 );
    const_unicode_digest_405ec5ff1c943cd273b0a0932b950391 = UNSTREAM_UNICODE( &constant_bin[ 908075 ], 18 );
    const_tuple_be53fac8911619da3fa3e231a9b3c752_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_be53fac8911619da3fa3e231a9b3c752_tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    const_str_plain_ip_str = UNSTREAM_STRING( &constant_bin[ 91999 ], 6, 1 );
    PyTuple_SET_ITEM( const_tuple_be53fac8911619da3fa3e231a9b3c752_tuple, 1, const_str_plain_ip_str ); Py_INCREF( const_str_plain_ip_str );
    PyTuple_SET_ITEM( const_tuple_be53fac8911619da3fa3e231a9b3c752_tuple, 2, const_str_plain_exc ); Py_INCREF( const_str_plain_exc );
    PyTuple_SET_ITEM( const_tuple_be53fac8911619da3fa3e231a9b3c752_tuple, 3, const_str_plain_octets ); Py_INCREF( const_str_plain_octets );
    const_str_plain__compat_str = UNSTREAM_STRING( &constant_bin[ 908093 ], 11, 1 );
    const_tuple_str_plain_cls_str_plain_netmask_str_str_plain_msg_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_netmask_str_str_plain_msg_tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    const_str_plain_netmask_str = UNSTREAM_STRING( &constant_bin[ 908104 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_netmask_str_str_plain_msg_tuple, 1, const_str_plain_netmask_str ); Py_INCREF( const_str_plain_netmask_str );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_netmask_str_str_plain_msg_tuple, 2, const_str_plain_msg ); Py_INCREF( const_str_plain_msg );
    const_str_plain__compat_bytes_to_byte_vals = UNSTREAM_STRING( &constant_bin[ 908115 ], 26, 1 );
    const_unicode_digest_9462791757a5ac738cf1ca2dd1f09e95 = UNSTREAM_UNICODE( &constant_bin[ 908141 ], 8 );
    const_tuple_str_plain_self_str_plain_address_str_plain_addr_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_address_str_plain_addr_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_address_str_plain_addr_tuple, 1, const_str_plain_address ); Py_INCREF( const_str_plain_address );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_address_str_plain_addr_tuple, 2, const_str_plain_addr ); Py_INCREF( const_str_plain_addr );
    const_tuple_str_plain_self_str_plain_other_str_plain_s2_str_plain_s1_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_other_str_plain_s2_str_plain_s1_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_other_str_plain_s2_str_plain_s1_tuple, 1, const_str_plain_other ); Py_INCREF( const_str_plain_other );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_other_str_plain_s2_str_plain_s1_tuple, 2, const_str_plain_s2 ); Py_INCREF( const_str_plain_s2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_other_str_plain_s2_str_plain_s1_tuple, 3, const_str_plain_s1 ); Py_INCREF( const_str_plain_s1 );
    const_str_plain_subnet_of = UNSTREAM_STRING( &constant_bin[ 908149 ], 9, 1 );
    const_unicode_digest_6a98397c0892ba5e9c29046762cbb9d8 = UNSTREAM_UNICODE( &constant_bin[ 908158 ], 5 );
    const_unicode_digest_caccb9a882e33dc7cad6440d3039a297 = UNSTREAM_UNICODE( &constant_bin[ 908163 ], 129 );
    const_tuple_unicode_digest_5685a0dd95ca231c7a311dcc298d847e_tuple = PyTuple_New( 1 );
    const_unicode_digest_5685a0dd95ca231c7a311dcc298d847e = UNSTREAM_UNICODE( &constant_bin[ 908292 ], 7 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_5685a0dd95ca231c7a311dcc298d847e_tuple, 0, const_unicode_digest_5685a0dd95ca231c7a311dcc298d847e ); Py_INCREF( const_unicode_digest_5685a0dd95ca231c7a311dcc298d847e );
    const_unicode_digest_43b2afee270b7a4815a53cb0c30479ad = UNSTREAM_UNICODE( &constant_bin[ 908299 ], 44 );
    const_dict_b84735d462e535bfd6f6cd43e07133d4 = _PyDict_NewPresized( 2 );
    PyDict_SetItem( const_dict_b84735d462e535bfd6f6cd43e07133d4, const_str_plain___module__, const_str_plain_ipaddress );
    const_unicode_digest_72c7247958606980b87c9cb8a19ea8a1 = UNSTREAM_UNICODE( &constant_bin[ 908343 ], 37 );
    PyDict_SetItem( const_dict_b84735d462e535bfd6f6cd43e07133d4, const_str_plain___doc__, const_unicode_digest_72c7247958606980b87c9cb8a19ea8a1 );
    assert( PyDict_Size( const_dict_b84735d462e535bfd6f6cd43e07133d4 ) == 2 );
    const_str_digest_8060bd90928781385c4bd80fdfcf370e = UNSTREAM_STRING( &constant_bin[ 908380 ], 2, 0 );
    const_dict_722093ea3cb4d742ab031ea9dda12a84 = _PyDict_NewPresized( 2 );
    PyDict_SetItem( const_dict_722093ea3cb4d742ab031ea9dda12a84, const_str_plain___module__, const_str_plain_ipaddress );
    const_unicode_digest_12c0ce2344269ec0369906c845e61853 = UNSTREAM_UNICODE( &constant_bin[ 908382 ], 37 );
    PyDict_SetItem( const_dict_722093ea3cb4d742ab031ea9dda12a84, const_str_plain___doc__, const_unicode_digest_12c0ce2344269ec0369906c845e61853 );
    assert( PyDict_Size( const_dict_722093ea3cb4d742ab031ea9dda12a84 ) == 2 );
    const_unicode_digest_6d039f42f7b89c8dc0c9eb3f203555ab = UNSTREAM_UNICODE( &constant_bin[ 908419 ], 271 );
    const_int_pos_536936448 = PyInt_FromLong( 536936448l );
    const_unicode_digest_f70fd07d18881f54cf18de3ff6348c33 = UNSTREAM_UNICODE( &constant_bin[ 908690 ], 1255 );
    const_tuple_unicode_digest_d399497e3404869de2f90bc4536c2cea_tuple = PyTuple_New( 1 );
    const_unicode_digest_d399497e3404869de2f90bc4536c2cea = UNSTREAM_UNICODE( &constant_bin[ 909945 ], 8 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_d399497e3404869de2f90bc4536c2cea_tuple, 0, const_unicode_digest_d399497e3404869de2f90bc4536c2cea ); Py_INCREF( const_unicode_digest_d399497e3404869de2f90bc4536c2cea );
    const_unicode_digest_98c89e98d08dd7d28bf0635a719bf24d = UNSTREAM_UNICODE( &constant_bin[ 909953 ], 50 );
    const_str_plain__count_righthand_zero_bits = UNSTREAM_STRING( &constant_bin[ 910003 ], 26, 1 );
    const_str_plain_summarize_address_range = UNSTREAM_STRING( &constant_bin[ 910029 ], 23, 1 );
    const_unicode_digest_10cfd1ff9fa2b2c1de094f0f58ee69fd = UNSTREAM_UNICODE( &constant_bin[ 910052 ], 300 );
    const_str_plain_byt = UNSTREAM_STRING( &constant_bin[ 256 ], 3, 1 );
    const_unicode_digest_59e693b3e55c03cdfbf51d3bfd2ecbbe = UNSTREAM_UNICODE( &constant_bin[ 910352 ], 219 );
    const_unicode_digest_0210282788da1a1bc7085fe52fd6486f = UNSTREAM_UNICODE( &constant_bin[ 910571 ], 374 );
    const_unicode_digest_aaa8df82589e3fcc3c5dc300a83c6345 = UNSTREAM_UNICODE( &constant_bin[ 910945 ], 9 );
    const_tuple_unicode_plain_broadcast_address_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_unicode_plain_broadcast_address_tuple, 0, const_unicode_plain_broadcast_address ); Py_INCREF( const_unicode_plain_broadcast_address );
    const_unicode_digest_bd8ac84a857b4ed91963d33543ce504a = UNSTREAM_UNICODE( &constant_bin[ 910954 ], 265 );
    const_unicode_digest_f5f271ff00e96b68abb5b126c6b3f130 = UNSTREAM_UNICODE( &constant_bin[ 911219 ], 25 );
    const_str_digest_a25a001858b466f6be5039bbd12f63ef = UNSTREAM_STRING( &constant_bin[ 911244 ], 45, 0 );
    const_unicode_digest_fcd0b976a07f817f01888853a28920d5 = UNSTREAM_UNICODE( &constant_bin[ 911289 ], 1189 );
    const_str_plain_v6_int_to_packed = UNSTREAM_STRING( &constant_bin[ 912478 ], 16, 1 );
    const_unicode_digest_74272e9e6b29f827a4600cd9d4bfe9d6 = UNSTREAM_UNICODE( &constant_bin[ 912494 ], 38 );
    const_unicode_plain_5 = UNSTREAM_UNICODE( &constant_bin[ 1457 ], 1 );
    const_tuple_str_plain_cls_str_plain_ip_str_str_plain_ip_int_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_ip_str_str_plain_ip_int_tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_ip_str_str_plain_ip_int_tuple, 1, const_str_plain_ip_str ); Py_INCREF( const_str_plain_ip_str );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_ip_str_str_plain_ip_int_tuple, 2, const_str_plain_ip_int ); Py_INCREF( const_str_plain_ip_int );
    const_unicode_digest_4e11e045f071f5745153d71dc21282d3 = UNSTREAM_UNICODE( &constant_bin[ 912532 ], 229 );
    const_unicode_digest_e387280a229c9db974e6c776d288bba6 = UNSTREAM_UNICODE( &constant_bin[ 912761 ], 8 );
    const_unicode_digest_786511cd0da76607fa48edaa91095b3b = UNSTREAM_UNICODE( &constant_bin[ 912769 ], 40 );
    const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_b_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_b_tuple, 0, const_str_digest_b9c4baf879ebd882d40843df3a4dead7 ); Py_INCREF( const_str_digest_b9c4baf879ebd882d40843df3a4dead7 );
    PyTuple_SET_ITEM( const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_b_tuple, 1, const_str_plain_b ); Py_INCREF( const_str_plain_b );
    const_str_plain__netmask_cache = UNSTREAM_STRING( &constant_bin[ 912809 ], 14, 1 );
    const_str_plain__string_from_ip_int = UNSTREAM_STRING( &constant_bin[ 912823 ], 19, 1 );
    const_str_plain_leading_ones = UNSTREAM_STRING( &constant_bin[ 912842 ], 12, 1 );
    const_tuple_unicode_digest_e9b7b96fb2ce3038ca93557a305aee61_tuple = PyTuple_New( 1 );
    const_unicode_digest_e9b7b96fb2ce3038ca93557a305aee61 = UNSTREAM_UNICODE( &constant_bin[ 912854 ], 8 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_e9b7b96fb2ce3038ca93557a305aee61_tuple, 0, const_unicode_digest_e9b7b96fb2ce3038ca93557a305aee61 ); Py_INCREF( const_unicode_digest_e9b7b96fb2ce3038ca93557a305aee61 );
    const_str_plain_ipv4_int = UNSTREAM_STRING( &constant_bin[ 912862 ], 8, 1 );
    const_str_plain__TotalOrderingMixin = UNSTREAM_STRING( &constant_bin[ 912870 ], 19, 1 );
    const_unicode_digest_04311a35f70305eb6ef19122d29249c2 = UNSTREAM_UNICODE( &constant_bin[ 912889 ], 128 );
    const_str_plain__prefixlen = UNSTREAM_STRING( &constant_bin[ 898380 ], 10, 1 );
    const_unicode_digest_e4b0d176f96493dd1d5d8cbd14cab77e = UNSTREAM_UNICODE( &constant_bin[ 913017 ], 8 );
    const_unicode_digest_5eb59a83c37d07a28c39bc523d9a7e7b = UNSTREAM_UNICODE( &constant_bin[ 913025 ], 7 );
    const_tuple_str_plain_self_str_plain_other_str_plain_less_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_other_str_plain_less_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_other_str_plain_less_tuple, 1, const_str_plain_other ); Py_INCREF( const_str_plain_other );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_other_str_plain_less_tuple, 2, const_str_plain_less ); Py_INCREF( const_str_plain_less );
    const_unicode_digest_d5a1201fe07f6f7e80d19f19f44f0cfb = UNSTREAM_UNICODE( &constant_bin[ 913032 ], 206 );
    const_unicode_digest_6525f1cc4fe3bcdb3c861d0842343832 = UNSTREAM_UNICODE( &constant_bin[ 913238 ], 32 );
    const_tuple_str_plain_cls_str_plain_hextet_str_str_plain_msg_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_hextet_str_str_plain_msg_tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_hextet_str_str_plain_msg_tuple, 1, const_str_plain_hextet_str ); Py_INCREF( const_str_plain_hextet_str );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_hextet_str_str_plain_msg_tuple, 2, const_str_plain_msg ); Py_INCREF( const_str_plain_msg );
    const_str_plain__sitelocal_network = UNSTREAM_STRING( &constant_bin[ 913270 ], 18, 1 );
    const_tuple_unicode_digest_9462791757a5ac738cf1ca2dd1f09e95_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_9462791757a5ac738cf1ca2dd1f09e95_tuple, 0, const_unicode_digest_9462791757a5ac738cf1ca2dd1f09e95 ); Py_INCREF( const_unicode_digest_9462791757a5ac738cf1ca2dd1f09e95 );
    const_tuple_unicode_digest_5eb59a83c37d07a28c39bc523d9a7e7b_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_5eb59a83c37d07a28c39bc523d9a7e7b_tuple, 0, const_unicode_digest_5eb59a83c37d07a28c39bc523d9a7e7b ); Py_INCREF( const_unicode_digest_5eb59a83c37d07a28c39bc523d9a7e7b );
    const_tuple_unicode_digest_101ebce5f61c0ce299ab3ac572b746e7_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_101ebce5f61c0ce299ab3ac572b746e7_tuple, 0, const_unicode_digest_101ebce5f61c0ce299ab3ac572b746e7 ); Py_INCREF( const_unicode_digest_101ebce5f61c0ce299ab3ac572b746e7 );
    const_str_plain__compat_to_bytes = UNSTREAM_STRING( &constant_bin[ 913288 ], 16, 1 );
    const_unicode_digest_713ebfce2d10e63958e8edc4d67a9c94 = UNSTREAM_UNICODE( &constant_bin[ 913304 ], 18 );
    const_unicode_digest_c50e4b7ca59e04bf8bf40c8c074f23f7 = UNSTREAM_UNICODE( &constant_bin[ 913322 ], 23 );
    const_int_pos_8194 = PyInt_FromLong( 8194l );
    const_str_plain_nets = UNSTREAM_STRING( &constant_bin[ 704601 ], 4, 1 );
    const_unicode_digest_fdc180e651f53b5645d6e63208353e99 = UNSTREAM_UNICODE( &constant_bin[ 913345 ], 8 );
    const_unicode_digest_92c107dbe635b4b79a97075dcd49ce3d = UNSTREAM_UNICODE( &constant_bin[ 913353 ], 484 );
    const_unicode_digest_7322ea8f60136157d13c0a45146fd35a = UNSTREAM_UNICODE( &constant_bin[ 913837 ], 59 );
    const_frozenset_66c1acb9d1286c78b6365c163e59bc78 = PyFrozenSet_New( NULL );
    PySet_Add( const_frozenset_66c1acb9d1286c78b6365c163e59bc78, const_unicode_plain_1 );
    PySet_Add( const_frozenset_66c1acb9d1286c78b6365c163e59bc78, const_unicode_plain_0 );
    PySet_Add( const_frozenset_66c1acb9d1286c78b6365c163e59bc78, const_unicode_plain_3 );
    PySet_Add( const_frozenset_66c1acb9d1286c78b6365c163e59bc78, const_unicode_plain_2 );
    PySet_Add( const_frozenset_66c1acb9d1286c78b6365c163e59bc78, const_unicode_plain_5 );
    const_unicode_plain_4 = UNSTREAM_UNICODE( &constant_bin[ 5711 ], 1 );
    PySet_Add( const_frozenset_66c1acb9d1286c78b6365c163e59bc78, const_unicode_plain_4 );
    const_unicode_plain_7 = UNSTREAM_UNICODE( &constant_bin[ 17 ], 1 );
    PySet_Add( const_frozenset_66c1acb9d1286c78b6365c163e59bc78, const_unicode_plain_7 );
    PySet_Add( const_frozenset_66c1acb9d1286c78b6365c163e59bc78, const_unicode_plain_6 );
    PySet_Add( const_frozenset_66c1acb9d1286c78b6365c163e59bc78, const_unicode_plain_9 );
    PySet_Add( const_frozenset_66c1acb9d1286c78b6365c163e59bc78, const_unicode_plain_8 );
    assert( PySet_Size( const_frozenset_66c1acb9d1286c78b6365c163e59bc78 ) == 10 );
    const_tuple_unicode_digest_ed7b60fe5be95741a2db22da8e4c1100_tuple = PyTuple_New( 1 );
    const_unicode_digest_ed7b60fe5be95741a2db22da8e4c1100 = UNSTREAM_UNICODE( &constant_bin[ 913896 ], 8 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_ed7b60fe5be95741a2db22da8e4c1100_tuple, 0, const_unicode_digest_ed7b60fe5be95741a2db22da8e4c1100 ); Py_INCREF( const_unicode_digest_ed7b60fe5be95741a2db22da8e4c1100 );
    const_str_plain__compat_int_from_byte_vals = UNSTREAM_STRING( &constant_bin[ 913904 ], 26, 1 );
    const_str_plain_is_site_local = UNSTREAM_STRING( &constant_bin[ 913930 ], 13, 1 );
    const_unicode_digest_0d4549e3c9ba6b05a7194583ebe788ee = UNSTREAM_UNICODE( &constant_bin[ 913943 ], 516 );
    const_tuple_str_plain_self_str_plain_other_str_plain_address_equal_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_other_str_plain_address_equal_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_other_str_plain_address_equal_tuple, 1, const_str_plain_other ); Py_INCREF( const_str_plain_other );
    const_str_plain_address_equal = UNSTREAM_STRING( &constant_bin[ 914459 ], 13, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_other_str_plain_address_equal_tuple, 2, const_str_plain_address_equal ); Py_INCREF( const_str_plain_address_equal );
    const_tuple_unicode_chr_58_unicode_empty_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_unicode_chr_58_unicode_empty_tuple, 0, const_unicode_chr_58 ); Py_INCREF( const_unicode_chr_58 );
    PyTuple_SET_ITEM( const_tuple_unicode_chr_58_unicode_empty_tuple, 1, const_unicode_empty ); Py_INCREF( const_unicode_empty );
    const_str_plain__compress_hextets = UNSTREAM_STRING( &constant_bin[ 914472 ], 17, 1 );
    const_frozenset_bcfae996d3e8c0199d3734036089d854 = PyFrozenSet_New( NULL );
    PySet_Add( const_frozenset_bcfae996d3e8c0199d3734036089d854, const_int_pos_224 );
    PySet_Add( const_frozenset_bcfae996d3e8c0199d3734036089d854, const_int_pos_192 );
    PySet_Add( const_frozenset_bcfae996d3e8c0199d3734036089d854, const_int_0 );
    PySet_Add( const_frozenset_bcfae996d3e8c0199d3734036089d854, const_int_pos_128 );
    PySet_Add( const_frozenset_bcfae996d3e8c0199d3734036089d854, const_int_pos_240 );
    const_int_pos_248 = PyInt_FromLong( 248l );
    PySet_Add( const_frozenset_bcfae996d3e8c0199d3734036089d854, const_int_pos_248 );
    PySet_Add( const_frozenset_bcfae996d3e8c0199d3734036089d854, const_int_pos_252 );
    PySet_Add( const_frozenset_bcfae996d3e8c0199d3734036089d854, const_int_pos_254 );
    PySet_Add( const_frozenset_bcfae996d3e8c0199d3734036089d854, const_int_pos_255 );
    assert( PySet_Size( const_frozenset_bcfae996d3e8c0199d3734036089d854 ) == 9 );
    const_str_plain_skip_index = UNSTREAM_STRING( &constant_bin[ 914489 ], 10, 1 );
    const_str_plain_equal = UNSTREAM_STRING( &constant_bin[ 10550 ], 5, 1 );
    const_unicode_digest_da1818644dfbad301b75eda6d440ddac = UNSTREAM_UNICODE( &constant_bin[ 914499 ], 187 );
    const_unicode_digest_f46719d0b0a4fb0eb47fa9ca9304fff5 = UNSTREAM_UNICODE( &constant_bin[ 914686 ], 47 );
    const_tuple_str_plain_number_str_plain_bits_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_number_str_plain_bits_tuple, 0, const_str_plain_number ); Py_INCREF( const_str_plain_number );
    PyTuple_SET_ITEM( const_tuple_str_plain_number_str_plain_bits_tuple, 1, const_str_plain_bits ); Py_INCREF( const_str_plain_bits );
    const_unicode_digest_b75fb6a47d7489ff4ba1e06eb56d2178 = UNSTREAM_UNICODE( &constant_bin[ 914733 ], 249 );
    const_tuple_str_plain_i_str_plain_res_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_i_str_plain_res_tuple, 0, const_str_plain_i ); Py_INCREF( const_str_plain_i );
    PyTuple_SET_ITEM( const_tuple_str_plain_i_str_plain_res_tuple, 1, const_str_plain_res ); Py_INCREF( const_str_plain_res );
    const_str_plain_IPv4Interface = UNSTREAM_STRING( &constant_bin[ 902126 ], 13, 1 );
    const_unicode_digest_9cdf3b748ac1a53affbd72eda589ecda = UNSTREAM_UNICODE( &constant_bin[ 914982 ], 20 );
    const_str_plain__compat_int_types = UNSTREAM_STRING( &constant_bin[ 915002 ], 17, 1 );
    const_str_plain_is_link_local = UNSTREAM_STRING( &constant_bin[ 915019 ], 13, 1 );
    const_tuple_ebba5bcca06086e920bc53fbfdc7c8df_tuple = PyTuple_New( 9 );
    PyTuple_SET_ITEM( const_tuple_ebba5bcca06086e920bc53fbfdc7c8df_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_ebba5bcca06086e920bc53fbfdc7c8df_tuple, 1, const_str_plain_prefixlen_diff ); Py_INCREF( const_str_plain_prefixlen_diff );
    PyTuple_SET_ITEM( const_tuple_ebba5bcca06086e920bc53fbfdc7c8df_tuple, 2, const_str_plain_new_prefix ); Py_INCREF( const_str_plain_new_prefix );
    PyTuple_SET_ITEM( const_tuple_ebba5bcca06086e920bc53fbfdc7c8df_tuple, 3, const_str_plain_end ); Py_INCREF( const_str_plain_end );
    PyTuple_SET_ITEM( const_tuple_ebba5bcca06086e920bc53fbfdc7c8df_tuple, 4, const_str_plain_new_addr ); Py_INCREF( const_str_plain_new_addr );
    PyTuple_SET_ITEM( const_tuple_ebba5bcca06086e920bc53fbfdc7c8df_tuple, 5, const_str_plain_new_prefixlen ); Py_INCREF( const_str_plain_new_prefixlen );
    PyTuple_SET_ITEM( const_tuple_ebba5bcca06086e920bc53fbfdc7c8df_tuple, 6, const_str_plain_current ); Py_INCREF( const_str_plain_current );
    PyTuple_SET_ITEM( const_tuple_ebba5bcca06086e920bc53fbfdc7c8df_tuple, 7, const_str_plain_start ); Py_INCREF( const_str_plain_start );
    PyTuple_SET_ITEM( const_tuple_ebba5bcca06086e920bc53fbfdc7c8df_tuple, 8, const_str_plain_step ); Py_INCREF( const_str_plain_step );
    const_unicode_digest_11db8dad0fdf85c306f5f6455601667d = UNSTREAM_UNICODE( &constant_bin[ 915032 ], 26 );
    const_tuple_unicode_digest_405ec5ff1c943cd273b0a0932b950391_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_405ec5ff1c943cd273b0a0932b950391_tuple, 0, const_unicode_digest_405ec5ff1c943cd273b0a0932b950391 ); Py_INCREF( const_unicode_digest_405ec5ff1c943cd273b0a0932b950391 );
    const_unicode_digest_4a4ec0bacc4ed8ebd5a4ce6c53c46388 = UNSTREAM_UNICODE( &constant_bin[ 915058 ], 120 );
    const_str_plain__reserved_network = UNSTREAM_STRING( &constant_bin[ 899290 ], 17, 1 );
    const_unicode_digest_187d30b5b2f1b6be67346bce62c4882f = UNSTREAM_UNICODE( &constant_bin[ 915178 ], 126 );
    const_unicode_digest_c4c97910d07aba163465ecf409f4030a = UNSTREAM_UNICODE( &constant_bin[ 915304 ], 49 );
    const_tuple_unicode_digest_97a8ca337c0108210bc28d6fe8f8ec60_tuple = PyTuple_New( 1 );
    const_unicode_digest_97a8ca337c0108210bc28d6fe8f8ec60 = UNSTREAM_UNICODE( &constant_bin[ 915353 ], 14 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_97a8ca337c0108210bc28d6fe8f8ec60_tuple, 0, const_unicode_digest_97a8ca337c0108210bc28d6fe8f8ec60 ); Py_INCREF( const_unicode_digest_97a8ca337c0108210bc28d6fe8f8ec60 );
    const_unicode_digest_d44bacc2290b5d18e632348ff9d94d65 = UNSTREAM_UNICODE( &constant_bin[ 915367 ], 6 );
    const_unicode_digest_dec03ab398d5a59037dd890fd3350705 = UNSTREAM_UNICODE( &constant_bin[ 915373 ], 42 );
    const_str_plain__min_parts = UNSTREAM_STRING( &constant_bin[ 915415 ], 10, 1 );
    const_unicode_digest_ac7f50929eae86b4966b77df5788b37d = UNSTREAM_UNICODE( &constant_bin[ 915425 ], 37 );
    const_unicode_plain_network_address = UNSTREAM_UNICODE( &constant_bin[ 902800 ], 15 );
    const_tuple_unicode_digest_9b517c1b35c5efe37b498ee36f2a46c2_tuple = PyTuple_New( 1 );
    const_unicode_digest_9b517c1b35c5efe37b498ee36f2a46c2 = UNSTREAM_UNICODE( &constant_bin[ 915462 ], 11 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_9b517c1b35c5efe37b498ee36f2a46c2_tuple, 0, const_unicode_digest_9b517c1b35c5efe37b498ee36f2a46c2 ); Py_INCREF( const_unicode_digest_9b517c1b35c5efe37b498ee36f2a46c2 );
    const_str_plain_teredo = UNSTREAM_STRING( &constant_bin[ 910370 ], 6, 1 );
    const_tuple_9098f7d838724863c7318ae87cb1bc40_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_9098f7d838724863c7318ae87cb1bc40_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_9098f7d838724863c7318ae87cb1bc40_tuple, 1, const_str_plain_address ); Py_INCREF( const_str_plain_address );
    PyTuple_SET_ITEM( const_tuple_9098f7d838724863c7318ae87cb1bc40_tuple, 2, const_str_plain_expected_len ); Py_INCREF( const_str_plain_expected_len );
    PyTuple_SET_ITEM( const_tuple_9098f7d838724863c7318ae87cb1bc40_tuple, 3, const_str_plain_msg ); Py_INCREF( const_str_plain_msg );
    const_str_plain_address_len = UNSTREAM_STRING( &constant_bin[ 915473 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_9098f7d838724863c7318ae87cb1bc40_tuple, 4, const_str_plain_address_len ); Py_INCREF( const_str_plain_address_len );
    const_str_plain_address_less = UNSTREAM_STRING( &constant_bin[ 915484 ], 12, 1 );
    const_str_plain_is_private = UNSTREAM_STRING( &constant_bin[ 901626 ], 10, 1 );
    const_tuple_unicode_digest_5bbe393519c9f8f834b0e4362b7f4892_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_5bbe393519c9f8f834b0e4362b7f4892_tuple, 0, const_unicode_digest_5bbe393519c9f8f834b0e4362b7f4892 ); Py_INCREF( const_unicode_digest_5bbe393519c9f8f834b0e4362b7f4892 );
    const_str_plain__IPAddressBase = UNSTREAM_STRING( &constant_bin[ 915496 ], 14, 1 );
    const_str_plain_is_global = UNSTREAM_STRING( &constant_bin[ 915510 ], 9, 1 );
    const_tuple_unicode_digest_ab9c76df45bc1dd7612ee4e57cee2742_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_ab9c76df45bc1dd7612ee4e57cee2742_tuple, 0, const_unicode_digest_ab9c76df45bc1dd7612ee4e57cee2742 ); Py_INCREF( const_unicode_digest_ab9c76df45bc1dd7612ee4e57cee2742 );
    const_unicode_digest_2bc0198930fe74059a20349326880c0a = UNSTREAM_UNICODE( &constant_bin[ 915519 ], 210 );
    const_unicode_digest_e117cb895af56362aabb03455887d34f = UNSTREAM_UNICODE( &constant_bin[ 915729 ], 31 );
    const_tuple_3c4458665ec97984dbef4c959f27790d_tuple = PyTuple_New( 7 );
    PyTuple_SET_ITEM( const_tuple_3c4458665ec97984dbef4c959f27790d_tuple, 0, const_str_plain_addresses ); Py_INCREF( const_str_plain_addresses );
    PyTuple_SET_ITEM( const_tuple_3c4458665ec97984dbef4c959f27790d_tuple, 1, const_str_plain_last ); Py_INCREF( const_str_plain_last );
    PyTuple_SET_ITEM( const_tuple_3c4458665ec97984dbef4c959f27790d_tuple, 2, const_str_plain_ip ); Py_INCREF( const_str_plain_ip );
    PyTuple_SET_ITEM( const_tuple_3c4458665ec97984dbef4c959f27790d_tuple, 3, const_str_plain_ips ); Py_INCREF( const_str_plain_ips );
    const_str_plain_addrs = UNSTREAM_STRING( &constant_bin[ 915760 ], 5, 1 );
    PyTuple_SET_ITEM( const_tuple_3c4458665ec97984dbef4c959f27790d_tuple, 4, const_str_plain_addrs ); Py_INCREF( const_str_plain_addrs );
    PyTuple_SET_ITEM( const_tuple_3c4458665ec97984dbef4c959f27790d_tuple, 5, const_str_plain_nets ); Py_INCREF( const_str_plain_nets );
    PyTuple_SET_ITEM( const_tuple_3c4458665ec97984dbef4c959f27790d_tuple, 6, const_str_plain_first ); Py_INCREF( const_str_plain_first );
    const_tuple_unicode_digest_8de571133ab8b9176c149e4e2555e2e4_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_8de571133ab8b9176c149e4e2555e2e4_tuple, 0, const_unicode_digest_8de571133ab8b9176c149e4e2555e2e4 ); Py_INCREF( const_unicode_digest_8de571133ab8b9176c149e4e2555e2e4 );
    const_str_plain_compare_networks = UNSTREAM_STRING( &constant_bin[ 915765 ], 16, 1 );
    const_tuple_unicode_digest_25403b7f1a1d82d5241e55405508207f_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_25403b7f1a1d82d5241e55405508207f_tuple, 0, const_unicode_digest_25403b7f1a1d82d5241e55405508207f ); Py_INCREF( const_unicode_digest_25403b7f1a1d82d5241e55405508207f );
    const_str_plain_collapse_addresses = UNSTREAM_STRING( &constant_bin[ 899731 ], 18, 1 );
    const_unicode_digest_dddb1f670b53dd4bfeade670d60a460f = UNSTREAM_UNICODE( &constant_bin[ 915781 ], 50 );
    const_str_plain_broadcast_address = UNSTREAM_STRING( &constant_bin[ 902894 ], 17, 1 );
    const_str_plain_first_int = UNSTREAM_STRING( &constant_bin[ 915831 ], 9, 1 );
    const_tuple_unicode_digest_aaa8df82589e3fcc3c5dc300a83c6345_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_aaa8df82589e3fcc3c5dc300a83c6345_tuple, 0, const_unicode_digest_aaa8df82589e3fcc3c5dc300a83c6345 ); Py_INCREF( const_unicode_digest_aaa8df82589e3fcc3c5dc300a83c6345 );
    const_str_plain_is_loopback = UNSTREAM_STRING( &constant_bin[ 915840 ], 11, 1 );
    const_tuple_unicode_digest_8f4a5718a9f7024daab1c7cbc36c9839_tuple = PyTuple_New( 1 );
    const_unicode_digest_8f4a5718a9f7024daab1c7cbc36c9839 = UNSTREAM_UNICODE( &constant_bin[ 915851 ], 14 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_8f4a5718a9f7024daab1c7cbc36c9839_tuple, 0, const_unicode_digest_8f4a5718a9f7024daab1c7cbc36c9839 ); Py_INCREF( const_unicode_digest_8f4a5718a9f7024daab1c7cbc36c9839 );
    const_tuple_unicode_digest_509911ef653d68dc2d9e8bf72450b69f_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_509911ef653d68dc2d9e8bf72450b69f_tuple, 0, const_unicode_digest_509911ef653d68dc2d9e8bf72450b69f ); Py_INCREF( const_unicode_digest_509911ef653d68dc2d9e8bf72450b69f );
    const_str_plain_IPv6Interface = UNSTREAM_STRING( &constant_bin[ 902143 ], 13, 1 );
    const_str_plain__BaseV4 = UNSTREAM_STRING( &constant_bin[ 915865 ], 7, 1 );
    const_str_plain__BaseV6 = UNSTREAM_STRING( &constant_bin[ 915872 ], 7, 1 );
    const_unicode_digest_7ed15216d64208508e99692b4f3b95c2 = UNSTREAM_UNICODE( &constant_bin[ 915879 ], 1210 );
    const_unicode_digest_2cede8cd7bf3896918371527eb9b7688 = UNSTREAM_UNICODE( &constant_bin[ 917089 ], 48 );
    const_frozenset_92edb4f75c5f6d7fbad23f3049445af9 = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 917137 ], 137 );
    const_unicode_digest_4d7919668db95bf4651353bc6dceea2a = UNSTREAM_UNICODE( &constant_bin[ 917274 ], 268 );
    const_str_plain__max_prefixlen = UNSTREAM_STRING( &constant_bin[ 917542 ], 14, 1 );
    const_tuple_str_plain_byt_str_plain_b_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_byt_str_plain_b_tuple, 0, const_str_plain_byt ); Py_INCREF( const_str_plain_byt );
    PyTuple_SET_ITEM( const_tuple_str_plain_byt_str_plain_b_tuple, 1, const_str_plain_b ); Py_INCREF( const_str_plain_b );
    const_tuple_unicode_digest_e387280a229c9db974e6c776d288bba6_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_e387280a229c9db974e6c776d288bba6_tuple, 0, const_unicode_digest_e387280a229c9db974e6c776d288bba6 ); Py_INCREF( const_unicode_digest_e387280a229c9db974e6c776d288bba6 );
    const_unicode_digest_b42e9aabcda64e41c569cb9a106baed7 = UNSTREAM_UNICODE( &constant_bin[ 917556 ], 33 );
    const_str_plain_get_mixed_type_key = UNSTREAM_STRING( &constant_bin[ 917589 ], 18, 1 );
    const_str_plain_parts_hi = UNSTREAM_STRING( &constant_bin[ 917607 ], 8, 1 );
    const_tuple_unicode_digest_e4b0d176f96493dd1d5d8cbd14cab77e_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_e4b0d176f96493dd1d5d8cbd14cab77e_tuple, 0, const_unicode_digest_e4b0d176f96493dd1d5d8cbd14cab77e ); Py_INCREF( const_unicode_digest_e4b0d176f96493dd1d5d8cbd14cab77e );
    const_unicode_digest_07222984af8a611c2d56ff1f58bcbed2 = UNSTREAM_UNICODE( &constant_bin[ 917615 ], 8 );
    const_unicode_digest_9ccf09593a54d4a7dcc17d246e4f9cea = UNSTREAM_UNICODE( &constant_bin[ 917623 ], 162 );
    const_tuple_unicode_digest_dd933a225f1d557f2f9048900cc16f9b_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_dd933a225f1d557f2f9048900cc16f9b_tuple, 0, const_unicode_digest_dd933a225f1d557f2f9048900cc16f9b ); Py_INCREF( const_unicode_digest_dd933a225f1d557f2f9048900cc16f9b );
    const_unicode_digest_90bd5c6e55bae17fe8d70044d13f64fa = UNSTREAM_UNICODE( &constant_bin[ 917785 ], 35 );
    const_str_plain_IPV4LENGTH = UNSTREAM_STRING( &constant_bin[ 917820 ], 10, 1 );
    const_str_plain__ip = UNSTREAM_STRING( &constant_bin[ 92078 ], 3, 1 );
    const_str_plain_bytvals = UNSTREAM_STRING( &constant_bin[ 917830 ], 7, 1 );
    const_unicode_digest_e44f916e3d7ef9d976f7d25c6c24f69c = UNSTREAM_UNICODE( &constant_bin[ 917837 ], 212 );
    const_unicode_digest_93b62600511a380f0935203a9df4765e = UNSTREAM_UNICODE( &constant_bin[ 918049 ], 41 );
    const_unicode_digest_edea999b5d5c2e617dee49e550687c1b = UNSTREAM_UNICODE( &constant_bin[ 918090 ], 433 );
    const_tuple_eb9d897fb9f331042703df74e8349709_tuple = PyTuple_New( 9 );
    PyTuple_SET_ITEM( const_tuple_eb9d897fb9f331042703df74e8349709_tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    PyTuple_SET_ITEM( const_tuple_eb9d897fb9f331042703df74e8349709_tuple, 1, const_str_plain_ip_int ); Py_INCREF( const_str_plain_ip_int );
    PyTuple_SET_ITEM( const_tuple_eb9d897fb9f331042703df74e8349709_tuple, 2, const_str_plain_leading_ones ); Py_INCREF( const_str_plain_leading_ones );
    PyTuple_SET_ITEM( const_tuple_eb9d897fb9f331042703df74e8349709_tuple, 3, const_str_plain_byteslen ); Py_INCREF( const_str_plain_byteslen );
    PyTuple_SET_ITEM( const_tuple_eb9d897fb9f331042703df74e8349709_tuple, 4, const_str_plain_trailing_zeroes ); Py_INCREF( const_str_plain_trailing_zeroes );
    PyTuple_SET_ITEM( const_tuple_eb9d897fb9f331042703df74e8349709_tuple, 5, const_str_plain_msg ); Py_INCREF( const_str_plain_msg );
    PyTuple_SET_ITEM( const_tuple_eb9d897fb9f331042703df74e8349709_tuple, 6, const_str_plain_all_ones ); Py_INCREF( const_str_plain_all_ones );
    PyTuple_SET_ITEM( const_tuple_eb9d897fb9f331042703df74e8349709_tuple, 7, const_str_plain_details ); Py_INCREF( const_str_plain_details );
    PyTuple_SET_ITEM( const_tuple_eb9d897fb9f331042703df74e8349709_tuple, 8, const_str_plain_prefixlen ); Py_INCREF( const_str_plain_prefixlen );
    const_str_plain__collapse_addresses_internal = UNSTREAM_STRING( &constant_bin[ 918523 ], 28, 1 );
    const_str_plain_bv = UNSTREAM_STRING( &constant_bin[ 898016 ], 2, 1 );
    const_tuple_str_plain_self_str_plain_other_str_plain_equal_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_other_str_plain_equal_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_other_str_plain_equal_tuple, 1, const_str_plain_other ); Py_INCREF( const_str_plain_other );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_other_str_plain_equal_tuple, 2, const_str_plain_equal ); Py_INCREF( const_str_plain_equal );
    const_unicode_digest_e58d37c1cbee6b52618f84115bc05cfc = UNSTREAM_UNICODE( &constant_bin[ 918551 ], 172 );
    const_str_plain__IPv4Constants = UNSTREAM_STRING( &constant_bin[ 918723 ], 14, 1 );
    const_tuple_unicode_digest_5b7f2e4a3310487a05cd73dbdc2ec2d9_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_5b7f2e4a3310487a05cd73dbdc2ec2d9_tuple, 0, const_unicode_digest_5b7f2e4a3310487a05cd73dbdc2ec2d9 ); Py_INCREF( const_unicode_digest_5b7f2e4a3310487a05cd73dbdc2ec2d9 );
    const_tuple_f0912223de68829e67499bcb23f9060a_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_f0912223de68829e67499bcb23f9060a_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_f0912223de68829e67499bcb23f9060a_tuple, 1, const_str_plain_ip_str ); Py_INCREF( const_str_plain_ip_str );
    PyTuple_SET_ITEM( const_tuple_f0912223de68829e67499bcb23f9060a_tuple, 2, const_str_plain_parts ); Py_INCREF( const_str_plain_parts );
    PyTuple_SET_ITEM( const_tuple_f0912223de68829e67499bcb23f9060a_tuple, 3, const_str_plain_bits ); Py_INCREF( const_str_plain_bits );
    PyTuple_SET_ITEM( const_tuple_f0912223de68829e67499bcb23f9060a_tuple, 4, const_str_plain_x ); Py_INCREF( const_str_plain_x );
    const_tuple_unicode_plain_hostmask_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_unicode_plain_hostmask_tuple, 0, const_unicode_plain_hostmask ); Py_INCREF( const_unicode_plain_hostmask );
    const_tuple_unicode_digest_07222984af8a611c2d56ff1f58bcbed2_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_07222984af8a611c2d56ff1f58bcbed2_tuple, 0, const_unicode_digest_07222984af8a611c2d56ff1f58bcbed2 ); Py_INCREF( const_unicode_digest_07222984af8a611c2d56ff1f58bcbed2 );
    const_unicode_digest_a8976dae4f4cb6a171c90676e02e7864 = UNSTREAM_UNICODE( &constant_bin[ 918737 ], 164 );
    const_unicode_digest_d83a1159969df2ac8ecaadc60ffc52aa = UNSTREAM_UNICODE( &constant_bin[ 918901 ], 329 );
    const_unicode_digest_87736fe902d897d977541c59e5443d08 = UNSTREAM_UNICODE( &constant_bin[ 919230 ], 25 );
    const_unicode_digest_3f6240938cc8b4c3691344def7c310a8 = UNSTREAM_UNICODE( &constant_bin[ 919255 ], 5 );
    const_tuple_unicode_digest_93b62600511a380f0935203a9df4765e_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_93b62600511a380f0935203a9df4765e_tuple, 0, const_unicode_digest_93b62600511a380f0935203a9df4765e ); Py_INCREF( const_unicode_digest_93b62600511a380f0935203a9df4765e );
    const_str_plain_issuperset = UNSTREAM_STRING( &constant_bin[ 919260 ], 10, 1 );
    const_str_plain_v4_int_to_packed = UNSTREAM_STRING( &constant_bin[ 919270 ], 16, 1 );
    const_str_plain__multicast_network = UNSTREAM_STRING( &constant_bin[ 919286 ], 18, 1 );
    const_str_plain_hosts = UNSTREAM_STRING( &constant_bin[ 905176 ], 5, 1 );
    const_str_plain_ipv4_mapped = UNSTREAM_STRING( &constant_bin[ 919304 ], 11, 1 );
    const_tuple_unicode_digest_dadff6dd3651f30e8cbbdd26cdbce215_tuple = PyTuple_New( 1 );
    const_unicode_digest_dadff6dd3651f30e8cbbdd26cdbce215 = UNSTREAM_UNICODE( &constant_bin[ 900410 ], 7 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_dadff6dd3651f30e8cbbdd26cdbce215_tuple, 0, const_unicode_digest_dadff6dd3651f30e8cbbdd26cdbce215 ); Py_INCREF( const_unicode_digest_dadff6dd3651f30e8cbbdd26cdbce215 );
    const_unicode_digest_54697220435798be94259c75534ddc2b = UNSTREAM_UNICODE( &constant_bin[ 919315 ], 144 );
    const_unicode_digest_a2d4646a8cc0fa37c20d1bd32a19571f = UNSTREAM_UNICODE( &constant_bin[ 919459 ], 1554 );
    const_tuple_50559fec2f469c57aa556ccd83f2df71_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_50559fec2f469c57aa556ccd83f2df71_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_50559fec2f469c57aa556ccd83f2df71_tuple, 1, const_str_plain_hex_str ); Py_INCREF( const_str_plain_hex_str );
    PyTuple_SET_ITEM( const_tuple_50559fec2f469c57aa556ccd83f2df71_tuple, 2, const_str_plain_ip_int ); Py_INCREF( const_str_plain_ip_int );
    PyTuple_SET_ITEM( const_tuple_50559fec2f469c57aa556ccd83f2df71_tuple, 3, const_str_plain_parts ); Py_INCREF( const_str_plain_parts );
    PyTuple_SET_ITEM( const_tuple_50559fec2f469c57aa556ccd83f2df71_tuple, 4, const_str_plain_x ); Py_INCREF( const_str_plain_x );
    PyTuple_SET_ITEM( const_tuple_50559fec2f469c57aa556ccd83f2df71_tuple, 5, const_str_plain_ip_str ); Py_INCREF( const_str_plain_ip_str );
    const_unicode_digest_47216010aeed65d4a29c64ed034fbfdb = UNSTREAM_UNICODE( &constant_bin[ 921013 ], 47 );
    const_tuple_unicode_digest_eabcf4377ca85e7b53b572d3d3177fe1_tuple = PyTuple_New( 1 );
    const_unicode_digest_eabcf4377ca85e7b53b572d3d3177fe1 = UNSTREAM_UNICODE( &constant_bin[ 921060 ], 13 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_eabcf4377ca85e7b53b572d3d3177fe1_tuple, 0, const_unicode_digest_eabcf4377ca85e7b53b572d3d3177fe1 ); Py_INCREF( const_unicode_digest_eabcf4377ca85e7b53b572d3d3177fe1 );
    const_tuple_unicode_digest_fce80ade8999b448027d3bc78b9fd2e2_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_fce80ade8999b448027d3bc78b9fd2e2_tuple, 0, const_unicode_digest_fce80ade8999b448027d3bc78b9fd2e2 ); Py_INCREF( const_unicode_digest_fce80ade8999b448027d3bc78b9fd2e2 );
    const_unicode_digest_f77aa8bd91c4bb866a3ac2b2f1ae555f = UNSTREAM_UNICODE( &constant_bin[ 921073 ], 352 );
    const_tuple_20590e930689906083ade7009277cd69_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_20590e930689906083ade7009277cd69_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_20590e930689906083ade7009277cd69_tuple, 1, const_str_plain_broadcast ); Py_INCREF( const_str_plain_broadcast );
    PyTuple_SET_ITEM( const_tuple_20590e930689906083ade7009277cd69_tuple, 2, const_str_plain_x ); Py_INCREF( const_str_plain_x );
    PyTuple_SET_ITEM( const_tuple_20590e930689906083ade7009277cd69_tuple, 3, const_str_plain_network ); Py_INCREF( const_str_plain_network );
    const_unicode_digest_5381a247d80f448053c8b52e061aecc0 = UNSTREAM_UNICODE( &constant_bin[ 921425 ], 38 );
    const_tuple_a0fcb231785a6904cd1cb11afbf3073f_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_a0fcb231785a6904cd1cb11afbf3073f_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_a0fcb231785a6904cd1cb11afbf3073f_tuple, 1, const_str_plain_other ); Py_INCREF( const_str_plain_other );
    PyTuple_SET_ITEM( const_tuple_a0fcb231785a6904cd1cb11afbf3073f_tuple, 2, const_str_plain_equal ); Py_INCREF( const_str_plain_equal );
    PyTuple_SET_ITEM( const_tuple_a0fcb231785a6904cd1cb11afbf3073f_tuple, 3, const_str_plain_less ); Py_INCREF( const_str_plain_less );
    const_str_plain_hostmask = UNSTREAM_STRING( &constant_bin[ 900598 ], 8, 1 );
    const_tuple_f71b17521653e2cdc027d93583942731_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_f71b17521653e2cdc027d93583942731_tuple, 0, const_str_plain_addresses ); Py_INCREF( const_str_plain_addresses );
    PyTuple_SET_ITEM( const_tuple_f71b17521653e2cdc027d93583942731_tuple, 1, const_str_plain_ip ); Py_INCREF( const_str_plain_ip );
    PyTuple_SET_ITEM( const_tuple_f71b17521653e2cdc027d93583942731_tuple, 2, const_str_plain_first ); Py_INCREF( const_str_plain_first );
    PyTuple_SET_ITEM( const_tuple_f71b17521653e2cdc027d93583942731_tuple, 3, const_str_plain_last ); Py_INCREF( const_str_plain_last );
    PyTuple_SET_ITEM( const_tuple_f71b17521653e2cdc027d93583942731_tuple, 4, const_str_plain_it ); Py_INCREF( const_str_plain_it );
    const_str_plain__check_packed_address = UNSTREAM_STRING( &constant_bin[ 921463 ], 21, 1 );
    const_unicode_digest_a6071b8f181f3ae395076bdc2a3c343f = UNSTREAM_UNICODE( &constant_bin[ 921484 ], 217 );
    const_unicode_digest_7034ed78731a4da5e33c8be78a50d678 = UNSTREAM_UNICODE( &constant_bin[ 921701 ], 121 );
    const_tuple_str_plain_address_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_address_tuple, 0, const_str_plain_address ); Py_INCREF( const_str_plain_address );
    const_unicode_digest_e922c2e07060bd895f3f403962951e84 = UNSTREAM_UNICODE( &constant_bin[ 921822 ], 37 );
    const_tuple_afca6ebc709d3fc175a5c8a3ab536908_tuple = PyTuple_New( 8 );
    PyTuple_SET_ITEM( const_tuple_afca6ebc709d3fc175a5c8a3ab536908_tuple, 0, const_str_plain_first ); Py_INCREF( const_str_plain_first );
    PyTuple_SET_ITEM( const_tuple_afca6ebc709d3fc175a5c8a3ab536908_tuple, 1, const_str_plain_last ); Py_INCREF( const_str_plain_last );
    PyTuple_SET_ITEM( const_tuple_afca6ebc709d3fc175a5c8a3ab536908_tuple, 2, const_str_plain_nbits ); Py_INCREF( const_str_plain_nbits );
    PyTuple_SET_ITEM( const_tuple_afca6ebc709d3fc175a5c8a3ab536908_tuple, 3, const_str_plain_ip ); Py_INCREF( const_str_plain_ip );
    PyTuple_SET_ITEM( const_tuple_afca6ebc709d3fc175a5c8a3ab536908_tuple, 4, const_str_plain_last_int ); Py_INCREF( const_str_plain_last_int );
    PyTuple_SET_ITEM( const_tuple_afca6ebc709d3fc175a5c8a3ab536908_tuple, 5, const_str_plain_ip_bits ); Py_INCREF( const_str_plain_ip_bits );
    PyTuple_SET_ITEM( const_tuple_afca6ebc709d3fc175a5c8a3ab536908_tuple, 6, const_str_plain_net ); Py_INCREF( const_str_plain_net );
    PyTuple_SET_ITEM( const_tuple_afca6ebc709d3fc175a5c8a3ab536908_tuple, 7, const_str_plain_first_int ); Py_INCREF( const_str_plain_first_int );
    const_unicode_digest_a6ef81b4dc8d6ca51bcc72d4b8e50fda = UNSTREAM_UNICODE( &constant_bin[ 921859 ], 129 );
    const_unicode_digest_fd94faa8eb259b55b9c302cc8ca594ce = UNSTREAM_UNICODE( &constant_bin[ 921988 ], 51 );
    const_tuple_str_plain_self_str_plain_other_str_plain_address_less_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_other_str_plain_address_less_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_other_str_plain_address_less_tuple, 1, const_str_plain_other ); Py_INCREF( const_str_plain_other );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_other_str_plain_address_less_tuple, 2, const_str_plain_address_less ); Py_INCREF( const_str_plain_address_less );
    const_tuple_unicode_digest_1c66251700e583bec5e8354f1f3817f8_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_1c66251700e583bec5e8354f1f3817f8_tuple, 0, const_unicode_digest_1c66251700e583bec5e8354f1f3817f8 ); Py_INCREF( const_unicode_digest_1c66251700e583bec5e8354f1f3817f8 );
    const_unicode_digest_5efcd38faf89c403a070f9e85430b29c = UNSTREAM_UNICODE( &constant_bin[ 922039 ], 22 );
    const_tuple_unicode_digest_f639d7203410adb553caafbcf683161e_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_f639d7203410adb553caafbcf683161e_tuple, 0, const_unicode_digest_f639d7203410adb553caafbcf683161e ); Py_INCREF( const_unicode_digest_f639d7203410adb553caafbcf683161e );
    const_unicode_digest_307b618e8fe3dea44ed44b7622abf36e = UNSTREAM_UNICODE( &constant_bin[ 922061 ], 13 );
    const_unicode_digest_2d8623d8a6589c5a67c27cdfbfcf46e3 = UNSTREAM_UNICODE( &constant_bin[ 922074 ], 181 );
    const_tuple_unicode_digest_fdc180e651f53b5645d6e63208353e99_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_fdc180e651f53b5645d6e63208353e99_tuple, 0, const_unicode_digest_fdc180e651f53b5645d6e63208353e99 ); Py_INCREF( const_unicode_digest_fdc180e651f53b5645d6e63208353e99 );
    const_unicode_digest_748251f41c9803a0c044ac91f17a32ea = UNSTREAM_UNICODE( &constant_bin[ 922255 ], 38 );
    const_tuple_str_plain_cls_str_plain_prefixlen_str_str_plain_prefixlen_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_prefixlen_str_str_plain_prefixlen_tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_prefixlen_str_str_plain_prefixlen_tuple, 1, const_str_plain_prefixlen_str ); Py_INCREF( const_str_plain_prefixlen_str );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_prefixlen_str_str_plain_prefixlen_tuple, 2, const_str_plain_prefixlen ); Py_INCREF( const_str_plain_prefixlen );
    const_tuple_unicode_digest_6439cf0468d27650b3db2b06ff3a5dd1_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_6439cf0468d27650b3db2b06ff3a5dd1_tuple, 0, const_unicode_digest_6439cf0468d27650b3db2b06ff3a5dd1 ); Py_INCREF( const_unicode_digest_6439cf0468d27650b3db2b06ff3a5dd1 );
    const_unicode_digest_dce79371adf00f5e6de2f2d426c56f59 = UNSTREAM_UNICODE( &constant_bin[ 922293 ], 177 );
    const_unicode_digest_7e2f39ab56e1398f630fda41c7d495e6 = UNSTREAM_UNICODE( &constant_bin[ 922470 ], 185 );
    const_tuple_unicode_digest_307b618e8fe3dea44ed44b7622abf36e_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_307b618e8fe3dea44ed44b7622abf36e_tuple, 0, const_unicode_digest_307b618e8fe3dea44ed44b7622abf36e ); Py_INCREF( const_unicode_digest_307b618e8fe3dea44ed44b7622abf36e );
    const_tuple_4cc0ec93b988fc0a4ad89cdb6c285e41_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_4cc0ec93b988fc0a4ad89cdb6c285e41_tuple, 0, const_str_plain_bytvals ); Py_INCREF( const_str_plain_bytvals );
    PyTuple_SET_ITEM( const_tuple_4cc0ec93b988fc0a4ad89cdb6c285e41_tuple, 1, const_str_plain_endianess ); Py_INCREF( const_str_plain_endianess );
    PyTuple_SET_ITEM( const_tuple_4cc0ec93b988fc0a4ad89cdb6c285e41_tuple, 2, const_str_plain_bv ); Py_INCREF( const_str_plain_bv );
    PyTuple_SET_ITEM( const_tuple_4cc0ec93b988fc0a4ad89cdb6c285e41_tuple, 3, const_str_plain_res ); Py_INCREF( const_str_plain_res );
    const_unicode_digest_577627ae9fd0ef6e23ffee5af41f536a = UNSTREAM_UNICODE( &constant_bin[ 922655 ], 173 );
    const_tuple_3447faa1dbe297d65e63446bccca6976_tuple = PyTuple_New( 8 );
    PyTuple_SET_ITEM( const_tuple_3447faa1dbe297d65e63446bccca6976_tuple, 0, const_int_0 ); Py_INCREF( const_int_0 );
    PyTuple_SET_ITEM( const_tuple_3447faa1dbe297d65e63446bccca6976_tuple, 1, const_int_pos_4 ); Py_INCREF( const_int_pos_4 );
    PyTuple_SET_ITEM( const_tuple_3447faa1dbe297d65e63446bccca6976_tuple, 2, const_int_pos_8 ); Py_INCREF( const_int_pos_8 );
    PyTuple_SET_ITEM( const_tuple_3447faa1dbe297d65e63446bccca6976_tuple, 3, const_int_pos_12 ); Py_INCREF( const_int_pos_12 );
    PyTuple_SET_ITEM( const_tuple_3447faa1dbe297d65e63446bccca6976_tuple, 4, const_int_pos_16 ); Py_INCREF( const_int_pos_16 );
    PyTuple_SET_ITEM( const_tuple_3447faa1dbe297d65e63446bccca6976_tuple, 5, const_int_pos_20 ); Py_INCREF( const_int_pos_20 );
    PyTuple_SET_ITEM( const_tuple_3447faa1dbe297d65e63446bccca6976_tuple, 6, const_int_pos_24 ); Py_INCREF( const_int_pos_24 );
    PyTuple_SET_ITEM( const_tuple_3447faa1dbe297d65e63446bccca6976_tuple, 7, const_int_pos_28 ); Py_INCREF( const_int_pos_28 );
    const_unicode_digest_eddf7f22fedb80dd2c5a5c8cec1a1c87 = UNSTREAM_UNICODE( &constant_bin[ 922828 ], 629 );
    const_unicode_digest_3d11cbcbf80fa8d2b7c658c556c6918d = UNSTREAM_UNICODE( &constant_bin[ 923457 ], 8 );
    const_unicode_digest_da5f25ffc686d67b336b34206396de7f = UNSTREAM_UNICODE( &constant_bin[ 923465 ], 65 );
    const_unicode_digest_40b73348e084c4c5959abc33f03bc16b = UNSTREAM_UNICODE( &constant_bin[ 923530 ], 59 );
    const_tuple_unicode_digest_55950b0245a58fcb76cb0333c18a4a6a_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_unicode_digest_55950b0245a58fcb76cb0333c18a4a6a_tuple, 0, const_unicode_digest_55950b0245a58fcb76cb0333c18a4a6a ); Py_INCREF( const_unicode_digest_55950b0245a58fcb76cb0333c18a4a6a );
    const_unicode_digest_2ad4c551e3bacbb3a65998acbd70fdf9 = UNSTREAM_UNICODE( &constant_bin[ 923589 ], 932 );
    const_unicode_digest_e9ecc59b2023c50be0d8f9a9c8aa42f1 = UNSTREAM_UNICODE( &constant_bin[ 924521 ], 25 );
    const_str_plain__prefix_from_ip_int = UNSTREAM_STRING( &constant_bin[ 924546 ], 19, 1 );
    const_str_plain__find_address_range = UNSTREAM_STRING( &constant_bin[ 924565 ], 19, 1 );
    const_tuple_d399ac830896faf254f71a17c228dc91_tuple = PyTuple_New( 14 );
    PyTuple_SET_ITEM( const_tuple_d399ac830896faf254f71a17c228dc91_tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    PyTuple_SET_ITEM( const_tuple_d399ac830896faf254f71a17c228dc91_tuple, 1, const_str_plain_ip_str ); Py_INCREF( const_str_plain_ip_str );
    PyTuple_SET_ITEM( const_tuple_d399ac830896faf254f71a17c228dc91_tuple, 2, const_str_plain_exc ); Py_INCREF( const_str_plain_exc );
    PyTuple_SET_ITEM( const_tuple_d399ac830896faf254f71a17c228dc91_tuple, 3, const_str_plain_ipv4_int ); Py_INCREF( const_str_plain_ipv4_int );
    PyTuple_SET_ITEM( const_tuple_d399ac830896faf254f71a17c228dc91_tuple, 4, const_str_plain_i ); Py_INCREF( const_str_plain_i );
    PyTuple_SET_ITEM( const_tuple_d399ac830896faf254f71a17c228dc91_tuple, 5, const_str_plain_ip_int ); Py_INCREF( const_str_plain_ip_int );
    PyTuple_SET_ITEM( const_tuple_d399ac830896faf254f71a17c228dc91_tuple, 6, const_str_plain__min_parts ); Py_INCREF( const_str_plain__min_parts );
    PyTuple_SET_ITEM( const_tuple_d399ac830896faf254f71a17c228dc91_tuple, 7, const_str_plain__max_parts ); Py_INCREF( const_str_plain__max_parts );
    PyTuple_SET_ITEM( const_tuple_d399ac830896faf254f71a17c228dc91_tuple, 8, const_str_plain_parts ); Py_INCREF( const_str_plain_parts );
    PyTuple_SET_ITEM( const_tuple_d399ac830896faf254f71a17c228dc91_tuple, 9, const_str_plain_skip_index ); Py_INCREF( const_str_plain_skip_index );
    PyTuple_SET_ITEM( const_tuple_d399ac830896faf254f71a17c228dc91_tuple, 10, const_str_plain_parts_lo ); Py_INCREF( const_str_plain_parts_lo );
    PyTuple_SET_ITEM( const_tuple_d399ac830896faf254f71a17c228dc91_tuple, 11, const_str_plain_msg ); Py_INCREF( const_str_plain_msg );
    PyTuple_SET_ITEM( const_tuple_d399ac830896faf254f71a17c228dc91_tuple, 12, const_str_plain_parts_skipped ); Py_INCREF( const_str_plain_parts_skipped );
    PyTuple_SET_ITEM( const_tuple_d399ac830896faf254f71a17c228dc91_tuple, 13, const_str_plain_parts_hi ); Py_INCREF( const_str_plain_parts_hi );
    const_tuple_str_plain_address_str_plain_addr_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_address_str_plain_addr_tuple, 0, const_str_plain_address ); Py_INCREF( const_str_plain_address );
    PyTuple_SET_ITEM( const_tuple_str_plain_address_str_plain_addr_tuple, 1, const_str_plain_addr ); Py_INCREF( const_str_plain_addr );
    const_unicode_digest_b3a9fa271b1ea846799383360611cf70 = UNSTREAM_UNICODE( &constant_bin[ 919051 ], 13 );
    const_str_plain_with_prefixlen = UNSTREAM_STRING( &constant_bin[ 924584 ], 14, 1 );
    const_str_plain__loopback_network = UNSTREAM_STRING( &constant_bin[ 924598 ], 17, 1 );

    constants_created = true;
}

/* Function to verify module private constants for non-corruption. */
#ifndef __NUITKA_NO_ASSERT__
void checkModuleConstants_ipaddress( void )
{
    // The module may not have been used at all, then ignore this.
    if (constants_created == false) return;


}
#endif

// The module code objects.
static PyCodeObject *codeobj_d505756ffecce6e65ef4e3ecec46e18a;
static PyCodeObject *codeobj_b59b8ccabe478d9a4d3c7681e2692fa3;
static PyCodeObject *codeobj_ca2967c7caa9f0af32a9a121041acb68;
static PyCodeObject *codeobj_88ebdd67cd462602af17693d337a8582;
static PyCodeObject *codeobj_a10b4ee15c0763ecce4ab0022f0f5fa7;
static PyCodeObject *codeobj_1a9921f46deeb2eb6639b77a939ad874;
static PyCodeObject *codeobj_8c5b956ab97dc62e74ac053cc531b3e0;
static PyCodeObject *codeobj_1b6fd3360f8022d9f0452f99d3cf6fba;
static PyCodeObject *codeobj_e3100639ef7adfb1b91bea0685b2bda9;
static PyCodeObject *codeobj_978c64aaac40067740426a6582d720f1;
static PyCodeObject *codeobj_eede468f789883f6726171dca68e049c;
static PyCodeObject *codeobj_039fb0cc98fcd1d5734f80fb0973e949;
static PyCodeObject *codeobj_f77fa86b0ce46b949fc4657d215efecb;
static PyCodeObject *codeobj_366e7e4afc4c79b4f2de94c1a936dae7;
static PyCodeObject *codeobj_dbc69dab8fd6a224013718cb1cbf5cd4;
static PyCodeObject *codeobj_1831ffa3cc2fcf6156ebd1cfb8c343f4;
static PyCodeObject *codeobj_e4f047505da49281bb85f001a8969afe;
static PyCodeObject *codeobj_9abed9769104b337e842b37b29bc8335;
static PyCodeObject *codeobj_75cfc528ffb67ea8d2c84948eee1df0b;
static PyCodeObject *codeobj_0186f03ed402b8f930ca7c2461b98230;
static PyCodeObject *codeobj_b2f94a1328d96c44d4a82b1e3c4b6114;
static PyCodeObject *codeobj_f9185ed1a170c02330bb8fd2e8d972c3;
static PyCodeObject *codeobj_b79d16e0a05c525ce1a86e8fc3c4bd76;
static PyCodeObject *codeobj_6b1370f0a4d4f18f0cf4ced6f6f5f56b;
static PyCodeObject *codeobj_0c15792d81d3f3f629d0aa7ac6cf19a4;
static PyCodeObject *codeobj_f7f38e383ec02fe43d0b472cb99f0b76;
static PyCodeObject *codeobj_c8b388385f1f9f775ba4daa3e7c06d3b;
static PyCodeObject *codeobj_a802e13262f2f1adf825e3a244d35ad0;
static PyCodeObject *codeobj_4b9e696776a8e3a1391c605ab86d1016;
static PyCodeObject *codeobj_5ab60d4e3551fabd11cba7f0c5ccf9ef;
static PyCodeObject *codeobj_40609662a1dd4462655d9c04cd6ccf15;
static PyCodeObject *codeobj_7f0f3df5e6d1653dd48befa6bc77ac64;
static PyCodeObject *codeobj_ce30d14ef98e4b5fb4f1bbda17cb1b5e;
static PyCodeObject *codeobj_bc7f8586f62fb3cbf6c042b03e688d28;
static PyCodeObject *codeobj_fee12ae33446c0d7b04e9fde4e87b023;
static PyCodeObject *codeobj_2f7e7db6799399502d6940e3245a34c6;
static PyCodeObject *codeobj_76720fec7c04811ad2bb6263663e1452;
static PyCodeObject *codeobj_cd86ecb14e7f6f0ffe0a002e37a7e37a;
static PyCodeObject *codeobj_d6198731425720bf74b62a3c85594e44;
static PyCodeObject *codeobj_a9c87da975507046d881307a08716b6a;
static PyCodeObject *codeobj_a4f6648fef564b16884f557db0779374;
static PyCodeObject *codeobj_0025b9efe3ddf8d01e63fbed9660773a;
static PyCodeObject *codeobj_85d0c509283f96c21d0470148697e1c2;
static PyCodeObject *codeobj_fa3a1065a48af6021c6b23a77663b3d5;
static PyCodeObject *codeobj_93e6fc29e52e68bb6ff597277c93b709;
static PyCodeObject *codeobj_e912ba0bfe133f34c669723d31be939b;
static PyCodeObject *codeobj_ecf3b750663a962c8345413a0f92b14f;
static PyCodeObject *codeobj_ed741ffdf26796e0ff1e303ebfd19808;
static PyCodeObject *codeobj_7d2642b77ac278ef54f940cfcbf38077;
static PyCodeObject *codeobj_1f09a9f606fe746196d89cb184d5e7c0;
static PyCodeObject *codeobj_81fb079e76541adf9e8bfbe35414892c;
static PyCodeObject *codeobj_1b1050c7cbb3699227e50b9e996a2d3f;
static PyCodeObject *codeobj_1af72631d4ce0035edf15f8f172d5fc2;
static PyCodeObject *codeobj_625cfb563c75cb0b49bcc7b223caabc6;
static PyCodeObject *codeobj_bbb4b9c00fafbe54124665f1f4641832;
static PyCodeObject *codeobj_2cfe51702bf97b246bfe200e1420b757;
static PyCodeObject *codeobj_f78f9052a3f53d3f5f58402f6adb4944;
static PyCodeObject *codeobj_67e26f96837097bd24506e72e861d756;
static PyCodeObject *codeobj_2f1cce2dd9f99f279577e205f1e726fe;
static PyCodeObject *codeobj_3aa7b3b68ced212bf157a71f3cb41b24;
static PyCodeObject *codeobj_ef713967755f9970e25b35c37c0ef9d1;
static PyCodeObject *codeobj_1d55304974863c80f8deb17902b6612b;
static PyCodeObject *codeobj_ddaf032ca36ff3666d4667ec7ee75bbe;
static PyCodeObject *codeobj_63f7a410e2fb3e552200f2a82a5285db;
static PyCodeObject *codeobj_9e6ebf7db345152cd0b801fe8b7dd4ce;
static PyCodeObject *codeobj_6c48ac6d4f9732d2aa38e88a2fc8b8c0;
static PyCodeObject *codeobj_ad30372b73c3d36542e3a940af829ee7;
static PyCodeObject *codeobj_1d375206df9e3c3637ab9124f31b1a59;
static PyCodeObject *codeobj_73951747500cefaada7ce57eac2afc74;
static PyCodeObject *codeobj_025da757111325499181d0330a4934f2;
static PyCodeObject *codeobj_af2a5c10f47089b7ca07ac0f61f0ee94;
static PyCodeObject *codeobj_21dad7c185498a4193f7a59a5bcd26b9;
static PyCodeObject *codeobj_8f1a1dcf125472cc5e5562ccf9d75921;
static PyCodeObject *codeobj_66965efd84eb1c5142457e86e95209e3;
static PyCodeObject *codeobj_aef582dae391f517bebe2068da97cde0;
static PyCodeObject *codeobj_f90b0be0f90a66a29fbcc60d47edce81;
static PyCodeObject *codeobj_0acab394733e19c6ca20d33f8286a543;
static PyCodeObject *codeobj_f6ab1da534820a295432dc985ea5c721;
static PyCodeObject *codeobj_ab75866f99bb0b58bdf97c9c49b3680d;
static PyCodeObject *codeobj_5cec4f1aab659e4de38ef9afc8d48e47;
static PyCodeObject *codeobj_779fd7a0aab1f3b76d0239378711294e;
static PyCodeObject *codeobj_81a497c5e641cb3dbfc1edaf5d4d15ad;
static PyCodeObject *codeobj_475e33420705710913bc618cb12cdaaa;
static PyCodeObject *codeobj_bb1e2ac1f2a08510058031fa56cc95e9;
static PyCodeObject *codeobj_00ee5b6806ca20bcda5fb1846ff2fa87;
static PyCodeObject *codeobj_65bdf21fa4f2995d9cbc9d64b9242437;
static PyCodeObject *codeobj_35b05f2076f28f93f5a20a6e91d03cdf;
static PyCodeObject *codeobj_e4457ed056c53cf95f24b187fd8e10b8;
static PyCodeObject *codeobj_965a59153c45ade1eb4421df6ac0207d;
static PyCodeObject *codeobj_124ad0b848fffa9587184710249546c6;
static PyCodeObject *codeobj_3769b2c4ffdc7c3f9f9b4dbc1cef7e71;
static PyCodeObject *codeobj_39e15cae3809f0757e14fe4a7c9b7fa2;
static PyCodeObject *codeobj_60a11b2dd91b774c274871d35d983f3a;
static PyCodeObject *codeobj_c45d853a29dec1f0248c5e593abb118c;
static PyCodeObject *codeobj_93f2eac4eb7c93371ce23e334a4e29f2;
static PyCodeObject *codeobj_e93d5bcbbebcc474c506583b2262be27;
static PyCodeObject *codeobj_8d3c219bed018f80d348d948e64e2a26;
static PyCodeObject *codeobj_9be0c556551336fa7c7c00a3df4577e6;
static PyCodeObject *codeobj_7294db2a9216f390dfeaedea67d0ffcf;
static PyCodeObject *codeobj_0ecc96483cf2638c04c31ede5f32d12f;
static PyCodeObject *codeobj_efc26b80524c8071b2ab77bc15354df5;
static PyCodeObject *codeobj_5fa2e0f0c94e079165acf06a3e2b0103;
static PyCodeObject *codeobj_90469e3b518446adc4eedffd44ffe52a;
static PyCodeObject *codeobj_8f5d37f073b7a64c59b07aa21d264e87;
static PyCodeObject *codeobj_08dacecb2456e05693d19a8e92c1c5d3;
static PyCodeObject *codeobj_e78bc76a4d1feac8d2458c32bc8aaf3d;
static PyCodeObject *codeobj_797202885290d9baeb7f5a55e4fd22c5;
static PyCodeObject *codeobj_6ef12be487ba919b62bfd71122d13134;
static PyCodeObject *codeobj_8f233debdccbd7f23dd58687a18eb3c8;
static PyCodeObject *codeobj_58f69ddfab375b10f28d409ed4e35d2f;
static PyCodeObject *codeobj_1e777b2cca1fdd718c4873963deb0023;
static PyCodeObject *codeobj_0c6b9c33eb0e964d2f2830e571976109;
static PyCodeObject *codeobj_b26421f87f4a69b7ea20133c9f845414;
static PyCodeObject *codeobj_c66eb78bb605c988fc86c10da130d5b9;
static PyCodeObject *codeobj_0f3c3c5183ea0c46a59155086c6f7125;
static PyCodeObject *codeobj_ddad72e202b73cfe919e21d5cf44518f;
static PyCodeObject *codeobj_05ec6fd01eb342b10aaf820f0f88358b;
static PyCodeObject *codeobj_1f58a578c801456122b311c4e070e4c5;
static PyCodeObject *codeobj_9884b10659aa16fb451f94aef6e0d207;
static PyCodeObject *codeobj_77bf576a262d37c8647e73432c32b9e8;
static PyCodeObject *codeobj_adc6579a2d3fee5fb2a17b97524c1b54;
static PyCodeObject *codeobj_c3b901b102aeaad9d46e4c7384759f59;
static PyCodeObject *codeobj_9c71824c4bdb84129e3146d7ba81701a;
static PyCodeObject *codeobj_7a258d001059db6f4e3d220e0e99a1a2;
static PyCodeObject *codeobj_b87026341f70c04f9c8a27abe812549e;
static PyCodeObject *codeobj_df336f9f31d2c5b6ff8f38a70df38b5c;
static PyCodeObject *codeobj_fce6ccb47dffbdcbdaa4a8ce79489a77;
static PyCodeObject *codeobj_f3fc95762b22ba9ceab359a9934b5168;
static PyCodeObject *codeobj_f8fcc3c4ac09b355399d18350c5a9f23;
static PyCodeObject *codeobj_2e57bd4f793084e6678d8088b4db5110;
static PyCodeObject *codeobj_b605231cd1026aa555c929e5b01f6bc1;
static PyCodeObject *codeobj_966fe35e427b37714c22ebe086cb0fa7;
static PyCodeObject *codeobj_daa648eaba38dc7c040c161e27018597;
static PyCodeObject *codeobj_f4b494f9d651886073c73f6a413cb5bc;
static PyCodeObject *codeobj_35f2f0b4833eb4d15fba0bdc439d87e6;
static PyCodeObject *codeobj_65a481757749f9bfb65fbb716f6aa9b0;
static PyCodeObject *codeobj_74f67d01bd167da0756775c14a3a8bb0;
static PyCodeObject *codeobj_21ddc125364ef772bcb1aad81be1d95e;
static PyCodeObject *codeobj_02eb5158aaf36af6a20d27401bd96db3;
static PyCodeObject *codeobj_0049438ffc60200b97a4b97bbed5f67d;
static PyCodeObject *codeobj_e2bdbfa49ffc502fdd64c2afed334e8d;
static PyCodeObject *codeobj_c403847f283cf7a81a7cf711a02170ce;
static PyCodeObject *codeobj_afd3bfdaef11bbc48af0b7dfa76ee499;
static PyCodeObject *codeobj_b1fe0f75950a86c7a08048741a3f59da;
static PyCodeObject *codeobj_40865f494124bd7ebca7599fd819457c;
static PyCodeObject *codeobj_1f679a65df6468242fd0f036feae969e;
static PyCodeObject *codeobj_08fcd993c7b81e47169ff1e3992e9c4b;
static PyCodeObject *codeobj_238d4641bef942b70ad192a34b24ce43;
static PyCodeObject *codeobj_124b766cd28bbd519eab91237988348d;
static PyCodeObject *codeobj_ca89dae17c23af9c1e2595574e987d31;
static PyCodeObject *codeobj_5beb6c0ecef6d2e4a9b887e5a1d874fe;
static PyCodeObject *codeobj_df20c4ec324ad955944c40cd6e9c34ee;
static PyCodeObject *codeobj_558a53c8ca1440f3014f54f358619139;
static PyCodeObject *codeobj_f5cf93a3617c153acb8c04a6ee43a9e3;
static PyCodeObject *codeobj_84242c2f8814b6ec54d58e169ead4095;
static PyCodeObject *codeobj_a77ea2ed442180f359e7236fa03ce30e;
static PyCodeObject *codeobj_031b9ad4d720268768a4bf8633c574fc;
static PyCodeObject *codeobj_ec9028b7009e5af16c10d0a9cc3c34f2;
static PyCodeObject *codeobj_e20490aef3e0cf3e11cbb7c3de926018;
static PyCodeObject *codeobj_625df4c5b3b8890b0a4145c1af1d8553;
static PyCodeObject *codeobj_1370e8ed5db9ed96af59bd81a5809fb0;

static void createModuleCodeObjects(void)
{
    module_filename_obj = const_str_digest_a25a001858b466f6be5039bbd12f63ef;
    codeobj_d505756ffecce6e65ef4e3ecec46e18a = MAKE_CODEOBJ( module_filename_obj, const_str_angle_genexpr, 1325, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_b_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_b59b8ccabe478d9a4d3c7681e2692fa3 = MAKE_CODEOBJ( module_filename_obj, const_str_angle_genexpr, 1436, const_tuple_9ff79281bff64fe91204cce2984dfc9d_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_ca2967c7caa9f0af32a9a121041acb68 = MAKE_CODEOBJ( module_filename_obj, const_str_angle_genexpr, 2071, const_tuple_15847381bc67e44c74cc6010c7c7f848_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_88ebdd67cd462602af17693d337a8582 = MAKE_CODEOBJ( module_filename_obj, const_str_angle_genexpr, 2106, const_tuple_9ff79281bff64fe91204cce2984dfc9d_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_a10b4ee15c0763ecce4ab0022f0f5fa7 = MAKE_CODEOBJ( module_filename_obj, const_str_digest_1ab9d69575e4bd45bb288b6bd05cd8cc, 1, const_tuple_empty, 0, CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_1a9921f46deeb2eb6639b77a939ad874 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_IPv4Address, 1369, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_8c5b956ab97dc62e74ac053cc531b3e0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_IPv4Interface, 1487, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_1b6fd3360f8022d9f0452f99d3cf6fba = MAKE_CODEOBJ( module_filename_obj, const_str_plain_IPv4Network, 1569, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_e3100639ef7adfb1b91bea0685b2bda9 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_IPv6Address, 2003, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_978c64aaac40067740426a6582d720f1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_IPv6Interface, 2183, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_eede468f789883f6726171dca68e049c = MAKE_CODEOBJ( module_filename_obj, const_str_plain_IPv6Network, 2269, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_039fb0cc98fcd1d5734f80fb0973e949 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__BaseNetwork, 722, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_f77fa86b0ce46b949fc4657d215efecb = MAKE_CODEOBJ( module_filename_obj, const_str_plain__BaseV4, 1200, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_366e7e4afc4c79b4f2de94c1a936dae7 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__BaseV6, 1718, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_dbc69dab8fd6a224013718cb1cbf5cd4 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__IPAddressBase, 503, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_1831ffa3cc2fcf6156ebd1cfb8c343f4 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__IPv4Constants, 1683, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_e4f047505da49281bb85f001a8969afe = MAKE_CODEOBJ( module_filename_obj, const_str_plain__IPv6Constants, 2392, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_9abed9769104b337e842b37b29bc8335 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___add__, 696, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_75cfc528ffb67ea8d2c84948eee1df0b = MAKE_CODEOBJ( module_filename_obj, const_str_plain___contains__, 796, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_0186f03ed402b8f930ca7c2461b98230 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___eq__, 87, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_b2f94a1328d96c44d4a82b1e3c4b6114 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___eq__, 674, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_f9185ed1a170c02330bb8fd2e8d972c3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___eq__, 785, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_b79d16e0a05c525ce1a86e8fc3c4bd76 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___eq__, 1521, const_tuple_str_plain_self_str_plain_other_str_plain_address_equal_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_6b1370f0a4d4f18f0cf4ced6f6f5f56b = MAKE_CODEOBJ( module_filename_obj, const_str_plain___eq__, 2213, const_tuple_str_plain_self_str_plain_other_str_plain_address_equal_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_0c15792d81d3f3f629d0aa7ac6cf19a4 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___ge__, 114, const_tuple_str_plain_self_str_plain_other_str_plain_less_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_f7f38e383ec02fe43d0b472cb99f0b76 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___getitem__, 757, const_tuple_1d39f04be793fb75107492e9cda65f46_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_c8b388385f1f9f775ba4daa3e7c06d3b = MAKE_CODEOBJ( module_filename_obj, const_str_plain___gt__, 105, const_tuple_a0fcb231785a6904cd1cb11afbf3073f_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_a802e13262f2f1adf825e3a244d35ad0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___hash__, 712, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_4b9e696776a8e3a1391c605ab86d1016 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___hash__, 793, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_5ab60d4e3551fabd11cba7f0c5ccf9ef = MAKE_CODEOBJ( module_filename_obj, const_str_plain___hash__, 1544, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_40609662a1dd4462655d9c04cd6ccf15 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___hash__, 2236, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_7f0f3df5e6d1653dd48befa6bc77ac64 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 730, const_tuple_str_plain_self_str_plain_address_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_ce30d14ef98e4b5fb4f1bbda17cb1b5e = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 1375, const_tuple_b99252a717af406174a953ceba374cca_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_bc7f8586f62fb3cbf6c042b03e688d28 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 1489, const_tuple_str_plain_self_str_plain_address_str_plain_addr_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_fee12ae33446c0d7b04e9fde4e87b023 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 1584, const_tuple_f8d906ece65b18c6af8aaf87035aebfe_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_2f7e7db6799399502d6940e3245a34c6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 2009, const_tuple_b99252a717af406174a953ceba374cca_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_76720fec7c04811ad2bb6263663e1452 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 2185, const_tuple_str_plain_self_str_plain_address_str_plain_addr_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_cd86ecb14e7f6f0ffe0a002e37a7e37a = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 2285, const_tuple_f8d906ece65b18c6af8aaf87035aebfe_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_d6198731425720bf74b62a3c85594e44 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___int__, 671, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_a9c87da975507046d881307a08716b6a = MAKE_CODEOBJ( module_filename_obj, const_str_plain___iter__, 751, const_tuple_20590e930689906083ade7009277cd69_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_a4f6648fef564b16884f557db0779374 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___le__, 99, const_tuple_str_plain_self_str_plain_other_str_plain_less_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_0025b9efe3ddf8d01e63fbed9660773a = MAKE_CODEOBJ( module_filename_obj, const_str_plain___lt__, 96, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_85d0c509283f96c21d0470148697e1c2 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___lt__, 681, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_fa3a1065a48af6021c6b23a77663b3d5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___lt__, 770, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_93e6fc29e52e68bb6ff597277c93b709 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___lt__, 1533, const_tuple_str_plain_self_str_plain_other_str_plain_address_less_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_e912ba0bfe133f34c669723d31be939b = MAKE_CODEOBJ( module_filename_obj, const_str_plain___lt__, 2225, const_tuple_str_plain_self_str_plain_other_str_plain_address_less_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_ecf3b750663a962c8345413a0f92b14f = MAKE_CODEOBJ( module_filename_obj, const_str_plain___ne__, 90, const_tuple_str_plain_self_str_plain_other_str_plain_equal_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_ed741ffdf26796e0ff1e303ebfd19808 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___reduce__, 657, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_7d2642b77ac278ef54f940cfcbf38077 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___reduce__, 718, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_1f09a9f606fe746196d89cb184d5e7c0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___repr__, 706, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_81fb079e76541adf9e8bfbe35414892c = MAKE_CODEOBJ( module_filename_obj, const_str_plain___repr__, 733, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_1b1050c7cbb3699227e50b9e996a2d3f = MAKE_CODEOBJ( module_filename_obj, const_str_plain___str__, 709, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_1af72631d4ce0035edf15f8f172d5fc2 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___str__, 736, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_625cfb563c75cb0b49bcc7b223caabc6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___str__, 1517, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_bbb4b9c00fafbe54124665f1f4641832 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___str__, 2209, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_2cfe51702bf97b246bfe200e1420b757 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___sub__, 701, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_f78f9052a3f53d3f5f58402f6adb4944 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__address_class, 850, const_tuple_str_plain_self_str_plain_msg_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_67e26f96837097bd24506e72e861d756 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__check_int_address, 535, const_tuple_str_plain_self_str_plain_address_str_plain_msg_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_2f1cce2dd9f99f279577e205f1e726fe = MAKE_CODEOBJ( module_filename_obj, const_str_plain__check_packed_address, 544, const_tuple_9098f7d838724863c7318ae87cb1bc40_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_3aa7b3b68ced212bf157a71f3cb41b24 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__collapse_addresses_internal, 375, const_tuple_f3db2b00dcab6aff87703f38eede988a_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_ef713967755f9970e25b35c37c0ef9d1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__compat_bit_length, 63, const_tuple_str_plain_i_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_1d55304974863c80f8deb17902b6612b = MAKE_CODEOBJ( module_filename_obj, const_str_plain__compat_bit_length, 66, const_tuple_str_plain_i_str_plain_res_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_ddaf032ca36ff3666d4667ec7ee75bbe = MAKE_CODEOBJ( module_filename_obj, const_str_plain__compat_bytes_to_byte_vals, 34, const_tuple_str_plain_byt_str_plain_b_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_63f7a410e2fb3e552200f2a82a5285db = MAKE_CODEOBJ( module_filename_obj, const_str_plain__compat_int_from_byte_vals, 39, const_tuple_4cc0ec93b988fc0a4ad89cdb6c285e41_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_9e6ebf7db345152cd0b801fe8b7dd4ce = MAKE_CODEOBJ( module_filename_obj, const_str_plain__compat_range, 72, const_tuple_str_plain_start_str_plain_end_str_plain_step_str_plain_i_tuple, 3, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_6c48ac6d4f9732d2aa38e88a2fc8b8c0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__compat_to_bytes, 48, const_tuple_str_plain_intval_str_plain_length_str_plain_endianess_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_ad30372b73c3d36542e3a940af829ee7 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__compress_hextets, 1887, const_tuple_f41119394ac30f2d0b96be932770c04a_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_1d375206df9e3c3637ab9124f31b1a59 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__count_righthand_zero_bits, 304, const_tuple_str_plain_number_str_plain_bits_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_73951747500cefaada7ce57eac2afc74 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__explode_shorthand_ip_string, 1223, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_025da757111325499181d0330a4934f2 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__explode_shorthand_ip_string, 1961, const_tuple_50559fec2f469c57aa556ccd83f2df71_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_af2a5c10f47089b7ca07ac0f61f0ee94 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__find_address_range, 284, const_tuple_f71b17521653e2cdc027d93583942731_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_21dad7c185498a4193f7a59a5bcd26b9 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__get_address_key, 715, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_8f1a1dcf125472cc5e5562ccf9d75921 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__get_networks_key, 985, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_66965efd84eb1c5142457e86e95209e3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__ip_int_from_prefix, 555, const_tuple_str_plain_cls_str_plain_prefixlen_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_aef582dae391f517bebe2068da97cde0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__ip_int_from_string, 1250, const_tuple_be53fac8911619da3fa3e231a9b3c752_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_f90b0be0f90a66a29fbcc60d47edce81 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__ip_int_from_string, 1756, const_tuple_d399ac830896faf254f71a17c228dc91_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_0acab394733e19c6ca20d33f8286a543 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__is_hostmask, 1330, const_tuple_f0912223de68829e67499bcb23f9060a_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_f6ab1da534820a295432dc985ea5c721 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__make_netmask, 1226, const_tuple_c95f92ffec2b139e3f927147ab9edcbd_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_ab75866f99bb0b58bdf97c9c49b3680d = MAKE_CODEOBJ( module_filename_obj, const_str_plain__make_netmask, 1738, const_tuple_c95f92ffec2b139e3f927147ab9edcbd_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_5cec4f1aab659e4de38ef9afc8d48e47 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__parse_hextet, 1861, const_tuple_str_plain_cls_str_plain_hextet_str_str_plain_msg_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_779fd7a0aab1f3b76d0239378711294e = MAKE_CODEOBJ( module_filename_obj, const_str_plain__parse_octet, 1277, const_tuple_df9bcb1b25e9c82423695469b9a4a37f_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_81a497c5e641cb3dbfc1edaf5d4d15ad = MAKE_CODEOBJ( module_filename_obj, const_str_plain__prefix_from_ip_int, 568, const_tuple_eb9d897fb9f331042703df74e8349709_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_475e33420705710913bc618cb12cdaaa = MAKE_CODEOBJ( module_filename_obj, const_str_plain__prefix_from_ip_string, 623, const_tuple_str_plain_cls_str_plain_ip_str_str_plain_ip_int_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_bb1e2ac1f2a08510058031fa56cc95e9 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__prefix_from_prefix_string, 598, const_tuple_str_plain_cls_str_plain_prefixlen_str_str_plain_prefixlen_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_00ee5b6806ca20bcda5fb1846ff2fa87 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__report_invalid_netmask, 593, const_tuple_str_plain_cls_str_plain_netmask_str_str_plain_msg_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_65bdf21fa4f2995d9cbc9d64b9242437 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__reverse_pointer, 1351, const_tuple_str_plain_self_str_plain_reverse_octets_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_35b05f2076f28f93f5a20a6e91d03cdf = MAKE_CODEOBJ( module_filename_obj, const_str_plain__reverse_pointer, 1985, const_tuple_str_plain_self_str_plain_reverse_chars_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_e4457ed056c53cf95f24b187fd8e10b8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__split_optional_netmask, 276, const_tuple_str_plain_address_str_plain_addr_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_965a59153c45ade1eb4421df6ac0207d = MAKE_CODEOBJ( module_filename_obj, const_str_plain__string_from_ip_int, 1314, const_tuple_str_plain_cls_str_plain_ip_int_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_124ad0b848fffa9587184710249546c6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__string_from_ip_int, 1935, const_tuple_61c8af5e7aa68d9f21df00511cc97c77_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_3769b2c4ffdc7c3f9f9b4dbc1cef7e71 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_address_exclude, 862, const_tuple_str_plain_self_str_plain_other_str_plain_s2_str_plain_s1_tuple, 2, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_39e15cae3809f0757e14fe4a7c9b7fa2 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_broadcast_address, 816, const_tuple_str_plain_self_str_plain_x_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_60a11b2dd91b774c274871d35d983f3a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_collapse_addresses, 424, const_tuple_3c4458665ec97984dbef4c959f27790d_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_c45d853a29dec1f0248c5e593abb118c = MAKE_CODEOBJ( module_filename_obj, const_str_plain_compare_networks, 937, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_93f2eac4eb7c93371ce23e334a4e29f2 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_compressed, 514, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_e93d5bcbbebcc474c506583b2262be27 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_exploded, 509, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_8d3c219bed018f80d348d948e64e2a26 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_mixed_type_key, 478, const_tuple_str_plain_obj_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_9be0c556551336fa7c7c00a3df4577e6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_hostmask, 825, const_tuple_str_plain_self_str_plain_x_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_7294db2a9216f390dfeaedea67d0ffcf = MAKE_CODEOBJ( module_filename_obj, const_str_plain_hosts, 739, const_tuple_20590e930689906083ade7009277cd69_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_0ecc96483cf2638c04c31ede5f32d12f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_hosts, 2364, const_tuple_20590e930689906083ade7009277cd69_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_efc26b80524c8071b2ab77bc15354df5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_ip, 1549, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_5fa2e0f0c94e079165acf06a3e2b0103 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_ip, 2241, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_90469e3b518446adc4eedffd44ffe52a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_ip_address, 133, const_tuple_str_plain_address_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_8f5d37f073b7a64c59b07aa21d264e87 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_ip_interface, 205, const_tuple_str_plain_address_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_08dacecb2456e05693d19a8e92c1c5d3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_ip_network, 169, const_tuple_str_plain_address_str_plain_strict_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_e78bc76a4d1feac8d2458c32bc8aaf3d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_ipv4_mapped, 2141, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_797202885290d9baeb7f5a55e4fd22c5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_is_global, 1164, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_6ef12be487ba919b62bfd71122d13134 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_is_global, 1438, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_8f233debdccbd7f23dd58687a18eb3c8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_is_global, 1669, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_58f69ddfab375b10f28d409ed4e35d2f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_is_global, 2108, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_1e777b2cca1fdd718c4873963deb0023 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_is_link_local, 1141, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_0c6b9c33eb0e964d2f2830e571976109 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_is_link_local, 1476, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_b26421f87f4a69b7ea20133c9f845414 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_is_link_local, 2073, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_c66eb78bb605c988fc86c10da130d5b9 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_is_loopback, 1187, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_0f3c3c5183ea0c46a59155086c6f7125 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_is_loopback, 1466, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_ddad72e202b73cfe919e21d5cf44518f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_is_loopback, 2130, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_05ec6fd01eb342b10aaf820f0f88358b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_is_loopback, 2264, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_1f58a578c801456122b311c4e070e4c5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_is_multicast, 1089, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_9884b10659aa16fb451f94aef6e0d207 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_is_multicast, 1444, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_77bf576a262d37c8647e73432c32b9e8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_is_multicast, 2051, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_adc6579a2d3fee5fb2a17b97524c1b54 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_is_private, 1152, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_c3b901b102aeaad9d46e4c7384759f59 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_is_private, 1427, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_9c71824c4bdb84129e3146d7ba81701a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_is_private, 2097, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_7a258d001059db6f4e3d220e0e99a1a2 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_is_reserved, 1129, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_b87026341f70c04f9c8a27abe812549e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_is_reserved, 1416, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_df336f9f31d2c5b6ff8f38a70df38b5c = MAKE_CODEOBJ( module_filename_obj, const_str_plain_is_reserved, 2062, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_fce6ccb47dffbdcbdaa4a8ce79489a77 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_is_site_local, 2083, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_f3fc95762b22ba9ceab359a9934b5168 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_is_site_local, 2376, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_f8fcc3c4ac09b355399d18350c5a9f23 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_is_unspecified, 1175, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_2e57bd4f793084e6678d8088b4db5110 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_is_unspecified, 1455, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_b605231cd1026aa555c929e5b01f6bc1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_is_unspecified, 2119, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_966fe35e427b37714c22ebe086cb0fa7 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_is_unspecified, 2260, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_daa648eaba38dc7c040c161e27018597 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_max_prefixlen, 1360, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_f4b494f9d651886073c73f6a413cb5bc = MAKE_CODEOBJ( module_filename_obj, const_str_plain_max_prefixlen, 1994, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_35f2f0b4833eb4d15fba0bdc439d87e6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_num_addresses, 845, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_65a481757749f9bfb65fbb716f6aa9b0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_overlaps, 809, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_74f67d01bd167da0756775c14a3a8bb0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_packed, 1411, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_21ddc125364ef772bcb1aad81be1d95e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_packed, 2046, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_02eb5158aaf36af6a20d27401bd96db3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_prefixlen, 858, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_0049438ffc60200b97a4b97bbed5f67d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_reverse_pointer, 519, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_e2bdbfa49ffc502fdd64c2afed334e8d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_sixtofour, 2169, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_c403847f283cf7a81a7cf711a02170ce = MAKE_CODEOBJ( module_filename_obj, const_str_plain_subnet_of, 1101, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_afd3bfdaef11bbc48af0b7dfa76ee499 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_subnets, 995, const_tuple_ebba5bcca06086e920bc53fbfdc7c8df_tuple, 3, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_b1fe0f75950a86c7a08048741a3f59da = MAKE_CODEOBJ( module_filename_obj, const_str_plain_summarize_address_range, 320, const_tuple_afca6ebc709d3fc175a5c8a3ab536908_tuple, 2, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_40865f494124bd7ebca7599fd819457c = MAKE_CODEOBJ( module_filename_obj, const_str_plain_supernet, 1048, const_tuple_ff4a526b5a6a1ed69c55d5f6a48b9762_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_1f679a65df6468242fd0f036feae969e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_supernet_of, 1115, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_08fcd993c7b81e47169ff1e3992e9c4b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_teredo, 2154, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_238d4641bef942b70ad192a34b24ce43 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_v4_int_to_packed, 240, const_tuple_str_plain_address_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_124b766cd28bbd519eab91237988348d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_v6_int_to_packed, 260, const_tuple_str_plain_address_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_ca89dae17c23af9c1e2595574e987d31 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_version, 530, const_tuple_str_plain_self_str_plain_msg_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_5beb6c0ecef6d2e4a9b887e5a1d874fe = MAKE_CODEOBJ( module_filename_obj, const_str_plain_version, 1364, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_df20c4ec324ad955944c40cd6e9c34ee = MAKE_CODEOBJ( module_filename_obj, const_str_plain_version, 1998, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_558a53c8ca1440f3014f54f358619139 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_with_hostmask, 841, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_f5cf93a3617c153acb8c04a6ee43a9e3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_with_hostmask, 1563, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_84242c2f8814b6ec54d58e169ead4095 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_with_hostmask, 2255, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_a77ea2ed442180f359e7236fa03ce30e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_with_netmask, 837, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_031b9ad4d720268768a4bf8633c574fc = MAKE_CODEOBJ( module_filename_obj, const_str_plain_with_netmask, 1558, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_ec9028b7009e5af16c10d0a9cc3c34f2 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_with_netmask, 2250, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_e20490aef3e0cf3e11cbb7c3de926018 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_with_prefixlen, 833, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_625df4c5b3b8890b0a4145c1af1d8553 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_with_prefixlen, 1553, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
    codeobj_1370e8ed5db9ed96af59bd81a5809fb0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_with_prefixlen, 2245, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_UNICODE_LITERALS );
}

// The module function declarations.
static PyObject *ipaddress$$$function_6__compat_range$$$genobj_1__compat_range_maker( void );


static PyObject *ipaddress$$$function_19__find_address_range$$$genobj_1__find_address_range_maker( void );


static PyObject *ipaddress$$$function_21_summarize_address_range$$$genobj_1_summarize_address_range_maker( void );


static PyObject *ipaddress$$$function_22__collapse_addresses_internal$$$genobj_1__collapse_addresses_internal_maker( void );


static PyObject *ipaddress$$$function_50_hosts$$$genobj_1_hosts_maker( void );


static PyObject *ipaddress$$$function_51___iter__$$$genobj_1___iter___maker( void );


static PyObject *ipaddress$$$function_66_address_exclude$$$genobj_1_address_exclude_maker( void );


static PyObject *ipaddress$$$function_69_subnets$$$genobj_1_subnets_maker( void );


static PyObject *ipaddress$$$function_84__string_from_ip_int$$$genexpr_1_genexpr_maker( void );


static PyObject *ipaddress$$$function_92_is_private$$$genexpr_1_genexpr_maker( void );


static PyObject *ipaddress$$$function_121_is_reserved$$$genexpr_1_genexpr_maker( void );


static PyObject *ipaddress$$$function_124_is_private$$$genexpr_1_genexpr_maker( void );


static PyObject *ipaddress$$$function_143_hosts$$$genobj_1_hosts_maker( void );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_100___eq__(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_101___lt__(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_102___hash__(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_103_ip(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_104_with_prefixlen(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_105_with_netmask(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_106_with_hostmask(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_107___init__( PyObject *defaults );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_108_is_global(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_109__make_netmask(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_10___le__(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_110__ip_int_from_string(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_111__parse_hextet(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_112__compress_hextets(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_113__string_from_ip_int( PyObject *defaults );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_114__explode_shorthand_ip_string(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_115__reverse_pointer(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_116_max_prefixlen(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_117_version(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_118___init__(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_119_packed(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_11___gt__(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_120_is_multicast(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_121_is_reserved(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_122_is_link_local(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_123_is_site_local(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_124_is_private(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_125_is_global(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_126_is_unspecified(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_127_is_loopback(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_128_ipv4_mapped(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_129_teredo(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_12___ge__(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_130_sixtofour(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_131___init__(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_132___str__(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_133___eq__(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_134___lt__(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_135___hash__(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_136_ip(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_137_with_prefixlen(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_138_with_netmask(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_139_with_hostmask(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_13_ip_address(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_140_is_unspecified(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_141_is_loopback(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_142___init__( PyObject *defaults );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_143_hosts(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_144_is_site_local(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_14_ip_network( PyObject *defaults );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_15_ip_interface(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_16_v4_int_to_packed(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_17_v6_int_to_packed(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_18__split_optional_netmask(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_19__find_address_range(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_1__compat_bytes_to_byte_vals(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_20__count_righthand_zero_bits(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_21_summarize_address_range(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_22__collapse_addresses_internal(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_23_collapse_addresses(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_24_get_mixed_type_key(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_25_exploded(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_26_compressed(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_27_reverse_pointer(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_28_version(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_29__check_int_address(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_2__compat_int_from_byte_vals(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_30__check_packed_address(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_31__ip_int_from_prefix(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_32__prefix_from_ip_int(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_33__report_invalid_netmask(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_34__prefix_from_prefix_string(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_35__prefix_from_ip_string(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_36___reduce__(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_37___int__(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_38___eq__(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_39___lt__(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_3__compat_to_bytes(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_40___add__(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_41___sub__(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_42___repr__(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_43___str__(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_44___hash__(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_45__get_address_key(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_46___reduce__(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_47___init__(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_48___repr__(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_49___str__(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_4__compat_bit_length(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_50_hosts(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_51___iter__(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_52___getitem__(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_53___lt__(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_54___eq__(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_55___hash__(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_56___contains__(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_57_overlaps(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_58_broadcast_address(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_59_hostmask(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_5__compat_bit_length(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_60_with_prefixlen(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_61_with_netmask(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_62_with_hostmask(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_63_num_addresses(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_64__address_class(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_65_prefixlen(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_66_address_exclude(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_67_compare_networks(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_68__get_networks_key(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_69_subnets( PyObject *defaults );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_6__compat_range( PyObject *defaults );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_70_supernet( PyObject *defaults );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_71_is_multicast(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_72_subnet_of(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_73_supernet_of(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_74_is_reserved(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_75_is_link_local(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_76_is_private(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_77_is_global(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_78_is_unspecified(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_79_is_loopback(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_7___eq__(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_80__explode_shorthand_ip_string(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_81__make_netmask(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_82__ip_int_from_string(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_83__parse_octet(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_84__string_from_ip_int(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_85__is_hostmask(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_86__reverse_pointer(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_87_max_prefixlen(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_88_version(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_89___init__(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_8___ne__(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_90_packed(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_91_is_reserved(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_92_is_private(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_93_is_global(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_94_is_multicast(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_95_is_unspecified(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_96_is_loopback(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_97_is_link_local(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_98___init__(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_99___str__(  );


static PyObject *MAKE_FUNCTION_ipaddress$$$function_9___lt__(  );


// The module function definitions.
static PyObject *impl_ipaddress$$$function_1__compat_bytes_to_byte_vals( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_byt = python_pars[ 0 ];
    PyObject *var_b = NULL;
    PyObject *tmp_list_contraction_1__$0 = NULL;
    PyObject *tmp_list_contraction_1__contraction_result = NULL;
    PyObject *tmp_list_contraction_1__iter_value_0 = NULL;
    struct Nuitka_FrameObject *frame_ddaf032ca36ff3666d4667ec7ee75bbe;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_ddaf032ca36ff3666d4667ec7ee75bbe = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ddaf032ca36ff3666d4667ec7ee75bbe, codeobj_ddaf032ca36ff3666d4667ec7ee75bbe, module_ipaddress, sizeof(void *)+sizeof(void *) );
    frame_ddaf032ca36ff3666d4667ec7ee75bbe = cache_frame_ddaf032ca36ff3666d4667ec7ee75bbe;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ddaf032ca36ff3666d4667ec7ee75bbe );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ddaf032ca36ff3666d4667ec7ee75bbe ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_iter_arg_1;
        CHECK_OBJECT( par_byt );
        tmp_iter_arg_1 = par_byt;
        tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 35;
            type_description_1 = "oo";
            goto try_except_handler_2;
        }
        assert( tmp_list_contraction_1__$0 == NULL );
        tmp_list_contraction_1__$0 = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        tmp_assign_source_2 = PyList_New( 0 );
        assert( tmp_list_contraction_1__contraction_result == NULL );
        tmp_list_contraction_1__contraction_result = tmp_assign_source_2;
    }
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_3;
        CHECK_OBJECT( tmp_list_contraction_1__$0 );
        tmp_next_source_1 = tmp_list_contraction_1__$0;
        tmp_assign_source_3 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_3 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "oo";
                exception_lineno = 35;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_list_contraction_1__iter_value_0;
            tmp_list_contraction_1__iter_value_0 = tmp_assign_source_3;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_4;
        CHECK_OBJECT( tmp_list_contraction_1__iter_value_0 );
        tmp_assign_source_4 = tmp_list_contraction_1__iter_value_0;
        {
            PyObject *old = var_b;
            var_b = tmp_assign_source_4;
            Py_INCREF( var_b );
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_append_list_1;
        PyObject *tmp_append_value_1;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_subscript_name_1;
        CHECK_OBJECT( tmp_list_contraction_1__contraction_result );
        tmp_append_list_1 = tmp_list_contraction_1__contraction_result;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_struct );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_struct );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "struct" );
            exception_tb = NULL;

            exception_lineno = 35;
            type_description_1 = "oo";
            goto try_except_handler_2;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        tmp_args_element_name_1 = const_str_digest_11a7e09c00a35df5b21f6600c68e78d8;
        CHECK_OBJECT( var_b );
        tmp_args_element_name_2 = var_b;
        frame_ddaf032ca36ff3666d4667ec7ee75bbe->m_frame.f_lineno = 35;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_subscribed_name_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_unpack, call_args );
        }

        if ( tmp_subscribed_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 35;
            type_description_1 = "oo";
            goto try_except_handler_2;
        }
        tmp_subscript_name_1 = const_int_0;
        tmp_append_value_1 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_1, tmp_subscript_name_1, 0 );
        Py_DECREF( tmp_subscribed_name_1 );
        if ( tmp_append_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 35;
            type_description_1 = "oo";
            goto try_except_handler_2;
        }
        assert( PyList_Check( tmp_append_list_1 ) );
        tmp_res = PyList_Append( tmp_append_list_1, tmp_append_value_1 );
        Py_DECREF( tmp_append_value_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 35;
            type_description_1 = "oo";
            goto try_except_handler_2;
        }
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 35;
        type_description_1 = "oo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    CHECK_OBJECT( tmp_list_contraction_1__contraction_result );
    tmp_return_value = tmp_list_contraction_1__contraction_result;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_2;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_1__compat_bytes_to_byte_vals );
    return NULL;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT( (PyObject *)tmp_list_contraction_1__$0 );
    Py_DECREF( tmp_list_contraction_1__$0 );
    tmp_list_contraction_1__$0 = NULL;

    CHECK_OBJECT( (PyObject *)tmp_list_contraction_1__contraction_result );
    Py_DECREF( tmp_list_contraction_1__contraction_result );
    tmp_list_contraction_1__contraction_result = NULL;

    Py_XDECREF( tmp_list_contraction_1__iter_value_0 );
    tmp_list_contraction_1__iter_value_0 = NULL;

    goto outline_result_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_list_contraction_1__$0 );
    tmp_list_contraction_1__$0 = NULL;

    Py_XDECREF( tmp_list_contraction_1__contraction_result );
    tmp_list_contraction_1__contraction_result = NULL;

    Py_XDECREF( tmp_list_contraction_1__iter_value_0 );
    tmp_list_contraction_1__iter_value_0 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_1__compat_bytes_to_byte_vals );
    return NULL;
    outline_result_1:;
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ddaf032ca36ff3666d4667ec7ee75bbe );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_ddaf032ca36ff3666d4667ec7ee75bbe );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ddaf032ca36ff3666d4667ec7ee75bbe );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ddaf032ca36ff3666d4667ec7ee75bbe, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ddaf032ca36ff3666d4667ec7ee75bbe->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ddaf032ca36ff3666d4667ec7ee75bbe, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ddaf032ca36ff3666d4667ec7ee75bbe,
        type_description_1,
        par_byt,
        var_b
    );


    // Release cached frame.
    if ( frame_ddaf032ca36ff3666d4667ec7ee75bbe == cache_frame_ddaf032ca36ff3666d4667ec7ee75bbe )
    {
        Py_DECREF( frame_ddaf032ca36ff3666d4667ec7ee75bbe );
    }
    cache_frame_ddaf032ca36ff3666d4667ec7ee75bbe = NULL;

    assertFrameObject( frame_ddaf032ca36ff3666d4667ec7ee75bbe );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_1__compat_bytes_to_byte_vals );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_byt );
    Py_DECREF( par_byt );
    par_byt = NULL;

    Py_XDECREF( var_b );
    var_b = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_byt );
    Py_DECREF( par_byt );
    par_byt = NULL;

    Py_XDECREF( var_b );
    var_b = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_1__compat_bytes_to_byte_vals );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_2__compat_int_from_byte_vals( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_bytvals = python_pars[ 0 ];
    PyObject *par_endianess = python_pars[ 1 ];
    PyObject *var_bv = NULL;
    PyObject *var_res = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_63f7a410e2fb3e552200f2a82a5285db;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_63f7a410e2fb3e552200f2a82a5285db = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_63f7a410e2fb3e552200f2a82a5285db, codeobj_63f7a410e2fb3e552200f2a82a5285db, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_63f7a410e2fb3e552200f2a82a5285db = cache_frame_63f7a410e2fb3e552200f2a82a5285db;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_63f7a410e2fb3e552200f2a82a5285db );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_63f7a410e2fb3e552200f2a82a5285db ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( par_endianess );
        tmp_compexpr_left_1 = par_endianess;
        tmp_compexpr_right_1 = const_unicode_plain_big;
        tmp_operand_name_1 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_operand_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 40;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        Py_DECREF( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 40;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            tmp_raise_type_1 = PyExc_AssertionError;
            exception_type = tmp_raise_type_1;
            Py_INCREF( tmp_raise_type_1 );
            exception_lineno = 40;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = const_int_0;
        assert( var_res == NULL );
        Py_INCREF( tmp_assign_source_1 );
        var_res = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_iter_arg_1;
        CHECK_OBJECT( par_bytvals );
        tmp_iter_arg_1 = par_bytvals;
        tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 42;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( tmp_for_loop_1__for_iterator == NULL );
        tmp_for_loop_1__for_iterator = tmp_assign_source_2;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_3;
        CHECK_OBJECT( tmp_for_loop_1__for_iterator );
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_3 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_3 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "oooo";
                exception_lineno = 42;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_3;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_4;
        CHECK_OBJECT( tmp_for_loop_1__iter_value );
        tmp_assign_source_4 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_bv;
            var_bv = tmp_assign_source_4;
            Py_INCREF( var_bv );
            Py_XDECREF( old );
        }

    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_2;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( var_bv );
        tmp_isinstance_inst_1 = var_bv;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_int_types );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__compat_int_types );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_compat_int_types" );
            exception_tb = NULL;

            exception_lineno = 43;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 43;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        tmp_operand_name_2 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 43;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_2;
            tmp_raise_type_2 = PyExc_AssertionError;
            exception_type = tmp_raise_type_2;
            Py_INCREF( tmp_raise_type_2 );
            exception_lineno = 43;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        branch_no_2:;
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_left_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_1;
        PyObject *tmp_right_name_2;
        CHECK_OBJECT( var_res );
        tmp_left_name_2 = var_res;
        tmp_right_name_1 = const_int_pos_8;
        tmp_left_name_1 = BINARY_OPERATION( PyNumber_Lshift, tmp_left_name_2, tmp_right_name_1 );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 44;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( var_bv );
        tmp_right_name_2 = var_bv;
        tmp_assign_source_5 = BINARY_OPERATION_ADD_OBJECT_OBJECT( tmp_left_name_1, tmp_right_name_2 );
        Py_DECREF( tmp_left_name_1 );
        if ( tmp_assign_source_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 44;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_res;
            assert( old != NULL );
            var_res = tmp_assign_source_5;
            Py_DECREF( old );
        }

    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 42;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_63f7a410e2fb3e552200f2a82a5285db );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_63f7a410e2fb3e552200f2a82a5285db );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_63f7a410e2fb3e552200f2a82a5285db, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_63f7a410e2fb3e552200f2a82a5285db->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_63f7a410e2fb3e552200f2a82a5285db, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_63f7a410e2fb3e552200f2a82a5285db,
        type_description_1,
        par_bytvals,
        par_endianess,
        var_bv,
        var_res
    );


    // Release cached frame.
    if ( frame_63f7a410e2fb3e552200f2a82a5285db == cache_frame_63f7a410e2fb3e552200f2a82a5285db )
    {
        Py_DECREF( frame_63f7a410e2fb3e552200f2a82a5285db );
    }
    cache_frame_63f7a410e2fb3e552200f2a82a5285db = NULL;

    assertFrameObject( frame_63f7a410e2fb3e552200f2a82a5285db );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    CHECK_OBJECT( var_res );
    tmp_return_value = var_res;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_2__compat_int_from_byte_vals );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_endianess );
    Py_DECREF( par_endianess );
    par_endianess = NULL;

    Py_XDECREF( var_bv );
    var_bv = NULL;

    CHECK_OBJECT( (PyObject *)par_bytvals );
    Py_DECREF( par_bytvals );
    par_bytvals = NULL;

    CHECK_OBJECT( (PyObject *)var_res );
    Py_DECREF( var_res );
    var_res = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_endianess );
    Py_DECREF( par_endianess );
    par_endianess = NULL;

    Py_XDECREF( var_bv );
    var_bv = NULL;

    CHECK_OBJECT( (PyObject *)par_bytvals );
    Py_DECREF( par_bytvals );
    par_bytvals = NULL;

    Py_XDECREF( var_res );
    var_res = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_2__compat_int_from_byte_vals );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_3__compat_to_bytes( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_intval = python_pars[ 0 ];
    PyObject *par_length = python_pars[ 1 ];
    PyObject *par_endianess = python_pars[ 2 ];
    struct Nuitka_FrameObject *frame_6c48ac6d4f9732d2aa38e88a2fc8b8c0;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_6c48ac6d4f9732d2aa38e88a2fc8b8c0 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6c48ac6d4f9732d2aa38e88a2fc8b8c0, codeobj_6c48ac6d4f9732d2aa38e88a2fc8b8c0, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_6c48ac6d4f9732d2aa38e88a2fc8b8c0 = cache_frame_6c48ac6d4f9732d2aa38e88a2fc8b8c0;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6c48ac6d4f9732d2aa38e88a2fc8b8c0 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6c48ac6d4f9732d2aa38e88a2fc8b8c0 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_intval );
        tmp_isinstance_inst_1 = par_intval;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_int_types );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__compat_int_types );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_compat_int_types" );
            exception_tb = NULL;

            exception_lineno = 49;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 49;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 49;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            tmp_raise_type_1 = PyExc_AssertionError;
            exception_type = tmp_raise_type_1;
            Py_INCREF( tmp_raise_type_1 );
            exception_lineno = 49;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( par_endianess );
        tmp_compexpr_left_1 = par_endianess;
        tmp_compexpr_right_1 = const_unicode_plain_big;
        tmp_operand_name_2 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_operand_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 50;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        Py_DECREF( tmp_operand_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 50;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_2;
            tmp_raise_type_2 = PyExc_AssertionError;
            exception_type = tmp_raise_type_2;
            Py_INCREF( tmp_raise_type_2 );
            exception_lineno = 50;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        CHECK_OBJECT( par_length );
        tmp_compexpr_left_2 = par_length;
        tmp_compexpr_right_2 = const_int_pos_4;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_INT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 51;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            nuitka_bool tmp_condition_result_4;
            int tmp_or_left_truth_1;
            nuitka_bool tmp_or_left_value_1;
            nuitka_bool tmp_or_right_value_1;
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            PyObject *tmp_compexpr_left_4;
            PyObject *tmp_compexpr_right_4;
            CHECK_OBJECT( par_intval );
            tmp_compexpr_left_3 = par_intval;
            tmp_compexpr_right_3 = const_int_0;
            tmp_res = RICH_COMPARE_BOOL_LT_OBJECT_INT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 52;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_or_left_value_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            tmp_or_left_truth_1 = tmp_or_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
            if ( tmp_or_left_truth_1 == 1 )
            {
                goto or_left_1;
            }
            else
            {
                goto or_right_1;
            }
            or_right_1:;
            CHECK_OBJECT( par_intval );
            tmp_compexpr_left_4 = par_intval;
            tmp_compexpr_right_4 = const_long_pos_4294967296;
            tmp_res = RICH_COMPARE_BOOL_GTE_OBJECT_OBJECT( tmp_compexpr_left_4, tmp_compexpr_right_4 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 52;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_or_right_value_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            tmp_condition_result_4 = tmp_or_right_value_1;
            goto or_end_1;
            or_left_1:;
            tmp_condition_result_4 = tmp_or_left_value_1;
            or_end_1:;
            if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_4;
            }
            else
            {
                goto branch_no_4;
            }
            branch_yes_4:;
            {
                PyObject *tmp_raise_type_3;
                PyObject *tmp_called_instance_1;
                PyObject *tmp_mvar_value_2;
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_struct );

                if (unlikely( tmp_mvar_value_2 == NULL ))
                {
                    tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_struct );
                }

                if ( tmp_mvar_value_2 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "struct" );
                    exception_tb = NULL;

                    exception_lineno = 53;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_instance_1 = tmp_mvar_value_2;
                frame_6c48ac6d4f9732d2aa38e88a2fc8b8c0->m_frame.f_lineno = 53;
                tmp_raise_type_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_error, &PyTuple_GET_ITEM( const_tuple_unicode_digest_d557365be24b3a7215b6d3030b88908b_tuple, 0 ) );

                if ( tmp_raise_type_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 53;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
                exception_type = tmp_raise_type_3;
                exception_lineno = 53;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            branch_no_4:;
        }
        {
            PyObject *tmp_called_instance_2;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_struct );

            if (unlikely( tmp_mvar_value_3 == NULL ))
            {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_struct );
            }

            if ( tmp_mvar_value_3 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "struct" );
                exception_tb = NULL;

                exception_lineno = 54;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_2 = tmp_mvar_value_3;
            tmp_args_element_name_1 = const_str_digest_8060bd90928781385c4bd80fdfcf370e;
            CHECK_OBJECT( par_intval );
            tmp_args_element_name_2 = par_intval;
            frame_6c48ac6d4f9732d2aa38e88a2fc8b8c0->m_frame.f_lineno = 54;
            {
                PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
                tmp_return_value = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_pack, call_args );
            }

            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 54;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        goto branch_end_3;
        branch_no_3:;
        {
            nuitka_bool tmp_condition_result_5;
            PyObject *tmp_compexpr_left_5;
            PyObject *tmp_compexpr_right_5;
            CHECK_OBJECT( par_length );
            tmp_compexpr_left_5 = par_length;
            tmp_compexpr_right_5 = const_int_pos_16;
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_INT( tmp_compexpr_left_5, tmp_compexpr_right_5 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 55;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_5 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_5;
            }
            else
            {
                goto branch_no_5;
            }
            branch_yes_5:;
            {
                nuitka_bool tmp_condition_result_6;
                int tmp_or_left_truth_2;
                nuitka_bool tmp_or_left_value_2;
                nuitka_bool tmp_or_right_value_2;
                PyObject *tmp_compexpr_left_6;
                PyObject *tmp_compexpr_right_6;
                PyObject *tmp_compexpr_left_7;
                PyObject *tmp_compexpr_right_7;
                CHECK_OBJECT( par_intval );
                tmp_compexpr_left_6 = par_intval;
                tmp_compexpr_right_6 = const_int_0;
                tmp_res = RICH_COMPARE_BOOL_LT_OBJECT_INT( tmp_compexpr_left_6, tmp_compexpr_right_6 );
                if ( tmp_res == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 56;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
                tmp_or_left_value_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                tmp_or_left_truth_2 = tmp_or_left_value_2 == NUITKA_BOOL_TRUE ? 1 : 0;
                if ( tmp_or_left_truth_2 == 1 )
                {
                    goto or_left_2;
                }
                else
                {
                    goto or_right_2;
                }
                or_right_2:;
                CHECK_OBJECT( par_intval );
                tmp_compexpr_left_7 = par_intval;
                tmp_compexpr_right_7 = const_b17c9d41053ae43805ed23be533f361d;
                tmp_res = RICH_COMPARE_BOOL_GTE_OBJECT_OBJECT( tmp_compexpr_left_7, tmp_compexpr_right_7 );
                if ( tmp_res == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 56;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
                tmp_or_right_value_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                tmp_condition_result_6 = tmp_or_right_value_2;
                goto or_end_2;
                or_left_2:;
                tmp_condition_result_6 = tmp_or_left_value_2;
                or_end_2:;
                if ( tmp_condition_result_6 == NUITKA_BOOL_TRUE )
                {
                    goto branch_yes_6;
                }
                else
                {
                    goto branch_no_6;
                }
                branch_yes_6:;
                {
                    PyObject *tmp_raise_type_4;
                    PyObject *tmp_called_instance_3;
                    PyObject *tmp_mvar_value_4;
                    tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_struct );

                    if (unlikely( tmp_mvar_value_4 == NULL ))
                    {
                        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_struct );
                    }

                    if ( tmp_mvar_value_4 == NULL )
                    {

                        exception_type = PyExc_NameError;
                        Py_INCREF( exception_type );
                        exception_value = PyString_FromFormat( "global name '%s' is not defined", "struct" );
                        exception_tb = NULL;

                        exception_lineno = 57;
                        type_description_1 = "ooo";
                        goto frame_exception_exit_1;
                    }

                    tmp_called_instance_3 = tmp_mvar_value_4;
                    frame_6c48ac6d4f9732d2aa38e88a2fc8b8c0->m_frame.f_lineno = 57;
                    tmp_raise_type_4 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_error, &PyTuple_GET_ITEM( const_tuple_unicode_digest_93b62600511a380f0935203a9df4765e_tuple, 0 ) );

                    if ( tmp_raise_type_4 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 57;
                        type_description_1 = "ooo";
                        goto frame_exception_exit_1;
                    }
                    exception_type = tmp_raise_type_4;
                    exception_lineno = 57;
                    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
                branch_no_6:;
            }
            {
                PyObject *tmp_called_name_1;
                PyObject *tmp_source_name_1;
                PyObject *tmp_mvar_value_5;
                PyObject *tmp_args_element_name_3;
                PyObject *tmp_args_element_name_4;
                PyObject *tmp_left_name_1;
                PyObject *tmp_right_name_1;
                PyObject *tmp_args_element_name_5;
                PyObject *tmp_left_name_2;
                PyObject *tmp_right_name_2;
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_struct );

                if (unlikely( tmp_mvar_value_5 == NULL ))
                {
                    tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_struct );
                }

                if ( tmp_mvar_value_5 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "struct" );
                    exception_tb = NULL;

                    exception_lineno = 58;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_1 = tmp_mvar_value_5;
                tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_pack );
                if ( tmp_called_name_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 58;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
                tmp_args_element_name_3 = const_str_digest_1dd9203bd723ff4d2badc10887999eb8;
                CHECK_OBJECT( par_intval );
                tmp_left_name_1 = par_intval;
                tmp_right_name_1 = const_int_pos_64;
                tmp_args_element_name_4 = BINARY_OPERATION( PyNumber_Rshift, tmp_left_name_1, tmp_right_name_1 );
                if ( tmp_args_element_name_4 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_called_name_1 );

                    exception_lineno = 58;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
                CHECK_OBJECT( par_intval );
                tmp_left_name_2 = par_intval;
                tmp_right_name_2 = const_long_pos_18446744073709551615;
                tmp_args_element_name_5 = BINARY_OPERATION( PyNumber_And, tmp_left_name_2, tmp_right_name_2 );
                if ( tmp_args_element_name_5 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_called_name_1 );
                    Py_DECREF( tmp_args_element_name_4 );

                    exception_lineno = 58;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
                frame_6c48ac6d4f9732d2aa38e88a2fc8b8c0->m_frame.f_lineno = 58;
                {
                    PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5 };
                    tmp_return_value = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
                }

                Py_DECREF( tmp_called_name_1 );
                Py_DECREF( tmp_args_element_name_4 );
                Py_DECREF( tmp_args_element_name_5 );
                if ( tmp_return_value == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 58;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
                goto frame_return_exit_1;
            }
            goto branch_end_5;
            branch_no_5:;
            {
                PyObject *tmp_raise_type_5;
                frame_6c48ac6d4f9732d2aa38e88a2fc8b8c0->m_frame.f_lineno = 60;
                tmp_raise_type_5 = CALL_FUNCTION_NO_ARGS( PyExc_NotImplementedError );
                assert( !(tmp_raise_type_5 == NULL) );
                exception_type = tmp_raise_type_5;
                exception_lineno = 60;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            branch_end_5:;
        }
        branch_end_3:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6c48ac6d4f9732d2aa38e88a2fc8b8c0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_6c48ac6d4f9732d2aa38e88a2fc8b8c0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6c48ac6d4f9732d2aa38e88a2fc8b8c0 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6c48ac6d4f9732d2aa38e88a2fc8b8c0, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6c48ac6d4f9732d2aa38e88a2fc8b8c0->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6c48ac6d4f9732d2aa38e88a2fc8b8c0, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6c48ac6d4f9732d2aa38e88a2fc8b8c0,
        type_description_1,
        par_intval,
        par_length,
        par_endianess
    );


    // Release cached frame.
    if ( frame_6c48ac6d4f9732d2aa38e88a2fc8b8c0 == cache_frame_6c48ac6d4f9732d2aa38e88a2fc8b8c0 )
    {
        Py_DECREF( frame_6c48ac6d4f9732d2aa38e88a2fc8b8c0 );
    }
    cache_frame_6c48ac6d4f9732d2aa38e88a2fc8b8c0 = NULL;

    assertFrameObject( frame_6c48ac6d4f9732d2aa38e88a2fc8b8c0 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_3__compat_to_bytes );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_endianess );
    Py_DECREF( par_endianess );
    par_endianess = NULL;

    CHECK_OBJECT( (PyObject *)par_length );
    Py_DECREF( par_length );
    par_length = NULL;

    CHECK_OBJECT( (PyObject *)par_intval );
    Py_DECREF( par_intval );
    par_intval = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_endianess );
    Py_DECREF( par_endianess );
    par_endianess = NULL;

    CHECK_OBJECT( (PyObject *)par_length );
    Py_DECREF( par_length );
    par_length = NULL;

    CHECK_OBJECT( (PyObject *)par_intval );
    Py_DECREF( par_intval );
    par_intval = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_3__compat_to_bytes );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_4__compat_bit_length( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_i = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_ef713967755f9970e25b35c37c0ef9d1;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_ef713967755f9970e25b35c37c0ef9d1 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ef713967755f9970e25b35c37c0ef9d1, codeobj_ef713967755f9970e25b35c37c0ef9d1, module_ipaddress, sizeof(void *) );
    frame_ef713967755f9970e25b35c37c0ef9d1 = cache_frame_ef713967755f9970e25b35c37c0ef9d1;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ef713967755f9970e25b35c37c0ef9d1 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ef713967755f9970e25b35c37c0ef9d1 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        CHECK_OBJECT( par_i );
        tmp_called_instance_1 = par_i;
        frame_ef713967755f9970e25b35c37c0ef9d1->m_frame.f_lineno = 64;
        tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_bit_length );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 64;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ef713967755f9970e25b35c37c0ef9d1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_ef713967755f9970e25b35c37c0ef9d1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ef713967755f9970e25b35c37c0ef9d1 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ef713967755f9970e25b35c37c0ef9d1, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ef713967755f9970e25b35c37c0ef9d1->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ef713967755f9970e25b35c37c0ef9d1, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ef713967755f9970e25b35c37c0ef9d1,
        type_description_1,
        par_i
    );


    // Release cached frame.
    if ( frame_ef713967755f9970e25b35c37c0ef9d1 == cache_frame_ef713967755f9970e25b35c37c0ef9d1 )
    {
        Py_DECREF( frame_ef713967755f9970e25b35c37c0ef9d1 );
    }
    cache_frame_ef713967755f9970e25b35c37c0ef9d1 = NULL;

    assertFrameObject( frame_ef713967755f9970e25b35c37c0ef9d1 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_4__compat_bit_length );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_i );
    Py_DECREF( par_i );
    par_i = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_i );
    Py_DECREF( par_i );
    par_i = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_4__compat_bit_length );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_5__compat_bit_length( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_i = python_pars[ 0 ];
    PyObject *var_res = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_1d55304974863c80f8deb17902b6612b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_1d55304974863c80f8deb17902b6612b = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1d55304974863c80f8deb17902b6612b, codeobj_1d55304974863c80f8deb17902b6612b, module_ipaddress, sizeof(void *)+sizeof(void *) );
    frame_1d55304974863c80f8deb17902b6612b = cache_frame_1d55304974863c80f8deb17902b6612b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1d55304974863c80f8deb17902b6612b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1d55304974863c80f8deb17902b6612b ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_itertools );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_itertools );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "itertools" );
            exception_tb = NULL;

            exception_lineno = 67;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_1d55304974863c80f8deb17902b6612b->m_frame.f_lineno = 67;
        tmp_iter_arg_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_count );
        if ( tmp_iter_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 67;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
        Py_DECREF( tmp_iter_arg_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 67;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert( tmp_for_loop_1__for_iterator == NULL );
        tmp_for_loop_1__for_iterator = tmp_assign_source_1;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT( tmp_for_loop_1__for_iterator );
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_2 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "oo";
                exception_lineno = 67;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_2;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_3;
        CHECK_OBJECT( tmp_for_loop_1__iter_value );
        tmp_assign_source_3 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_res;
            var_res = tmp_assign_source_3;
            Py_INCREF( var_res );
            Py_XDECREF( old );
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        CHECK_OBJECT( par_i );
        tmp_left_name_1 = par_i;
        CHECK_OBJECT( var_res );
        tmp_right_name_1 = var_res;
        tmp_compexpr_left_1 = BINARY_OPERATION( PyNumber_Rshift, tmp_left_name_1, tmp_right_name_1 );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 68;
            type_description_1 = "oo";
            goto try_except_handler_2;
        }
        tmp_compexpr_right_1 = const_int_0;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_INT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 68;
            type_description_1 = "oo";
            goto try_except_handler_2;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        CHECK_OBJECT( var_res );
        tmp_return_value = var_res;
        Py_INCREF( tmp_return_value );
        goto try_return_handler_2;
        branch_no_1:;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 67;
        type_description_1 = "oo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__iter_value );
    Py_DECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    goto frame_return_exit_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1d55304974863c80f8deb17902b6612b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_1d55304974863c80f8deb17902b6612b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1d55304974863c80f8deb17902b6612b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1d55304974863c80f8deb17902b6612b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1d55304974863c80f8deb17902b6612b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1d55304974863c80f8deb17902b6612b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1d55304974863c80f8deb17902b6612b,
        type_description_1,
        par_i,
        var_res
    );


    // Release cached frame.
    if ( frame_1d55304974863c80f8deb17902b6612b == cache_frame_1d55304974863c80f8deb17902b6612b )
    {
        Py_DECREF( frame_1d55304974863c80f8deb17902b6612b );
    }
    cache_frame_1d55304974863c80f8deb17902b6612b = NULL;

    assertFrameObject( frame_1d55304974863c80f8deb17902b6612b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_5__compat_bit_length );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_i );
    Py_DECREF( par_i );
    par_i = NULL;

    Py_XDECREF( var_res );
    var_res = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_i );
    Py_DECREF( par_i );
    par_i = NULL;

    Py_XDECREF( var_res );
    var_res = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_5__compat_bit_length );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_6__compat_range( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_start = PyCell_NEW1( python_pars[ 0 ] );
    struct Nuitka_CellObject *par_end = PyCell_NEW1( python_pars[ 1 ] );
    struct Nuitka_CellObject *par_step = PyCell_NEW1( python_pars[ 2 ] );
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    // Tried code:
    tmp_return_value = ipaddress$$$function_6__compat_range$$$genobj_1__compat_range_maker();

    ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[0] = par_end;
    Py_INCREF( ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[0] );
    ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[1] = par_start;
    Py_INCREF( ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[1] );
    ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[2] = par_step;
    Py_INCREF( ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[2] );


    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_6__compat_range );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_start );
    Py_DECREF( par_start );
    par_start = NULL;

    CHECK_OBJECT( (PyObject *)par_step );
    Py_DECREF( par_step );
    par_step = NULL;

    CHECK_OBJECT( (PyObject *)par_end );
    Py_DECREF( par_end );
    par_end = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_start );
    Py_DECREF( par_start );
    par_start = NULL;

    CHECK_OBJECT( (PyObject *)par_step );
    Py_DECREF( par_step );
    par_step = NULL;

    CHECK_OBJECT( (PyObject *)par_end );
    Py_DECREF( par_end );
    par_end = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_6__compat_range );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}



struct ipaddress$$$function_6__compat_range$$$genobj_1__compat_range_locals {
    PyObject *var_i;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    int tmp_res;
    bool tmp_result;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
};

static PyObject *ipaddress$$$function_6__compat_range$$$genobj_1__compat_range_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Heap access if used.
    struct ipaddress$$$function_6__compat_range$$$genobj_1__compat_range_locals *generator_heap = (struct ipaddress$$$function_6__compat_range$$$genobj_1__compat_range_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_i = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_m_frame, codeobj_9e6ebf7db345152cd0b801fe8b7dd4ce, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

#if PYTHON_VERSION < 370
        generator->m_frame->m_frame.f_exc_type = EXC_TYPE( thread_state );
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
        Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#else
        generator->m_exc_state.exc_type = EXC_TYPE( thread_state );
        if ( generator->m_exc_state.exc_type == Py_None ) generator->m_exc_state.exc_type = NULL;
        Py_XINCREF( generator->m_exc_state.exc_type );
        generator->m_exc_state.exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_value );
        generator->m_exc_state.exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_traceback );
#endif
    }

#endif

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        if ( PyCell_GET( generator->m_closure[2] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "step" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 73;
            generator_heap->type_description_1 = "ccco";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_left_1 = PyCell_GET( generator->m_closure[2] );
        tmp_compexpr_right_1 = const_int_0;
        tmp_operand_name_1 = RICH_COMPARE_GT_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_operand_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 73;
            generator_heap->type_description_1 = "ccco";
            goto frame_exception_exit_1;
        }
        generator_heap->tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        Py_DECREF( tmp_operand_name_1 );
        if ( generator_heap->tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 73;
            generator_heap->type_description_1 = "ccco";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( generator_heap->tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            tmp_raise_type_1 = PyExc_AssertionError;
            generator_heap->exception_type = tmp_raise_type_1;
            Py_INCREF( tmp_raise_type_1 );
            generator_heap->exception_lineno = 73;
            RAISE_EXCEPTION_WITH_TYPE( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
            generator_heap->type_description_1 = "ccco";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        if ( PyCell_GET( generator->m_closure[1] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "start" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 74;
            generator_heap->type_description_1 = "ccco";
            goto frame_exception_exit_1;
        }

        tmp_assign_source_1 = PyCell_GET( generator->m_closure[1] );
        assert( generator_heap->var_i == NULL );
        Py_INCREF( tmp_assign_source_1 );
        generator_heap->var_i = tmp_assign_source_1;
    }
    loop_start_1:;
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        CHECK_OBJECT( generator_heap->var_i );
        tmp_compexpr_left_2 = generator_heap->var_i;
        if ( PyCell_GET( generator->m_closure[0] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "end" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 75;
            generator_heap->type_description_1 = "ccco";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_2 = PyCell_GET( generator->m_closure[0] );
        tmp_operand_name_2 = RICH_COMPARE_LT_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        if ( tmp_operand_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 75;
            generator_heap->type_description_1 = "ccco";
            goto frame_exception_exit_1;
        }
        generator_heap->tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        Py_DECREF( tmp_operand_name_2 );
        if ( generator_heap->tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 75;
            generator_heap->type_description_1 = "ccco";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( generator_heap->tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        goto loop_end_1;
        branch_no_2:;
    }
    {
        PyObject *tmp_expression_name_1;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        CHECK_OBJECT( generator_heap->var_i );
        tmp_expression_name_1 = generator_heap->var_i;
        Py_INCREF( tmp_expression_name_1 );
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        if ( yield_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 76;
            generator_heap->type_description_1 = "ccco";
            goto frame_exception_exit_1;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        CHECK_OBJECT( generator_heap->var_i );
        tmp_left_name_1 = generator_heap->var_i;
        if ( PyCell_GET( generator->m_closure[2] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "step" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 77;
            generator_heap->type_description_1 = "ccco";
            goto frame_exception_exit_1;
        }

        tmp_right_name_1 = PyCell_GET( generator->m_closure[2] );
        generator_heap->tmp_result = BINARY_OPERATION_ADD_OBJECT_OBJECT_INPLACE( &tmp_left_name_1, tmp_right_name_1 );
        if ( generator_heap->tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 77;
            generator_heap->type_description_1 = "ccco";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_2 = tmp_left_name_1;
        generator_heap->var_i = tmp_assign_source_2;

    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


        generator_heap->exception_lineno = 75;
        generator_heap->type_description_1 = "ccco";
        goto frame_exception_exit_1;
    }
    goto loop_start_1;
    loop_end_1:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( generator_heap->exception_type ) )
    {
        if ( generator_heap->exception_tb == NULL )
        {
            generator_heap->exception_tb = MAKE_TRACEBACK( generator->m_frame, generator_heap->exception_lineno );
        }
        else if ( generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            generator_heap->exception_tb = ADD_TRACEBACK( generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            generator->m_closure[1],
            generator->m_closure[0],
            generator->m_closure[2],
            generator_heap->var_i
        );


        // Release cached frame.
        if ( generator->m_frame == cache_m_frame )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_m_frame = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->var_i );
    generator_heap->var_i = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:
    try_end_1:;
    CHECK_OBJECT( (PyObject *)generator_heap->var_i );
    Py_DECREF( generator_heap->var_i );
    generator_heap->var_i = NULL;



    return NULL;

    function_exception_exit:
    assert( generator_heap->exception_type );
    RESTORE_ERROR_OCCURRED( generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb );

    return NULL;

}

static PyObject *ipaddress$$$function_6__compat_range$$$genobj_1__compat_range_maker( void )
{
    return Nuitka_Generator_New(
        ipaddress$$$function_6__compat_range$$$genobj_1__compat_range_context,
        module_ipaddress,
        const_str_plain__compat_range,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_9e6ebf7db345152cd0b801fe8b7dd4ce,
        3,
        sizeof(struct ipaddress$$$function_6__compat_range$$$genobj_1__compat_range_locals)
    );
}


static PyObject *impl_ipaddress$$$function_7___eq__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_0186f03ed402b8f930ca7c2461b98230;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_0186f03ed402b8f930ca7c2461b98230 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0186f03ed402b8f930ca7c2461b98230, codeobj_0186f03ed402b8f930ca7c2461b98230, module_ipaddress, sizeof(void *)+sizeof(void *) );
    frame_0186f03ed402b8f930ca7c2461b98230 = cache_frame_0186f03ed402b8f930ca7c2461b98230;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0186f03ed402b8f930ca7c2461b98230 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0186f03ed402b8f930ca7c2461b98230 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_raise_type_1;
        tmp_raise_type_1 = PyExc_NotImplementedError;
        exception_type = tmp_raise_type_1;
        Py_INCREF( tmp_raise_type_1 );
        exception_lineno = 88;
        RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0186f03ed402b8f930ca7c2461b98230 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0186f03ed402b8f930ca7c2461b98230 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0186f03ed402b8f930ca7c2461b98230, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0186f03ed402b8f930ca7c2461b98230->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0186f03ed402b8f930ca7c2461b98230, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0186f03ed402b8f930ca7c2461b98230,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_0186f03ed402b8f930ca7c2461b98230 == cache_frame_0186f03ed402b8f930ca7c2461b98230 )
    {
        Py_DECREF( frame_0186f03ed402b8f930ca7c2461b98230 );
    }
    cache_frame_0186f03ed402b8f930ca7c2461b98230 = NULL;

    assertFrameObject( frame_0186f03ed402b8f930ca7c2461b98230 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_7___eq__ );
    return NULL;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_7___eq__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

}


static PyObject *impl_ipaddress$$$function_8___ne__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *var_equal = NULL;
    struct Nuitka_FrameObject *frame_ecf3b750663a962c8345413a0f92b14f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_ecf3b750663a962c8345413a0f92b14f = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ecf3b750663a962c8345413a0f92b14f, codeobj_ecf3b750663a962c8345413a0f92b14f, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_ecf3b750663a962c8345413a0f92b14f = cache_frame_ecf3b750663a962c8345413a0f92b14f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ecf3b750663a962c8345413a0f92b14f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ecf3b750663a962c8345413a0f92b14f ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        CHECK_OBJECT( par_other );
        tmp_args_element_name_1 = par_other;
        frame_ecf3b750663a962c8345413a0f92b14f->m_frame.f_lineno = 91;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain___eq__, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 91;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_equal == NULL );
        var_equal = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( var_equal );
        tmp_compexpr_left_1 = var_equal;
        tmp_compexpr_right_1 = Py_NotImplemented;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_NotImplemented;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_operand_name_1;
        CHECK_OBJECT( var_equal );
        tmp_operand_name_1 = var_equal;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 94;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = ( tmp_res == 0 ) ? Py_True : Py_False;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ecf3b750663a962c8345413a0f92b14f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_ecf3b750663a962c8345413a0f92b14f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ecf3b750663a962c8345413a0f92b14f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ecf3b750663a962c8345413a0f92b14f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ecf3b750663a962c8345413a0f92b14f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ecf3b750663a962c8345413a0f92b14f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ecf3b750663a962c8345413a0f92b14f,
        type_description_1,
        par_self,
        par_other,
        var_equal
    );


    // Release cached frame.
    if ( frame_ecf3b750663a962c8345413a0f92b14f == cache_frame_ecf3b750663a962c8345413a0f92b14f )
    {
        Py_DECREF( frame_ecf3b750663a962c8345413a0f92b14f );
    }
    cache_frame_ecf3b750663a962c8345413a0f92b14f = NULL;

    assertFrameObject( frame_ecf3b750663a962c8345413a0f92b14f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_8___ne__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    CHECK_OBJECT( (PyObject *)var_equal );
    Py_DECREF( var_equal );
    var_equal = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    Py_XDECREF( var_equal );
    var_equal = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_8___ne__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_9___lt__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_0025b9efe3ddf8d01e63fbed9660773a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_0025b9efe3ddf8d01e63fbed9660773a = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0025b9efe3ddf8d01e63fbed9660773a, codeobj_0025b9efe3ddf8d01e63fbed9660773a, module_ipaddress, sizeof(void *)+sizeof(void *) );
    frame_0025b9efe3ddf8d01e63fbed9660773a = cache_frame_0025b9efe3ddf8d01e63fbed9660773a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0025b9efe3ddf8d01e63fbed9660773a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0025b9efe3ddf8d01e63fbed9660773a ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_raise_type_1;
        tmp_raise_type_1 = PyExc_NotImplementedError;
        exception_type = tmp_raise_type_1;
        Py_INCREF( tmp_raise_type_1 );
        exception_lineno = 97;
        RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0025b9efe3ddf8d01e63fbed9660773a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0025b9efe3ddf8d01e63fbed9660773a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0025b9efe3ddf8d01e63fbed9660773a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0025b9efe3ddf8d01e63fbed9660773a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0025b9efe3ddf8d01e63fbed9660773a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0025b9efe3ddf8d01e63fbed9660773a,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_0025b9efe3ddf8d01e63fbed9660773a == cache_frame_0025b9efe3ddf8d01e63fbed9660773a )
    {
        Py_DECREF( frame_0025b9efe3ddf8d01e63fbed9660773a );
    }
    cache_frame_0025b9efe3ddf8d01e63fbed9660773a = NULL;

    assertFrameObject( frame_0025b9efe3ddf8d01e63fbed9660773a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_9___lt__ );
    return NULL;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_9___lt__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

}


static PyObject *impl_ipaddress$$$function_10___le__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *var_less = NULL;
    struct Nuitka_FrameObject *frame_a4f6648fef564b16884f557db0779374;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_a4f6648fef564b16884f557db0779374 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a4f6648fef564b16884f557db0779374, codeobj_a4f6648fef564b16884f557db0779374, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_a4f6648fef564b16884f557db0779374 = cache_frame_a4f6648fef564b16884f557db0779374;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a4f6648fef564b16884f557db0779374 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a4f6648fef564b16884f557db0779374 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        CHECK_OBJECT( par_other );
        tmp_args_element_name_1 = par_other;
        frame_a4f6648fef564b16884f557db0779374->m_frame.f_lineno = 100;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain___lt__, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 100;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_less == NULL );
        var_less = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_or_left_truth_1;
        nuitka_bool tmp_or_left_value_1;
        nuitka_bool tmp_or_right_value_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_operand_name_1;
        CHECK_OBJECT( var_less );
        tmp_compexpr_left_1 = var_less;
        tmp_compexpr_right_1 = Py_NotImplemented;
        tmp_or_left_value_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_or_left_truth_1 = tmp_or_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_or_left_truth_1 == 1 )
        {
            goto or_left_1;
        }
        else
        {
            goto or_right_1;
        }
        or_right_1:;
        CHECK_OBJECT( var_less );
        tmp_operand_name_1 = var_less;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 101;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_or_right_value_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_condition_result_1 = tmp_or_right_value_1;
        goto or_end_1;
        or_left_1:;
        tmp_condition_result_1 = tmp_or_left_value_1;
        or_end_1:;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_instance_2;
            PyObject *tmp_args_element_name_2;
            CHECK_OBJECT( par_self );
            tmp_called_instance_2 = par_self;
            CHECK_OBJECT( par_other );
            tmp_args_element_name_2 = par_other;
            frame_a4f6648fef564b16884f557db0779374->m_frame.f_lineno = 102;
            {
                PyObject *call_args[] = { tmp_args_element_name_2 };
                tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain___eq__, call_args );
            }

            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 102;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a4f6648fef564b16884f557db0779374 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_a4f6648fef564b16884f557db0779374 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a4f6648fef564b16884f557db0779374 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a4f6648fef564b16884f557db0779374, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a4f6648fef564b16884f557db0779374->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a4f6648fef564b16884f557db0779374, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a4f6648fef564b16884f557db0779374,
        type_description_1,
        par_self,
        par_other,
        var_less
    );


    // Release cached frame.
    if ( frame_a4f6648fef564b16884f557db0779374 == cache_frame_a4f6648fef564b16884f557db0779374 )
    {
        Py_DECREF( frame_a4f6648fef564b16884f557db0779374 );
    }
    cache_frame_a4f6648fef564b16884f557db0779374 = NULL;

    assertFrameObject( frame_a4f6648fef564b16884f557db0779374 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_less );
    tmp_return_value = var_less;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_10___le__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    CHECK_OBJECT( (PyObject *)var_less );
    Py_DECREF( var_less );
    var_less = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    Py_XDECREF( var_less );
    var_less = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_10___le__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_11___gt__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *var_equal = NULL;
    PyObject *var_less = NULL;
    struct Nuitka_FrameObject *frame_c8b388385f1f9f775ba4daa3e7c06d3b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_c8b388385f1f9f775ba4daa3e7c06d3b = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c8b388385f1f9f775ba4daa3e7c06d3b, codeobj_c8b388385f1f9f775ba4daa3e7c06d3b, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_c8b388385f1f9f775ba4daa3e7c06d3b = cache_frame_c8b388385f1f9f775ba4daa3e7c06d3b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c8b388385f1f9f775ba4daa3e7c06d3b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c8b388385f1f9f775ba4daa3e7c06d3b ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        CHECK_OBJECT( par_other );
        tmp_args_element_name_1 = par_other;
        frame_c8b388385f1f9f775ba4daa3e7c06d3b->m_frame.f_lineno = 106;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain___lt__, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 106;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_less == NULL );
        var_less = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( var_less );
        tmp_compexpr_left_1 = var_less;
        tmp_compexpr_right_1 = Py_NotImplemented;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_NotImplemented;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT( par_self );
        tmp_called_instance_2 = par_self;
        CHECK_OBJECT( par_other );
        tmp_args_element_name_2 = par_other;
        frame_c8b388385f1f9f775ba4daa3e7c06d3b->m_frame.f_lineno = 109;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain___eq__, call_args );
        }

        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 109;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_equal == NULL );
        var_equal = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        CHECK_OBJECT( var_equal );
        tmp_compexpr_left_2 = var_equal;
        tmp_compexpr_right_2 = Py_NotImplemented;
        tmp_condition_result_2 = ( tmp_compexpr_left_2 == tmp_compexpr_right_2 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        tmp_return_value = Py_NotImplemented;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_2:;
    }
    {
        PyObject *tmp_operand_name_1;
        int tmp_or_left_truth_1;
        PyObject *tmp_or_left_value_1;
        PyObject *tmp_or_right_value_1;
        CHECK_OBJECT( var_less );
        tmp_or_left_value_1 = var_less;
        tmp_or_left_truth_1 = CHECK_IF_TRUE( tmp_or_left_value_1 );
        if ( tmp_or_left_truth_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 112;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        if ( tmp_or_left_truth_1 == 1 )
        {
            goto or_left_1;
        }
        else
        {
            goto or_right_1;
        }
        or_right_1:;
        CHECK_OBJECT( var_equal );
        tmp_or_right_value_1 = var_equal;
        tmp_operand_name_1 = tmp_or_right_value_1;
        goto or_end_1;
        or_left_1:;
        tmp_operand_name_1 = tmp_or_left_value_1;
        or_end_1:;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 112;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = ( tmp_res == 0 ) ? Py_True : Py_False;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c8b388385f1f9f775ba4daa3e7c06d3b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_c8b388385f1f9f775ba4daa3e7c06d3b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c8b388385f1f9f775ba4daa3e7c06d3b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c8b388385f1f9f775ba4daa3e7c06d3b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c8b388385f1f9f775ba4daa3e7c06d3b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c8b388385f1f9f775ba4daa3e7c06d3b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c8b388385f1f9f775ba4daa3e7c06d3b,
        type_description_1,
        par_self,
        par_other,
        var_equal,
        var_less
    );


    // Release cached frame.
    if ( frame_c8b388385f1f9f775ba4daa3e7c06d3b == cache_frame_c8b388385f1f9f775ba4daa3e7c06d3b )
    {
        Py_DECREF( frame_c8b388385f1f9f775ba4daa3e7c06d3b );
    }
    cache_frame_c8b388385f1f9f775ba4daa3e7c06d3b = NULL;

    assertFrameObject( frame_c8b388385f1f9f775ba4daa3e7c06d3b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_11___gt__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    Py_XDECREF( var_equal );
    var_equal = NULL;

    CHECK_OBJECT( (PyObject *)var_less );
    Py_DECREF( var_less );
    var_less = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    Py_XDECREF( var_equal );
    var_equal = NULL;

    Py_XDECREF( var_less );
    var_less = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_11___gt__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_12___ge__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *var_less = NULL;
    struct Nuitka_FrameObject *frame_0c15792d81d3f3f629d0aa7ac6cf19a4;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_0c15792d81d3f3f629d0aa7ac6cf19a4 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0c15792d81d3f3f629d0aa7ac6cf19a4, codeobj_0c15792d81d3f3f629d0aa7ac6cf19a4, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_0c15792d81d3f3f629d0aa7ac6cf19a4 = cache_frame_0c15792d81d3f3f629d0aa7ac6cf19a4;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0c15792d81d3f3f629d0aa7ac6cf19a4 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0c15792d81d3f3f629d0aa7ac6cf19a4 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        CHECK_OBJECT( par_other );
        tmp_args_element_name_1 = par_other;
        frame_0c15792d81d3f3f629d0aa7ac6cf19a4->m_frame.f_lineno = 115;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain___lt__, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 115;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_less == NULL );
        var_less = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( var_less );
        tmp_compexpr_left_1 = var_less;
        tmp_compexpr_right_1 = Py_NotImplemented;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_NotImplemented;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_operand_name_1;
        CHECK_OBJECT( var_less );
        tmp_operand_name_1 = var_less;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 118;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = ( tmp_res == 0 ) ? Py_True : Py_False;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0c15792d81d3f3f629d0aa7ac6cf19a4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_0c15792d81d3f3f629d0aa7ac6cf19a4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0c15792d81d3f3f629d0aa7ac6cf19a4 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0c15792d81d3f3f629d0aa7ac6cf19a4, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0c15792d81d3f3f629d0aa7ac6cf19a4->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0c15792d81d3f3f629d0aa7ac6cf19a4, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0c15792d81d3f3f629d0aa7ac6cf19a4,
        type_description_1,
        par_self,
        par_other,
        var_less
    );


    // Release cached frame.
    if ( frame_0c15792d81d3f3f629d0aa7ac6cf19a4 == cache_frame_0c15792d81d3f3f629d0aa7ac6cf19a4 )
    {
        Py_DECREF( frame_0c15792d81d3f3f629d0aa7ac6cf19a4 );
    }
    cache_frame_0c15792d81d3f3f629d0aa7ac6cf19a4 = NULL;

    assertFrameObject( frame_0c15792d81d3f3f629d0aa7ac6cf19a4 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_12___ge__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    CHECK_OBJECT( (PyObject *)var_less );
    Py_DECREF( var_less );
    var_less = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    Py_XDECREF( var_less );
    var_less = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_12___ge__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_13_ip_address( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_address = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_90469e3b518446adc4eedffd44ffe52a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_res;
    bool tmp_result;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    static struct Nuitka_FrameObject *cache_frame_90469e3b518446adc4eedffd44ffe52a = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_90469e3b518446adc4eedffd44ffe52a, codeobj_90469e3b518446adc4eedffd44ffe52a, module_ipaddress, sizeof(void *) );
    frame_90469e3b518446adc4eedffd44ffe52a = cache_frame_90469e3b518446adc4eedffd44ffe52a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_90469e3b518446adc4eedffd44ffe52a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_90469e3b518446adc4eedffd44ffe52a ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Address );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Address );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv4Address" );
            exception_tb = NULL;

            exception_lineno = 150;
            type_description_1 = "o";
            goto try_except_handler_2;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_address );
        tmp_args_element_name_1 = par_address;
        frame_90469e3b518446adc4eedffd44ffe52a->m_frame.f_lineno = 150;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 150;
            type_description_1 = "o";
            goto try_except_handler_2;
        }
        goto frame_return_exit_1;
    }
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_13_ip_address );
    return NULL;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_90469e3b518446adc4eedffd44ffe52a );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_90469e3b518446adc4eedffd44ffe52a, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_90469e3b518446adc4eedffd44ffe52a, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_mvar_value_3;
        tmp_compexpr_left_1 = EXC_TYPE(PyThreadState_GET());
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_AddressValueError );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AddressValueError );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "AddressValueError" );
            exception_tb = NULL;

            exception_lineno = 151;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_tuple_element_1 = tmp_mvar_value_2;
        tmp_compexpr_right_1 = PyTuple_New( 2 );
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_compexpr_right_1, 0, tmp_tuple_element_1 );
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_NetmaskValueError );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NetmaskValueError );
        }

        if ( tmp_mvar_value_3 == NULL )
        {
            Py_DECREF( tmp_compexpr_right_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "NetmaskValueError" );
            exception_tb = NULL;

            exception_lineno = 151;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_tuple_element_1 = tmp_mvar_value_3;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_compexpr_right_1, 1, tmp_tuple_element_1 );
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 151;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 151;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 149;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_90469e3b518446adc4eedffd44ffe52a->m_frame) frame_90469e3b518446adc4eedffd44ffe52a->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "o";
        goto frame_exception_exit_1;
        branch_no_1:;
    }
    goto try_end_1;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_13_ip_address );
    return NULL;
    // End of try:
    try_end_1:;
    // Tried code:
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Address );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Address );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv6Address" );
            exception_tb = NULL;

            exception_lineno = 155;
            type_description_1 = "o";
            goto try_except_handler_3;
        }

        tmp_called_name_2 = tmp_mvar_value_4;
        CHECK_OBJECT( par_address );
        tmp_args_element_name_2 = par_address;
        frame_90469e3b518446adc4eedffd44ffe52a->m_frame.f_lineno = 155;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 155;
            type_description_1 = "o";
            goto try_except_handler_3;
        }
        goto frame_return_exit_1;
    }
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_13_ip_address );
    return NULL;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_90469e3b518446adc4eedffd44ffe52a );
    if ( exception_keeper_tb_2 == NULL )
    {
        exception_keeper_tb_2 = MAKE_TRACEBACK( frame_90469e3b518446adc4eedffd44ffe52a, exception_keeper_lineno_2 );
    }
    else if ( exception_keeper_lineno_2 != 0 )
    {
        exception_keeper_tb_2 = ADD_TRACEBACK( exception_keeper_tb_2, frame_90469e3b518446adc4eedffd44ffe52a, exception_keeper_lineno_2 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_2, &exception_keeper_value_2, &exception_keeper_tb_2 );
    PUBLISH_EXCEPTION( &exception_keeper_type_2, &exception_keeper_value_2, &exception_keeper_tb_2 );
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_tuple_element_2;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_mvar_value_6;
        tmp_compexpr_left_2 = EXC_TYPE(PyThreadState_GET());
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_AddressValueError );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AddressValueError );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "AddressValueError" );
            exception_tb = NULL;

            exception_lineno = 156;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_tuple_element_2 = tmp_mvar_value_5;
        tmp_compexpr_right_2 = PyTuple_New( 2 );
        Py_INCREF( tmp_tuple_element_2 );
        PyTuple_SET_ITEM( tmp_compexpr_right_2, 0, tmp_tuple_element_2 );
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_NetmaskValueError );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NetmaskValueError );
        }

        if ( tmp_mvar_value_6 == NULL )
        {
            Py_DECREF( tmp_compexpr_right_2 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "NetmaskValueError" );
            exception_tb = NULL;

            exception_lineno = 156;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_tuple_element_2 = tmp_mvar_value_6;
        Py_INCREF( tmp_tuple_element_2 );
        PyTuple_SET_ITEM( tmp_compexpr_right_2, 1, tmp_tuple_element_2 );
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        Py_DECREF( tmp_compexpr_right_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 156;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_2 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 156;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 154;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_90469e3b518446adc4eedffd44ffe52a->m_frame) frame_90469e3b518446adc4eedffd44ffe52a->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "o";
        goto frame_exception_exit_1;
        branch_no_2:;
    }
    goto try_end_2;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_13_ip_address );
    return NULL;
    // End of try:
    try_end_2:;
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        CHECK_OBJECT( par_address );
        tmp_isinstance_inst_1 = par_address;
        tmp_isinstance_cls_1 = (PyObject *)&PyString_Type;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 159;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_called_name_3;
            PyObject *tmp_mvar_value_7;
            PyObject *tmp_args_element_name_3;
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_AddressValueError );

            if (unlikely( tmp_mvar_value_7 == NULL ))
            {
                tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AddressValueError );
            }

            if ( tmp_mvar_value_7 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "AddressValueError" );
                exception_tb = NULL;

                exception_lineno = 160;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }

            tmp_called_name_3 = tmp_mvar_value_7;
            tmp_left_name_1 = const_unicode_digest_fad41d1e4e853f25a53f8ca47aca44ae;
            CHECK_OBJECT( par_address );
            tmp_right_name_1 = par_address;
            tmp_args_element_name_3 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
            if ( tmp_args_element_name_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 161;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            frame_90469e3b518446adc4eedffd44ffe52a->m_frame.f_lineno = 160;
            {
                PyObject *call_args[] = { tmp_args_element_name_3 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
            }

            Py_DECREF( tmp_args_element_name_3 );
            if ( tmp_raise_type_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 160;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            exception_type = tmp_raise_type_1;
            exception_lineno = 160;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        branch_no_3:;
    }
    {
        PyObject *tmp_raise_type_2;
        PyObject *tmp_make_exception_arg_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_2;
        tmp_left_name_2 = const_unicode_digest_82f1741cd06220f67668319322d6ad23;
        CHECK_OBJECT( par_address );
        tmp_right_name_2 = par_address;
        tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_2, tmp_right_name_2 );
        if ( tmp_make_exception_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 165;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_90469e3b518446adc4eedffd44ffe52a->m_frame.f_lineno = 165;
        {
            PyObject *call_args[] = { tmp_make_exception_arg_1 };
            tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
        }

        Py_DECREF( tmp_make_exception_arg_1 );
        assert( !(tmp_raise_type_2 == NULL) );
        exception_type = tmp_raise_type_2;
        exception_lineno = 165;
        RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

#if 1
    RESTORE_FRAME_EXCEPTION( frame_90469e3b518446adc4eedffd44ffe52a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_90469e3b518446adc4eedffd44ffe52a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_90469e3b518446adc4eedffd44ffe52a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_90469e3b518446adc4eedffd44ffe52a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_90469e3b518446adc4eedffd44ffe52a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_90469e3b518446adc4eedffd44ffe52a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_90469e3b518446adc4eedffd44ffe52a,
        type_description_1,
        par_address
    );


    // Release cached frame.
    if ( frame_90469e3b518446adc4eedffd44ffe52a == cache_frame_90469e3b518446adc4eedffd44ffe52a )
    {
        Py_DECREF( frame_90469e3b518446adc4eedffd44ffe52a );
    }
    cache_frame_90469e3b518446adc4eedffd44ffe52a = NULL;

    assertFrameObject( frame_90469e3b518446adc4eedffd44ffe52a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_13_ip_address );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_address );
    Py_DECREF( par_address );
    par_address = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_address );
    Py_DECREF( par_address );
    par_address = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_13_ip_address );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_14_ip_network( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_address = python_pars[ 0 ];
    PyObject *par_strict = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_08dacecb2456e05693d19a8e92c1c5d3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_res;
    bool tmp_result;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    static struct Nuitka_FrameObject *cache_frame_08dacecb2456e05693d19a8e92c1c5d3 = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_08dacecb2456e05693d19a8e92c1c5d3, codeobj_08dacecb2456e05693d19a8e92c1c5d3, module_ipaddress, sizeof(void *)+sizeof(void *) );
    frame_08dacecb2456e05693d19a8e92c1c5d3 = cache_frame_08dacecb2456e05693d19a8e92c1c5d3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_08dacecb2456e05693d19a8e92c1c5d3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_08dacecb2456e05693d19a8e92c1c5d3 ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Network );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Network );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv4Network" );
            exception_tb = NULL;

            exception_lineno = 186;
            type_description_1 = "oo";
            goto try_except_handler_2;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_address );
        tmp_args_element_name_1 = par_address;
        CHECK_OBJECT( par_strict );
        tmp_args_element_name_2 = par_strict;
        frame_08dacecb2456e05693d19a8e92c1c5d3->m_frame.f_lineno = 186;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 186;
            type_description_1 = "oo";
            goto try_except_handler_2;
        }
        goto frame_return_exit_1;
    }
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_14_ip_network );
    return NULL;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_08dacecb2456e05693d19a8e92c1c5d3 );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_08dacecb2456e05693d19a8e92c1c5d3, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_08dacecb2456e05693d19a8e92c1c5d3, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_mvar_value_3;
        tmp_compexpr_left_1 = EXC_TYPE(PyThreadState_GET());
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_AddressValueError );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AddressValueError );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "AddressValueError" );
            exception_tb = NULL;

            exception_lineno = 187;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_tuple_element_1 = tmp_mvar_value_2;
        tmp_compexpr_right_1 = PyTuple_New( 2 );
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_compexpr_right_1, 0, tmp_tuple_element_1 );
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_NetmaskValueError );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NetmaskValueError );
        }

        if ( tmp_mvar_value_3 == NULL )
        {
            Py_DECREF( tmp_compexpr_right_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "NetmaskValueError" );
            exception_tb = NULL;

            exception_lineno = 187;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_tuple_element_1 = tmp_mvar_value_3;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_compexpr_right_1, 1, tmp_tuple_element_1 );
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 187;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 187;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 185;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_08dacecb2456e05693d19a8e92c1c5d3->m_frame) frame_08dacecb2456e05693d19a8e92c1c5d3->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
        branch_no_1:;
    }
    goto try_end_1;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_14_ip_network );
    return NULL;
    // End of try:
    try_end_1:;
    // Tried code:
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Network );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Network );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv6Network" );
            exception_tb = NULL;

            exception_lineno = 191;
            type_description_1 = "oo";
            goto try_except_handler_3;
        }

        tmp_called_name_2 = tmp_mvar_value_4;
        CHECK_OBJECT( par_address );
        tmp_args_element_name_3 = par_address;
        CHECK_OBJECT( par_strict );
        tmp_args_element_name_4 = par_strict;
        frame_08dacecb2456e05693d19a8e92c1c5d3->m_frame.f_lineno = 191;
        {
            PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 191;
            type_description_1 = "oo";
            goto try_except_handler_3;
        }
        goto frame_return_exit_1;
    }
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_14_ip_network );
    return NULL;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_08dacecb2456e05693d19a8e92c1c5d3 );
    if ( exception_keeper_tb_2 == NULL )
    {
        exception_keeper_tb_2 = MAKE_TRACEBACK( frame_08dacecb2456e05693d19a8e92c1c5d3, exception_keeper_lineno_2 );
    }
    else if ( exception_keeper_lineno_2 != 0 )
    {
        exception_keeper_tb_2 = ADD_TRACEBACK( exception_keeper_tb_2, frame_08dacecb2456e05693d19a8e92c1c5d3, exception_keeper_lineno_2 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_2, &exception_keeper_value_2, &exception_keeper_tb_2 );
    PUBLISH_EXCEPTION( &exception_keeper_type_2, &exception_keeper_value_2, &exception_keeper_tb_2 );
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_tuple_element_2;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_mvar_value_6;
        tmp_compexpr_left_2 = EXC_TYPE(PyThreadState_GET());
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_AddressValueError );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AddressValueError );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "AddressValueError" );
            exception_tb = NULL;

            exception_lineno = 192;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_tuple_element_2 = tmp_mvar_value_5;
        tmp_compexpr_right_2 = PyTuple_New( 2 );
        Py_INCREF( tmp_tuple_element_2 );
        PyTuple_SET_ITEM( tmp_compexpr_right_2, 0, tmp_tuple_element_2 );
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_NetmaskValueError );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NetmaskValueError );
        }

        if ( tmp_mvar_value_6 == NULL )
        {
            Py_DECREF( tmp_compexpr_right_2 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "NetmaskValueError" );
            exception_tb = NULL;

            exception_lineno = 192;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_tuple_element_2 = tmp_mvar_value_6;
        Py_INCREF( tmp_tuple_element_2 );
        PyTuple_SET_ITEM( tmp_compexpr_right_2, 1, tmp_tuple_element_2 );
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        Py_DECREF( tmp_compexpr_right_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 192;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_2 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 192;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 190;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_08dacecb2456e05693d19a8e92c1c5d3->m_frame) frame_08dacecb2456e05693d19a8e92c1c5d3->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
        branch_no_2:;
    }
    goto try_end_2;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_14_ip_network );
    return NULL;
    // End of try:
    try_end_2:;
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        CHECK_OBJECT( par_address );
        tmp_isinstance_inst_1 = par_address;
        tmp_isinstance_cls_1 = (PyObject *)&PyString_Type;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 195;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_called_name_3;
            PyObject *tmp_mvar_value_7;
            PyObject *tmp_args_element_name_5;
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_AddressValueError );

            if (unlikely( tmp_mvar_value_7 == NULL ))
            {
                tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AddressValueError );
            }

            if ( tmp_mvar_value_7 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "AddressValueError" );
                exception_tb = NULL;

                exception_lineno = 196;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_3 = tmp_mvar_value_7;
            tmp_left_name_1 = const_unicode_digest_4a4ec0bacc4ed8ebd5a4ce6c53c46388;
            CHECK_OBJECT( par_address );
            tmp_right_name_1 = par_address;
            tmp_args_element_name_5 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
            if ( tmp_args_element_name_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 197;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            frame_08dacecb2456e05693d19a8e92c1c5d3->m_frame.f_lineno = 196;
            {
                PyObject *call_args[] = { tmp_args_element_name_5 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
            }

            Py_DECREF( tmp_args_element_name_5 );
            if ( tmp_raise_type_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 196;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            exception_type = tmp_raise_type_1;
            exception_lineno = 196;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_3:;
    }
    {
        PyObject *tmp_raise_type_2;
        PyObject *tmp_make_exception_arg_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_2;
        tmp_left_name_2 = const_unicode_digest_582de6307aaf0806e961bc838a12ef52;
        CHECK_OBJECT( par_address );
        tmp_right_name_2 = par_address;
        tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_2, tmp_right_name_2 );
        if ( tmp_make_exception_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 201;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_08dacecb2456e05693d19a8e92c1c5d3->m_frame.f_lineno = 201;
        {
            PyObject *call_args[] = { tmp_make_exception_arg_1 };
            tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
        }

        Py_DECREF( tmp_make_exception_arg_1 );
        assert( !(tmp_raise_type_2 == NULL) );
        exception_type = tmp_raise_type_2;
        exception_lineno = 201;
        RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

#if 1
    RESTORE_FRAME_EXCEPTION( frame_08dacecb2456e05693d19a8e92c1c5d3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_08dacecb2456e05693d19a8e92c1c5d3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_08dacecb2456e05693d19a8e92c1c5d3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_08dacecb2456e05693d19a8e92c1c5d3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_08dacecb2456e05693d19a8e92c1c5d3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_08dacecb2456e05693d19a8e92c1c5d3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_08dacecb2456e05693d19a8e92c1c5d3,
        type_description_1,
        par_address,
        par_strict
    );


    // Release cached frame.
    if ( frame_08dacecb2456e05693d19a8e92c1c5d3 == cache_frame_08dacecb2456e05693d19a8e92c1c5d3 )
    {
        Py_DECREF( frame_08dacecb2456e05693d19a8e92c1c5d3 );
    }
    cache_frame_08dacecb2456e05693d19a8e92c1c5d3 = NULL;

    assertFrameObject( frame_08dacecb2456e05693d19a8e92c1c5d3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_14_ip_network );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_strict );
    Py_DECREF( par_strict );
    par_strict = NULL;

    CHECK_OBJECT( (PyObject *)par_address );
    Py_DECREF( par_address );
    par_address = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_strict );
    Py_DECREF( par_strict );
    par_strict = NULL;

    CHECK_OBJECT( (PyObject *)par_address );
    Py_DECREF( par_address );
    par_address = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_14_ip_network );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_15_ip_interface( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_address = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_8f5d37f073b7a64c59b07aa21d264e87;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_res;
    bool tmp_result;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    static struct Nuitka_FrameObject *cache_frame_8f5d37f073b7a64c59b07aa21d264e87 = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8f5d37f073b7a64c59b07aa21d264e87, codeobj_8f5d37f073b7a64c59b07aa21d264e87, module_ipaddress, sizeof(void *) );
    frame_8f5d37f073b7a64c59b07aa21d264e87 = cache_frame_8f5d37f073b7a64c59b07aa21d264e87;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8f5d37f073b7a64c59b07aa21d264e87 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8f5d37f073b7a64c59b07aa21d264e87 ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Interface );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Interface );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv4Interface" );
            exception_tb = NULL;

            exception_lineno = 227;
            type_description_1 = "o";
            goto try_except_handler_2;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_address );
        tmp_args_element_name_1 = par_address;
        frame_8f5d37f073b7a64c59b07aa21d264e87->m_frame.f_lineno = 227;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 227;
            type_description_1 = "o";
            goto try_except_handler_2;
        }
        goto frame_return_exit_1;
    }
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_15_ip_interface );
    return NULL;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_8f5d37f073b7a64c59b07aa21d264e87 );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_8f5d37f073b7a64c59b07aa21d264e87, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_8f5d37f073b7a64c59b07aa21d264e87, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_mvar_value_3;
        tmp_compexpr_left_1 = EXC_TYPE(PyThreadState_GET());
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_AddressValueError );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AddressValueError );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "AddressValueError" );
            exception_tb = NULL;

            exception_lineno = 228;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_tuple_element_1 = tmp_mvar_value_2;
        tmp_compexpr_right_1 = PyTuple_New( 2 );
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_compexpr_right_1, 0, tmp_tuple_element_1 );
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_NetmaskValueError );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NetmaskValueError );
        }

        if ( tmp_mvar_value_3 == NULL )
        {
            Py_DECREF( tmp_compexpr_right_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "NetmaskValueError" );
            exception_tb = NULL;

            exception_lineno = 228;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_tuple_element_1 = tmp_mvar_value_3;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_compexpr_right_1, 1, tmp_tuple_element_1 );
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 228;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 228;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 226;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_8f5d37f073b7a64c59b07aa21d264e87->m_frame) frame_8f5d37f073b7a64c59b07aa21d264e87->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "o";
        goto frame_exception_exit_1;
        branch_no_1:;
    }
    goto try_end_1;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_15_ip_interface );
    return NULL;
    // End of try:
    try_end_1:;
    // Tried code:
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Interface );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Interface );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv6Interface" );
            exception_tb = NULL;

            exception_lineno = 232;
            type_description_1 = "o";
            goto try_except_handler_3;
        }

        tmp_called_name_2 = tmp_mvar_value_4;
        CHECK_OBJECT( par_address );
        tmp_args_element_name_2 = par_address;
        frame_8f5d37f073b7a64c59b07aa21d264e87->m_frame.f_lineno = 232;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 232;
            type_description_1 = "o";
            goto try_except_handler_3;
        }
        goto frame_return_exit_1;
    }
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_15_ip_interface );
    return NULL;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_8f5d37f073b7a64c59b07aa21d264e87 );
    if ( exception_keeper_tb_2 == NULL )
    {
        exception_keeper_tb_2 = MAKE_TRACEBACK( frame_8f5d37f073b7a64c59b07aa21d264e87, exception_keeper_lineno_2 );
    }
    else if ( exception_keeper_lineno_2 != 0 )
    {
        exception_keeper_tb_2 = ADD_TRACEBACK( exception_keeper_tb_2, frame_8f5d37f073b7a64c59b07aa21d264e87, exception_keeper_lineno_2 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_2, &exception_keeper_value_2, &exception_keeper_tb_2 );
    PUBLISH_EXCEPTION( &exception_keeper_type_2, &exception_keeper_value_2, &exception_keeper_tb_2 );
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_tuple_element_2;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_mvar_value_6;
        tmp_compexpr_left_2 = EXC_TYPE(PyThreadState_GET());
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_AddressValueError );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AddressValueError );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "AddressValueError" );
            exception_tb = NULL;

            exception_lineno = 233;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_tuple_element_2 = tmp_mvar_value_5;
        tmp_compexpr_right_2 = PyTuple_New( 2 );
        Py_INCREF( tmp_tuple_element_2 );
        PyTuple_SET_ITEM( tmp_compexpr_right_2, 0, tmp_tuple_element_2 );
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_NetmaskValueError );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NetmaskValueError );
        }

        if ( tmp_mvar_value_6 == NULL )
        {
            Py_DECREF( tmp_compexpr_right_2 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "NetmaskValueError" );
            exception_tb = NULL;

            exception_lineno = 233;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_tuple_element_2 = tmp_mvar_value_6;
        Py_INCREF( tmp_tuple_element_2 );
        PyTuple_SET_ITEM( tmp_compexpr_right_2, 1, tmp_tuple_element_2 );
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        Py_DECREF( tmp_compexpr_right_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 233;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_2 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 233;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 231;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_8f5d37f073b7a64c59b07aa21d264e87->m_frame) frame_8f5d37f073b7a64c59b07aa21d264e87->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "o";
        goto frame_exception_exit_1;
        branch_no_2:;
    }
    goto try_end_2;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_15_ip_interface );
    return NULL;
    // End of try:
    try_end_2:;
    {
        PyObject *tmp_raise_type_1;
        PyObject *tmp_make_exception_arg_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        tmp_left_name_1 = const_unicode_digest_dddb1f670b53dd4bfeade670d60a460f;
        CHECK_OBJECT( par_address );
        tmp_right_name_1 = par_address;
        tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
        if ( tmp_make_exception_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 236;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_8f5d37f073b7a64c59b07aa21d264e87->m_frame.f_lineno = 236;
        {
            PyObject *call_args[] = { tmp_make_exception_arg_1 };
            tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
        }

        Py_DECREF( tmp_make_exception_arg_1 );
        assert( !(tmp_raise_type_1 == NULL) );
        exception_type = tmp_raise_type_1;
        exception_lineno = 236;
        RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

#if 1
    RESTORE_FRAME_EXCEPTION( frame_8f5d37f073b7a64c59b07aa21d264e87 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_8f5d37f073b7a64c59b07aa21d264e87 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_8f5d37f073b7a64c59b07aa21d264e87 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8f5d37f073b7a64c59b07aa21d264e87, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8f5d37f073b7a64c59b07aa21d264e87->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8f5d37f073b7a64c59b07aa21d264e87, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8f5d37f073b7a64c59b07aa21d264e87,
        type_description_1,
        par_address
    );


    // Release cached frame.
    if ( frame_8f5d37f073b7a64c59b07aa21d264e87 == cache_frame_8f5d37f073b7a64c59b07aa21d264e87 )
    {
        Py_DECREF( frame_8f5d37f073b7a64c59b07aa21d264e87 );
    }
    cache_frame_8f5d37f073b7a64c59b07aa21d264e87 = NULL;

    assertFrameObject( frame_8f5d37f073b7a64c59b07aa21d264e87 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_15_ip_interface );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_address );
    Py_DECREF( par_address );
    par_address = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_address );
    Py_DECREF( par_address );
    par_address = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_15_ip_interface );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_16_v4_int_to_packed( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_address = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_238d4641bef942b70ad192a34b24ce43;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_238d4641bef942b70ad192a34b24ce43 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_238d4641bef942b70ad192a34b24ce43, codeobj_238d4641bef942b70ad192a34b24ce43, module_ipaddress, sizeof(void *) );
    frame_238d4641bef942b70ad192a34b24ce43 = cache_frame_238d4641bef942b70ad192a34b24ce43;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_238d4641bef942b70ad192a34b24ce43 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_238d4641bef942b70ad192a34b24ce43 ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_to_bytes );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__compat_to_bytes );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_compat_to_bytes" );
            exception_tb = NULL;

            exception_lineno = 255;
            type_description_1 = "o";
            goto try_except_handler_2;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_address );
        tmp_args_element_name_1 = par_address;
        tmp_args_element_name_2 = const_int_pos_4;
        tmp_args_element_name_3 = const_unicode_plain_big;
        frame_238d4641bef942b70ad192a34b24ce43->m_frame.f_lineno = 255;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 255;
            type_description_1 = "o";
            goto try_except_handler_2;
        }
        goto frame_return_exit_1;
    }
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_16_v4_int_to_packed );
    return NULL;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_238d4641bef942b70ad192a34b24ce43 );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_238d4641bef942b70ad192a34b24ce43, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_238d4641bef942b70ad192a34b24ce43, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        tmp_compexpr_left_1 = EXC_TYPE(PyThreadState_GET());
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_struct );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_struct );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "struct" );
            exception_tb = NULL;

            exception_lineno = 256;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_error );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 256;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = PyTuple_New( 2 );
        PyTuple_SET_ITEM( tmp_compexpr_right_1, 0, tmp_tuple_element_1 );
        tmp_tuple_element_1 = PyExc_OverflowError;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_compexpr_right_1, 1, tmp_tuple_element_1 );
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 256;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_unicode_digest_780f01a2ac4ecdb58e54af04ef9a0303;
            frame_238d4641bef942b70ad192a34b24ce43->m_frame.f_lineno = 257;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 257;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 254;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_238d4641bef942b70ad192a34b24ce43->m_frame) frame_238d4641bef942b70ad192a34b24ce43->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "o";
        goto frame_exception_exit_1;
        branch_end_1:;
    }
    // End of try:

#if 1
    RESTORE_FRAME_EXCEPTION( frame_238d4641bef942b70ad192a34b24ce43 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_238d4641bef942b70ad192a34b24ce43 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_238d4641bef942b70ad192a34b24ce43 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_238d4641bef942b70ad192a34b24ce43, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_238d4641bef942b70ad192a34b24ce43->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_238d4641bef942b70ad192a34b24ce43, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_238d4641bef942b70ad192a34b24ce43,
        type_description_1,
        par_address
    );


    // Release cached frame.
    if ( frame_238d4641bef942b70ad192a34b24ce43 == cache_frame_238d4641bef942b70ad192a34b24ce43 )
    {
        Py_DECREF( frame_238d4641bef942b70ad192a34b24ce43 );
    }
    cache_frame_238d4641bef942b70ad192a34b24ce43 = NULL;

    assertFrameObject( frame_238d4641bef942b70ad192a34b24ce43 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_16_v4_int_to_packed );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_address );
    Py_DECREF( par_address );
    par_address = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_address );
    Py_DECREF( par_address );
    par_address = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_16_v4_int_to_packed );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_17_v6_int_to_packed( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_address = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_124b766cd28bbd519eab91237988348d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_124b766cd28bbd519eab91237988348d = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_124b766cd28bbd519eab91237988348d, codeobj_124b766cd28bbd519eab91237988348d, module_ipaddress, sizeof(void *) );
    frame_124b766cd28bbd519eab91237988348d = cache_frame_124b766cd28bbd519eab91237988348d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_124b766cd28bbd519eab91237988348d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_124b766cd28bbd519eab91237988348d ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_to_bytes );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__compat_to_bytes );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_compat_to_bytes" );
            exception_tb = NULL;

            exception_lineno = 271;
            type_description_1 = "o";
            goto try_except_handler_2;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_address );
        tmp_args_element_name_1 = par_address;
        tmp_args_element_name_2 = const_int_pos_16;
        tmp_args_element_name_3 = const_unicode_plain_big;
        frame_124b766cd28bbd519eab91237988348d->m_frame.f_lineno = 271;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 271;
            type_description_1 = "o";
            goto try_except_handler_2;
        }
        goto frame_return_exit_1;
    }
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_17_v6_int_to_packed );
    return NULL;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_124b766cd28bbd519eab91237988348d );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_124b766cd28bbd519eab91237988348d, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_124b766cd28bbd519eab91237988348d, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        tmp_compexpr_left_1 = EXC_TYPE(PyThreadState_GET());
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_struct );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_struct );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "struct" );
            exception_tb = NULL;

            exception_lineno = 272;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_error );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 272;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = PyTuple_New( 2 );
        PyTuple_SET_ITEM( tmp_compexpr_right_1, 0, tmp_tuple_element_1 );
        tmp_tuple_element_1 = PyExc_OverflowError;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_compexpr_right_1, 1, tmp_tuple_element_1 );
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 272;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_unicode_digest_748251f41c9803a0c044ac91f17a32ea;
            frame_124b766cd28bbd519eab91237988348d->m_frame.f_lineno = 273;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 273;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 270;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_124b766cd28bbd519eab91237988348d->m_frame) frame_124b766cd28bbd519eab91237988348d->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "o";
        goto frame_exception_exit_1;
        branch_end_1:;
    }
    // End of try:

#if 1
    RESTORE_FRAME_EXCEPTION( frame_124b766cd28bbd519eab91237988348d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_124b766cd28bbd519eab91237988348d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_124b766cd28bbd519eab91237988348d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_124b766cd28bbd519eab91237988348d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_124b766cd28bbd519eab91237988348d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_124b766cd28bbd519eab91237988348d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_124b766cd28bbd519eab91237988348d,
        type_description_1,
        par_address
    );


    // Release cached frame.
    if ( frame_124b766cd28bbd519eab91237988348d == cache_frame_124b766cd28bbd519eab91237988348d )
    {
        Py_DECREF( frame_124b766cd28bbd519eab91237988348d );
    }
    cache_frame_124b766cd28bbd519eab91237988348d = NULL;

    assertFrameObject( frame_124b766cd28bbd519eab91237988348d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_17_v6_int_to_packed );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_address );
    Py_DECREF( par_address );
    par_address = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_address );
    Py_DECREF( par_address );
    par_address = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_17_v6_int_to_packed );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_18__split_optional_netmask( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_address = python_pars[ 0 ];
    PyObject *var_addr = NULL;
    struct Nuitka_FrameObject *frame_e4457ed056c53cf95f24b187fd8e10b8;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_e4457ed056c53cf95f24b187fd8e10b8 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e4457ed056c53cf95f24b187fd8e10b8, codeobj_e4457ed056c53cf95f24b187fd8e10b8, module_ipaddress, sizeof(void *)+sizeof(void *) );
    frame_e4457ed056c53cf95f24b187fd8e10b8 = cache_frame_e4457ed056c53cf95f24b187fd8e10b8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e4457ed056c53cf95f24b187fd8e10b8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e4457ed056c53cf95f24b187fd8e10b8 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_str );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__compat_str );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_compat_str" );
            exception_tb = NULL;

            exception_lineno = 278;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_address );
        tmp_args_element_name_1 = par_address;
        frame_e4457ed056c53cf95f24b187fd8e10b8->m_frame.f_lineno = 278;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_called_instance_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 278;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_e4457ed056c53cf95f24b187fd8e10b8->m_frame.f_lineno = 278;
        tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_split, &PyTuple_GET_ITEM( const_tuple_unicode_chr_47_tuple, 0 ) );

        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 278;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert( var_addr == NULL );
        var_addr = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_len_arg_1;
        CHECK_OBJECT( var_addr );
        tmp_len_arg_1 = var_addr;
        tmp_compexpr_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 279;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = const_int_pos_2;
        tmp_res = RICH_COMPARE_BOOL_GT_OBJECT_INT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        assert( !(tmp_res == -1) );
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_called_name_2;
            PyObject *tmp_mvar_value_2;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_AddressValueError );

            if (unlikely( tmp_mvar_value_2 == NULL ))
            {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AddressValueError );
            }

            if ( tmp_mvar_value_2 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "AddressValueError" );
                exception_tb = NULL;

                exception_lineno = 280;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_2 = tmp_mvar_value_2;
            tmp_left_name_1 = const_unicode_digest_3254e3c725f90e44e7995b9143540a57;
            CHECK_OBJECT( par_address );
            tmp_right_name_1 = par_address;
            tmp_args_element_name_2 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
            if ( tmp_args_element_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 280;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            frame_e4457ed056c53cf95f24b187fd8e10b8->m_frame.f_lineno = 280;
            {
                PyObject *call_args[] = { tmp_args_element_name_2 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
            }

            Py_DECREF( tmp_args_element_name_2 );
            if ( tmp_raise_type_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 280;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            exception_type = tmp_raise_type_1;
            exception_lineno = 280;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e4457ed056c53cf95f24b187fd8e10b8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e4457ed056c53cf95f24b187fd8e10b8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e4457ed056c53cf95f24b187fd8e10b8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e4457ed056c53cf95f24b187fd8e10b8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e4457ed056c53cf95f24b187fd8e10b8, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e4457ed056c53cf95f24b187fd8e10b8,
        type_description_1,
        par_address,
        var_addr
    );


    // Release cached frame.
    if ( frame_e4457ed056c53cf95f24b187fd8e10b8 == cache_frame_e4457ed056c53cf95f24b187fd8e10b8 )
    {
        Py_DECREF( frame_e4457ed056c53cf95f24b187fd8e10b8 );
    }
    cache_frame_e4457ed056c53cf95f24b187fd8e10b8 = NULL;

    assertFrameObject( frame_e4457ed056c53cf95f24b187fd8e10b8 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_addr );
    tmp_return_value = var_addr;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_18__split_optional_netmask );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_addr );
    Py_DECREF( var_addr );
    var_addr = NULL;

    CHECK_OBJECT( (PyObject *)par_address );
    Py_DECREF( par_address );
    par_address = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_addr );
    var_addr = NULL;

    CHECK_OBJECT( (PyObject *)par_address );
    Py_DECREF( par_address );
    par_address = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_18__split_optional_netmask );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_19__find_address_range( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_addresses = PyCell_NEW1( python_pars[ 0 ] );
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    // Tried code:
    tmp_return_value = ipaddress$$$function_19__find_address_range$$$genobj_1__find_address_range_maker();

    ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[0] = par_addresses;
    Py_INCREF( ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[0] );


    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_19__find_address_range );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_addresses );
    Py_DECREF( par_addresses );
    par_addresses = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_addresses );
    Py_DECREF( par_addresses );
    par_addresses = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_19__find_address_range );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}



struct ipaddress$$$function_19__find_address_range$$$genobj_1__find_address_range_locals {
    PyObject *var_ip;
    PyObject *var_first;
    PyObject *var_last;
    PyObject *var_it;
    PyObject *tmp_assign_unpack_1__assign_source;
    PyObject *tmp_for_loop_1__for_iterator;
    PyObject *tmp_for_loop_1__iter_value;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    int tmp_res;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
};

static PyObject *ipaddress$$$function_19__find_address_range$$$genobj_1__find_address_range_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Heap access if used.
    struct ipaddress$$$function_19__find_address_range$$$genobj_1__find_address_range_locals *generator_heap = (struct ipaddress$$$function_19__find_address_range$$$genobj_1__find_address_range_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 2: goto yield_return_2;
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_ip = NULL;
    generator_heap->var_first = NULL;
    generator_heap->var_last = NULL;
    generator_heap->var_it = NULL;
    generator_heap->tmp_assign_unpack_1__assign_source = NULL;
    generator_heap->tmp_for_loop_1__for_iterator = NULL;
    generator_heap->tmp_for_loop_1__iter_value = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_m_frame, codeobj_af2a5c10f47089b7ca07ac0f61f0ee94, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

#if PYTHON_VERSION < 370
        generator->m_frame->m_frame.f_exc_type = EXC_TYPE( thread_state );
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
        Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#else
        generator->m_exc_state.exc_type = EXC_TYPE( thread_state );
        if ( generator->m_exc_state.exc_type == Py_None ) generator->m_exc_state.exc_type = NULL;
        Py_XINCREF( generator->m_exc_state.exc_type );
        generator->m_exc_state.exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_value );
        generator->m_exc_state.exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_traceback );
#endif
    }

#endif

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_iter_arg_1;
        if ( PyCell_GET( generator->m_closure[0] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "addresses" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 294;
            generator_heap->type_description_1 = "coooo";
            goto frame_exception_exit_1;
        }

        tmp_iter_arg_1 = PyCell_GET( generator->m_closure[0] );
        tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 294;
            generator_heap->type_description_1 = "coooo";
            goto frame_exception_exit_1;
        }
        assert( generator_heap->var_it == NULL );
        generator_heap->var_it = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_value_name_1;
        CHECK_OBJECT( generator_heap->var_it );
        tmp_value_name_1 = generator_heap->var_it;
        tmp_assign_source_2 = ITERATOR_NEXT( tmp_value_name_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            if ( !ERROR_OCCURRED() )
            {
                generator_heap->exception_type = PyExc_StopIteration;
                Py_INCREF( generator_heap->exception_type );
                generator_heap->exception_value = NULL;
                generator_heap->exception_tb = NULL;
            }
            else
            {
                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
            }


            generator_heap->type_description_1 = "coooo";
            generator_heap->exception_lineno = 295;
            goto frame_exception_exit_1;
        }
        assert( generator_heap->tmp_assign_unpack_1__assign_source == NULL );
        generator_heap->tmp_assign_unpack_1__assign_source = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        CHECK_OBJECT( generator_heap->tmp_assign_unpack_1__assign_source );
        tmp_assign_source_3 = generator_heap->tmp_assign_unpack_1__assign_source;
        assert( generator_heap->var_first == NULL );
        Py_INCREF( tmp_assign_source_3 );
        generator_heap->var_first = tmp_assign_source_3;
    }
    {
        PyObject *tmp_assign_source_4;
        CHECK_OBJECT( generator_heap->tmp_assign_unpack_1__assign_source );
        tmp_assign_source_4 = generator_heap->tmp_assign_unpack_1__assign_source;
        assert( generator_heap->var_last == NULL );
        Py_INCREF( tmp_assign_source_4 );
        generator_heap->var_last = tmp_assign_source_4;
    }
    CHECK_OBJECT( (PyObject *)generator_heap->tmp_assign_unpack_1__assign_source );
    Py_DECREF( generator_heap->tmp_assign_unpack_1__assign_source );
    generator_heap->tmp_assign_unpack_1__assign_source = NULL;

    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_iter_arg_2;
        CHECK_OBJECT( generator_heap->var_it );
        tmp_iter_arg_2 = generator_heap->var_it;
        tmp_assign_source_5 = MAKE_ITERATOR( tmp_iter_arg_2 );
        if ( tmp_assign_source_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 296;
            generator_heap->type_description_1 = "coooo";
            goto frame_exception_exit_1;
        }
        assert( generator_heap->tmp_for_loop_1__for_iterator == NULL );
        generator_heap->tmp_for_loop_1__for_iterator = tmp_assign_source_5;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_6;
        CHECK_OBJECT( generator_heap->tmp_for_loop_1__for_iterator );
        tmp_next_source_1 = generator_heap->tmp_for_loop_1__for_iterator;
        tmp_assign_source_6 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_6 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
                generator_heap->type_description_1 = "coooo";
                generator_heap->exception_lineno = 296;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_for_loop_1__iter_value;
            generator_heap->tmp_for_loop_1__iter_value = tmp_assign_source_6;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_7;
        CHECK_OBJECT( generator_heap->tmp_for_loop_1__iter_value );
        tmp_assign_source_7 = generator_heap->tmp_for_loop_1__iter_value;
        {
            PyObject *old = generator_heap->var_ip;
            generator_heap->var_ip = tmp_assign_source_7;
            Py_INCREF( generator_heap->var_ip );
            Py_XDECREF( old );
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_right_name_1;
        CHECK_OBJECT( generator_heap->var_ip );
        tmp_source_name_1 = generator_heap->var_ip;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__ip );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 297;
            generator_heap->type_description_1 = "coooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( generator_heap->var_last );
        tmp_source_name_2 = generator_heap->var_last;
        tmp_left_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ip );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
            Py_DECREF( tmp_compexpr_left_1 );

            generator_heap->exception_lineno = 297;
            generator_heap->type_description_1 = "coooo";
            goto try_except_handler_2;
        }
        tmp_right_name_1 = const_int_pos_1;
        tmp_compexpr_right_1 = BINARY_OPERATION_ADD_OBJECT_INT( tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_left_name_1 );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
            Py_DECREF( tmp_compexpr_left_1 );

            generator_heap->exception_lineno = 297;
            generator_heap->type_description_1 = "coooo";
            goto try_except_handler_2;
        }
        generator_heap->tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( generator_heap->tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 297;
            generator_heap->type_description_1 = "coooo";
            goto try_except_handler_2;
        }
        tmp_condition_result_1 = ( generator_heap->tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_expression_name_1;
            PyObject *tmp_tuple_element_1;
            NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
            if ( generator_heap->var_first == NULL )
            {

                generator_heap->exception_type = PyExc_UnboundLocalError;
                Py_INCREF( generator_heap->exception_type );
                generator_heap->exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "first" );
                generator_heap->exception_tb = NULL;

                generator_heap->exception_lineno = 298;
                generator_heap->type_description_1 = "coooo";
                goto try_except_handler_2;
            }

            tmp_tuple_element_1 = generator_heap->var_first;
            tmp_expression_name_1 = PyTuple_New( 2 );
            Py_INCREF( tmp_tuple_element_1 );
            PyTuple_SET_ITEM( tmp_expression_name_1, 0, tmp_tuple_element_1 );
            CHECK_OBJECT( generator_heap->var_last );
            tmp_tuple_element_1 = generator_heap->var_last;
            Py_INCREF( tmp_tuple_element_1 );
            PyTuple_SET_ITEM( tmp_expression_name_1, 1, tmp_tuple_element_1 );
            Nuitka_PreserveHeap( generator_heap->yield_tmps, &tmp_condition_result_1, sizeof(nuitka_bool), &tmp_compexpr_left_1, sizeof(PyObject *), &tmp_compexpr_right_1, sizeof(PyObject *), &tmp_source_name_1, sizeof(PyObject *), &tmp_left_name_1, sizeof(PyObject *), &tmp_source_name_2, sizeof(PyObject *), &tmp_right_name_1, sizeof(PyObject *), &tmp_tuple_element_1, sizeof(PyObject *), NULL );
            generator->m_yield_return_index = 1;
            return tmp_expression_name_1;
            yield_return_1:
            Nuitka_RestoreHeap( generator_heap->yield_tmps, &tmp_condition_result_1, sizeof(nuitka_bool), &tmp_compexpr_left_1, sizeof(PyObject *), &tmp_compexpr_right_1, sizeof(PyObject *), &tmp_source_name_1, sizeof(PyObject *), &tmp_left_name_1, sizeof(PyObject *), &tmp_source_name_2, sizeof(PyObject *), &tmp_right_name_1, sizeof(PyObject *), &tmp_tuple_element_1, sizeof(PyObject *), NULL );
            if ( yield_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


                generator_heap->exception_lineno = 298;
                generator_heap->type_description_1 = "coooo";
                goto try_except_handler_2;
            }
            tmp_yield_result_1 = yield_return_value;
        }
        {
            PyObject *tmp_assign_source_8;
            CHECK_OBJECT( generator_heap->var_ip );
            tmp_assign_source_8 = generator_heap->var_ip;
            {
                PyObject *old = generator_heap->var_first;
                generator_heap->var_first = tmp_assign_source_8;
                Py_INCREF( generator_heap->var_first );
                Py_XDECREF( old );
            }

        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_9;
        CHECK_OBJECT( generator_heap->var_ip );
        tmp_assign_source_9 = generator_heap->var_ip;
        {
            PyObject *old = generator_heap->var_last;
            assert( old != NULL );
            generator_heap->var_last = tmp_assign_source_9;
            Py_INCREF( generator_heap->var_last );
            Py_DECREF( old );
        }

    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


        generator_heap->exception_lineno = 296;
        generator_heap->type_description_1 = "coooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->tmp_for_loop_1__iter_value );
    generator_heap->tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)generator_heap->tmp_for_loop_1__for_iterator );
    Py_DECREF( generator_heap->tmp_for_loop_1__for_iterator );
    generator_heap->tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    Py_XDECREF( generator_heap->tmp_for_loop_1__iter_value );
    generator_heap->tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)generator_heap->tmp_for_loop_1__for_iterator );
    Py_DECREF( generator_heap->tmp_for_loop_1__for_iterator );
    generator_heap->tmp_for_loop_1__for_iterator = NULL;

    {
        PyObject *tmp_expression_name_2;
        PyObject *tmp_tuple_element_2;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_2;
        if ( generator_heap->var_first == NULL )
        {

            generator_heap->exception_type = PyExc_UnboundLocalError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "first" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 301;
            generator_heap->type_description_1 = "coooo";
            goto frame_exception_exit_1;
        }

        tmp_tuple_element_2 = generator_heap->var_first;
        tmp_expression_name_2 = PyTuple_New( 2 );
        Py_INCREF( tmp_tuple_element_2 );
        PyTuple_SET_ITEM( tmp_expression_name_2, 0, tmp_tuple_element_2 );
        CHECK_OBJECT( generator_heap->var_last );
        tmp_tuple_element_2 = generator_heap->var_last;
        Py_INCREF( tmp_tuple_element_2 );
        PyTuple_SET_ITEM( tmp_expression_name_2, 1, tmp_tuple_element_2 );
        Nuitka_PreserveHeap( generator_heap->yield_tmps, &tmp_tuple_element_2, sizeof(PyObject *), NULL );
        generator->m_yield_return_index = 2;
        return tmp_expression_name_2;
        yield_return_2:
        Nuitka_RestoreHeap( generator_heap->yield_tmps, &tmp_tuple_element_2, sizeof(PyObject *), NULL );
        if ( yield_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 301;
            generator_heap->type_description_1 = "coooo";
            goto frame_exception_exit_1;
        }
        tmp_yield_result_2 = yield_return_value;
    }

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( generator_heap->exception_type ) )
    {
        if ( generator_heap->exception_tb == NULL )
        {
            generator_heap->exception_tb = MAKE_TRACEBACK( generator->m_frame, generator_heap->exception_lineno );
        }
        else if ( generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            generator_heap->exception_tb = ADD_TRACEBACK( generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            generator->m_closure[0],
            generator_heap->var_ip,
            generator_heap->var_first,
            generator_heap->var_last,
            generator_heap->var_it
        );


        // Release cached frame.
        if ( generator->m_frame == cache_m_frame )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_m_frame = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->var_ip );
    generator_heap->var_ip = NULL;

    Py_XDECREF( generator_heap->var_first );
    generator_heap->var_first = NULL;

    Py_XDECREF( generator_heap->var_last );
    generator_heap->var_last = NULL;

    Py_XDECREF( generator_heap->var_it );
    generator_heap->var_it = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:
    try_end_2:;
    Py_XDECREF( generator_heap->var_ip );
    generator_heap->var_ip = NULL;

    Py_XDECREF( generator_heap->var_first );
    generator_heap->var_first = NULL;

    CHECK_OBJECT( (PyObject *)generator_heap->var_last );
    Py_DECREF( generator_heap->var_last );
    generator_heap->var_last = NULL;

    CHECK_OBJECT( (PyObject *)generator_heap->var_it );
    Py_DECREF( generator_heap->var_it );
    generator_heap->var_it = NULL;



    return NULL;

    function_exception_exit:
    assert( generator_heap->exception_type );
    RESTORE_ERROR_OCCURRED( generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb );

    return NULL;

}

static PyObject *ipaddress$$$function_19__find_address_range$$$genobj_1__find_address_range_maker( void )
{
    return Nuitka_Generator_New(
        ipaddress$$$function_19__find_address_range$$$genobj_1__find_address_range_context,
        module_ipaddress,
        const_str_plain__find_address_range,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_af2a5c10f47089b7ca07ac0f61f0ee94,
        1,
        sizeof(struct ipaddress$$$function_19__find_address_range$$$genobj_1__find_address_range_locals)
    );
}


static PyObject *impl_ipaddress$$$function_20__count_righthand_zero_bits( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_number = python_pars[ 0 ];
    PyObject *par_bits = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_1d375206df9e3c3637ab9124f31b1a59;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    int tmp_res;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_1d375206df9e3c3637ab9124f31b1a59 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1d375206df9e3c3637ab9124f31b1a59, codeobj_1d375206df9e3c3637ab9124f31b1a59, module_ipaddress, sizeof(void *)+sizeof(void *) );
    frame_1d375206df9e3c3637ab9124f31b1a59 = cache_frame_1d375206df9e3c3637ab9124f31b1a59;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1d375206df9e3c3637ab9124f31b1a59 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1d375206df9e3c3637ab9124f31b1a59 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( par_number );
        tmp_compexpr_left_1 = par_number;
        tmp_compexpr_right_1 = const_int_0;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_INT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 315;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        CHECK_OBJECT( par_bits );
        tmp_return_value = par_bits;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_left_name_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_2;
        tmp_called_name_1 = LOOKUP_BUILTIN( const_str_plain_min );
        assert( tmp_called_name_1 != NULL );
        CHECK_OBJECT( par_bits );
        tmp_args_element_name_1 = par_bits;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_bit_length );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__compat_bit_length );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_compat_bit_length" );
            exception_tb = NULL;

            exception_lineno = 317;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_1;
        CHECK_OBJECT( par_number );
        tmp_operand_name_1 = par_number;
        tmp_left_name_1 = UNARY_OPERATION( PyNumber_Invert, tmp_operand_name_1 );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 317;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_number );
        tmp_left_name_2 = par_number;
        tmp_right_name_2 = const_int_pos_1;
        tmp_right_name_1 = BINARY_OPERATION_SUB( tmp_left_name_2, tmp_right_name_2 );
        if ( tmp_right_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_left_name_1 );

            exception_lineno = 317;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = BINARY_OPERATION( PyNumber_And, tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_left_name_1 );
        Py_DECREF( tmp_right_name_1 );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 317;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_1d375206df9e3c3637ab9124f31b1a59->m_frame.f_lineno = 317;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_args_element_name_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 317;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_1d375206df9e3c3637ab9124f31b1a59->m_frame.f_lineno = 317;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 317;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1d375206df9e3c3637ab9124f31b1a59 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_1d375206df9e3c3637ab9124f31b1a59 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1d375206df9e3c3637ab9124f31b1a59 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1d375206df9e3c3637ab9124f31b1a59, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1d375206df9e3c3637ab9124f31b1a59->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1d375206df9e3c3637ab9124f31b1a59, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1d375206df9e3c3637ab9124f31b1a59,
        type_description_1,
        par_number,
        par_bits
    );


    // Release cached frame.
    if ( frame_1d375206df9e3c3637ab9124f31b1a59 == cache_frame_1d375206df9e3c3637ab9124f31b1a59 )
    {
        Py_DECREF( frame_1d375206df9e3c3637ab9124f31b1a59 );
    }
    cache_frame_1d375206df9e3c3637ab9124f31b1a59 = NULL;

    assertFrameObject( frame_1d375206df9e3c3637ab9124f31b1a59 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_20__count_righthand_zero_bits );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_bits );
    Py_DECREF( par_bits );
    par_bits = NULL;

    CHECK_OBJECT( (PyObject *)par_number );
    Py_DECREF( par_number );
    par_number = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_bits );
    Py_DECREF( par_bits );
    par_bits = NULL;

    CHECK_OBJECT( (PyObject *)par_number );
    Py_DECREF( par_number );
    par_number = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_20__count_righthand_zero_bits );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_21_summarize_address_range( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_first = PyCell_NEW1( python_pars[ 0 ] );
    struct Nuitka_CellObject *par_last = PyCell_NEW1( python_pars[ 1 ] );
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    // Tried code:
    tmp_return_value = ipaddress$$$function_21_summarize_address_range$$$genobj_1_summarize_address_range_maker();

    ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[0] = par_first;
    Py_INCREF( ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[0] );
    ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[1] = par_last;
    Py_INCREF( ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[1] );


    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_21_summarize_address_range );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_last );
    Py_DECREF( par_last );
    par_last = NULL;

    CHECK_OBJECT( (PyObject *)par_first );
    Py_DECREF( par_first );
    par_first = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_last );
    Py_DECREF( par_last );
    par_last = NULL;

    CHECK_OBJECT( (PyObject *)par_first );
    Py_DECREF( par_first );
    par_first = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_21_summarize_address_range );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}



struct ipaddress$$$function_21_summarize_address_range$$$genobj_1_summarize_address_range_locals {
    PyObject *var_nbits;
    PyObject *var_ip;
    PyObject *var_last_int;
    PyObject *var_ip_bits;
    PyObject *var_net;
    PyObject *var_first_int;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    int tmp_res;
    bool tmp_result;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
};

static PyObject *ipaddress$$$function_21_summarize_address_range$$$genobj_1_summarize_address_range_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Heap access if used.
    struct ipaddress$$$function_21_summarize_address_range$$$genobj_1_summarize_address_range_locals *generator_heap = (struct ipaddress$$$function_21_summarize_address_range$$$genobj_1_summarize_address_range_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_nbits = NULL;
    generator_heap->var_ip = NULL;
    generator_heap->var_last_int = NULL;
    generator_heap->var_ip_bits = NULL;
    generator_heap->var_net = NULL;
    generator_heap->var_first_int = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_m_frame, codeobj_b1fe0f75950a86c7a08048741a3f59da, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

#if PYTHON_VERSION < 370
        generator->m_frame->m_frame.f_exc_type = EXC_TYPE( thread_state );
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
        Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#else
        generator->m_exc_state.exc_type = EXC_TYPE( thread_state );
        if ( generator->m_exc_state.exc_type == Py_None ) generator->m_exc_state.exc_type = NULL;
        Py_XINCREF( generator->m_exc_state.exc_type );
        generator->m_exc_state.exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_value );
        generator->m_exc_state.exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_traceback );
#endif
    }

#endif

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        int tmp_and_left_truth_1;
        PyObject *tmp_and_left_value_1;
        PyObject *tmp_and_right_value_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_isinstance_inst_2;
        PyObject *tmp_isinstance_cls_2;
        PyObject *tmp_mvar_value_2;
        if ( PyCell_GET( generator->m_closure[0] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "first" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 346;
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_inst_1 = PyCell_GET( generator->m_closure[0] );
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__BaseAddress );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__BaseAddress );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "global name '%s' is not defined", "_BaseAddress" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 346;
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        generator_heap->tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( generator_heap->tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 346;
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_1 = ( generator_heap->tmp_res != 0 ) ? Py_True : Py_False;
        tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
        if ( tmp_and_left_truth_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 347;
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }
        if ( tmp_and_left_truth_1 == 1 )
        {
            goto and_right_1;
        }
        else
        {
            goto and_left_1;
        }
        and_right_1:;
        if ( PyCell_GET( generator->m_closure[1] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "last" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 347;
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_inst_2 = PyCell_GET( generator->m_closure[1] );
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__BaseAddress );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__BaseAddress );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "global name '%s' is not defined", "_BaseAddress" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 347;
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_2 = tmp_mvar_value_2;
        generator_heap->tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
        if ( generator_heap->tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 347;
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_1 = ( generator_heap->tmp_res != 0 ) ? Py_True : Py_False;
        tmp_operand_name_1 = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_operand_name_1 = tmp_and_left_value_1;
        and_end_1:;
        generator_heap->tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( generator_heap->tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 346;
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( generator_heap->tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_unicode_digest_c4c97910d07aba163465ecf409f4030a;
            generator->m_frame->m_frame.f_lineno = 348;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            generator_heap->exception_type = tmp_raise_type_1;
            generator_heap->exception_lineno = 348;
            RAISE_EXCEPTION_WITH_TYPE( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        if ( PyCell_GET( generator->m_closure[0] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "first" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 349;
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = PyCell_GET( generator->m_closure[0] );
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_version );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 349;
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }
        if ( PyCell_GET( generator->m_closure[1] ) == NULL )
        {
            Py_DECREF( tmp_compexpr_left_1 );
            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "last" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 349;
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = PyCell_GET( generator->m_closure[1] );
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_version );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
            Py_DECREF( tmp_compexpr_left_1 );

            generator_heap->exception_lineno = 349;
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }
        generator_heap->tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( generator_heap->tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 349;
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( generator_heap->tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_make_exception_arg_2;
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            PyObject *tmp_tuple_element_1;
            tmp_left_name_1 = const_unicode_digest_e922c2e07060bd895f3f403962951e84;
            if ( PyCell_GET( generator->m_closure[0] ) == NULL )
            {

                generator_heap->exception_type = PyExc_NameError;
                Py_INCREF( generator_heap->exception_type );
                generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "first" );
                generator_heap->exception_tb = NULL;

                generator_heap->exception_lineno = 351;
                generator_heap->type_description_1 = "ccoooooo";
                goto frame_exception_exit_1;
            }

            tmp_tuple_element_1 = PyCell_GET( generator->m_closure[0] );
            tmp_right_name_1 = PyTuple_New( 2 );
            Py_INCREF( tmp_tuple_element_1 );
            PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
            if ( PyCell_GET( generator->m_closure[1] ) == NULL )
            {
                Py_DECREF( tmp_right_name_1 );
                generator_heap->exception_type = PyExc_NameError;
                Py_INCREF( generator_heap->exception_type );
                generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "last" );
                generator_heap->exception_tb = NULL;

                generator_heap->exception_lineno = 351;
                generator_heap->type_description_1 = "ccoooooo";
                goto frame_exception_exit_1;
            }

            tmp_tuple_element_1 = PyCell_GET( generator->m_closure[1] );
            Py_INCREF( tmp_tuple_element_1 );
            PyTuple_SET_ITEM( tmp_right_name_1, 1, tmp_tuple_element_1 );
            tmp_make_exception_arg_2 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
            Py_DECREF( tmp_right_name_1 );
            if ( tmp_make_exception_arg_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


                generator_heap->exception_lineno = 350;
                generator_heap->type_description_1 = "ccoooooo";
                goto frame_exception_exit_1;
            }
            generator->m_frame->m_frame.f_lineno = 350;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_2 };
                tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            Py_DECREF( tmp_make_exception_arg_2 );
            assert( !(tmp_raise_type_2 == NULL) );
            generator_heap->exception_type = tmp_raise_type_2;
            generator_heap->exception_lineno = 350;
            RAISE_EXCEPTION_WITH_TYPE( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        if ( PyCell_GET( generator->m_closure[0] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "first" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 352;
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_left_2 = PyCell_GET( generator->m_closure[0] );
        if ( PyCell_GET( generator->m_closure[1] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "last" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 352;
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_2 = PyCell_GET( generator->m_closure[1] );
        generator_heap->tmp_res = RICH_COMPARE_BOOL_GT_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        if ( generator_heap->tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 352;
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = ( generator_heap->tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_raise_type_3;
            PyObject *tmp_make_exception_arg_3;
            tmp_make_exception_arg_3 = const_unicode_digest_8b0c900fbdeea9771930f9c584b257a2;
            generator->m_frame->m_frame.f_lineno = 353;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_3 };
                tmp_raise_type_3 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_3 == NULL) );
            generator_heap->exception_type = tmp_raise_type_3;
            generator_heap->exception_lineno = 353;
            RAISE_EXCEPTION_WITH_TYPE( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }
        branch_no_3:;
    }
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_source_name_3;
        if ( PyCell_GET( generator->m_closure[0] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "first" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 355;
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = PyCell_GET( generator->m_closure[0] );
        tmp_compexpr_left_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_version );
        if ( tmp_compexpr_left_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 355;
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_3 = const_int_pos_4;
        generator_heap->tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_INT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
        Py_DECREF( tmp_compexpr_left_3 );
        if ( generator_heap->tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 355;
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_4 = ( generator_heap->tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_4;
        }
        else
        {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_mvar_value_3;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Network );

            if (unlikely( tmp_mvar_value_3 == NULL ))
            {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Network );
            }

            if ( tmp_mvar_value_3 == NULL )
            {

                generator_heap->exception_type = PyExc_NameError;
                Py_INCREF( generator_heap->exception_type );
                generator_heap->exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv4Network" );
                generator_heap->exception_tb = NULL;

                generator_heap->exception_lineno = 356;
                generator_heap->type_description_1 = "ccoooooo";
                goto frame_exception_exit_1;
            }

            tmp_assign_source_1 = tmp_mvar_value_3;
            assert( generator_heap->var_ip == NULL );
            Py_INCREF( tmp_assign_source_1 );
            generator_heap->var_ip = tmp_assign_source_1;
        }
        goto branch_end_4;
        branch_no_4:;
        {
            nuitka_bool tmp_condition_result_5;
            PyObject *tmp_compexpr_left_4;
            PyObject *tmp_compexpr_right_4;
            PyObject *tmp_source_name_4;
            if ( PyCell_GET( generator->m_closure[0] ) == NULL )
            {

                generator_heap->exception_type = PyExc_NameError;
                Py_INCREF( generator_heap->exception_type );
                generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "first" );
                generator_heap->exception_tb = NULL;

                generator_heap->exception_lineno = 357;
                generator_heap->type_description_1 = "ccoooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_4 = PyCell_GET( generator->m_closure[0] );
            tmp_compexpr_left_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_version );
            if ( tmp_compexpr_left_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


                generator_heap->exception_lineno = 357;
                generator_heap->type_description_1 = "ccoooooo";
                goto frame_exception_exit_1;
            }
            tmp_compexpr_right_4 = const_int_pos_6;
            generator_heap->tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_INT( tmp_compexpr_left_4, tmp_compexpr_right_4 );
            Py_DECREF( tmp_compexpr_left_4 );
            if ( generator_heap->tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


                generator_heap->exception_lineno = 357;
                generator_heap->type_description_1 = "ccoooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_5 = ( generator_heap->tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_5;
            }
            else
            {
                goto branch_no_5;
            }
            branch_yes_5:;
            {
                PyObject *tmp_assign_source_2;
                PyObject *tmp_mvar_value_4;
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Network );

                if (unlikely( tmp_mvar_value_4 == NULL ))
                {
                    tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Network );
                }

                if ( tmp_mvar_value_4 == NULL )
                {

                    generator_heap->exception_type = PyExc_NameError;
                    Py_INCREF( generator_heap->exception_type );
                    generator_heap->exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv6Network" );
                    generator_heap->exception_tb = NULL;

                    generator_heap->exception_lineno = 358;
                    generator_heap->type_description_1 = "ccoooooo";
                    goto frame_exception_exit_1;
                }

                tmp_assign_source_2 = tmp_mvar_value_4;
                assert( generator_heap->var_ip == NULL );
                Py_INCREF( tmp_assign_source_2 );
                generator_heap->var_ip = tmp_assign_source_2;
            }
            goto branch_end_5;
            branch_no_5:;
            {
                PyObject *tmp_raise_type_4;
                PyObject *tmp_make_exception_arg_4;
                tmp_make_exception_arg_4 = const_unicode_digest_713ebfce2d10e63958e8edc4d67a9c94;
                generator->m_frame->m_frame.f_lineno = 360;
                {
                    PyObject *call_args[] = { tmp_make_exception_arg_4 };
                    tmp_raise_type_4 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
                }

                assert( !(tmp_raise_type_4 == NULL) );
                generator_heap->exception_type = tmp_raise_type_4;
                generator_heap->exception_lineno = 360;
                RAISE_EXCEPTION_WITH_TYPE( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
                generator_heap->type_description_1 = "ccoooooo";
                goto frame_exception_exit_1;
            }
            branch_end_5:;
        }
        branch_end_4:;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_source_name_5;
        if ( PyCell_GET( generator->m_closure[0] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "first" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 362;
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = PyCell_GET( generator->m_closure[0] );
        tmp_assign_source_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__max_prefixlen );
        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 362;
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }
        assert( generator_heap->var_ip_bits == NULL );
        generator_heap->var_ip_bits = tmp_assign_source_3;
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_source_name_6;
        if ( PyCell_GET( generator->m_closure[0] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "first" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 363;
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = PyCell_GET( generator->m_closure[0] );
        tmp_assign_source_4 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__ip );
        if ( tmp_assign_source_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 363;
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }
        assert( generator_heap->var_first_int == NULL );
        generator_heap->var_first_int = tmp_assign_source_4;
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_source_name_7;
        if ( PyCell_GET( generator->m_closure[1] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "last" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 364;
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_7 = PyCell_GET( generator->m_closure[1] );
        tmp_assign_source_5 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__ip );
        if ( tmp_assign_source_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 364;
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }
        assert( generator_heap->var_last_int == NULL );
        generator_heap->var_last_int = tmp_assign_source_5;
    }
    loop_start_1:;
    {
        nuitka_bool tmp_condition_result_6;
        PyObject *tmp_operand_name_2;
        PyObject *tmp_compexpr_left_5;
        PyObject *tmp_compexpr_right_5;
        CHECK_OBJECT( generator_heap->var_first_int );
        tmp_compexpr_left_5 = generator_heap->var_first_int;
        CHECK_OBJECT( generator_heap->var_last_int );
        tmp_compexpr_right_5 = generator_heap->var_last_int;
        tmp_operand_name_2 = RICH_COMPARE_LTE_OBJECT_OBJECT( tmp_compexpr_left_5, tmp_compexpr_right_5 );
        if ( tmp_operand_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 365;
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }
        generator_heap->tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        Py_DECREF( tmp_operand_name_2 );
        if ( generator_heap->tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 365;
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_6 = ( generator_heap->tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_6 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_6;
        }
        else
        {
            goto branch_no_6;
        }
        branch_yes_6:;
        goto loop_end_1;
        branch_no_6:;
    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_left_name_2;
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_left_name_3;
        PyObject *tmp_left_name_4;
        PyObject *tmp_right_name_2;
        PyObject *tmp_right_name_3;
        PyObject *tmp_right_name_4;
        tmp_called_name_1 = LOOKUP_BUILTIN( const_str_plain_min );
        assert( tmp_called_name_1 != NULL );
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__count_righthand_zero_bits );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__count_righthand_zero_bits );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "global name '%s' is not defined", "_count_righthand_zero_bits" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 366;
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_5;
        CHECK_OBJECT( generator_heap->var_first_int );
        tmp_args_element_name_2 = generator_heap->var_first_int;
        CHECK_OBJECT( generator_heap->var_ip_bits );
        tmp_args_element_name_3 = generator_heap->var_ip_bits;
        generator->m_frame->m_frame.f_lineno = 366;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 366;
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_bit_length );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__compat_bit_length );
        }

        if ( tmp_mvar_value_6 == NULL )
        {
            Py_DECREF( tmp_args_element_name_1 );
            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "global name '%s' is not defined", "_compat_bit_length" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 367;
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_6;
        CHECK_OBJECT( generator_heap->var_last_int );
        tmp_left_name_4 = generator_heap->var_last_int;
        CHECK_OBJECT( generator_heap->var_first_int );
        tmp_right_name_2 = generator_heap->var_first_int;
        tmp_left_name_3 = BINARY_OPERATION_SUB( tmp_left_name_4, tmp_right_name_2 );
        if ( tmp_left_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
            Py_DECREF( tmp_args_element_name_1 );

            generator_heap->exception_lineno = 367;
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }
        tmp_right_name_3 = const_int_pos_1;
        tmp_args_element_name_5 = BINARY_OPERATION_ADD_OBJECT_INT( tmp_left_name_3, tmp_right_name_3 );
        Py_DECREF( tmp_left_name_3 );
        if ( tmp_args_element_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
            Py_DECREF( tmp_args_element_name_1 );

            generator_heap->exception_lineno = 367;
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }
        generator->m_frame->m_frame.f_lineno = 367;
        {
            PyObject *call_args[] = { tmp_args_element_name_5 };
            tmp_left_name_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_args_element_name_5 );
        if ( tmp_left_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
            Py_DECREF( tmp_args_element_name_1 );

            generator_heap->exception_lineno = 367;
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }
        tmp_right_name_4 = const_int_pos_1;
        tmp_args_element_name_4 = BINARY_OPERATION_SUB( tmp_left_name_2, tmp_right_name_4 );
        Py_DECREF( tmp_left_name_2 );
        if ( tmp_args_element_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
            Py_DECREF( tmp_args_element_name_1 );

            generator_heap->exception_lineno = 367;
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }
        generator->m_frame->m_frame.f_lineno = 366;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_4 };
            tmp_assign_source_6 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_4 );
        if ( tmp_assign_source_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 366;
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = generator_heap->var_nbits;
            generator_heap->var_nbits = tmp_assign_source_6;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_called_name_4;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_tuple_element_2;
        PyObject *tmp_left_name_5;
        PyObject *tmp_right_name_5;
        if ( generator_heap->var_ip == NULL )
        {

            generator_heap->exception_type = PyExc_UnboundLocalError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "ip" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 368;
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_4 = generator_heap->var_ip;
        CHECK_OBJECT( generator_heap->var_first_int );
        tmp_tuple_element_2 = generator_heap->var_first_int;
        tmp_args_element_name_6 = PyTuple_New( 2 );
        Py_INCREF( tmp_tuple_element_2 );
        PyTuple_SET_ITEM( tmp_args_element_name_6, 0, tmp_tuple_element_2 );
        CHECK_OBJECT( generator_heap->var_ip_bits );
        tmp_left_name_5 = generator_heap->var_ip_bits;
        CHECK_OBJECT( generator_heap->var_nbits );
        tmp_right_name_5 = generator_heap->var_nbits;
        tmp_tuple_element_2 = BINARY_OPERATION_SUB( tmp_left_name_5, tmp_right_name_5 );
        if ( tmp_tuple_element_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
            Py_DECREF( tmp_args_element_name_6 );

            generator_heap->exception_lineno = 368;
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM( tmp_args_element_name_6, 1, tmp_tuple_element_2 );
        generator->m_frame->m_frame.f_lineno = 368;
        {
            PyObject *call_args[] = { tmp_args_element_name_6 };
            tmp_assign_source_7 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
        }

        Py_DECREF( tmp_args_element_name_6 );
        if ( tmp_assign_source_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 368;
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = generator_heap->var_net;
            generator_heap->var_net = tmp_assign_source_7;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_expression_name_1;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        CHECK_OBJECT( generator_heap->var_net );
        tmp_expression_name_1 = generator_heap->var_net;
        Py_INCREF( tmp_expression_name_1 );
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        if ( yield_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 369;
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    {
        PyObject *tmp_assign_source_8;
        PyObject *tmp_left_name_6;
        PyObject *tmp_right_name_6;
        PyObject *tmp_left_name_7;
        PyObject *tmp_right_name_7;
        CHECK_OBJECT( generator_heap->var_first_int );
        tmp_left_name_6 = generator_heap->var_first_int;
        tmp_left_name_7 = const_int_pos_1;
        CHECK_OBJECT( generator_heap->var_nbits );
        tmp_right_name_7 = generator_heap->var_nbits;
        tmp_right_name_6 = BINARY_OPERATION( PyNumber_Lshift, tmp_left_name_7, tmp_right_name_7 );
        if ( tmp_right_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 370;
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }
        generator_heap->tmp_result = BINARY_OPERATION_ADD_OBJECT_OBJECT_INPLACE( &tmp_left_name_6, tmp_right_name_6 );
        Py_DECREF( tmp_right_name_6 );
        if ( generator_heap->tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 370;
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_8 = tmp_left_name_6;
        generator_heap->var_first_int = tmp_assign_source_8;

    }
    {
        nuitka_bool tmp_condition_result_7;
        PyObject *tmp_compexpr_left_6;
        PyObject *tmp_compexpr_right_6;
        PyObject *tmp_left_name_8;
        PyObject *tmp_right_name_8;
        PyObject *tmp_source_name_8;
        CHECK_OBJECT( generator_heap->var_first_int );
        tmp_left_name_8 = generator_heap->var_first_int;
        tmp_right_name_8 = const_int_pos_1;
        tmp_compexpr_left_6 = BINARY_OPERATION_SUB( tmp_left_name_8, tmp_right_name_8 );
        if ( tmp_compexpr_left_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 371;
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }
        if ( generator_heap->var_ip == NULL )
        {
            Py_DECREF( tmp_compexpr_left_6 );
            generator_heap->exception_type = PyExc_UnboundLocalError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "ip" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 371;
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_8 = generator_heap->var_ip;
        tmp_compexpr_right_6 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain__ALL_ONES );
        if ( tmp_compexpr_right_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
            Py_DECREF( tmp_compexpr_left_6 );

            generator_heap->exception_lineno = 371;
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }
        generator_heap->tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_6, tmp_compexpr_right_6 );
        Py_DECREF( tmp_compexpr_left_6 );
        Py_DECREF( tmp_compexpr_right_6 );
        if ( generator_heap->tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 371;
            generator_heap->type_description_1 = "ccoooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_7 = ( generator_heap->tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_7 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_7;
        }
        else
        {
            goto branch_no_7;
        }
        branch_yes_7:;
        goto loop_end_1;
        branch_no_7:;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


        generator_heap->exception_lineno = 365;
        generator_heap->type_description_1 = "ccoooooo";
        goto frame_exception_exit_1;
    }
    goto loop_start_1;
    loop_end_1:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( generator_heap->exception_type ) )
    {
        if ( generator_heap->exception_tb == NULL )
        {
            generator_heap->exception_tb = MAKE_TRACEBACK( generator->m_frame, generator_heap->exception_lineno );
        }
        else if ( generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            generator_heap->exception_tb = ADD_TRACEBACK( generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            generator->m_closure[0],
            generator->m_closure[1],
            generator_heap->var_nbits,
            generator_heap->var_ip,
            generator_heap->var_last_int,
            generator_heap->var_ip_bits,
            generator_heap->var_net,
            generator_heap->var_first_int
        );


        // Release cached frame.
        if ( generator->m_frame == cache_m_frame )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_m_frame = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->var_nbits );
    generator_heap->var_nbits = NULL;

    Py_XDECREF( generator_heap->var_ip );
    generator_heap->var_ip = NULL;

    Py_XDECREF( generator_heap->var_last_int );
    generator_heap->var_last_int = NULL;

    Py_XDECREF( generator_heap->var_ip_bits );
    generator_heap->var_ip_bits = NULL;

    Py_XDECREF( generator_heap->var_net );
    generator_heap->var_net = NULL;

    Py_XDECREF( generator_heap->var_first_int );
    generator_heap->var_first_int = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:
    try_end_1:;
    Py_XDECREF( generator_heap->var_nbits );
    generator_heap->var_nbits = NULL;

    Py_XDECREF( generator_heap->var_ip );
    generator_heap->var_ip = NULL;

    CHECK_OBJECT( (PyObject *)generator_heap->var_last_int );
    Py_DECREF( generator_heap->var_last_int );
    generator_heap->var_last_int = NULL;

    CHECK_OBJECT( (PyObject *)generator_heap->var_ip_bits );
    Py_DECREF( generator_heap->var_ip_bits );
    generator_heap->var_ip_bits = NULL;

    Py_XDECREF( generator_heap->var_net );
    generator_heap->var_net = NULL;

    Py_XDECREF( generator_heap->var_first_int );
    generator_heap->var_first_int = NULL;



    return NULL;

    function_exception_exit:
    assert( generator_heap->exception_type );
    RESTORE_ERROR_OCCURRED( generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb );

    return NULL;

}

static PyObject *ipaddress$$$function_21_summarize_address_range$$$genobj_1_summarize_address_range_maker( void )
{
    return Nuitka_Generator_New(
        ipaddress$$$function_21_summarize_address_range$$$genobj_1_summarize_address_range_context,
        module_ipaddress,
        const_str_plain_summarize_address_range,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_b1fe0f75950a86c7a08048741a3f59da,
        2,
        sizeof(struct ipaddress$$$function_21_summarize_address_range$$$genobj_1_summarize_address_range_locals)
    );
}


static PyObject *impl_ipaddress$$$function_22__collapse_addresses_internal( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_addresses = PyCell_NEW1( python_pars[ 0 ] );
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    // Tried code:
    tmp_return_value = ipaddress$$$function_22__collapse_addresses_internal$$$genobj_1__collapse_addresses_internal_maker();

    ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[0] = par_addresses;
    Py_INCREF( ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[0] );


    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_22__collapse_addresses_internal );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_addresses );
    Py_DECREF( par_addresses );
    par_addresses = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_addresses );
    Py_DECREF( par_addresses );
    par_addresses = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_22__collapse_addresses_internal );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}



struct ipaddress$$$function_22__collapse_addresses_internal$$$genobj_1__collapse_addresses_internal_locals {
    PyObject *var_subnets;
    PyObject *var_supernet;
    PyObject *var_last;
    PyObject *var_existing;
    PyObject *var_to_merge;
    PyObject *var_net;
    PyObject *tmp_for_loop_1__for_iterator;
    PyObject *tmp_for_loop_1__iter_value;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    int tmp_res;
    PyObject *tmp_dictset_value;
    PyObject *tmp_dictset_dict;
    PyObject *tmp_dictset_key;
    PyObject *tmp_dictdel_dict;
    PyObject *tmp_dictdel_key;
    bool tmp_result;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
};

static PyObject *ipaddress$$$function_22__collapse_addresses_internal$$$genobj_1__collapse_addresses_internal_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Heap access if used.
    struct ipaddress$$$function_22__collapse_addresses_internal$$$genobj_1__collapse_addresses_internal_locals *generator_heap = (struct ipaddress$$$function_22__collapse_addresses_internal$$$genobj_1__collapse_addresses_internal_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_subnets = NULL;
    generator_heap->var_supernet = NULL;
    generator_heap->var_last = NULL;
    generator_heap->var_existing = NULL;
    generator_heap->var_to_merge = NULL;
    generator_heap->var_net = NULL;
    generator_heap->tmp_for_loop_1__for_iterator = NULL;
    generator_heap->tmp_for_loop_1__iter_value = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_m_frame, codeobj_3aa7b3b68ced212bf157a71f3cb41b24, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

#if PYTHON_VERSION < 370
        generator->m_frame->m_frame.f_exc_type = EXC_TYPE( thread_state );
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
        Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#else
        generator->m_exc_state.exc_type = EXC_TYPE( thread_state );
        if ( generator->m_exc_state.exc_type == Py_None ) generator->m_exc_state.exc_type = NULL;
        Py_XINCREF( generator->m_exc_state.exc_type );
        generator->m_exc_state.exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_value );
        generator->m_exc_state.exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_traceback );
#endif
    }

#endif

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_list_arg_1;
        if ( PyCell_GET( generator->m_closure[0] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "addresses" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 400;
            generator_heap->type_description_1 = "coooooo";
            goto frame_exception_exit_1;
        }

        tmp_list_arg_1 = PyCell_GET( generator->m_closure[0] );
        tmp_assign_source_1 = PySequence_List( tmp_list_arg_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 400;
            generator_heap->type_description_1 = "coooooo";
            goto frame_exception_exit_1;
        }
        assert( generator_heap->var_to_merge == NULL );
        generator_heap->var_to_merge = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        tmp_assign_source_2 = PyDict_New();
        assert( generator_heap->var_subnets == NULL );
        generator_heap->var_subnets = tmp_assign_source_2;
    }
    loop_start_1:;
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        CHECK_OBJECT( generator_heap->var_to_merge );
        tmp_operand_name_1 = generator_heap->var_to_merge;
        generator_heap->tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( generator_heap->tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 402;
            generator_heap->type_description_1 = "coooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( generator_heap->tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        goto loop_end_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_instance_1;
        CHECK_OBJECT( generator_heap->var_to_merge );
        tmp_called_instance_1 = generator_heap->var_to_merge;
        generator->m_frame->m_frame.f_lineno = 403;
        tmp_assign_source_3 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_pop );
        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 403;
            generator_heap->type_description_1 = "coooooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = generator_heap->var_net;
            generator_heap->var_net = tmp_assign_source_3;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_instance_2;
        CHECK_OBJECT( generator_heap->var_net );
        tmp_called_instance_2 = generator_heap->var_net;
        generator->m_frame->m_frame.f_lineno = 404;
        tmp_assign_source_4 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_supernet );
        if ( tmp_assign_source_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 404;
            generator_heap->type_description_1 = "coooooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = generator_heap->var_supernet;
            generator_heap->var_supernet = tmp_assign_source_4;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT( generator_heap->var_subnets );
        tmp_called_instance_3 = generator_heap->var_subnets;
        CHECK_OBJECT( generator_heap->var_supernet );
        tmp_args_element_name_1 = generator_heap->var_supernet;
        generator->m_frame->m_frame.f_lineno = 405;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_5 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_get, call_args );
        }

        if ( tmp_assign_source_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 405;
            generator_heap->type_description_1 = "coooooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = generator_heap->var_existing;
            generator_heap->var_existing = tmp_assign_source_5;
            Py_XDECREF( old );
        }

    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( generator_heap->var_existing );
        tmp_compexpr_left_1 = generator_heap->var_existing;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_2 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        CHECK_OBJECT( generator_heap->var_net );
        generator_heap->tmp_dictset_value = generator_heap->var_net;
        CHECK_OBJECT( generator_heap->var_subnets );
        generator_heap->tmp_dictset_dict = generator_heap->var_subnets;
        CHECK_OBJECT( generator_heap->var_supernet );
        generator_heap->tmp_dictset_key = generator_heap->var_supernet;
        generator_heap->tmp_res = PyDict_SetItem( generator_heap->tmp_dictset_dict, generator_heap->tmp_dictset_key, generator_heap->tmp_dictset_value );
        if ( generator_heap->tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 407;
            generator_heap->type_description_1 = "coooooo";
            goto frame_exception_exit_1;
        }
        goto branch_end_2;
        branch_no_2:;
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            CHECK_OBJECT( generator_heap->var_existing );
            tmp_compexpr_left_2 = generator_heap->var_existing;
            CHECK_OBJECT( generator_heap->var_net );
            tmp_compexpr_right_2 = generator_heap->var_net;
            generator_heap->tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
            if ( generator_heap->tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


                generator_heap->exception_lineno = 408;
                generator_heap->type_description_1 = "coooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_3 = ( generator_heap->tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_3;
            }
            else
            {
                goto branch_no_3;
            }
            branch_yes_3:;
            CHECK_OBJECT( generator_heap->var_subnets );
            generator_heap->tmp_dictdel_dict = generator_heap->var_subnets;
            CHECK_OBJECT( generator_heap->var_supernet );
            generator_heap->tmp_dictdel_key = generator_heap->var_supernet;
            generator_heap->tmp_result = DICT_REMOVE_ITEM( generator_heap->tmp_dictdel_dict, generator_heap->tmp_dictdel_key );
            if ( generator_heap->tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


                generator_heap->exception_lineno = 410;
                generator_heap->type_description_1 = "coooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *tmp_called_instance_4;
                PyObject *tmp_call_result_1;
                PyObject *tmp_args_element_name_2;
                CHECK_OBJECT( generator_heap->var_to_merge );
                tmp_called_instance_4 = generator_heap->var_to_merge;
                CHECK_OBJECT( generator_heap->var_supernet );
                tmp_args_element_name_2 = generator_heap->var_supernet;
                generator->m_frame->m_frame.f_lineno = 411;
                {
                    PyObject *call_args[] = { tmp_args_element_name_2 };
                    tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_append, call_args );
                }

                if ( tmp_call_result_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


                    generator_heap->exception_lineno = 411;
                    generator_heap->type_description_1 = "coooooo";
                    goto frame_exception_exit_1;
                }
                Py_DECREF( tmp_call_result_1 );
            }
            branch_no_3:;
        }
        branch_end_2:;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


        generator_heap->exception_lineno = 402;
        generator_heap->type_description_1 = "coooooo";
        goto frame_exception_exit_1;
    }
    goto loop_start_1;
    loop_end_1:;
    {
        PyObject *tmp_assign_source_6;
        tmp_assign_source_6 = Py_None;
        assert( generator_heap->var_last == NULL );
        Py_INCREF( tmp_assign_source_6 );
        generator_heap->var_last = tmp_assign_source_6;
    }
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_called_instance_5;
        tmp_called_name_1 = LOOKUP_BUILTIN( const_str_plain_sorted );
        assert( tmp_called_name_1 != NULL );
        CHECK_OBJECT( generator_heap->var_subnets );
        tmp_called_instance_5 = generator_heap->var_subnets;
        generator->m_frame->m_frame.f_lineno = 414;
        tmp_args_element_name_3 = CALL_METHOD_NO_ARGS( tmp_called_instance_5, const_str_plain_values );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 414;
            generator_heap->type_description_1 = "coooooo";
            goto frame_exception_exit_1;
        }
        generator->m_frame->m_frame.f_lineno = 414;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_iter_arg_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_iter_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 414;
            generator_heap->type_description_1 = "coooooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_7 = MAKE_ITERATOR( tmp_iter_arg_1 );
        Py_DECREF( tmp_iter_arg_1 );
        if ( tmp_assign_source_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 414;
            generator_heap->type_description_1 = "coooooo";
            goto frame_exception_exit_1;
        }
        assert( generator_heap->tmp_for_loop_1__for_iterator == NULL );
        generator_heap->tmp_for_loop_1__for_iterator = tmp_assign_source_7;
    }
    // Tried code:
    loop_start_2:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_8;
        CHECK_OBJECT( generator_heap->tmp_for_loop_1__for_iterator );
        tmp_next_source_1 = generator_heap->tmp_for_loop_1__for_iterator;
        tmp_assign_source_8 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_8 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_2;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
                generator_heap->type_description_1 = "coooooo";
                generator_heap->exception_lineno = 414;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_for_loop_1__iter_value;
            generator_heap->tmp_for_loop_1__iter_value = tmp_assign_source_8;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_9;
        CHECK_OBJECT( generator_heap->tmp_for_loop_1__iter_value );
        tmp_assign_source_9 = generator_heap->tmp_for_loop_1__iter_value;
        {
            PyObject *old = generator_heap->var_net;
            generator_heap->var_net = tmp_assign_source_9;
            Py_INCREF( generator_heap->var_net );
            Py_XDECREF( old );
        }

    }
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        CHECK_OBJECT( generator_heap->var_last );
        tmp_compexpr_left_3 = generator_heap->var_last;
        tmp_compexpr_right_3 = Py_None;
        tmp_condition_result_4 = ( tmp_compexpr_left_3 != tmp_compexpr_right_3 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_4;
        }
        else
        {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            nuitka_bool tmp_condition_result_5;
            PyObject *tmp_compexpr_left_4;
            PyObject *tmp_compexpr_right_4;
            PyObject *tmp_source_name_1;
            PyObject *tmp_source_name_2;
            CHECK_OBJECT( generator_heap->var_last );
            tmp_source_name_1 = generator_heap->var_last;
            tmp_compexpr_left_4 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_broadcast_address );
            if ( tmp_compexpr_left_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


                generator_heap->exception_lineno = 418;
                generator_heap->type_description_1 = "coooooo";
                goto try_except_handler_2;
            }
            CHECK_OBJECT( generator_heap->var_net );
            tmp_source_name_2 = generator_heap->var_net;
            tmp_compexpr_right_4 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_broadcast_address );
            if ( tmp_compexpr_right_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
                Py_DECREF( tmp_compexpr_left_4 );

                generator_heap->exception_lineno = 418;
                generator_heap->type_description_1 = "coooooo";
                goto try_except_handler_2;
            }
            generator_heap->tmp_res = RICH_COMPARE_BOOL_GTE_OBJECT_OBJECT( tmp_compexpr_left_4, tmp_compexpr_right_4 );
            Py_DECREF( tmp_compexpr_left_4 );
            Py_DECREF( tmp_compexpr_right_4 );
            if ( generator_heap->tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


                generator_heap->exception_lineno = 418;
                generator_heap->type_description_1 = "coooooo";
                goto try_except_handler_2;
            }
            tmp_condition_result_5 = ( generator_heap->tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_5;
            }
            else
            {
                goto branch_no_5;
            }
            branch_yes_5:;
            goto loop_start_2;
            branch_no_5:;
        }
        branch_no_4:;
    }
    {
        PyObject *tmp_expression_name_1;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        CHECK_OBJECT( generator_heap->var_net );
        tmp_expression_name_1 = generator_heap->var_net;
        Py_INCREF( tmp_expression_name_1 );
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        if ( yield_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 420;
            generator_heap->type_description_1 = "coooooo";
            goto try_except_handler_2;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    {
        PyObject *tmp_assign_source_10;
        CHECK_OBJECT( generator_heap->var_net );
        tmp_assign_source_10 = generator_heap->var_net;
        {
            PyObject *old = generator_heap->var_last;
            assert( old != NULL );
            generator_heap->var_last = tmp_assign_source_10;
            Py_INCREF( generator_heap->var_last );
            Py_DECREF( old );
        }

    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


        generator_heap->exception_lineno = 414;
        generator_heap->type_description_1 = "coooooo";
        goto try_except_handler_2;
    }
    goto loop_start_2;
    loop_end_2:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->tmp_for_loop_1__iter_value );
    generator_heap->tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)generator_heap->tmp_for_loop_1__for_iterator );
    Py_DECREF( generator_heap->tmp_for_loop_1__for_iterator );
    generator_heap->tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( generator_heap->exception_type ) )
    {
        if ( generator_heap->exception_tb == NULL )
        {
            generator_heap->exception_tb = MAKE_TRACEBACK( generator->m_frame, generator_heap->exception_lineno );
        }
        else if ( generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            generator_heap->exception_tb = ADD_TRACEBACK( generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            generator->m_closure[0],
            generator_heap->var_subnets,
            generator_heap->var_supernet,
            generator_heap->var_last,
            generator_heap->var_existing,
            generator_heap->var_to_merge,
            generator_heap->var_net
        );


        // Release cached frame.
        if ( generator->m_frame == cache_m_frame )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_m_frame = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->var_subnets );
    generator_heap->var_subnets = NULL;

    Py_XDECREF( generator_heap->var_supernet );
    generator_heap->var_supernet = NULL;

    Py_XDECREF( generator_heap->var_last );
    generator_heap->var_last = NULL;

    Py_XDECREF( generator_heap->var_existing );
    generator_heap->var_existing = NULL;

    Py_XDECREF( generator_heap->var_to_merge );
    generator_heap->var_to_merge = NULL;

    Py_XDECREF( generator_heap->var_net );
    generator_heap->var_net = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:
    try_end_2:;
    Py_XDECREF( generator_heap->tmp_for_loop_1__iter_value );
    generator_heap->tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)generator_heap->tmp_for_loop_1__for_iterator );
    Py_DECREF( generator_heap->tmp_for_loop_1__for_iterator );
    generator_heap->tmp_for_loop_1__for_iterator = NULL;

    CHECK_OBJECT( (PyObject *)generator_heap->var_subnets );
    Py_DECREF( generator_heap->var_subnets );
    generator_heap->var_subnets = NULL;

    Py_XDECREF( generator_heap->var_supernet );
    generator_heap->var_supernet = NULL;

    CHECK_OBJECT( (PyObject *)generator_heap->var_last );
    Py_DECREF( generator_heap->var_last );
    generator_heap->var_last = NULL;

    Py_XDECREF( generator_heap->var_existing );
    generator_heap->var_existing = NULL;

    CHECK_OBJECT( (PyObject *)generator_heap->var_to_merge );
    Py_DECREF( generator_heap->var_to_merge );
    generator_heap->var_to_merge = NULL;

    Py_XDECREF( generator_heap->var_net );
    generator_heap->var_net = NULL;



    return NULL;

    function_exception_exit:
    assert( generator_heap->exception_type );
    RESTORE_ERROR_OCCURRED( generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb );

    return NULL;

}

static PyObject *ipaddress$$$function_22__collapse_addresses_internal$$$genobj_1__collapse_addresses_internal_maker( void )
{
    return Nuitka_Generator_New(
        ipaddress$$$function_22__collapse_addresses_internal$$$genobj_1__collapse_addresses_internal_context,
        module_ipaddress,
        const_str_plain__collapse_addresses_internal,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_3aa7b3b68ced212bf157a71f3cb41b24,
        1,
        sizeof(struct ipaddress$$$function_22__collapse_addresses_internal$$$genobj_1__collapse_addresses_internal_locals)
    );
}


static PyObject *impl_ipaddress$$$function_23_collapse_addresses( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_addresses = python_pars[ 0 ];
    PyObject *var_last = NULL;
    PyObject *var_ip = NULL;
    PyObject *var_ips = NULL;
    PyObject *var_addrs = NULL;
    PyObject *var_nets = NULL;
    PyObject *var_first = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *tmp_for_loop_2__for_iterator = NULL;
    PyObject *tmp_for_loop_2__iter_value = NULL;
    PyObject *tmp_tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_tuple_unpack_1__source_iter = NULL;
    struct Nuitka_FrameObject *frame_60a11b2dd91b774c274871d35d983f3a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    bool tmp_result;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_iterator_attempt;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_60a11b2dd91b774c274871d35d983f3a = NULL;
    PyObject *exception_keeper_type_6;
    PyObject *exception_keeper_value_6;
    PyTracebackObject *exception_keeper_tb_6;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_6;

    // Actual function body.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = PyList_New( 0 );
        assert( var_addrs == NULL );
        var_addrs = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        tmp_assign_source_2 = PyList_New( 0 );
        assert( var_ips == NULL );
        var_ips = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        tmp_assign_source_3 = PyList_New( 0 );
        assert( var_nets == NULL );
        var_nets = tmp_assign_source_3;
    }
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_60a11b2dd91b774c274871d35d983f3a, codeobj_60a11b2dd91b774c274871d35d983f3a, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_60a11b2dd91b774c274871d35d983f3a = cache_frame_60a11b2dd91b774c274871d35d983f3a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_60a11b2dd91b774c274871d35d983f3a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_60a11b2dd91b774c274871d35d983f3a ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_iter_arg_1;
        CHECK_OBJECT( par_addresses );
        tmp_iter_arg_1 = par_addresses;
        tmp_assign_source_4 = MAKE_ITERATOR( tmp_iter_arg_1 );
        if ( tmp_assign_source_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 447;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        assert( tmp_for_loop_1__for_iterator == NULL );
        tmp_for_loop_1__for_iterator = tmp_assign_source_4;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_5;
        CHECK_OBJECT( tmp_for_loop_1__for_iterator );
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_5 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_5 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "ooooooo";
                exception_lineno = 447;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_5;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_6;
        CHECK_OBJECT( tmp_for_loop_1__iter_value );
        tmp_assign_source_6 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_ip;
            var_ip = tmp_assign_source_6;
            Py_INCREF( var_ip );
            Py_XDECREF( old );
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( var_ip );
        tmp_isinstance_inst_1 = var_ip;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__BaseAddress );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__BaseAddress );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_BaseAddress" );
            exception_tb = NULL;

            exception_lineno = 448;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 448;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            nuitka_bool tmp_condition_result_2;
            int tmp_and_left_truth_1;
            nuitka_bool tmp_and_left_value_1;
            nuitka_bool tmp_and_right_value_1;
            int tmp_truth_name_1;
            PyObject *tmp_compexpr_left_1;
            PyObject *tmp_compexpr_right_1;
            PyObject *tmp_source_name_1;
            PyObject *tmp_subscribed_name_1;
            PyObject *tmp_subscript_name_1;
            PyObject *tmp_source_name_2;
            CHECK_OBJECT( var_ips );
            tmp_truth_name_1 = CHECK_IF_TRUE( var_ips );
            if ( tmp_truth_name_1 == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 449;
                type_description_1 = "ooooooo";
                goto try_except_handler_2;
            }
            tmp_and_left_value_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            tmp_and_left_truth_1 = tmp_and_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
            if ( tmp_and_left_truth_1 == 1 )
            {
                goto and_right_1;
            }
            else
            {
                goto and_left_1;
            }
            and_right_1:;
            CHECK_OBJECT( var_ips );
            tmp_subscribed_name_1 = var_ips;
            tmp_subscript_name_1 = const_int_neg_1;
            tmp_source_name_1 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_1, tmp_subscript_name_1, -1 );
            if ( tmp_source_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 449;
                type_description_1 = "ooooooo";
                goto try_except_handler_2;
            }
            tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__version );
            Py_DECREF( tmp_source_name_1 );
            if ( tmp_compexpr_left_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 449;
                type_description_1 = "ooooooo";
                goto try_except_handler_2;
            }
            CHECK_OBJECT( var_ip );
            tmp_source_name_2 = var_ip;
            tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__version );
            if ( tmp_compexpr_right_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_compexpr_left_1 );

                exception_lineno = 449;
                type_description_1 = "ooooooo";
                goto try_except_handler_2;
            }
            tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
            Py_DECREF( tmp_compexpr_left_1 );
            Py_DECREF( tmp_compexpr_right_1 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 449;
                type_description_1 = "ooooooo";
                goto try_except_handler_2;
            }
            tmp_and_right_value_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            tmp_condition_result_2 = tmp_and_right_value_1;
            goto and_end_1;
            and_left_1:;
            tmp_condition_result_2 = tmp_and_left_value_1;
            and_end_1:;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_raise_type_1;
                PyObject *tmp_make_exception_arg_1;
                PyObject *tmp_left_name_1;
                PyObject *tmp_right_name_1;
                PyObject *tmp_tuple_element_1;
                PyObject *tmp_subscribed_name_2;
                PyObject *tmp_subscript_name_2;
                tmp_left_name_1 = const_unicode_digest_e922c2e07060bd895f3f403962951e84;
                CHECK_OBJECT( var_ip );
                tmp_tuple_element_1 = var_ip;
                tmp_right_name_1 = PyTuple_New( 2 );
                Py_INCREF( tmp_tuple_element_1 );
                PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
                CHECK_OBJECT( var_ips );
                tmp_subscribed_name_2 = var_ips;
                tmp_subscript_name_2 = const_int_neg_1;
                tmp_tuple_element_1 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_2, tmp_subscript_name_2, -1 );
                if ( tmp_tuple_element_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_right_name_1 );

                    exception_lineno = 451;
                    type_description_1 = "ooooooo";
                    goto try_except_handler_2;
                }
                PyTuple_SET_ITEM( tmp_right_name_1, 1, tmp_tuple_element_1 );
                tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
                Py_DECREF( tmp_right_name_1 );
                if ( tmp_make_exception_arg_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 450;
                    type_description_1 = "ooooooo";
                    goto try_except_handler_2;
                }
                frame_60a11b2dd91b774c274871d35d983f3a->m_frame.f_lineno = 450;
                {
                    PyObject *call_args[] = { tmp_make_exception_arg_1 };
                    tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
                }

                Py_DECREF( tmp_make_exception_arg_1 );
                assert( !(tmp_raise_type_1 == NULL) );
                exception_type = tmp_raise_type_1;
                exception_lineno = 450;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "ooooooo";
                goto try_except_handler_2;
            }
            branch_no_2:;
        }
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_1;
            CHECK_OBJECT( var_ips );
            tmp_called_instance_1 = var_ips;
            CHECK_OBJECT( var_ip );
            tmp_args_element_name_1 = var_ip;
            frame_60a11b2dd91b774c274871d35d983f3a->m_frame.f_lineno = 452;
            {
                PyObject *call_args[] = { tmp_args_element_name_1 };
                tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_append, call_args );
            }

            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 452;
                type_description_1 = "ooooooo";
                goto try_except_handler_2;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        goto branch_end_1;
        branch_no_1:;
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_source_name_3;
            PyObject *tmp_source_name_4;
            CHECK_OBJECT( var_ip );
            tmp_source_name_3 = var_ip;
            tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__prefixlen );
            if ( tmp_compexpr_left_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 453;
                type_description_1 = "ooooooo";
                goto try_except_handler_2;
            }
            CHECK_OBJECT( var_ip );
            tmp_source_name_4 = var_ip;
            tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__max_prefixlen );
            if ( tmp_compexpr_right_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_compexpr_left_2 );

                exception_lineno = 453;
                type_description_1 = "ooooooo";
                goto try_except_handler_2;
            }
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
            Py_DECREF( tmp_compexpr_left_2 );
            Py_DECREF( tmp_compexpr_right_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 453;
                type_description_1 = "ooooooo";
                goto try_except_handler_2;
            }
            tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_3;
            }
            else
            {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                nuitka_bool tmp_condition_result_4;
                int tmp_and_left_truth_2;
                nuitka_bool tmp_and_left_value_2;
                nuitka_bool tmp_and_right_value_2;
                int tmp_truth_name_2;
                PyObject *tmp_compexpr_left_3;
                PyObject *tmp_compexpr_right_3;
                PyObject *tmp_source_name_5;
                PyObject *tmp_subscribed_name_3;
                PyObject *tmp_subscript_name_3;
                PyObject *tmp_source_name_6;
                CHECK_OBJECT( var_ips );
                tmp_truth_name_2 = CHECK_IF_TRUE( var_ips );
                if ( tmp_truth_name_2 == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 454;
                    type_description_1 = "ooooooo";
                    goto try_except_handler_2;
                }
                tmp_and_left_value_2 = tmp_truth_name_2 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                tmp_and_left_truth_2 = tmp_and_left_value_2 == NUITKA_BOOL_TRUE ? 1 : 0;
                if ( tmp_and_left_truth_2 == 1 )
                {
                    goto and_right_2;
                }
                else
                {
                    goto and_left_2;
                }
                and_right_2:;
                CHECK_OBJECT( var_ips );
                tmp_subscribed_name_3 = var_ips;
                tmp_subscript_name_3 = const_int_neg_1;
                tmp_source_name_5 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_3, tmp_subscript_name_3, -1 );
                if ( tmp_source_name_5 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 454;
                    type_description_1 = "ooooooo";
                    goto try_except_handler_2;
                }
                tmp_compexpr_left_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__version );
                Py_DECREF( tmp_source_name_5 );
                if ( tmp_compexpr_left_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 454;
                    type_description_1 = "ooooooo";
                    goto try_except_handler_2;
                }
                CHECK_OBJECT( var_ip );
                tmp_source_name_6 = var_ip;
                tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__version );
                if ( tmp_compexpr_right_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_compexpr_left_3 );

                    exception_lineno = 454;
                    type_description_1 = "ooooooo";
                    goto try_except_handler_2;
                }
                tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
                Py_DECREF( tmp_compexpr_left_3 );
                Py_DECREF( tmp_compexpr_right_3 );
                if ( tmp_res == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 454;
                    type_description_1 = "ooooooo";
                    goto try_except_handler_2;
                }
                tmp_and_right_value_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                tmp_condition_result_4 = tmp_and_right_value_2;
                goto and_end_2;
                and_left_2:;
                tmp_condition_result_4 = tmp_and_left_value_2;
                and_end_2:;
                if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
                {
                    goto branch_yes_4;
                }
                else
                {
                    goto branch_no_4;
                }
                branch_yes_4:;
                {
                    PyObject *tmp_raise_type_2;
                    PyObject *tmp_make_exception_arg_2;
                    PyObject *tmp_left_name_2;
                    PyObject *tmp_right_name_2;
                    PyObject *tmp_tuple_element_2;
                    PyObject *tmp_subscribed_name_4;
                    PyObject *tmp_subscript_name_4;
                    tmp_left_name_2 = const_unicode_digest_e922c2e07060bd895f3f403962951e84;
                    CHECK_OBJECT( var_ip );
                    tmp_tuple_element_2 = var_ip;
                    tmp_right_name_2 = PyTuple_New( 2 );
                    Py_INCREF( tmp_tuple_element_2 );
                    PyTuple_SET_ITEM( tmp_right_name_2, 0, tmp_tuple_element_2 );
                    CHECK_OBJECT( var_ips );
                    tmp_subscribed_name_4 = var_ips;
                    tmp_subscript_name_4 = const_int_neg_1;
                    tmp_tuple_element_2 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_4, tmp_subscript_name_4, -1 );
                    if ( tmp_tuple_element_2 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                        Py_DECREF( tmp_right_name_2 );

                        exception_lineno = 456;
                        type_description_1 = "ooooooo";
                        goto try_except_handler_2;
                    }
                    PyTuple_SET_ITEM( tmp_right_name_2, 1, tmp_tuple_element_2 );
                    tmp_make_exception_arg_2 = BINARY_OPERATION_REMAINDER( tmp_left_name_2, tmp_right_name_2 );
                    Py_DECREF( tmp_right_name_2 );
                    if ( tmp_make_exception_arg_2 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 455;
                        type_description_1 = "ooooooo";
                        goto try_except_handler_2;
                    }
                    frame_60a11b2dd91b774c274871d35d983f3a->m_frame.f_lineno = 455;
                    {
                        PyObject *call_args[] = { tmp_make_exception_arg_2 };
                        tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
                    }

                    Py_DECREF( tmp_make_exception_arg_2 );
                    assert( !(tmp_raise_type_2 == NULL) );
                    exception_type = tmp_raise_type_2;
                    exception_lineno = 455;
                    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                    type_description_1 = "ooooooo";
                    goto try_except_handler_2;
                }
                branch_no_4:;
            }
            // Tried code:
            {
                PyObject *tmp_called_name_1;
                PyObject *tmp_source_name_7;
                PyObject *tmp_call_result_2;
                PyObject *tmp_args_element_name_2;
                PyObject *tmp_source_name_8;
                CHECK_OBJECT( var_ips );
                tmp_source_name_7 = var_ips;
                tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_append );
                if ( tmp_called_name_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 458;
                    type_description_1 = "ooooooo";
                    goto try_except_handler_3;
                }
                CHECK_OBJECT( var_ip );
                tmp_source_name_8 = var_ip;
                tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_ip );
                if ( tmp_args_element_name_2 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_called_name_1 );

                    exception_lineno = 458;
                    type_description_1 = "ooooooo";
                    goto try_except_handler_3;
                }
                frame_60a11b2dd91b774c274871d35d983f3a->m_frame.f_lineno = 458;
                {
                    PyObject *call_args[] = { tmp_args_element_name_2 };
                    tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
                }

                Py_DECREF( tmp_called_name_1 );
                Py_DECREF( tmp_args_element_name_2 );
                if ( tmp_call_result_2 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 458;
                    type_description_1 = "ooooooo";
                    goto try_except_handler_3;
                }
                Py_DECREF( tmp_call_result_2 );
            }
            goto try_end_1;
            // Exception handler code:
            try_except_handler_3:;
            exception_keeper_type_1 = exception_type;
            exception_keeper_value_1 = exception_value;
            exception_keeper_tb_1 = exception_tb;
            exception_keeper_lineno_1 = exception_lineno;
            exception_type = NULL;
            exception_value = NULL;
            exception_tb = NULL;
            exception_lineno = 0;

            // Preserve existing published exception.
            PRESERVE_FRAME_EXCEPTION( frame_60a11b2dd91b774c274871d35d983f3a );
            if ( exception_keeper_tb_1 == NULL )
            {
                exception_keeper_tb_1 = MAKE_TRACEBACK( frame_60a11b2dd91b774c274871d35d983f3a, exception_keeper_lineno_1 );
            }
            else if ( exception_keeper_lineno_1 != 0 )
            {
                exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_60a11b2dd91b774c274871d35d983f3a, exception_keeper_lineno_1 );
            }

            NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
            PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
            {
                nuitka_bool tmp_condition_result_5;
                PyObject *tmp_compexpr_left_4;
                PyObject *tmp_compexpr_right_4;
                tmp_compexpr_left_4 = EXC_TYPE(PyThreadState_GET());
                tmp_compexpr_right_4 = PyExc_AttributeError;
                tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_4, tmp_compexpr_right_4 );
                if ( tmp_res == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 459;
                    type_description_1 = "ooooooo";
                    goto try_except_handler_2;
                }
                tmp_condition_result_5 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
                {
                    goto branch_yes_5;
                }
                else
                {
                    goto branch_no_5;
                }
                branch_yes_5:;
                {
                    PyObject *tmp_called_name_2;
                    PyObject *tmp_source_name_9;
                    PyObject *tmp_call_result_3;
                    PyObject *tmp_args_element_name_3;
                    PyObject *tmp_source_name_10;
                    CHECK_OBJECT( var_ips );
                    tmp_source_name_9 = var_ips;
                    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_append );
                    if ( tmp_called_name_2 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 460;
                        type_description_1 = "ooooooo";
                        goto try_except_handler_2;
                    }
                    CHECK_OBJECT( var_ip );
                    tmp_source_name_10 = var_ip;
                    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_network_address );
                    if ( tmp_args_element_name_3 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                        Py_DECREF( tmp_called_name_2 );

                        exception_lineno = 460;
                        type_description_1 = "ooooooo";
                        goto try_except_handler_2;
                    }
                    frame_60a11b2dd91b774c274871d35d983f3a->m_frame.f_lineno = 460;
                    {
                        PyObject *call_args[] = { tmp_args_element_name_3 };
                        tmp_call_result_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
                    }

                    Py_DECREF( tmp_called_name_2 );
                    Py_DECREF( tmp_args_element_name_3 );
                    if ( tmp_call_result_3 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 460;
                        type_description_1 = "ooooooo";
                        goto try_except_handler_2;
                    }
                    Py_DECREF( tmp_call_result_3 );
                }
                goto branch_end_5;
                branch_no_5:;
                tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                if (unlikely( tmp_result == false ))
                {
                    exception_lineno = 457;
                }

                if (exception_tb && exception_tb->tb_frame == &frame_60a11b2dd91b774c274871d35d983f3a->m_frame) frame_60a11b2dd91b774c274871d35d983f3a->m_frame.f_lineno = exception_tb->tb_lineno;
                type_description_1 = "ooooooo";
                goto try_except_handler_2;
                branch_end_5:;
            }
            goto try_end_1;
            // exception handler codes exits in all cases
            NUITKA_CANNOT_GET_HERE( ipaddress$$$function_23_collapse_addresses );
            return NULL;
            // End of try:
            try_end_1:;
            goto branch_end_3;
            branch_no_3:;
            {
                nuitka_bool tmp_condition_result_6;
                int tmp_and_left_truth_3;
                nuitka_bool tmp_and_left_value_3;
                nuitka_bool tmp_and_right_value_3;
                int tmp_truth_name_3;
                PyObject *tmp_compexpr_left_5;
                PyObject *tmp_compexpr_right_5;
                PyObject *tmp_source_name_11;
                PyObject *tmp_subscribed_name_5;
                PyObject *tmp_subscript_name_5;
                PyObject *tmp_source_name_12;
                CHECK_OBJECT( var_nets );
                tmp_truth_name_3 = CHECK_IF_TRUE( var_nets );
                if ( tmp_truth_name_3 == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 462;
                    type_description_1 = "ooooooo";
                    goto try_except_handler_2;
                }
                tmp_and_left_value_3 = tmp_truth_name_3 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                tmp_and_left_truth_3 = tmp_and_left_value_3 == NUITKA_BOOL_TRUE ? 1 : 0;
                if ( tmp_and_left_truth_3 == 1 )
                {
                    goto and_right_3;
                }
                else
                {
                    goto and_left_3;
                }
                and_right_3:;
                CHECK_OBJECT( var_nets );
                tmp_subscribed_name_5 = var_nets;
                tmp_subscript_name_5 = const_int_neg_1;
                tmp_source_name_11 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_5, tmp_subscript_name_5, -1 );
                if ( tmp_source_name_11 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 462;
                    type_description_1 = "ooooooo";
                    goto try_except_handler_2;
                }
                tmp_compexpr_left_5 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain__version );
                Py_DECREF( tmp_source_name_11 );
                if ( tmp_compexpr_left_5 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 462;
                    type_description_1 = "ooooooo";
                    goto try_except_handler_2;
                }
                CHECK_OBJECT( var_ip );
                tmp_source_name_12 = var_ip;
                tmp_compexpr_right_5 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain__version );
                if ( tmp_compexpr_right_5 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_compexpr_left_5 );

                    exception_lineno = 462;
                    type_description_1 = "ooooooo";
                    goto try_except_handler_2;
                }
                tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_5, tmp_compexpr_right_5 );
                Py_DECREF( tmp_compexpr_left_5 );
                Py_DECREF( tmp_compexpr_right_5 );
                if ( tmp_res == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 462;
                    type_description_1 = "ooooooo";
                    goto try_except_handler_2;
                }
                tmp_and_right_value_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                tmp_condition_result_6 = tmp_and_right_value_3;
                goto and_end_3;
                and_left_3:;
                tmp_condition_result_6 = tmp_and_left_value_3;
                and_end_3:;
                if ( tmp_condition_result_6 == NUITKA_BOOL_TRUE )
                {
                    goto branch_yes_6;
                }
                else
                {
                    goto branch_no_6;
                }
                branch_yes_6:;
                {
                    PyObject *tmp_raise_type_3;
                    PyObject *tmp_make_exception_arg_3;
                    PyObject *tmp_left_name_3;
                    PyObject *tmp_right_name_3;
                    PyObject *tmp_tuple_element_3;
                    PyObject *tmp_subscribed_name_6;
                    PyObject *tmp_subscript_name_6;
                    tmp_left_name_3 = const_unicode_digest_e922c2e07060bd895f3f403962951e84;
                    CHECK_OBJECT( var_ip );
                    tmp_tuple_element_3 = var_ip;
                    tmp_right_name_3 = PyTuple_New( 2 );
                    Py_INCREF( tmp_tuple_element_3 );
                    PyTuple_SET_ITEM( tmp_right_name_3, 0, tmp_tuple_element_3 );
                    CHECK_OBJECT( var_nets );
                    tmp_subscribed_name_6 = var_nets;
                    tmp_subscript_name_6 = const_int_neg_1;
                    tmp_tuple_element_3 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_6, tmp_subscript_name_6, -1 );
                    if ( tmp_tuple_element_3 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                        Py_DECREF( tmp_right_name_3 );

                        exception_lineno = 464;
                        type_description_1 = "ooooooo";
                        goto try_except_handler_2;
                    }
                    PyTuple_SET_ITEM( tmp_right_name_3, 1, tmp_tuple_element_3 );
                    tmp_make_exception_arg_3 = BINARY_OPERATION_REMAINDER( tmp_left_name_3, tmp_right_name_3 );
                    Py_DECREF( tmp_right_name_3 );
                    if ( tmp_make_exception_arg_3 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 463;
                        type_description_1 = "ooooooo";
                        goto try_except_handler_2;
                    }
                    frame_60a11b2dd91b774c274871d35d983f3a->m_frame.f_lineno = 463;
                    {
                        PyObject *call_args[] = { tmp_make_exception_arg_3 };
                        tmp_raise_type_3 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
                    }

                    Py_DECREF( tmp_make_exception_arg_3 );
                    assert( !(tmp_raise_type_3 == NULL) );
                    exception_type = tmp_raise_type_3;
                    exception_lineno = 463;
                    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                    type_description_1 = "ooooooo";
                    goto try_except_handler_2;
                }
                branch_no_6:;
            }
            {
                PyObject *tmp_called_instance_2;
                PyObject *tmp_call_result_4;
                PyObject *tmp_args_element_name_4;
                CHECK_OBJECT( var_nets );
                tmp_called_instance_2 = var_nets;
                CHECK_OBJECT( var_ip );
                tmp_args_element_name_4 = var_ip;
                frame_60a11b2dd91b774c274871d35d983f3a->m_frame.f_lineno = 465;
                {
                    PyObject *call_args[] = { tmp_args_element_name_4 };
                    tmp_call_result_4 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_append, call_args );
                }

                if ( tmp_call_result_4 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 465;
                    type_description_1 = "ooooooo";
                    goto try_except_handler_2;
                }
                Py_DECREF( tmp_call_result_4 );
            }
            branch_end_3:;
        }
        branch_end_1:;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 447;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_called_name_3;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_set_arg_1;
        tmp_called_name_3 = LOOKUP_BUILTIN( const_str_plain_sorted );
        assert( tmp_called_name_3 != NULL );
        CHECK_OBJECT( var_ips );
        tmp_set_arg_1 = var_ips;
        tmp_args_element_name_5 = PySet_New( tmp_set_arg_1 );
        if ( tmp_args_element_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 468;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        frame_60a11b2dd91b774c274871d35d983f3a->m_frame.f_lineno = 468;
        {
            PyObject *call_args[] = { tmp_args_element_name_5 };
            tmp_assign_source_7 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_args_element_name_5 );
        if ( tmp_assign_source_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 468;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = var_ips;
            assert( old != NULL );
            var_ips = tmp_assign_source_7;
            Py_DECREF( old );
        }

    }
    {
        nuitka_bool tmp_condition_result_7;
        int tmp_truth_name_4;
        CHECK_OBJECT( var_ips );
        tmp_truth_name_4 = CHECK_IF_TRUE( var_ips );
        if ( tmp_truth_name_4 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 471;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_7 = tmp_truth_name_4 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_7 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_7;
        }
        else
        {
            goto branch_no_7;
        }
        branch_yes_7:;
        {
            PyObject *tmp_assign_source_8;
            PyObject *tmp_iter_arg_2;
            PyObject *tmp_called_name_4;
            PyObject *tmp_mvar_value_2;
            PyObject *tmp_args_element_name_6;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__find_address_range );

            if (unlikely( tmp_mvar_value_2 == NULL ))
            {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__find_address_range );
            }

            if ( tmp_mvar_value_2 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_find_address_range" );
                exception_tb = NULL;

                exception_lineno = 472;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_4 = tmp_mvar_value_2;
            CHECK_OBJECT( var_ips );
            tmp_args_element_name_6 = var_ips;
            frame_60a11b2dd91b774c274871d35d983f3a->m_frame.f_lineno = 472;
            {
                PyObject *call_args[] = { tmp_args_element_name_6 };
                tmp_iter_arg_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
            }

            if ( tmp_iter_arg_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 472;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            tmp_assign_source_8 = MAKE_ITERATOR( tmp_iter_arg_2 );
            Py_DECREF( tmp_iter_arg_2 );
            if ( tmp_assign_source_8 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 472;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            assert( tmp_for_loop_2__for_iterator == NULL );
            tmp_for_loop_2__for_iterator = tmp_assign_source_8;
        }
        // Tried code:
        loop_start_2:;
        {
            PyObject *tmp_next_source_2;
            PyObject *tmp_assign_source_9;
            CHECK_OBJECT( tmp_for_loop_2__for_iterator );
            tmp_next_source_2 = tmp_for_loop_2__for_iterator;
            tmp_assign_source_9 = ITERATOR_NEXT( tmp_next_source_2 );
            if ( tmp_assign_source_9 == NULL )
            {
                if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
                {

                    goto loop_end_2;
                }
                else
                {

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    type_description_1 = "ooooooo";
                    exception_lineno = 472;
                    goto try_except_handler_4;
                }
            }

            {
                PyObject *old = tmp_for_loop_2__iter_value;
                tmp_for_loop_2__iter_value = tmp_assign_source_9;
                Py_XDECREF( old );
            }

        }
        // Tried code:
        {
            PyObject *tmp_assign_source_10;
            PyObject *tmp_iter_arg_3;
            CHECK_OBJECT( tmp_for_loop_2__iter_value );
            tmp_iter_arg_3 = tmp_for_loop_2__iter_value;
            tmp_assign_source_10 = MAKE_ITERATOR( tmp_iter_arg_3 );
            if ( tmp_assign_source_10 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 472;
                type_description_1 = "ooooooo";
                goto try_except_handler_5;
            }
            {
                PyObject *old = tmp_tuple_unpack_1__source_iter;
                tmp_tuple_unpack_1__source_iter = tmp_assign_source_10;
                Py_XDECREF( old );
            }

        }
        // Tried code:
        {
            PyObject *tmp_assign_source_11;
            PyObject *tmp_unpack_1;
            CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
            tmp_unpack_1 = tmp_tuple_unpack_1__source_iter;
            tmp_assign_source_11 = UNPACK_NEXT( tmp_unpack_1, 0 );
            if ( tmp_assign_source_11 == NULL )
            {
                if ( !ERROR_OCCURRED() )
                {
                    exception_type = PyExc_StopIteration;
                    Py_INCREF( exception_type );
                    exception_value = NULL;
                    exception_tb = NULL;
                }
                else
                {
                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                }


                type_description_1 = "ooooooo";
                exception_lineno = 472;
                goto try_except_handler_6;
            }
            {
                PyObject *old = tmp_tuple_unpack_1__element_1;
                tmp_tuple_unpack_1__element_1 = tmp_assign_source_11;
                Py_XDECREF( old );
            }

        }
        {
            PyObject *tmp_assign_source_12;
            PyObject *tmp_unpack_2;
            CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
            tmp_unpack_2 = tmp_tuple_unpack_1__source_iter;
            tmp_assign_source_12 = UNPACK_NEXT( tmp_unpack_2, 1 );
            if ( tmp_assign_source_12 == NULL )
            {
                if ( !ERROR_OCCURRED() )
                {
                    exception_type = PyExc_StopIteration;
                    Py_INCREF( exception_type );
                    exception_value = NULL;
                    exception_tb = NULL;
                }
                else
                {
                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                }


                type_description_1 = "ooooooo";
                exception_lineno = 472;
                goto try_except_handler_6;
            }
            {
                PyObject *old = tmp_tuple_unpack_1__element_2;
                tmp_tuple_unpack_1__element_2 = tmp_assign_source_12;
                Py_XDECREF( old );
            }

        }
        {
            PyObject *tmp_iterator_name_1;
            CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
            tmp_iterator_name_1 = tmp_tuple_unpack_1__source_iter;
            // Check if iterator has left-over elements.
            CHECK_OBJECT( tmp_iterator_name_1 ); assert( HAS_ITERNEXT( tmp_iterator_name_1 ) );

            tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_1 )->tp_iternext)( tmp_iterator_name_1 );

            if (likely( tmp_iterator_attempt == NULL ))
            {
                PyObject *error = GET_ERROR_OCCURRED();

                if ( error != NULL )
                {
                    if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
                    {
                        CLEAR_ERROR_OCCURRED();
                    }
                    else
                    {
                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                        type_description_1 = "ooooooo";
                        exception_lineno = 472;
                        goto try_except_handler_6;
                    }
                }
            }
            else
            {
                Py_DECREF( tmp_iterator_attempt );

                // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
                PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
                PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 2)" );
#endif
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                type_description_1 = "ooooooo";
                exception_lineno = 472;
                goto try_except_handler_6;
            }
        }
        goto try_end_3;
        // Exception handler code:
        try_except_handler_6:;
        exception_keeper_type_3 = exception_type;
        exception_keeper_value_3 = exception_value;
        exception_keeper_tb_3 = exception_tb;
        exception_keeper_lineno_3 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
        Py_DECREF( tmp_tuple_unpack_1__source_iter );
        tmp_tuple_unpack_1__source_iter = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_3;
        exception_value = exception_keeper_value_3;
        exception_tb = exception_keeper_tb_3;
        exception_lineno = exception_keeper_lineno_3;

        goto try_except_handler_5;
        // End of try:
        try_end_3:;
        goto try_end_4;
        // Exception handler code:
        try_except_handler_5:;
        exception_keeper_type_4 = exception_type;
        exception_keeper_value_4 = exception_value;
        exception_keeper_tb_4 = exception_tb;
        exception_keeper_lineno_4 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF( tmp_tuple_unpack_1__element_1 );
        tmp_tuple_unpack_1__element_1 = NULL;

        Py_XDECREF( tmp_tuple_unpack_1__element_2 );
        tmp_tuple_unpack_1__element_2 = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_4;
        exception_value = exception_keeper_value_4;
        exception_tb = exception_keeper_tb_4;
        exception_lineno = exception_keeper_lineno_4;

        goto try_except_handler_4;
        // End of try:
        try_end_4:;
        CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
        Py_DECREF( tmp_tuple_unpack_1__source_iter );
        tmp_tuple_unpack_1__source_iter = NULL;

        {
            PyObject *tmp_assign_source_13;
            CHECK_OBJECT( tmp_tuple_unpack_1__element_1 );
            tmp_assign_source_13 = tmp_tuple_unpack_1__element_1;
            {
                PyObject *old = var_first;
                var_first = tmp_assign_source_13;
                Py_INCREF( var_first );
                Py_XDECREF( old );
            }

        }
        Py_XDECREF( tmp_tuple_unpack_1__element_1 );
        tmp_tuple_unpack_1__element_1 = NULL;

        {
            PyObject *tmp_assign_source_14;
            CHECK_OBJECT( tmp_tuple_unpack_1__element_2 );
            tmp_assign_source_14 = tmp_tuple_unpack_1__element_2;
            {
                PyObject *old = var_last;
                var_last = tmp_assign_source_14;
                Py_INCREF( var_last );
                Py_XDECREF( old );
            }

        }
        Py_XDECREF( tmp_tuple_unpack_1__element_2 );
        tmp_tuple_unpack_1__element_2 = NULL;

        {
            PyObject *tmp_called_name_5;
            PyObject *tmp_source_name_13;
            PyObject *tmp_call_result_5;
            PyObject *tmp_args_element_name_7;
            PyObject *tmp_called_name_6;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_args_element_name_8;
            PyObject *tmp_args_element_name_9;
            CHECK_OBJECT( var_addrs );
            tmp_source_name_13 = var_addrs;
            tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_13, const_str_plain_extend );
            if ( tmp_called_name_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 473;
                type_description_1 = "ooooooo";
                goto try_except_handler_4;
            }
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_summarize_address_range );

            if (unlikely( tmp_mvar_value_3 == NULL ))
            {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_summarize_address_range );
            }

            if ( tmp_mvar_value_3 == NULL )
            {
                Py_DECREF( tmp_called_name_5 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "summarize_address_range" );
                exception_tb = NULL;

                exception_lineno = 473;
                type_description_1 = "ooooooo";
                goto try_except_handler_4;
            }

            tmp_called_name_6 = tmp_mvar_value_3;
            CHECK_OBJECT( var_first );
            tmp_args_element_name_8 = var_first;
            CHECK_OBJECT( var_last );
            tmp_args_element_name_9 = var_last;
            frame_60a11b2dd91b774c274871d35d983f3a->m_frame.f_lineno = 473;
            {
                PyObject *call_args[] = { tmp_args_element_name_8, tmp_args_element_name_9 };
                tmp_args_element_name_7 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_6, call_args );
            }

            if ( tmp_args_element_name_7 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_5 );

                exception_lineno = 473;
                type_description_1 = "ooooooo";
                goto try_except_handler_4;
            }
            frame_60a11b2dd91b774c274871d35d983f3a->m_frame.f_lineno = 473;
            {
                PyObject *call_args[] = { tmp_args_element_name_7 };
                tmp_call_result_5 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
            }

            Py_DECREF( tmp_called_name_5 );
            Py_DECREF( tmp_args_element_name_7 );
            if ( tmp_call_result_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 473;
                type_description_1 = "ooooooo";
                goto try_except_handler_4;
            }
            Py_DECREF( tmp_call_result_5 );
        }
        if ( CONSIDER_THREADING() == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 472;
            type_description_1 = "ooooooo";
            goto try_except_handler_4;
        }
        goto loop_start_2;
        loop_end_2:;
        goto try_end_5;
        // Exception handler code:
        try_except_handler_4:;
        exception_keeper_type_5 = exception_type;
        exception_keeper_value_5 = exception_value;
        exception_keeper_tb_5 = exception_tb;
        exception_keeper_lineno_5 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF( tmp_for_loop_2__iter_value );
        tmp_for_loop_2__iter_value = NULL;

        CHECK_OBJECT( (PyObject *)tmp_for_loop_2__for_iterator );
        Py_DECREF( tmp_for_loop_2__for_iterator );
        tmp_for_loop_2__for_iterator = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_5;
        exception_value = exception_keeper_value_5;
        exception_tb = exception_keeper_tb_5;
        exception_lineno = exception_keeper_lineno_5;

        goto frame_exception_exit_1;
        // End of try:
        try_end_5:;
        Py_XDECREF( tmp_for_loop_2__iter_value );
        tmp_for_loop_2__iter_value = NULL;

        CHECK_OBJECT( (PyObject *)tmp_for_loop_2__for_iterator );
        Py_DECREF( tmp_for_loop_2__for_iterator );
        tmp_for_loop_2__for_iterator = NULL;

        branch_no_7:;
    }
    {
        PyObject *tmp_called_name_7;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_left_name_4;
        PyObject *tmp_right_name_4;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__collapse_addresses_internal );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__collapse_addresses_internal );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_collapse_addresses_internal" );
            exception_tb = NULL;

            exception_lineno = 475;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_7 = tmp_mvar_value_4;
        CHECK_OBJECT( var_addrs );
        tmp_left_name_4 = var_addrs;
        CHECK_OBJECT( var_nets );
        tmp_right_name_4 = var_nets;
        tmp_args_element_name_10 = BINARY_OPERATION_ADD_LIST_LIST( tmp_left_name_4, tmp_right_name_4 );
        assert( !(tmp_args_element_name_10 == NULL) );
        frame_60a11b2dd91b774c274871d35d983f3a->m_frame.f_lineno = 475;
        {
            PyObject *call_args[] = { tmp_args_element_name_10 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_7, call_args );
        }

        Py_DECREF( tmp_args_element_name_10 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 475;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 1
    RESTORE_FRAME_EXCEPTION( frame_60a11b2dd91b774c274871d35d983f3a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_60a11b2dd91b774c274871d35d983f3a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_60a11b2dd91b774c274871d35d983f3a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_60a11b2dd91b774c274871d35d983f3a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_60a11b2dd91b774c274871d35d983f3a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_60a11b2dd91b774c274871d35d983f3a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_60a11b2dd91b774c274871d35d983f3a,
        type_description_1,
        par_addresses,
        var_last,
        var_ip,
        var_ips,
        var_addrs,
        var_nets,
        var_first
    );


    // Release cached frame.
    if ( frame_60a11b2dd91b774c274871d35d983f3a == cache_frame_60a11b2dd91b774c274871d35d983f3a )
    {
        Py_DECREF( frame_60a11b2dd91b774c274871d35d983f3a );
    }
    cache_frame_60a11b2dd91b774c274871d35d983f3a = NULL;

    assertFrameObject( frame_60a11b2dd91b774c274871d35d983f3a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_23_collapse_addresses );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_last );
    var_last = NULL;

    CHECK_OBJECT( (PyObject *)par_addresses );
    Py_DECREF( par_addresses );
    par_addresses = NULL;

    Py_XDECREF( var_ip );
    var_ip = NULL;

    CHECK_OBJECT( (PyObject *)var_ips );
    Py_DECREF( var_ips );
    var_ips = NULL;

    CHECK_OBJECT( (PyObject *)var_addrs );
    Py_DECREF( var_addrs );
    var_addrs = NULL;

    CHECK_OBJECT( (PyObject *)var_nets );
    Py_DECREF( var_nets );
    var_nets = NULL;

    Py_XDECREF( var_first );
    var_first = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_6 = exception_type;
    exception_keeper_value_6 = exception_value;
    exception_keeper_tb_6 = exception_tb;
    exception_keeper_lineno_6 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_last );
    var_last = NULL;

    CHECK_OBJECT( (PyObject *)par_addresses );
    Py_DECREF( par_addresses );
    par_addresses = NULL;

    Py_XDECREF( var_ip );
    var_ip = NULL;

    CHECK_OBJECT( (PyObject *)var_ips );
    Py_DECREF( var_ips );
    var_ips = NULL;

    CHECK_OBJECT( (PyObject *)var_addrs );
    Py_DECREF( var_addrs );
    var_addrs = NULL;

    CHECK_OBJECT( (PyObject *)var_nets );
    Py_DECREF( var_nets );
    var_nets = NULL;

    Py_XDECREF( var_first );
    var_first = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_6;
    exception_value = exception_keeper_value_6;
    exception_tb = exception_keeper_tb_6;
    exception_lineno = exception_keeper_lineno_6;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_23_collapse_addresses );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_24_get_mixed_type_key( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_obj = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_8d3c219bed018f80d348d948e64e2a26;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_8d3c219bed018f80d348d948e64e2a26 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8d3c219bed018f80d348d948e64e2a26, codeobj_8d3c219bed018f80d348d948e64e2a26, module_ipaddress, sizeof(void *) );
    frame_8d3c219bed018f80d348d948e64e2a26 = cache_frame_8d3c219bed018f80d348d948e64e2a26;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8d3c219bed018f80d348d948e64e2a26 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8d3c219bed018f80d348d948e64e2a26 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_obj );
        tmp_isinstance_inst_1 = par_obj;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__BaseNetwork );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__BaseNetwork );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_BaseNetwork" );
            exception_tb = NULL;

            exception_lineno = 496;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 496;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_instance_1;
            CHECK_OBJECT( par_obj );
            tmp_called_instance_1 = par_obj;
            frame_8d3c219bed018f80d348d948e64e2a26->m_frame.f_lineno = 497;
            tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain__get_networks_key );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 497;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_isinstance_inst_2;
            PyObject *tmp_isinstance_cls_2;
            PyObject *tmp_mvar_value_2;
            CHECK_OBJECT( par_obj );
            tmp_isinstance_inst_2 = par_obj;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__BaseAddress );

            if (unlikely( tmp_mvar_value_2 == NULL ))
            {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__BaseAddress );
            }

            if ( tmp_mvar_value_2 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_BaseAddress" );
                exception_tb = NULL;

                exception_lineno = 498;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }

            tmp_isinstance_cls_2 = tmp_mvar_value_2;
            tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 498;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_called_instance_2;
                CHECK_OBJECT( par_obj );
                tmp_called_instance_2 = par_obj;
                frame_8d3c219bed018f80d348d948e64e2a26->m_frame.f_lineno = 499;
                tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain__get_address_key );
                if ( tmp_return_value == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 499;
                    type_description_1 = "o";
                    goto frame_exception_exit_1;
                }
                goto frame_return_exit_1;
            }
            branch_no_2:;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8d3c219bed018f80d348d948e64e2a26 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_8d3c219bed018f80d348d948e64e2a26 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8d3c219bed018f80d348d948e64e2a26 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8d3c219bed018f80d348d948e64e2a26, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8d3c219bed018f80d348d948e64e2a26->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8d3c219bed018f80d348d948e64e2a26, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8d3c219bed018f80d348d948e64e2a26,
        type_description_1,
        par_obj
    );


    // Release cached frame.
    if ( frame_8d3c219bed018f80d348d948e64e2a26 == cache_frame_8d3c219bed018f80d348d948e64e2a26 )
    {
        Py_DECREF( frame_8d3c219bed018f80d348d948e64e2a26 );
    }
    cache_frame_8d3c219bed018f80d348d948e64e2a26 = NULL;

    assertFrameObject( frame_8d3c219bed018f80d348d948e64e2a26 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_NotImplemented;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_24_get_mixed_type_key );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_obj );
    Py_DECREF( par_obj );
    par_obj = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_obj );
    Py_DECREF( par_obj );
    par_obj = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_24_get_mixed_type_key );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_25_exploded( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_e93d5bcbbebcc474c506583b2262be27;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_e93d5bcbbebcc474c506583b2262be27 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e93d5bcbbebcc474c506583b2262be27, codeobj_e93d5bcbbebcc474c506583b2262be27, module_ipaddress, sizeof(void *) );
    frame_e93d5bcbbebcc474c506583b2262be27 = cache_frame_e93d5bcbbebcc474c506583b2262be27;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e93d5bcbbebcc474c506583b2262be27 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e93d5bcbbebcc474c506583b2262be27 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        frame_e93d5bcbbebcc474c506583b2262be27->m_frame.f_lineno = 512;
        tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain__explode_shorthand_ip_string );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 512;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e93d5bcbbebcc474c506583b2262be27 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_e93d5bcbbebcc474c506583b2262be27 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e93d5bcbbebcc474c506583b2262be27 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e93d5bcbbebcc474c506583b2262be27, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e93d5bcbbebcc474c506583b2262be27->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e93d5bcbbebcc474c506583b2262be27, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e93d5bcbbebcc474c506583b2262be27,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_e93d5bcbbebcc474c506583b2262be27 == cache_frame_e93d5bcbbebcc474c506583b2262be27 )
    {
        Py_DECREF( frame_e93d5bcbbebcc474c506583b2262be27 );
    }
    cache_frame_e93d5bcbbebcc474c506583b2262be27 = NULL;

    assertFrameObject( frame_e93d5bcbbebcc474c506583b2262be27 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_25_exploded );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_25_exploded );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_26_compressed( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_93f2eac4eb7c93371ce23e334a4e29f2;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_93f2eac4eb7c93371ce23e334a4e29f2 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_93f2eac4eb7c93371ce23e334a4e29f2, codeobj_93f2eac4eb7c93371ce23e334a4e29f2, module_ipaddress, sizeof(void *) );
    frame_93f2eac4eb7c93371ce23e334a4e29f2 = cache_frame_93f2eac4eb7c93371ce23e334a4e29f2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_93f2eac4eb7c93371ce23e334a4e29f2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_93f2eac4eb7c93371ce23e334a4e29f2 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_str );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__compat_str );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_compat_str" );
            exception_tb = NULL;

            exception_lineno = 517;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_self );
        tmp_args_element_name_1 = par_self;
        frame_93f2eac4eb7c93371ce23e334a4e29f2->m_frame.f_lineno = 517;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 517;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_93f2eac4eb7c93371ce23e334a4e29f2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_93f2eac4eb7c93371ce23e334a4e29f2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_93f2eac4eb7c93371ce23e334a4e29f2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_93f2eac4eb7c93371ce23e334a4e29f2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_93f2eac4eb7c93371ce23e334a4e29f2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_93f2eac4eb7c93371ce23e334a4e29f2, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_93f2eac4eb7c93371ce23e334a4e29f2,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_93f2eac4eb7c93371ce23e334a4e29f2 == cache_frame_93f2eac4eb7c93371ce23e334a4e29f2 )
    {
        Py_DECREF( frame_93f2eac4eb7c93371ce23e334a4e29f2 );
    }
    cache_frame_93f2eac4eb7c93371ce23e334a4e29f2 = NULL;

    assertFrameObject( frame_93f2eac4eb7c93371ce23e334a4e29f2 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_26_compressed );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_26_compressed );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_27_reverse_pointer( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_0049438ffc60200b97a4b97bbed5f67d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_0049438ffc60200b97a4b97bbed5f67d = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0049438ffc60200b97a4b97bbed5f67d, codeobj_0049438ffc60200b97a4b97bbed5f67d, module_ipaddress, sizeof(void *) );
    frame_0049438ffc60200b97a4b97bbed5f67d = cache_frame_0049438ffc60200b97a4b97bbed5f67d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0049438ffc60200b97a4b97bbed5f67d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0049438ffc60200b97a4b97bbed5f67d ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        frame_0049438ffc60200b97a4b97bbed5f67d->m_frame.f_lineno = 528;
        tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain__reverse_pointer );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 528;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0049438ffc60200b97a4b97bbed5f67d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_0049438ffc60200b97a4b97bbed5f67d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0049438ffc60200b97a4b97bbed5f67d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0049438ffc60200b97a4b97bbed5f67d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0049438ffc60200b97a4b97bbed5f67d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0049438ffc60200b97a4b97bbed5f67d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0049438ffc60200b97a4b97bbed5f67d,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_0049438ffc60200b97a4b97bbed5f67d == cache_frame_0049438ffc60200b97a4b97bbed5f67d )
    {
        Py_DECREF( frame_0049438ffc60200b97a4b97bbed5f67d );
    }
    cache_frame_0049438ffc60200b97a4b97bbed5f67d = NULL;

    assertFrameObject( frame_0049438ffc60200b97a4b97bbed5f67d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_27_reverse_pointer );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_27_reverse_pointer );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_28_version( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_msg = NULL;
    struct Nuitka_FrameObject *frame_ca89dae17c23af9c1e2595574e987d31;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_ca89dae17c23af9c1e2595574e987d31 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ca89dae17c23af9c1e2595574e987d31, codeobj_ca89dae17c23af9c1e2595574e987d31, module_ipaddress, sizeof(void *)+sizeof(void *) );
    frame_ca89dae17c23af9c1e2595574e987d31 = cache_frame_ca89dae17c23af9c1e2595574e987d31;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ca89dae17c23af9c1e2595574e987d31 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ca89dae17c23af9c1e2595574e987d31 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_type_arg_1;
        tmp_left_name_1 = const_unicode_digest_faf8e5c5460d2a31764ac224ef24fa52;
        CHECK_OBJECT( par_self );
        tmp_type_arg_1 = par_self;
        tmp_tuple_element_1 = BUILTIN_TYPE1( tmp_type_arg_1 );
        assert( !(tmp_tuple_element_1 == NULL) );
        tmp_right_name_1 = PyTuple_New( 1 );
        PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
        tmp_assign_source_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_right_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 532;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert( var_msg == NULL );
        var_msg = tmp_assign_source_1;
    }
    {
        PyObject *tmp_raise_type_1;
        PyObject *tmp_make_exception_arg_1;
        CHECK_OBJECT( var_msg );
        tmp_make_exception_arg_1 = var_msg;
        frame_ca89dae17c23af9c1e2595574e987d31->m_frame.f_lineno = 533;
        {
            PyObject *call_args[] = { tmp_make_exception_arg_1 };
            tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_NotImplementedError, call_args );
        }

        assert( !(tmp_raise_type_1 == NULL) );
        exception_type = tmp_raise_type_1;
        exception_lineno = 533;
        RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ca89dae17c23af9c1e2595574e987d31 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ca89dae17c23af9c1e2595574e987d31 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ca89dae17c23af9c1e2595574e987d31, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ca89dae17c23af9c1e2595574e987d31->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ca89dae17c23af9c1e2595574e987d31, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ca89dae17c23af9c1e2595574e987d31,
        type_description_1,
        par_self,
        var_msg
    );


    // Release cached frame.
    if ( frame_ca89dae17c23af9c1e2595574e987d31 == cache_frame_ca89dae17c23af9c1e2595574e987d31 )
    {
        Py_DECREF( frame_ca89dae17c23af9c1e2595574e987d31 );
    }
    cache_frame_ca89dae17c23af9c1e2595574e987d31 = NULL;

    assertFrameObject( frame_ca89dae17c23af9c1e2595574e987d31 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_28_version );
    return NULL;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_msg );
    var_msg = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_28_version );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

}


static PyObject *impl_ipaddress$$$function_29__check_int_address( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_address = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_67e26f96837097bd24506e72e861d756;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    int tmp_res;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_67e26f96837097bd24506e72e861d756 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_67e26f96837097bd24506e72e861d756, codeobj_67e26f96837097bd24506e72e861d756, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_67e26f96837097bd24506e72e861d756 = cache_frame_67e26f96837097bd24506e72e861d756;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_67e26f96837097bd24506e72e861d756 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_67e26f96837097bd24506e72e861d756 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( par_address );
        tmp_compexpr_left_1 = par_address;
        tmp_compexpr_right_1 = const_int_0;
        tmp_res = RICH_COMPARE_BOOL_LT_OBJECT_INT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 536;
            type_description_1 = "ooN";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_called_name_1;
            PyObject *tmp_mvar_value_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            PyObject *tmp_tuple_element_1;
            PyObject *tmp_source_name_1;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_AddressValueError );

            if (unlikely( tmp_mvar_value_1 == NULL ))
            {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AddressValueError );
            }

            if ( tmp_mvar_value_1 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "AddressValueError" );
                exception_tb = NULL;

                exception_lineno = 538;
                type_description_1 = "ooN";
                goto frame_exception_exit_1;
            }

            tmp_called_name_1 = tmp_mvar_value_1;
            tmp_left_name_1 = const_unicode_digest_6fd026f58df80ebafc0af41197edbd33;
            CHECK_OBJECT( par_address );
            tmp_tuple_element_1 = par_address;
            tmp_right_name_1 = PyTuple_New( 2 );
            Py_INCREF( tmp_tuple_element_1 );
            PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
            CHECK_OBJECT( par_self );
            tmp_source_name_1 = par_self;
            tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__version );
            if ( tmp_tuple_element_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_right_name_1 );

                exception_lineno = 538;
                type_description_1 = "ooN";
                goto frame_exception_exit_1;
            }
            PyTuple_SET_ITEM( tmp_right_name_1, 1, tmp_tuple_element_1 );
            tmp_args_element_name_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
            Py_DECREF( tmp_right_name_1 );
            if ( tmp_args_element_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 538;
                type_description_1 = "ooN";
                goto frame_exception_exit_1;
            }
            frame_67e26f96837097bd24506e72e861d756->m_frame.f_lineno = 538;
            {
                PyObject *call_args[] = { tmp_args_element_name_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
            }

            Py_DECREF( tmp_args_element_name_1 );
            if ( tmp_raise_type_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 538;
                type_description_1 = "ooN";
                goto frame_exception_exit_1;
            }
            exception_type = tmp_raise_type_1;
            exception_lineno = 538;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooN";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( par_address );
        tmp_compexpr_left_2 = par_address;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ALL_ONES );
        if ( tmp_compexpr_right_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 539;
            type_description_1 = "ooN";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_GT_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        Py_DECREF( tmp_compexpr_right_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 539;
            type_description_1 = "ooN";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_called_name_2;
            PyObject *tmp_mvar_value_2;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_left_name_2;
            PyObject *tmp_right_name_2;
            PyObject *tmp_tuple_element_2;
            PyObject *tmp_source_name_3;
            PyObject *tmp_source_name_4;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_AddressValueError );

            if (unlikely( tmp_mvar_value_2 == NULL ))
            {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AddressValueError );
            }

            if ( tmp_mvar_value_2 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "AddressValueError" );
                exception_tb = NULL;

                exception_lineno = 541;
                type_description_1 = "ooN";
                goto frame_exception_exit_1;
            }

            tmp_called_name_2 = tmp_mvar_value_2;
            tmp_left_name_2 = const_unicode_digest_98c89e98d08dd7d28bf0635a719bf24d;
            CHECK_OBJECT( par_address );
            tmp_tuple_element_2 = par_address;
            tmp_right_name_2 = PyTuple_New( 3 );
            Py_INCREF( tmp_tuple_element_2 );
            PyTuple_SET_ITEM( tmp_right_name_2, 0, tmp_tuple_element_2 );
            CHECK_OBJECT( par_self );
            tmp_source_name_3 = par_self;
            tmp_tuple_element_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__max_prefixlen );
            if ( tmp_tuple_element_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_right_name_2 );

                exception_lineno = 541;
                type_description_1 = "ooN";
                goto frame_exception_exit_1;
            }
            PyTuple_SET_ITEM( tmp_right_name_2, 1, tmp_tuple_element_2 );
            CHECK_OBJECT( par_self );
            tmp_source_name_4 = par_self;
            tmp_tuple_element_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__version );
            if ( tmp_tuple_element_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_right_name_2 );

                exception_lineno = 542;
                type_description_1 = "ooN";
                goto frame_exception_exit_1;
            }
            PyTuple_SET_ITEM( tmp_right_name_2, 2, tmp_tuple_element_2 );
            tmp_args_element_name_2 = BINARY_OPERATION_REMAINDER( tmp_left_name_2, tmp_right_name_2 );
            Py_DECREF( tmp_right_name_2 );
            if ( tmp_args_element_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 541;
                type_description_1 = "ooN";
                goto frame_exception_exit_1;
            }
            frame_67e26f96837097bd24506e72e861d756->m_frame.f_lineno = 541;
            {
                PyObject *call_args[] = { tmp_args_element_name_2 };
                tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
            }

            Py_DECREF( tmp_args_element_name_2 );
            if ( tmp_raise_type_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 541;
                type_description_1 = "ooN";
                goto frame_exception_exit_1;
            }
            exception_type = tmp_raise_type_2;
            exception_lineno = 541;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooN";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_67e26f96837097bd24506e72e861d756 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_67e26f96837097bd24506e72e861d756 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_67e26f96837097bd24506e72e861d756, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_67e26f96837097bd24506e72e861d756->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_67e26f96837097bd24506e72e861d756, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_67e26f96837097bd24506e72e861d756,
        type_description_1,
        par_self,
        par_address,
        NULL
    );


    // Release cached frame.
    if ( frame_67e26f96837097bd24506e72e861d756 == cache_frame_67e26f96837097bd24506e72e861d756 )
    {
        Py_DECREF( frame_67e26f96837097bd24506e72e861d756 );
    }
    cache_frame_67e26f96837097bd24506e72e861d756 = NULL;

    assertFrameObject( frame_67e26f96837097bd24506e72e861d756 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_29__check_int_address );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_address );
    Py_DECREF( par_address );
    par_address = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_address );
    Py_DECREF( par_address );
    par_address = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_29__check_int_address );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_30__check_packed_address( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_address = python_pars[ 1 ];
    PyObject *par_expected_len = python_pars[ 2 ];
    PyObject *var_address_len = NULL;
    struct Nuitka_FrameObject *frame_2f1cce2dd9f99f279577e205f1e726fe;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_2f1cce2dd9f99f279577e205f1e726fe = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2f1cce2dd9f99f279577e205f1e726fe, codeobj_2f1cce2dd9f99f279577e205f1e726fe, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_2f1cce2dd9f99f279577e205f1e726fe = cache_frame_2f1cce2dd9f99f279577e205f1e726fe;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2f1cce2dd9f99f279577e205f1e726fe );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2f1cce2dd9f99f279577e205f1e726fe ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_len_arg_1;
        CHECK_OBJECT( par_address );
        tmp_len_arg_1 = par_address;
        tmp_assign_source_1 = BUILTIN_LEN( tmp_len_arg_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 545;
            type_description_1 = "oooNo";
            goto frame_exception_exit_1;
        }
        assert( var_address_len == NULL );
        var_address_len = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( var_address_len );
        tmp_compexpr_left_1 = var_address_len;
        CHECK_OBJECT( par_expected_len );
        tmp_compexpr_right_1 = par_expected_len;
        tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 546;
            type_description_1 = "oooNo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_called_name_1;
            PyObject *tmp_mvar_value_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            PyObject *tmp_tuple_element_1;
            PyObject *tmp_source_name_1;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_AddressValueError );

            if (unlikely( tmp_mvar_value_1 == NULL ))
            {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AddressValueError );
            }

            if ( tmp_mvar_value_1 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "AddressValueError" );
                exception_tb = NULL;

                exception_lineno = 552;
                type_description_1 = "oooNo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_1 = tmp_mvar_value_1;
            tmp_left_name_1 = const_unicode_digest_57ad7c388c09157d6398d6e4e29b2ea6;
            CHECK_OBJECT( par_address );
            tmp_tuple_element_1 = par_address;
            tmp_right_name_1 = PyTuple_New( 4 );
            Py_INCREF( tmp_tuple_element_1 );
            PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
            CHECK_OBJECT( var_address_len );
            tmp_tuple_element_1 = var_address_len;
            Py_INCREF( tmp_tuple_element_1 );
            PyTuple_SET_ITEM( tmp_right_name_1, 1, tmp_tuple_element_1 );
            CHECK_OBJECT( par_expected_len );
            tmp_tuple_element_1 = par_expected_len;
            Py_INCREF( tmp_tuple_element_1 );
            PyTuple_SET_ITEM( tmp_right_name_1, 2, tmp_tuple_element_1 );
            CHECK_OBJECT( par_self );
            tmp_source_name_1 = par_self;
            tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__version );
            if ( tmp_tuple_element_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_right_name_1 );

                exception_lineno = 553;
                type_description_1 = "oooNo";
                goto frame_exception_exit_1;
            }
            PyTuple_SET_ITEM( tmp_right_name_1, 3, tmp_tuple_element_1 );
            tmp_args_element_name_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
            Py_DECREF( tmp_right_name_1 );
            if ( tmp_args_element_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 552;
                type_description_1 = "oooNo";
                goto frame_exception_exit_1;
            }
            frame_2f1cce2dd9f99f279577e205f1e726fe->m_frame.f_lineno = 552;
            {
                PyObject *call_args[] = { tmp_args_element_name_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
            }

            Py_DECREF( tmp_args_element_name_1 );
            if ( tmp_raise_type_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 552;
                type_description_1 = "oooNo";
                goto frame_exception_exit_1;
            }
            exception_type = tmp_raise_type_1;
            exception_lineno = 552;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooNo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2f1cce2dd9f99f279577e205f1e726fe );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2f1cce2dd9f99f279577e205f1e726fe );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2f1cce2dd9f99f279577e205f1e726fe, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2f1cce2dd9f99f279577e205f1e726fe->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2f1cce2dd9f99f279577e205f1e726fe, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2f1cce2dd9f99f279577e205f1e726fe,
        type_description_1,
        par_self,
        par_address,
        par_expected_len,
        NULL,
        var_address_len
    );


    // Release cached frame.
    if ( frame_2f1cce2dd9f99f279577e205f1e726fe == cache_frame_2f1cce2dd9f99f279577e205f1e726fe )
    {
        Py_DECREF( frame_2f1cce2dd9f99f279577e205f1e726fe );
    }
    cache_frame_2f1cce2dd9f99f279577e205f1e726fe = NULL;

    assertFrameObject( frame_2f1cce2dd9f99f279577e205f1e726fe );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_30__check_packed_address );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_expected_len );
    Py_DECREF( par_expected_len );
    par_expected_len = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_address_len );
    Py_DECREF( var_address_len );
    var_address_len = NULL;

    CHECK_OBJECT( (PyObject *)par_address );
    Py_DECREF( par_address );
    par_address = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_expected_len );
    Py_DECREF( par_expected_len );
    par_expected_len = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_address_len );
    var_address_len = NULL;

    CHECK_OBJECT( (PyObject *)par_address );
    Py_DECREF( par_address );
    par_address = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_30__check_packed_address );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_31__ip_int_from_prefix( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_prefixlen = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_66965efd84eb1c5142457e86e95209e3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_66965efd84eb1c5142457e86e95209e3 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_66965efd84eb1c5142457e86e95209e3, codeobj_66965efd84eb1c5142457e86e95209e3, module_ipaddress, sizeof(void *)+sizeof(void *) );
    frame_66965efd84eb1c5142457e86e95209e3 = cache_frame_66965efd84eb1c5142457e86e95209e3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_66965efd84eb1c5142457e86e95209e3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_66965efd84eb1c5142457e86e95209e3 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_right_name_2;
        CHECK_OBJECT( par_cls );
        tmp_source_name_1 = par_cls;
        tmp_left_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__ALL_ONES );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 566;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_cls );
        tmp_source_name_2 = par_cls;
        tmp_left_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ALL_ONES );
        if ( tmp_left_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_left_name_1 );

            exception_lineno = 566;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_prefixlen );
        tmp_right_name_2 = par_prefixlen;
        tmp_right_name_1 = BINARY_OPERATION( PyNumber_Rshift, tmp_left_name_2, tmp_right_name_2 );
        Py_DECREF( tmp_left_name_2 );
        if ( tmp_right_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_left_name_1 );

            exception_lineno = 566;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = BINARY_OPERATION( PyNumber_Xor, tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_left_name_1 );
        Py_DECREF( tmp_right_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 566;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_66965efd84eb1c5142457e86e95209e3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_66965efd84eb1c5142457e86e95209e3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_66965efd84eb1c5142457e86e95209e3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_66965efd84eb1c5142457e86e95209e3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_66965efd84eb1c5142457e86e95209e3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_66965efd84eb1c5142457e86e95209e3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_66965efd84eb1c5142457e86e95209e3,
        type_description_1,
        par_cls,
        par_prefixlen
    );


    // Release cached frame.
    if ( frame_66965efd84eb1c5142457e86e95209e3 == cache_frame_66965efd84eb1c5142457e86e95209e3 )
    {
        Py_DECREF( frame_66965efd84eb1c5142457e86e95209e3 );
    }
    cache_frame_66965efd84eb1c5142457e86e95209e3 = NULL;

    assertFrameObject( frame_66965efd84eb1c5142457e86e95209e3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_31__ip_int_from_prefix );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_prefixlen );
    Py_DECREF( par_prefixlen );
    par_prefixlen = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_prefixlen );
    Py_DECREF( par_prefixlen );
    par_prefixlen = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_31__ip_int_from_prefix );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_32__prefix_from_ip_int( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_ip_int = python_pars[ 1 ];
    PyObject *var_leading_ones = NULL;
    PyObject *var_byteslen = NULL;
    PyObject *var_trailing_zeroes = NULL;
    PyObject *var_all_ones = NULL;
    PyObject *var_details = NULL;
    PyObject *var_prefixlen = NULL;
    struct Nuitka_FrameObject *frame_81a497c5e641cb3dbfc1edaf5d4d15ad;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_81a497c5e641cb3dbfc1edaf5d4d15ad = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_81a497c5e641cb3dbfc1edaf5d4d15ad, codeobj_81a497c5e641cb3dbfc1edaf5d4d15ad, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_81a497c5e641cb3dbfc1edaf5d4d15ad = cache_frame_81a497c5e641cb3dbfc1edaf5d4d15ad;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_81a497c5e641cb3dbfc1edaf5d4d15ad );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_81a497c5e641cb3dbfc1edaf5d4d15ad ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__count_righthand_zero_bits );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__count_righthand_zero_bits );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_count_righthand_zero_bits" );
            exception_tb = NULL;

            exception_lineno = 581;
            type_description_1 = "oooooNooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_ip_int );
        tmp_args_element_name_1 = par_ip_int;
        CHECK_OBJECT( par_cls );
        tmp_source_name_1 = par_cls;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__max_prefixlen );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 582;
            type_description_1 = "oooooNooo";
            goto frame_exception_exit_1;
        }
        frame_81a497c5e641cb3dbfc1edaf5d4d15ad->m_frame.f_lineno = 581;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 581;
            type_description_1 = "oooooNooo";
            goto frame_exception_exit_1;
        }
        assert( var_trailing_zeroes == NULL );
        var_trailing_zeroes = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_left_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_right_name_1;
        CHECK_OBJECT( par_cls );
        tmp_source_name_2 = par_cls;
        tmp_left_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__max_prefixlen );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 583;
            type_description_1 = "oooooNooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_trailing_zeroes );
        tmp_right_name_1 = var_trailing_zeroes;
        tmp_assign_source_2 = BINARY_OPERATION_SUB( tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_left_name_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 583;
            type_description_1 = "oooooNooo";
            goto frame_exception_exit_1;
        }
        assert( var_prefixlen == NULL );
        var_prefixlen = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_2;
        CHECK_OBJECT( par_ip_int );
        tmp_left_name_2 = par_ip_int;
        CHECK_OBJECT( var_trailing_zeroes );
        tmp_right_name_2 = var_trailing_zeroes;
        tmp_assign_source_3 = BINARY_OPERATION( PyNumber_Rshift, tmp_left_name_2, tmp_right_name_2 );
        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 584;
            type_description_1 = "oooooNooo";
            goto frame_exception_exit_1;
        }
        assert( var_leading_ones == NULL );
        var_leading_ones = tmp_assign_source_3;
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_left_name_3;
        PyObject *tmp_left_name_4;
        PyObject *tmp_right_name_3;
        PyObject *tmp_right_name_4;
        tmp_left_name_4 = const_int_pos_1;
        CHECK_OBJECT( var_prefixlen );
        tmp_right_name_3 = var_prefixlen;
        tmp_left_name_3 = BINARY_OPERATION( PyNumber_Lshift, tmp_left_name_4, tmp_right_name_3 );
        if ( tmp_left_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 585;
            type_description_1 = "oooooNooo";
            goto frame_exception_exit_1;
        }
        tmp_right_name_4 = const_int_pos_1;
        tmp_assign_source_4 = BINARY_OPERATION_SUB( tmp_left_name_3, tmp_right_name_4 );
        Py_DECREF( tmp_left_name_3 );
        if ( tmp_assign_source_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 585;
            type_description_1 = "oooooNooo";
            goto frame_exception_exit_1;
        }
        assert( var_all_ones == NULL );
        var_all_ones = tmp_assign_source_4;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( var_leading_ones );
        tmp_compexpr_left_1 = var_leading_ones;
        CHECK_OBJECT( var_all_ones );
        tmp_compexpr_right_1 = var_all_ones;
        tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 586;
            type_description_1 = "oooooNooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_5;
            PyObject *tmp_left_name_5;
            PyObject *tmp_source_name_3;
            PyObject *tmp_right_name_5;
            CHECK_OBJECT( par_cls );
            tmp_source_name_3 = par_cls;
            tmp_left_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__max_prefixlen );
            if ( tmp_left_name_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 587;
                type_description_1 = "oooooNooo";
                goto frame_exception_exit_1;
            }
            tmp_right_name_5 = const_int_pos_8;
            tmp_assign_source_5 = BINARY_OPERATION_FLOORDIV( tmp_left_name_5, tmp_right_name_5 );
            Py_DECREF( tmp_left_name_5 );
            if ( tmp_assign_source_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 587;
                type_description_1 = "oooooNooo";
                goto frame_exception_exit_1;
            }
            assert( var_byteslen == NULL );
            var_byteslen = tmp_assign_source_5;
        }
        {
            PyObject *tmp_assign_source_6;
            PyObject *tmp_called_name_2;
            PyObject *tmp_mvar_value_2;
            PyObject *tmp_args_element_name_3;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_args_element_name_5;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_to_bytes );

            if (unlikely( tmp_mvar_value_2 == NULL ))
            {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__compat_to_bytes );
            }

            if ( tmp_mvar_value_2 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_compat_to_bytes" );
                exception_tb = NULL;

                exception_lineno = 588;
                type_description_1 = "oooooNooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_2 = tmp_mvar_value_2;
            CHECK_OBJECT( par_ip_int );
            tmp_args_element_name_3 = par_ip_int;
            CHECK_OBJECT( var_byteslen );
            tmp_args_element_name_4 = var_byteslen;
            tmp_args_element_name_5 = const_unicode_plain_big;
            frame_81a497c5e641cb3dbfc1edaf5d4d15ad->m_frame.f_lineno = 588;
            {
                PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5 };
                tmp_assign_source_6 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_2, call_args );
            }

            if ( tmp_assign_source_6 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 588;
                type_description_1 = "oooooNooo";
                goto frame_exception_exit_1;
            }
            assert( var_details == NULL );
            var_details = tmp_assign_source_6;
        }
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            PyObject *tmp_left_name_6;
            PyObject *tmp_right_name_6;
            tmp_left_name_6 = const_unicode_digest_5381a247d80f448053c8b52e061aecc0;
            CHECK_OBJECT( var_details );
            tmp_right_name_6 = var_details;
            tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_6, tmp_right_name_6 );
            if ( tmp_make_exception_arg_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 590;
                type_description_1 = "oooooNooo";
                goto frame_exception_exit_1;
            }
            frame_81a497c5e641cb3dbfc1edaf5d4d15ad->m_frame.f_lineno = 590;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            Py_DECREF( tmp_make_exception_arg_1 );
            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 590;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooooNooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_81a497c5e641cb3dbfc1edaf5d4d15ad );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_81a497c5e641cb3dbfc1edaf5d4d15ad );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_81a497c5e641cb3dbfc1edaf5d4d15ad, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_81a497c5e641cb3dbfc1edaf5d4d15ad->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_81a497c5e641cb3dbfc1edaf5d4d15ad, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_81a497c5e641cb3dbfc1edaf5d4d15ad,
        type_description_1,
        par_cls,
        par_ip_int,
        var_leading_ones,
        var_byteslen,
        var_trailing_zeroes,
        NULL,
        var_all_ones,
        var_details,
        var_prefixlen
    );


    // Release cached frame.
    if ( frame_81a497c5e641cb3dbfc1edaf5d4d15ad == cache_frame_81a497c5e641cb3dbfc1edaf5d4d15ad )
    {
        Py_DECREF( frame_81a497c5e641cb3dbfc1edaf5d4d15ad );
    }
    cache_frame_81a497c5e641cb3dbfc1edaf5d4d15ad = NULL;

    assertFrameObject( frame_81a497c5e641cb3dbfc1edaf5d4d15ad );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_prefixlen );
    tmp_return_value = var_prefixlen;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_32__prefix_from_ip_int );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_leading_ones );
    Py_DECREF( var_leading_ones );
    var_leading_ones = NULL;

    CHECK_OBJECT( (PyObject *)var_trailing_zeroes );
    Py_DECREF( var_trailing_zeroes );
    var_trailing_zeroes = NULL;

    CHECK_OBJECT( (PyObject *)var_all_ones );
    Py_DECREF( var_all_ones );
    var_all_ones = NULL;

    CHECK_OBJECT( (PyObject *)par_ip_int );
    Py_DECREF( par_ip_int );
    par_ip_int = NULL;

    CHECK_OBJECT( (PyObject *)var_prefixlen );
    Py_DECREF( var_prefixlen );
    var_prefixlen = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_leading_ones );
    var_leading_ones = NULL;

    Py_XDECREF( var_byteslen );
    var_byteslen = NULL;

    Py_XDECREF( var_trailing_zeroes );
    var_trailing_zeroes = NULL;

    Py_XDECREF( var_all_ones );
    var_all_ones = NULL;

    Py_XDECREF( var_details );
    var_details = NULL;

    CHECK_OBJECT( (PyObject *)par_ip_int );
    Py_DECREF( par_ip_int );
    par_ip_int = NULL;

    Py_XDECREF( var_prefixlen );
    var_prefixlen = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_32__prefix_from_ip_int );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_33__report_invalid_netmask( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_netmask_str = python_pars[ 1 ];
    PyObject *var_msg = NULL;
    struct Nuitka_FrameObject *frame_00ee5b6806ca20bcda5fb1846ff2fa87;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_00ee5b6806ca20bcda5fb1846ff2fa87 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_00ee5b6806ca20bcda5fb1846ff2fa87, codeobj_00ee5b6806ca20bcda5fb1846ff2fa87, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_00ee5b6806ca20bcda5fb1846ff2fa87 = cache_frame_00ee5b6806ca20bcda5fb1846ff2fa87;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_00ee5b6806ca20bcda5fb1846ff2fa87 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_00ee5b6806ca20bcda5fb1846ff2fa87 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        tmp_left_name_1 = const_unicode_digest_efc16551a4ac6506a616591ae7a04018;
        CHECK_OBJECT( par_netmask_str );
        tmp_right_name_1 = par_netmask_str;
        tmp_assign_source_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 595;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_msg == NULL );
        var_msg = tmp_assign_source_1;
    }
    {
        PyObject *tmp_raise_type_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_NetmaskValueError );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NetmaskValueError );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "NetmaskValueError" );
            exception_tb = NULL;

            exception_lineno = 596;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( var_msg );
        tmp_args_element_name_1 = var_msg;
        frame_00ee5b6806ca20bcda5fb1846ff2fa87->m_frame.f_lineno = 596;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        if ( tmp_raise_type_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 596;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        exception_type = tmp_raise_type_1;
        exception_lineno = 596;
        RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_00ee5b6806ca20bcda5fb1846ff2fa87 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_00ee5b6806ca20bcda5fb1846ff2fa87 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_00ee5b6806ca20bcda5fb1846ff2fa87, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_00ee5b6806ca20bcda5fb1846ff2fa87->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_00ee5b6806ca20bcda5fb1846ff2fa87, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_00ee5b6806ca20bcda5fb1846ff2fa87,
        type_description_1,
        par_cls,
        par_netmask_str,
        var_msg
    );


    // Release cached frame.
    if ( frame_00ee5b6806ca20bcda5fb1846ff2fa87 == cache_frame_00ee5b6806ca20bcda5fb1846ff2fa87 )
    {
        Py_DECREF( frame_00ee5b6806ca20bcda5fb1846ff2fa87 );
    }
    cache_frame_00ee5b6806ca20bcda5fb1846ff2fa87 = NULL;

    assertFrameObject( frame_00ee5b6806ca20bcda5fb1846ff2fa87 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_33__report_invalid_netmask );
    return NULL;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_msg );
    var_msg = NULL;

    CHECK_OBJECT( (PyObject *)par_netmask_str );
    Py_DECREF( par_netmask_str );
    par_netmask_str = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_33__report_invalid_netmask );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

}


static PyObject *impl_ipaddress$$$function_34__prefix_from_prefix_string( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_prefixlen_str = python_pars[ 1 ];
    PyObject *var_prefixlen = NULL;
    PyObject *tmp_comparison_chain_1__comparison_result = NULL;
    PyObject *tmp_comparison_chain_1__operand_2 = NULL;
    struct Nuitka_FrameObject *frame_bb1e2ac1f2a08510058031fa56cc95e9;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    bool tmp_result;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_bb1e2ac1f2a08510058031fa56cc95e9 = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_bb1e2ac1f2a08510058031fa56cc95e9, codeobj_bb1e2ac1f2a08510058031fa56cc95e9, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_bb1e2ac1f2a08510058031fa56cc95e9 = cache_frame_bb1e2ac1f2a08510058031fa56cc95e9;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_bb1e2ac1f2a08510058031fa56cc95e9 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_bb1e2ac1f2a08510058031fa56cc95e9 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__BaseV4 );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__BaseV4 );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_BaseV4" );
            exception_tb = NULL;

            exception_lineno = 613;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__DECIMAL_DIGITS );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 613;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_prefixlen_str );
        tmp_args_element_name_1 = par_prefixlen_str;
        frame_bb1e2ac1f2a08510058031fa56cc95e9->m_frame.f_lineno = 613;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_operand_name_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_issuperset, call_args );
        }

        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_operand_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 613;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        Py_DECREF( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 613;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_instance_2;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_2;
            CHECK_OBJECT( par_cls );
            tmp_called_instance_2 = par_cls;
            CHECK_OBJECT( par_prefixlen_str );
            tmp_args_element_name_2 = par_prefixlen_str;
            frame_bb1e2ac1f2a08510058031fa56cc95e9->m_frame.f_lineno = 614;
            {
                PyObject *call_args[] = { tmp_args_element_name_2 };
                tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain__report_invalid_netmask, call_args );
            }

            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 614;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        branch_no_1:;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_int_arg_1;
        CHECK_OBJECT( par_prefixlen_str );
        tmp_int_arg_1 = par_prefixlen_str;
        tmp_assign_source_1 = PyNumber_Int( tmp_int_arg_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 616;
            type_description_1 = "ooo";
            goto try_except_handler_2;
        }
        assert( var_prefixlen == NULL );
        var_prefixlen = tmp_assign_source_1;
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_bb1e2ac1f2a08510058031fa56cc95e9 );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_bb1e2ac1f2a08510058031fa56cc95e9, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_bb1e2ac1f2a08510058031fa56cc95e9, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_compexpr_left_1 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_1 = PyExc_ValueError;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 617;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_called_instance_3;
            PyObject *tmp_call_result_2;
            PyObject *tmp_args_element_name_3;
            CHECK_OBJECT( par_cls );
            tmp_called_instance_3 = par_cls;
            CHECK_OBJECT( par_prefixlen_str );
            tmp_args_element_name_3 = par_prefixlen_str;
            frame_bb1e2ac1f2a08510058031fa56cc95e9->m_frame.f_lineno = 618;
            {
                PyObject *call_args[] = { tmp_args_element_name_3 };
                tmp_call_result_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain__report_invalid_netmask, call_args );
            }

            if ( tmp_call_result_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 618;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_2 );
        }
        goto branch_end_2;
        branch_no_2:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 615;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_bb1e2ac1f2a08510058031fa56cc95e9->m_frame) frame_bb1e2ac1f2a08510058031fa56cc95e9->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
        branch_end_2:;
    }
    goto try_end_1;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_34__prefix_from_prefix_string );
    return NULL;
    // End of try:
    try_end_1:;
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_operand_name_2;
        // Tried code:
        {
            PyObject *tmp_assign_source_2;
            if ( var_prefixlen == NULL )
            {

                exception_type = PyExc_UnboundLocalError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "prefixlen" );
                exception_tb = NULL;

                exception_lineno = 619;
                type_description_1 = "ooo";
                goto try_except_handler_3;
            }

            tmp_assign_source_2 = var_prefixlen;
            assert( tmp_comparison_chain_1__operand_2 == NULL );
            Py_INCREF( tmp_assign_source_2 );
            tmp_comparison_chain_1__operand_2 = tmp_assign_source_2;
        }
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            tmp_compexpr_left_2 = const_int_0;
            CHECK_OBJECT( tmp_comparison_chain_1__operand_2 );
            tmp_compexpr_right_2 = tmp_comparison_chain_1__operand_2;
            tmp_assign_source_3 = RICH_COMPARE_LTE_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
            if ( tmp_assign_source_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 619;
                type_description_1 = "ooo";
                goto try_except_handler_3;
            }
            assert( tmp_comparison_chain_1__comparison_result == NULL );
            tmp_comparison_chain_1__comparison_result = tmp_assign_source_3;
        }
        {
            nuitka_bool tmp_condition_result_4;
            PyObject *tmp_operand_name_3;
            CHECK_OBJECT( tmp_comparison_chain_1__comparison_result );
            tmp_operand_name_3 = tmp_comparison_chain_1__comparison_result;
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_3 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 619;
                type_description_1 = "ooo";
                goto try_except_handler_3;
            }
            tmp_condition_result_4 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_4;
            }
            else
            {
                goto branch_no_4;
            }
            branch_yes_4:;
            CHECK_OBJECT( tmp_comparison_chain_1__comparison_result );
            tmp_operand_name_2 = tmp_comparison_chain_1__comparison_result;
            Py_INCREF( tmp_operand_name_2 );
            goto try_return_handler_3;
            branch_no_4:;
        }
        {
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            PyObject *tmp_source_name_2;
            CHECK_OBJECT( tmp_comparison_chain_1__operand_2 );
            tmp_compexpr_left_3 = tmp_comparison_chain_1__operand_2;
            CHECK_OBJECT( par_cls );
            tmp_source_name_2 = par_cls;
            tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__max_prefixlen );
            if ( tmp_compexpr_right_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 619;
                type_description_1 = "ooo";
                goto try_except_handler_3;
            }
            tmp_operand_name_2 = RICH_COMPARE_LTE_OBJECT_OBJECT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
            Py_DECREF( tmp_compexpr_right_3 );
            if ( tmp_operand_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 619;
                type_description_1 = "ooo";
                goto try_except_handler_3;
            }
            goto try_return_handler_3;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ipaddress$$$function_34__prefix_from_prefix_string );
        return NULL;
        // Return handler code:
        try_return_handler_3:;
        CHECK_OBJECT( (PyObject *)tmp_comparison_chain_1__operand_2 );
        Py_DECREF( tmp_comparison_chain_1__operand_2 );
        tmp_comparison_chain_1__operand_2 = NULL;

        CHECK_OBJECT( (PyObject *)tmp_comparison_chain_1__comparison_result );
        Py_DECREF( tmp_comparison_chain_1__comparison_result );
        tmp_comparison_chain_1__comparison_result = NULL;

        goto outline_result_1;
        // Exception handler code:
        try_except_handler_3:;
        exception_keeper_type_2 = exception_type;
        exception_keeper_value_2 = exception_value;
        exception_keeper_tb_2 = exception_tb;
        exception_keeper_lineno_2 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF( tmp_comparison_chain_1__operand_2 );
        tmp_comparison_chain_1__operand_2 = NULL;

        Py_XDECREF( tmp_comparison_chain_1__comparison_result );
        tmp_comparison_chain_1__comparison_result = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_2;
        exception_value = exception_keeper_value_2;
        exception_tb = exception_keeper_tb_2;
        exception_lineno = exception_keeper_lineno_2;

        goto frame_exception_exit_1;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( ipaddress$$$function_34__prefix_from_prefix_string );
        return NULL;
        outline_result_1:;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        Py_DECREF( tmp_operand_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 619;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_called_instance_4;
            PyObject *tmp_call_result_3;
            PyObject *tmp_args_element_name_4;
            CHECK_OBJECT( par_cls );
            tmp_called_instance_4 = par_cls;
            CHECK_OBJECT( par_prefixlen_str );
            tmp_args_element_name_4 = par_prefixlen_str;
            frame_bb1e2ac1f2a08510058031fa56cc95e9->m_frame.f_lineno = 620;
            {
                PyObject *call_args[] = { tmp_args_element_name_4 };
                tmp_call_result_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain__report_invalid_netmask, call_args );
            }

            if ( tmp_call_result_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 620;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_3 );
        }
        branch_no_3:;
    }
    if ( var_prefixlen == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "prefixlen" );
        exception_tb = NULL;

        exception_lineno = 621;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_return_value = var_prefixlen;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_bb1e2ac1f2a08510058031fa56cc95e9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_bb1e2ac1f2a08510058031fa56cc95e9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_bb1e2ac1f2a08510058031fa56cc95e9 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_bb1e2ac1f2a08510058031fa56cc95e9, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_bb1e2ac1f2a08510058031fa56cc95e9->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_bb1e2ac1f2a08510058031fa56cc95e9, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_bb1e2ac1f2a08510058031fa56cc95e9,
        type_description_1,
        par_cls,
        par_prefixlen_str,
        var_prefixlen
    );


    // Release cached frame.
    if ( frame_bb1e2ac1f2a08510058031fa56cc95e9 == cache_frame_bb1e2ac1f2a08510058031fa56cc95e9 )
    {
        Py_DECREF( frame_bb1e2ac1f2a08510058031fa56cc95e9 );
    }
    cache_frame_bb1e2ac1f2a08510058031fa56cc95e9 = NULL;

    assertFrameObject( frame_bb1e2ac1f2a08510058031fa56cc95e9 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_34__prefix_from_prefix_string );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_prefixlen );
    var_prefixlen = NULL;

    CHECK_OBJECT( (PyObject *)par_prefixlen_str );
    Py_DECREF( par_prefixlen_str );
    par_prefixlen_str = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_prefixlen );
    var_prefixlen = NULL;

    CHECK_OBJECT( (PyObject *)par_prefixlen_str );
    Py_DECREF( par_prefixlen_str );
    par_prefixlen_str = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_34__prefix_from_prefix_string );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_35__prefix_from_ip_string( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_ip_str = python_pars[ 1 ];
    PyObject *var_ip_int = NULL;
    struct Nuitka_FrameObject *frame_475e33420705710913bc618cb12cdaaa;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    static struct Nuitka_FrameObject *cache_frame_475e33420705710913bc618cb12cdaaa = NULL;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_475e33420705710913bc618cb12cdaaa, codeobj_475e33420705710913bc618cb12cdaaa, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_475e33420705710913bc618cb12cdaaa = cache_frame_475e33420705710913bc618cb12cdaaa;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_475e33420705710913bc618cb12cdaaa );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_475e33420705710913bc618cb12cdaaa ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT( par_cls );
        tmp_called_instance_1 = par_cls;
        CHECK_OBJECT( par_ip_str );
        tmp_args_element_name_1 = par_ip_str;
        frame_475e33420705710913bc618cb12cdaaa->m_frame.f_lineno = 638;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain__ip_int_from_string, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 638;
            type_description_1 = "ooo";
            goto try_except_handler_2;
        }
        assert( var_ip_int == NULL );
        var_ip_int = tmp_assign_source_1;
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_475e33420705710913bc618cb12cdaaa );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_475e33420705710913bc618cb12cdaaa, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_475e33420705710913bc618cb12cdaaa, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        tmp_compexpr_left_1 = EXC_TYPE(PyThreadState_GET());
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_AddressValueError );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AddressValueError );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "AddressValueError" );
            exception_tb = NULL;

            exception_lineno = 639;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 639;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_instance_2;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_2;
            CHECK_OBJECT( par_cls );
            tmp_called_instance_2 = par_cls;
            CHECK_OBJECT( par_ip_str );
            tmp_args_element_name_2 = par_ip_str;
            frame_475e33420705710913bc618cb12cdaaa->m_frame.f_lineno = 640;
            {
                PyObject *call_args[] = { tmp_args_element_name_2 };
                tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain__report_invalid_netmask, call_args );
            }

            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 640;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        goto branch_end_1;
        branch_no_1:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 637;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_475e33420705710913bc618cb12cdaaa->m_frame) frame_475e33420705710913bc618cb12cdaaa->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
        branch_end_1:;
    }
    goto try_end_1;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_35__prefix_from_ip_string );
    return NULL;
    // End of try:
    try_end_1:;
    // Tried code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_3;
        CHECK_OBJECT( par_cls );
        tmp_source_name_1 = par_cls;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__prefix_from_ip_int );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 646;
            type_description_1 = "ooo";
            goto try_except_handler_3;
        }
        if ( var_ip_int == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "ip_int" );
            exception_tb = NULL;

            exception_lineno = 646;
            type_description_1 = "ooo";
            goto try_except_handler_3;
        }

        tmp_args_element_name_3 = var_ip_int;
        frame_475e33420705710913bc618cb12cdaaa->m_frame.f_lineno = 646;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 646;
            type_description_1 = "ooo";
            goto try_except_handler_3;
        }
        goto frame_return_exit_1;
    }
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_35__prefix_from_ip_string );
    return NULL;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_475e33420705710913bc618cb12cdaaa );
    if ( exception_keeper_tb_2 == NULL )
    {
        exception_keeper_tb_2 = MAKE_TRACEBACK( frame_475e33420705710913bc618cb12cdaaa, exception_keeper_lineno_2 );
    }
    else if ( exception_keeper_lineno_2 != 0 )
    {
        exception_keeper_tb_2 = ADD_TRACEBACK( exception_keeper_tb_2, frame_475e33420705710913bc618cb12cdaaa, exception_keeper_lineno_2 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_2, &exception_keeper_value_2, &exception_keeper_tb_2 );
    PUBLISH_EXCEPTION( &exception_keeper_type_2, &exception_keeper_value_2, &exception_keeper_tb_2 );
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        tmp_compexpr_left_2 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_2 = PyExc_ValueError;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 647;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 647;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 645;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_475e33420705710913bc618cb12cdaaa->m_frame) frame_475e33420705710913bc618cb12cdaaa->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
        branch_no_2:;
    }
    goto try_end_2;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_35__prefix_from_ip_string );
    return NULL;
    // End of try:
    try_end_2:;
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_source_name_2;
        if ( var_ip_int == NULL )
        {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "ip_int" );
            exception_tb = NULL;

            exception_lineno = 651;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_left_name_1 = var_ip_int;
        CHECK_OBJECT( par_cls );
        tmp_source_name_2 = par_cls;
        tmp_right_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ALL_ONES );
        if ( tmp_right_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 651;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_result = BINARY_OPERATION_INPLACE( PyNumber_InPlaceXor, &tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_right_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 651;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_2 = tmp_left_name_1;
        var_ip_int = tmp_assign_source_2;

    }
    // Tried code:
    {
        PyObject *tmp_called_instance_3;
        PyObject *tmp_args_element_name_4;
        CHECK_OBJECT( par_cls );
        tmp_called_instance_3 = par_cls;
        CHECK_OBJECT( var_ip_int );
        tmp_args_element_name_4 = var_ip_int;
        frame_475e33420705710913bc618cb12cdaaa->m_frame.f_lineno = 653;
        {
            PyObject *call_args[] = { tmp_args_element_name_4 };
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain__prefix_from_ip_int, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 653;
            type_description_1 = "ooo";
            goto try_except_handler_4;
        }
        goto frame_return_exit_1;
    }
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_35__prefix_from_ip_string );
    return NULL;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_475e33420705710913bc618cb12cdaaa );
    if ( exception_keeper_tb_3 == NULL )
    {
        exception_keeper_tb_3 = MAKE_TRACEBACK( frame_475e33420705710913bc618cb12cdaaa, exception_keeper_lineno_3 );
    }
    else if ( exception_keeper_lineno_3 != 0 )
    {
        exception_keeper_tb_3 = ADD_TRACEBACK( exception_keeper_tb_3, frame_475e33420705710913bc618cb12cdaaa, exception_keeper_lineno_3 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_3, &exception_keeper_value_3, &exception_keeper_tb_3 );
    PUBLISH_EXCEPTION( &exception_keeper_type_3, &exception_keeper_value_3, &exception_keeper_tb_3 );
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        tmp_compexpr_left_3 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_3 = PyExc_ValueError;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_3, tmp_compexpr_right_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 654;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_called_instance_4;
            PyObject *tmp_call_result_2;
            PyObject *tmp_args_element_name_5;
            CHECK_OBJECT( par_cls );
            tmp_called_instance_4 = par_cls;
            CHECK_OBJECT( par_ip_str );
            tmp_args_element_name_5 = par_ip_str;
            frame_475e33420705710913bc618cb12cdaaa->m_frame.f_lineno = 655;
            {
                PyObject *call_args[] = { tmp_args_element_name_5 };
                tmp_call_result_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain__report_invalid_netmask, call_args );
            }

            if ( tmp_call_result_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 655;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_2 );
        }
        goto branch_end_3;
        branch_no_3:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 652;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_475e33420705710913bc618cb12cdaaa->m_frame) frame_475e33420705710913bc618cb12cdaaa->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
        branch_end_3:;
    }
    goto try_end_3;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_35__prefix_from_ip_string );
    return NULL;
    // End of try:
    try_end_3:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_475e33420705710913bc618cb12cdaaa );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_475e33420705710913bc618cb12cdaaa );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_475e33420705710913bc618cb12cdaaa );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_475e33420705710913bc618cb12cdaaa, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_475e33420705710913bc618cb12cdaaa->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_475e33420705710913bc618cb12cdaaa, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_475e33420705710913bc618cb12cdaaa,
        type_description_1,
        par_cls,
        par_ip_str,
        var_ip_int
    );


    // Release cached frame.
    if ( frame_475e33420705710913bc618cb12cdaaa == cache_frame_475e33420705710913bc618cb12cdaaa )
    {
        Py_DECREF( frame_475e33420705710913bc618cb12cdaaa );
    }
    cache_frame_475e33420705710913bc618cb12cdaaa = NULL;

    assertFrameObject( frame_475e33420705710913bc618cb12cdaaa );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_35__prefix_from_ip_string );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_ip_str );
    Py_DECREF( par_ip_str );
    par_ip_str = NULL;

    Py_XDECREF( var_ip_int );
    var_ip_int = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_ip_str );
    Py_DECREF( par_ip_str );
    par_ip_str = NULL;

    Py_XDECREF( var_ip_int );
    var_ip_int = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_35__prefix_from_ip_string );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_36___reduce__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_ed741ffdf26796e0ff1e303ebfd19808;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_ed741ffdf26796e0ff1e303ebfd19808 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ed741ffdf26796e0ff1e303ebfd19808, codeobj_ed741ffdf26796e0ff1e303ebfd19808, module_ipaddress, sizeof(void *) );
    frame_ed741ffdf26796e0ff1e303ebfd19808 = cache_frame_ed741ffdf26796e0ff1e303ebfd19808;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ed741ffdf26796e0ff1e303ebfd19808 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ed741ffdf26796e0ff1e303ebfd19808 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_tuple_element_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_1 );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 658;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = PyTuple_New( 2 );
        PyTuple_SET_ITEM( tmp_return_value, 0, tmp_tuple_element_1 );
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_str );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__compat_str );
        }

        if ( tmp_mvar_value_1 == NULL )
        {
            Py_DECREF( tmp_return_value );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_compat_str" );
            exception_tb = NULL;

            exception_lineno = 658;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_self );
        tmp_args_element_name_1 = par_self;
        frame_ed741ffdf26796e0ff1e303ebfd19808->m_frame.f_lineno = 658;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_tuple_element_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        if ( tmp_tuple_element_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_return_value );

            exception_lineno = 658;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_tuple_element_1 = PyTuple_New( 1 );
        PyTuple_SET_ITEM( tmp_tuple_element_1, 0, tmp_tuple_element_2 );
        PyTuple_SET_ITEM( tmp_return_value, 1, tmp_tuple_element_1 );
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ed741ffdf26796e0ff1e303ebfd19808 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_ed741ffdf26796e0ff1e303ebfd19808 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ed741ffdf26796e0ff1e303ebfd19808 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ed741ffdf26796e0ff1e303ebfd19808, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ed741ffdf26796e0ff1e303ebfd19808->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ed741ffdf26796e0ff1e303ebfd19808, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ed741ffdf26796e0ff1e303ebfd19808,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_ed741ffdf26796e0ff1e303ebfd19808 == cache_frame_ed741ffdf26796e0ff1e303ebfd19808 )
    {
        Py_DECREF( frame_ed741ffdf26796e0ff1e303ebfd19808 );
    }
    cache_frame_ed741ffdf26796e0ff1e303ebfd19808 = NULL;

    assertFrameObject( frame_ed741ffdf26796e0ff1e303ebfd19808 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_36___reduce__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_36___reduce__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_37___int__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_d6198731425720bf74b62a3c85594e44;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_d6198731425720bf74b62a3c85594e44 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d6198731425720bf74b62a3c85594e44, codeobj_d6198731425720bf74b62a3c85594e44, module_ipaddress, sizeof(void *) );
    frame_d6198731425720bf74b62a3c85594e44 = cache_frame_d6198731425720bf74b62a3c85594e44;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d6198731425720bf74b62a3c85594e44 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d6198731425720bf74b62a3c85594e44 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__ip );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 672;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d6198731425720bf74b62a3c85594e44 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d6198731425720bf74b62a3c85594e44 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d6198731425720bf74b62a3c85594e44 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d6198731425720bf74b62a3c85594e44, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d6198731425720bf74b62a3c85594e44->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d6198731425720bf74b62a3c85594e44, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d6198731425720bf74b62a3c85594e44,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_d6198731425720bf74b62a3c85594e44 == cache_frame_d6198731425720bf74b62a3c85594e44 )
    {
        Py_DECREF( frame_d6198731425720bf74b62a3c85594e44 );
    }
    cache_frame_d6198731425720bf74b62a3c85594e44 = NULL;

    assertFrameObject( frame_d6198731425720bf74b62a3c85594e44 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_37___int__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_37___int__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_38___eq__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_b2f94a1328d96c44d4a82b1e3c4b6114;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_b2f94a1328d96c44d4a82b1e3c4b6114 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b2f94a1328d96c44d4a82b1e3c4b6114, codeobj_b2f94a1328d96c44d4a82b1e3c4b6114, module_ipaddress, sizeof(void *)+sizeof(void *) );
    frame_b2f94a1328d96c44d4a82b1e3c4b6114 = cache_frame_b2f94a1328d96c44d4a82b1e3c4b6114;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b2f94a1328d96c44d4a82b1e3c4b6114 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b2f94a1328d96c44d4a82b1e3c4b6114 ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    {
        int tmp_and_left_truth_1;
        PyObject *tmp_and_left_value_1;
        PyObject *tmp_and_right_value_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_source_name_4;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__ip );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 676;
            type_description_1 = "oo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( par_other );
        tmp_source_name_2 = par_other;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ip );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_1 );

            exception_lineno = 676;
            type_description_1 = "oo";
            goto try_except_handler_2;
        }
        tmp_and_left_value_1 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_and_left_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 676;
            type_description_1 = "oo";
            goto try_except_handler_2;
        }
        tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
        if ( tmp_and_left_truth_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_and_left_value_1 );

            exception_lineno = 677;
            type_description_1 = "oo";
            goto try_except_handler_2;
        }
        if ( tmp_and_left_truth_1 == 1 )
        {
            goto and_right_1;
        }
        else
        {
            goto and_left_1;
        }
        and_right_1:;
        Py_DECREF( tmp_and_left_value_1 );
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__version );
        if ( tmp_compexpr_left_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 677;
            type_description_1 = "oo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( par_other );
        tmp_source_name_4 = par_other;
        tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__version );
        if ( tmp_compexpr_right_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_2 );

            exception_lineno = 677;
            type_description_1 = "oo";
            goto try_except_handler_2;
        }
        tmp_and_right_value_1 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        Py_DECREF( tmp_compexpr_left_2 );
        Py_DECREF( tmp_compexpr_right_2 );
        if ( tmp_and_right_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 677;
            type_description_1 = "oo";
            goto try_except_handler_2;
        }
        tmp_return_value = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_return_value = tmp_and_left_value_1;
        and_end_1:;
        goto frame_return_exit_1;
    }
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_38___eq__ );
    return NULL;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_b2f94a1328d96c44d4a82b1e3c4b6114 );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_b2f94a1328d96c44d4a82b1e3c4b6114, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_b2f94a1328d96c44d4a82b1e3c4b6114, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        tmp_compexpr_left_3 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_3 = PyExc_AttributeError;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_3, tmp_compexpr_right_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 678;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_NotImplemented;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        goto branch_end_1;
        branch_no_1:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 675;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_b2f94a1328d96c44d4a82b1e3c4b6114->m_frame) frame_b2f94a1328d96c44d4a82b1e3c4b6114->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
        branch_end_1:;
    }
    // End of try:

#if 1
    RESTORE_FRAME_EXCEPTION( frame_b2f94a1328d96c44d4a82b1e3c4b6114 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_b2f94a1328d96c44d4a82b1e3c4b6114 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_b2f94a1328d96c44d4a82b1e3c4b6114 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b2f94a1328d96c44d4a82b1e3c4b6114, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b2f94a1328d96c44d4a82b1e3c4b6114->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b2f94a1328d96c44d4a82b1e3c4b6114, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b2f94a1328d96c44d4a82b1e3c4b6114,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_b2f94a1328d96c44d4a82b1e3c4b6114 == cache_frame_b2f94a1328d96c44d4a82b1e3c4b6114 )
    {
        Py_DECREF( frame_b2f94a1328d96c44d4a82b1e3c4b6114 );
    }
    cache_frame_b2f94a1328d96c44d4a82b1e3c4b6114 = NULL;

    assertFrameObject( frame_b2f94a1328d96c44d4a82b1e3c4b6114 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_38___eq__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_38___eq__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_39___lt__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_85d0c509283f96c21d0470148697e1c2;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_85d0c509283f96c21d0470148697e1c2 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_85d0c509283f96c21d0470148697e1c2, codeobj_85d0c509283f96c21d0470148697e1c2, module_ipaddress, sizeof(void *)+sizeof(void *) );
    frame_85d0c509283f96c21d0470148697e1c2 = cache_frame_85d0c509283f96c21d0470148697e1c2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_85d0c509283f96c21d0470148697e1c2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_85d0c509283f96c21d0470148697e1c2 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_other );
        tmp_isinstance_inst_1 = par_other;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__IPAddressBase );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__IPAddressBase );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_IPAddressBase" );
            exception_tb = NULL;

            exception_lineno = 682;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 682;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 682;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_NotImplemented;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_2;
        PyObject *tmp_isinstance_inst_2;
        PyObject *tmp_isinstance_cls_2;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT( par_other );
        tmp_isinstance_inst_2 = par_other;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__BaseAddress );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__BaseAddress );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_BaseAddress" );
            exception_tb = NULL;

            exception_lineno = 684;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_2 = tmp_mvar_value_2;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 684;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_2 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 684;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            PyObject *tmp_tuple_element_1;
            tmp_left_name_1 = const_unicode_digest_ce28e1a0d596488778adc7f428c3ab1f;
            CHECK_OBJECT( par_self );
            tmp_tuple_element_1 = par_self;
            tmp_right_name_1 = PyTuple_New( 2 );
            Py_INCREF( tmp_tuple_element_1 );
            PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
            CHECK_OBJECT( par_other );
            tmp_tuple_element_1 = par_other;
            Py_INCREF( tmp_tuple_element_1 );
            PyTuple_SET_ITEM( tmp_right_name_1, 1, tmp_tuple_element_1 );
            tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
            Py_DECREF( tmp_right_name_1 );
            if ( tmp_make_exception_arg_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 685;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            frame_85d0c509283f96c21d0470148697e1c2->m_frame.f_lineno = 685;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            Py_DECREF( tmp_make_exception_arg_1 );
            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 685;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__version );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 687;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_other );
        tmp_source_name_2 = par_other;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__version );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_1 );

            exception_lineno = 687;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 687;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_make_exception_arg_2;
            PyObject *tmp_left_name_2;
            PyObject *tmp_right_name_2;
            PyObject *tmp_tuple_element_2;
            tmp_left_name_2 = const_unicode_digest_e922c2e07060bd895f3f403962951e84;
            CHECK_OBJECT( par_self );
            tmp_tuple_element_2 = par_self;
            tmp_right_name_2 = PyTuple_New( 2 );
            Py_INCREF( tmp_tuple_element_2 );
            PyTuple_SET_ITEM( tmp_right_name_2, 0, tmp_tuple_element_2 );
            CHECK_OBJECT( par_other );
            tmp_tuple_element_2 = par_other;
            Py_INCREF( tmp_tuple_element_2 );
            PyTuple_SET_ITEM( tmp_right_name_2, 1, tmp_tuple_element_2 );
            tmp_make_exception_arg_2 = BINARY_OPERATION_REMAINDER( tmp_left_name_2, tmp_right_name_2 );
            Py_DECREF( tmp_right_name_2 );
            if ( tmp_make_exception_arg_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 688;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            frame_85d0c509283f96c21d0470148697e1c2->m_frame.f_lineno = 688;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_2 };
                tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            Py_DECREF( tmp_make_exception_arg_2 );
            assert( !(tmp_raise_type_2 == NULL) );
            exception_type = tmp_raise_type_2;
            exception_lineno = 688;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_3:;
    }
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_source_name_4;
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__ip );
        if ( tmp_compexpr_left_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 690;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_other );
        tmp_source_name_4 = par_other;
        tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__ip );
        if ( tmp_compexpr_right_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_2 );

            exception_lineno = 690;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        Py_DECREF( tmp_compexpr_left_2 );
        Py_DECREF( tmp_compexpr_right_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 690;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_4 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_4;
        }
        else
        {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            PyObject *tmp_source_name_5;
            PyObject *tmp_source_name_6;
            CHECK_OBJECT( par_self );
            tmp_source_name_5 = par_self;
            tmp_compexpr_left_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__ip );
            if ( tmp_compexpr_left_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 691;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_other );
            tmp_source_name_6 = par_other;
            tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__ip );
            if ( tmp_compexpr_right_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_compexpr_left_3 );

                exception_lineno = 691;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            tmp_return_value = RICH_COMPARE_LT_OBJECT_OBJECT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
            Py_DECREF( tmp_compexpr_left_3 );
            Py_DECREF( tmp_compexpr_right_3 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 691;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_no_4:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_85d0c509283f96c21d0470148697e1c2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_85d0c509283f96c21d0470148697e1c2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_85d0c509283f96c21d0470148697e1c2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_85d0c509283f96c21d0470148697e1c2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_85d0c509283f96c21d0470148697e1c2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_85d0c509283f96c21d0470148697e1c2, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_85d0c509283f96c21d0470148697e1c2,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_85d0c509283f96c21d0470148697e1c2 == cache_frame_85d0c509283f96c21d0470148697e1c2 )
    {
        Py_DECREF( frame_85d0c509283f96c21d0470148697e1c2 );
    }
    cache_frame_85d0c509283f96c21d0470148697e1c2 = NULL;

    assertFrameObject( frame_85d0c509283f96c21d0470148697e1c2 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_False;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_39___lt__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_39___lt__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_40___add__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_9abed9769104b337e842b37b29bc8335;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_9abed9769104b337e842b37b29bc8335 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9abed9769104b337e842b37b29bc8335, codeobj_9abed9769104b337e842b37b29bc8335, module_ipaddress, sizeof(void *)+sizeof(void *) );
    frame_9abed9769104b337e842b37b29bc8335 = cache_frame_9abed9769104b337e842b37b29bc8335;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9abed9769104b337e842b37b29bc8335 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9abed9769104b337e842b37b29bc8335 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_other );
        tmp_isinstance_inst_1 = par_other;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_int_types );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__compat_int_types );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_compat_int_types" );
            exception_tb = NULL;

            exception_lineno = 697;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 697;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 697;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_NotImplemented;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_int_arg_1;
        PyObject *tmp_right_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_1 );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 699;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_int_arg_1 = par_self;
        tmp_left_name_1 = PyNumber_Int( tmp_int_arg_1 );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 699;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_other );
        tmp_right_name_1 = par_other;
        tmp_args_element_name_1 = BINARY_OPERATION_ADD_OBJECT_OBJECT( tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_left_name_1 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 699;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_9abed9769104b337e842b37b29bc8335->m_frame.f_lineno = 699;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 699;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9abed9769104b337e842b37b29bc8335 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_9abed9769104b337e842b37b29bc8335 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9abed9769104b337e842b37b29bc8335 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9abed9769104b337e842b37b29bc8335, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9abed9769104b337e842b37b29bc8335->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9abed9769104b337e842b37b29bc8335, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9abed9769104b337e842b37b29bc8335,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_9abed9769104b337e842b37b29bc8335 == cache_frame_9abed9769104b337e842b37b29bc8335 )
    {
        Py_DECREF( frame_9abed9769104b337e842b37b29bc8335 );
    }
    cache_frame_9abed9769104b337e842b37b29bc8335 = NULL;

    assertFrameObject( frame_9abed9769104b337e842b37b29bc8335 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_40___add__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_40___add__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_41___sub__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_2cfe51702bf97b246bfe200e1420b757;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_2cfe51702bf97b246bfe200e1420b757 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2cfe51702bf97b246bfe200e1420b757, codeobj_2cfe51702bf97b246bfe200e1420b757, module_ipaddress, sizeof(void *)+sizeof(void *) );
    frame_2cfe51702bf97b246bfe200e1420b757 = cache_frame_2cfe51702bf97b246bfe200e1420b757;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2cfe51702bf97b246bfe200e1420b757 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2cfe51702bf97b246bfe200e1420b757 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_other );
        tmp_isinstance_inst_1 = par_other;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_int_types );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__compat_int_types );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_compat_int_types" );
            exception_tb = NULL;

            exception_lineno = 702;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 702;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 702;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_NotImplemented;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_int_arg_1;
        PyObject *tmp_right_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_1 );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 704;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_int_arg_1 = par_self;
        tmp_left_name_1 = PyNumber_Int( tmp_int_arg_1 );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 704;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_other );
        tmp_right_name_1 = par_other;
        tmp_args_element_name_1 = BINARY_OPERATION_SUB( tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_left_name_1 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 704;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_2cfe51702bf97b246bfe200e1420b757->m_frame.f_lineno = 704;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 704;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2cfe51702bf97b246bfe200e1420b757 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_2cfe51702bf97b246bfe200e1420b757 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2cfe51702bf97b246bfe200e1420b757 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2cfe51702bf97b246bfe200e1420b757, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2cfe51702bf97b246bfe200e1420b757->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2cfe51702bf97b246bfe200e1420b757, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2cfe51702bf97b246bfe200e1420b757,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_2cfe51702bf97b246bfe200e1420b757 == cache_frame_2cfe51702bf97b246bfe200e1420b757 )
    {
        Py_DECREF( frame_2cfe51702bf97b246bfe200e1420b757 );
    }
    cache_frame_2cfe51702bf97b246bfe200e1420b757 = NULL;

    assertFrameObject( frame_2cfe51702bf97b246bfe200e1420b757 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_41___sub__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_41___sub__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_42___repr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_1f09a9f606fe746196d89cb184d5e7c0;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_1f09a9f606fe746196d89cb184d5e7c0 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1f09a9f606fe746196d89cb184d5e7c0, codeobj_1f09a9f606fe746196d89cb184d5e7c0, module_ipaddress, sizeof(void *) );
    frame_1f09a9f606fe746196d89cb184d5e7c0 = cache_frame_1f09a9f606fe746196d89cb184d5e7c0;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1f09a9f606fe746196d89cb184d5e7c0 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1f09a9f606fe746196d89cb184d5e7c0 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_left_name_1 = const_unicode_digest_d44bacc2290b5d18e632348ff9d94d65;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_2 );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 707;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain___name__ );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 707;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_1 = PyTuple_New( 2 );
        PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_str );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__compat_str );
        }

        if ( tmp_mvar_value_1 == NULL )
        {
            Py_DECREF( tmp_right_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_compat_str" );
            exception_tb = NULL;

            exception_lineno = 707;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_self );
        tmp_args_element_name_1 = par_self;
        frame_1f09a9f606fe746196d89cb184d5e7c0->m_frame.f_lineno = 707;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_tuple_element_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_right_name_1 );

            exception_lineno = 707;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM( tmp_right_name_1, 1, tmp_tuple_element_1 );
        tmp_return_value = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_right_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 707;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1f09a9f606fe746196d89cb184d5e7c0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_1f09a9f606fe746196d89cb184d5e7c0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1f09a9f606fe746196d89cb184d5e7c0 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1f09a9f606fe746196d89cb184d5e7c0, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1f09a9f606fe746196d89cb184d5e7c0->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1f09a9f606fe746196d89cb184d5e7c0, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1f09a9f606fe746196d89cb184d5e7c0,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_1f09a9f606fe746196d89cb184d5e7c0 == cache_frame_1f09a9f606fe746196d89cb184d5e7c0 )
    {
        Py_DECREF( frame_1f09a9f606fe746196d89cb184d5e7c0 );
    }
    cache_frame_1f09a9f606fe746196d89cb184d5e7c0 = NULL;

    assertFrameObject( frame_1f09a9f606fe746196d89cb184d5e7c0 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_42___repr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_42___repr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_43___str__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_1b1050c7cbb3699227e50b9e996a2d3f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_1b1050c7cbb3699227e50b9e996a2d3f = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1b1050c7cbb3699227e50b9e996a2d3f, codeobj_1b1050c7cbb3699227e50b9e996a2d3f, module_ipaddress, sizeof(void *) );
    frame_1b1050c7cbb3699227e50b9e996a2d3f = cache_frame_1b1050c7cbb3699227e50b9e996a2d3f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1b1050c7cbb3699227e50b9e996a2d3f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1b1050c7cbb3699227e50b9e996a2d3f ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_str );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__compat_str );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_compat_str" );
            exception_tb = NULL;

            exception_lineno = 710;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__string_from_ip_int );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 710;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ip );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 710;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_1b1050c7cbb3699227e50b9e996a2d3f->m_frame.f_lineno = 710;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 710;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_1b1050c7cbb3699227e50b9e996a2d3f->m_frame.f_lineno = 710;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 710;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1b1050c7cbb3699227e50b9e996a2d3f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_1b1050c7cbb3699227e50b9e996a2d3f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1b1050c7cbb3699227e50b9e996a2d3f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1b1050c7cbb3699227e50b9e996a2d3f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1b1050c7cbb3699227e50b9e996a2d3f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1b1050c7cbb3699227e50b9e996a2d3f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1b1050c7cbb3699227e50b9e996a2d3f,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_1b1050c7cbb3699227e50b9e996a2d3f == cache_frame_1b1050c7cbb3699227e50b9e996a2d3f )
    {
        Py_DECREF( frame_1b1050c7cbb3699227e50b9e996a2d3f );
    }
    cache_frame_1b1050c7cbb3699227e50b9e996a2d3f = NULL;

    assertFrameObject( frame_1b1050c7cbb3699227e50b9e996a2d3f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_43___str__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_43___str__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_44___hash__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_a802e13262f2f1adf825e3a244d35ad0;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_a802e13262f2f1adf825e3a244d35ad0 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a802e13262f2f1adf825e3a244d35ad0, codeobj_a802e13262f2f1adf825e3a244d35ad0, module_ipaddress, sizeof(void *) );
    frame_a802e13262f2f1adf825e3a244d35ad0 = cache_frame_a802e13262f2f1adf825e3a244d35ad0;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a802e13262f2f1adf825e3a244d35ad0 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a802e13262f2f1adf825e3a244d35ad0 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_hash_arg_1;
        PyObject *tmp_hex_arg_1;
        PyObject *tmp_int_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_int_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__ip );
        if ( tmp_int_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 713;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_hex_arg_1 = PyNumber_Int( tmp_int_arg_1 );
        Py_DECREF( tmp_int_arg_1 );
        if ( tmp_hex_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 713;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_hash_arg_1 = BUILTIN_HEX( tmp_hex_arg_1 );
        Py_DECREF( tmp_hex_arg_1 );
        if ( tmp_hash_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 713;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = BUILTIN_HASH( tmp_hash_arg_1 );
        Py_DECREF( tmp_hash_arg_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 713;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a802e13262f2f1adf825e3a244d35ad0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_a802e13262f2f1adf825e3a244d35ad0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a802e13262f2f1adf825e3a244d35ad0 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a802e13262f2f1adf825e3a244d35ad0, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a802e13262f2f1adf825e3a244d35ad0->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a802e13262f2f1adf825e3a244d35ad0, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a802e13262f2f1adf825e3a244d35ad0,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_a802e13262f2f1adf825e3a244d35ad0 == cache_frame_a802e13262f2f1adf825e3a244d35ad0 )
    {
        Py_DECREF( frame_a802e13262f2f1adf825e3a244d35ad0 );
    }
    cache_frame_a802e13262f2f1adf825e3a244d35ad0 = NULL;

    assertFrameObject( frame_a802e13262f2f1adf825e3a244d35ad0 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_44___hash__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_44___hash__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_45__get_address_key( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_21dad7c185498a4193f7a59a5bcd26b9;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_21dad7c185498a4193f7a59a5bcd26b9 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_21dad7c185498a4193f7a59a5bcd26b9, codeobj_21dad7c185498a4193f7a59a5bcd26b9, module_ipaddress, sizeof(void *) );
    frame_21dad7c185498a4193f7a59a5bcd26b9 = cache_frame_21dad7c185498a4193f7a59a5bcd26b9;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_21dad7c185498a4193f7a59a5bcd26b9 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_21dad7c185498a4193f7a59a5bcd26b9 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__version );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 716;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = PyTuple_New( 2 );
        PyTuple_SET_ITEM( tmp_return_value, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( par_self );
        tmp_tuple_element_1 = par_self;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_return_value, 1, tmp_tuple_element_1 );
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_21dad7c185498a4193f7a59a5bcd26b9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_21dad7c185498a4193f7a59a5bcd26b9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_21dad7c185498a4193f7a59a5bcd26b9 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_21dad7c185498a4193f7a59a5bcd26b9, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_21dad7c185498a4193f7a59a5bcd26b9->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_21dad7c185498a4193f7a59a5bcd26b9, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_21dad7c185498a4193f7a59a5bcd26b9,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_21dad7c185498a4193f7a59a5bcd26b9 == cache_frame_21dad7c185498a4193f7a59a5bcd26b9 )
    {
        Py_DECREF( frame_21dad7c185498a4193f7a59a5bcd26b9 );
    }
    cache_frame_21dad7c185498a4193f7a59a5bcd26b9 = NULL;

    assertFrameObject( frame_21dad7c185498a4193f7a59a5bcd26b9 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_45__get_address_key );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_45__get_address_key );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_46___reduce__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_7d2642b77ac278ef54f940cfcbf38077;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_7d2642b77ac278ef54f940cfcbf38077 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_7d2642b77ac278ef54f940cfcbf38077, codeobj_7d2642b77ac278ef54f940cfcbf38077, module_ipaddress, sizeof(void *) );
    frame_7d2642b77ac278ef54f940cfcbf38077 = cache_frame_7d2642b77ac278ef54f940cfcbf38077;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_7d2642b77ac278ef54f940cfcbf38077 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_7d2642b77ac278ef54f940cfcbf38077 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_tuple_element_2;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_1 );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 719;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = PyTuple_New( 2 );
        PyTuple_SET_ITEM( tmp_return_value, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_tuple_element_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ip );
        if ( tmp_tuple_element_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_return_value );

            exception_lineno = 719;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_tuple_element_1 = PyTuple_New( 1 );
        PyTuple_SET_ITEM( tmp_tuple_element_1, 0, tmp_tuple_element_2 );
        PyTuple_SET_ITEM( tmp_return_value, 1, tmp_tuple_element_1 );
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7d2642b77ac278ef54f940cfcbf38077 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_7d2642b77ac278ef54f940cfcbf38077 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7d2642b77ac278ef54f940cfcbf38077 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_7d2642b77ac278ef54f940cfcbf38077, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_7d2642b77ac278ef54f940cfcbf38077->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_7d2642b77ac278ef54f940cfcbf38077, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7d2642b77ac278ef54f940cfcbf38077,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_7d2642b77ac278ef54f940cfcbf38077 == cache_frame_7d2642b77ac278ef54f940cfcbf38077 )
    {
        Py_DECREF( frame_7d2642b77ac278ef54f940cfcbf38077 );
    }
    cache_frame_7d2642b77ac278ef54f940cfcbf38077 = NULL;

    assertFrameObject( frame_7d2642b77ac278ef54f940cfcbf38077 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_46___reduce__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_46___reduce__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_47___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_address = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_7f0f3df5e6d1653dd48befa6bc77ac64;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    bool tmp_result;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_7f0f3df5e6d1653dd48befa6bc77ac64 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_7f0f3df5e6d1653dd48befa6bc77ac64, codeobj_7f0f3df5e6d1653dd48befa6bc77ac64, module_ipaddress, sizeof(void *)+sizeof(void *) );
    frame_7f0f3df5e6d1653dd48befa6bc77ac64 = cache_frame_7f0f3df5e6d1653dd48befa6bc77ac64;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_7f0f3df5e6d1653dd48befa6bc77ac64 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_7f0f3df5e6d1653dd48befa6bc77ac64 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        tmp_assattr_name_1 = PyDict_New();
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__cache, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 731;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7f0f3df5e6d1653dd48befa6bc77ac64 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7f0f3df5e6d1653dd48befa6bc77ac64 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_7f0f3df5e6d1653dd48befa6bc77ac64, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_7f0f3df5e6d1653dd48befa6bc77ac64->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_7f0f3df5e6d1653dd48befa6bc77ac64, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7f0f3df5e6d1653dd48befa6bc77ac64,
        type_description_1,
        par_self,
        par_address
    );


    // Release cached frame.
    if ( frame_7f0f3df5e6d1653dd48befa6bc77ac64 == cache_frame_7f0f3df5e6d1653dd48befa6bc77ac64 )
    {
        Py_DECREF( frame_7f0f3df5e6d1653dd48befa6bc77ac64 );
    }
    cache_frame_7f0f3df5e6d1653dd48befa6bc77ac64 = NULL;

    assertFrameObject( frame_7f0f3df5e6d1653dd48befa6bc77ac64 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_47___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_address );
    Py_DECREF( par_address );
    par_address = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_address );
    Py_DECREF( par_address );
    par_address = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_47___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_48___repr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_81fb079e76541adf9e8bfbe35414892c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_81fb079e76541adf9e8bfbe35414892c = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_81fb079e76541adf9e8bfbe35414892c, codeobj_81fb079e76541adf9e8bfbe35414892c, module_ipaddress, sizeof(void *) );
    frame_81fb079e76541adf9e8bfbe35414892c = cache_frame_81fb079e76541adf9e8bfbe35414892c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_81fb079e76541adf9e8bfbe35414892c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_81fb079e76541adf9e8bfbe35414892c ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_left_name_1 = const_unicode_digest_d44bacc2290b5d18e632348ff9d94d65;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_2 );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 734;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain___name__ );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 734;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_1 = PyTuple_New( 2 );
        PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_str );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__compat_str );
        }

        if ( tmp_mvar_value_1 == NULL )
        {
            Py_DECREF( tmp_right_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_compat_str" );
            exception_tb = NULL;

            exception_lineno = 734;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_self );
        tmp_args_element_name_1 = par_self;
        frame_81fb079e76541adf9e8bfbe35414892c->m_frame.f_lineno = 734;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_tuple_element_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_right_name_1 );

            exception_lineno = 734;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM( tmp_right_name_1, 1, tmp_tuple_element_1 );
        tmp_return_value = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_right_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 734;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_81fb079e76541adf9e8bfbe35414892c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_81fb079e76541adf9e8bfbe35414892c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_81fb079e76541adf9e8bfbe35414892c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_81fb079e76541adf9e8bfbe35414892c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_81fb079e76541adf9e8bfbe35414892c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_81fb079e76541adf9e8bfbe35414892c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_81fb079e76541adf9e8bfbe35414892c,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_81fb079e76541adf9e8bfbe35414892c == cache_frame_81fb079e76541adf9e8bfbe35414892c )
    {
        Py_DECREF( frame_81fb079e76541adf9e8bfbe35414892c );
    }
    cache_frame_81fb079e76541adf9e8bfbe35414892c = NULL;

    assertFrameObject( frame_81fb079e76541adf9e8bfbe35414892c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_48___repr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_48___repr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_49___str__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_1af72631d4ce0035edf15f8f172d5fc2;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_1af72631d4ce0035edf15f8f172d5fc2 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1af72631d4ce0035edf15f8f172d5fc2, codeobj_1af72631d4ce0035edf15f8f172d5fc2, module_ipaddress, sizeof(void *) );
    frame_1af72631d4ce0035edf15f8f172d5fc2 = cache_frame_1af72631d4ce0035edf15f8f172d5fc2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1af72631d4ce0035edf15f8f172d5fc2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1af72631d4ce0035edf15f8f172d5fc2 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        tmp_left_name_1 = const_unicode_digest_6a98397c0892ba5e9c29046762cbb9d8;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_network_address );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 737;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_1 = PyTuple_New( 2 );
        PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_prefixlen );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_right_name_1 );

            exception_lineno = 737;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM( tmp_right_name_1, 1, tmp_tuple_element_1 );
        tmp_return_value = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_right_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 737;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1af72631d4ce0035edf15f8f172d5fc2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_1af72631d4ce0035edf15f8f172d5fc2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1af72631d4ce0035edf15f8f172d5fc2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1af72631d4ce0035edf15f8f172d5fc2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1af72631d4ce0035edf15f8f172d5fc2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1af72631d4ce0035edf15f8f172d5fc2, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1af72631d4ce0035edf15f8f172d5fc2,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_1af72631d4ce0035edf15f8f172d5fc2 == cache_frame_1af72631d4ce0035edf15f8f172d5fc2 )
    {
        Py_DECREF( frame_1af72631d4ce0035edf15f8f172d5fc2 );
    }
    cache_frame_1af72631d4ce0035edf15f8f172d5fc2 = NULL;

    assertFrameObject( frame_1af72631d4ce0035edf15f8f172d5fc2 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_49___str__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_49___str__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_50_hosts( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1( python_pars[ 0 ] );
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    // Tried code:
    tmp_return_value = ipaddress$$$function_50_hosts$$$genobj_1_hosts_maker();

    ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[0] = par_self;
    Py_INCREF( ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[0] );


    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_50_hosts );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_50_hosts );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}



struct ipaddress$$$function_50_hosts$$$genobj_1_hosts_locals {
    PyObject *var_broadcast;
    PyObject *var_x;
    PyObject *var_network;
    PyObject *tmp_for_loop_1__for_iterator;
    PyObject *tmp_for_loop_1__iter_value;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
};

static PyObject *ipaddress$$$function_50_hosts$$$genobj_1_hosts_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Heap access if used.
    struct ipaddress$$$function_50_hosts$$$genobj_1_hosts_locals *generator_heap = (struct ipaddress$$$function_50_hosts$$$genobj_1_hosts_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_broadcast = NULL;
    generator_heap->var_x = NULL;
    generator_heap->var_network = NULL;
    generator_heap->tmp_for_loop_1__for_iterator = NULL;
    generator_heap->tmp_for_loop_1__iter_value = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_m_frame, codeobj_7294db2a9216f390dfeaedea67d0ffcf, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

#if PYTHON_VERSION < 370
        generator->m_frame->m_frame.f_exc_type = EXC_TYPE( thread_state );
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
        Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#else
        generator->m_exc_state.exc_type = EXC_TYPE( thread_state );
        if ( generator->m_exc_state.exc_type == Py_None ) generator->m_exc_state.exc_type = NULL;
        Py_XINCREF( generator->m_exc_state.exc_type );
        generator->m_exc_state.exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_value );
        generator->m_exc_state.exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_traceback );
#endif
    }

#endif

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_int_arg_1;
        PyObject *tmp_source_name_1;
        if ( PyCell_GET( generator->m_closure[0] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 746;
            generator_heap->type_description_1 = "cooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = PyCell_GET( generator->m_closure[0] );
        tmp_int_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_network_address );
        if ( tmp_int_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 746;
            generator_heap->type_description_1 = "cooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_1 = PyNumber_Int( tmp_int_arg_1 );
        Py_DECREF( tmp_int_arg_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 746;
            generator_heap->type_description_1 = "cooo";
            goto frame_exception_exit_1;
        }
        assert( generator_heap->var_network == NULL );
        generator_heap->var_network = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_int_arg_2;
        PyObject *tmp_source_name_2;
        if ( PyCell_GET( generator->m_closure[0] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 747;
            generator_heap->type_description_1 = "cooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = PyCell_GET( generator->m_closure[0] );
        tmp_int_arg_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_broadcast_address );
        if ( tmp_int_arg_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 747;
            generator_heap->type_description_1 = "cooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_2 = PyNumber_Int( tmp_int_arg_2 );
        Py_DECREF( tmp_int_arg_2 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 747;
            generator_heap->type_description_1 = "cooo";
            goto frame_exception_exit_1;
        }
        assert( generator_heap->var_broadcast == NULL );
        generator_heap->var_broadcast = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_range );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__compat_range );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "global name '%s' is not defined", "_compat_range" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 748;
            generator_heap->type_description_1 = "cooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( generator_heap->var_network );
        tmp_left_name_1 = generator_heap->var_network;
        tmp_right_name_1 = const_int_pos_1;
        tmp_args_element_name_1 = BINARY_OPERATION_ADD_OBJECT_INT( tmp_left_name_1, tmp_right_name_1 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 748;
            generator_heap->type_description_1 = "cooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( generator_heap->var_broadcast );
        tmp_args_element_name_2 = generator_heap->var_broadcast;
        generator->m_frame->m_frame.f_lineno = 748;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_iter_arg_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_iter_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 748;
            generator_heap->type_description_1 = "cooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_3 = MAKE_ITERATOR( tmp_iter_arg_1 );
        Py_DECREF( tmp_iter_arg_1 );
        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 748;
            generator_heap->type_description_1 = "cooo";
            goto frame_exception_exit_1;
        }
        assert( generator_heap->tmp_for_loop_1__for_iterator == NULL );
        generator_heap->tmp_for_loop_1__for_iterator = tmp_assign_source_3;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_4;
        CHECK_OBJECT( generator_heap->tmp_for_loop_1__for_iterator );
        tmp_next_source_1 = generator_heap->tmp_for_loop_1__for_iterator;
        tmp_assign_source_4 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_4 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
                generator_heap->type_description_1 = "cooo";
                generator_heap->exception_lineno = 748;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_for_loop_1__iter_value;
            generator_heap->tmp_for_loop_1__iter_value = tmp_assign_source_4;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_5;
        CHECK_OBJECT( generator_heap->tmp_for_loop_1__iter_value );
        tmp_assign_source_5 = generator_heap->tmp_for_loop_1__iter_value;
        {
            PyObject *old = generator_heap->var_x;
            generator_heap->var_x = tmp_assign_source_5;
            Py_INCREF( generator_heap->var_x );
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_expression_name_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_3;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        if ( PyCell_GET( generator->m_closure[0] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 749;
            generator_heap->type_description_1 = "cooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_1 = PyCell_GET( generator->m_closure[0] );
        CHECK_OBJECT( generator_heap->var_x );
        tmp_args_element_name_3 = generator_heap->var_x;
        generator->m_frame->m_frame.f_lineno = 749;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_expression_name_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain__address_class, call_args );
        }

        if ( tmp_expression_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 749;
            generator_heap->type_description_1 = "cooo";
            goto try_except_handler_2;
        }
        Nuitka_PreserveHeap( generator_heap->yield_tmps, &tmp_called_instance_1, sizeof(PyObject *), &tmp_args_element_name_3, sizeof(PyObject *), NULL );
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        Nuitka_RestoreHeap( generator_heap->yield_tmps, &tmp_called_instance_1, sizeof(PyObject *), &tmp_args_element_name_3, sizeof(PyObject *), NULL );
        if ( yield_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 749;
            generator_heap->type_description_1 = "cooo";
            goto try_except_handler_2;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


        generator_heap->exception_lineno = 748;
        generator_heap->type_description_1 = "cooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->tmp_for_loop_1__iter_value );
    generator_heap->tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)generator_heap->tmp_for_loop_1__for_iterator );
    Py_DECREF( generator_heap->tmp_for_loop_1__for_iterator );
    generator_heap->tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( generator_heap->exception_type ) )
    {
        if ( generator_heap->exception_tb == NULL )
        {
            generator_heap->exception_tb = MAKE_TRACEBACK( generator->m_frame, generator_heap->exception_lineno );
        }
        else if ( generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            generator_heap->exception_tb = ADD_TRACEBACK( generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            generator->m_closure[0],
            generator_heap->var_broadcast,
            generator_heap->var_x,
            generator_heap->var_network
        );


        // Release cached frame.
        if ( generator->m_frame == cache_m_frame )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_m_frame = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->var_broadcast );
    generator_heap->var_broadcast = NULL;

    Py_XDECREF( generator_heap->var_x );
    generator_heap->var_x = NULL;

    Py_XDECREF( generator_heap->var_network );
    generator_heap->var_network = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:
    try_end_2:;
    Py_XDECREF( generator_heap->tmp_for_loop_1__iter_value );
    generator_heap->tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)generator_heap->tmp_for_loop_1__for_iterator );
    Py_DECREF( generator_heap->tmp_for_loop_1__for_iterator );
    generator_heap->tmp_for_loop_1__for_iterator = NULL;

    CHECK_OBJECT( (PyObject *)generator_heap->var_broadcast );
    Py_DECREF( generator_heap->var_broadcast );
    generator_heap->var_broadcast = NULL;

    Py_XDECREF( generator_heap->var_x );
    generator_heap->var_x = NULL;

    CHECK_OBJECT( (PyObject *)generator_heap->var_network );
    Py_DECREF( generator_heap->var_network );
    generator_heap->var_network = NULL;



    return NULL;

    function_exception_exit:
    assert( generator_heap->exception_type );
    RESTORE_ERROR_OCCURRED( generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb );

    return NULL;

}

static PyObject *ipaddress$$$function_50_hosts$$$genobj_1_hosts_maker( void )
{
    return Nuitka_Generator_New(
        ipaddress$$$function_50_hosts$$$genobj_1_hosts_context,
        module_ipaddress,
        const_str_plain_hosts,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_7294db2a9216f390dfeaedea67d0ffcf,
        1,
        sizeof(struct ipaddress$$$function_50_hosts$$$genobj_1_hosts_locals)
    );
}


static PyObject *impl_ipaddress$$$function_51___iter__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1( python_pars[ 0 ] );
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    // Tried code:
    tmp_return_value = ipaddress$$$function_51___iter__$$$genobj_1___iter___maker();

    ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[0] = par_self;
    Py_INCREF( ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[0] );


    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_51___iter__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_51___iter__ );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}



struct ipaddress$$$function_51___iter__$$$genobj_1___iter___locals {
    PyObject *var_broadcast;
    PyObject *var_x;
    PyObject *var_network;
    PyObject *tmp_for_loop_1__for_iterator;
    PyObject *tmp_for_loop_1__iter_value;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
};

static PyObject *ipaddress$$$function_51___iter__$$$genobj_1___iter___context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Heap access if used.
    struct ipaddress$$$function_51___iter__$$$genobj_1___iter___locals *generator_heap = (struct ipaddress$$$function_51___iter__$$$genobj_1___iter___locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_broadcast = NULL;
    generator_heap->var_x = NULL;
    generator_heap->var_network = NULL;
    generator_heap->tmp_for_loop_1__for_iterator = NULL;
    generator_heap->tmp_for_loop_1__iter_value = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_m_frame, codeobj_a9c87da975507046d881307a08716b6a, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

#if PYTHON_VERSION < 370
        generator->m_frame->m_frame.f_exc_type = EXC_TYPE( thread_state );
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
        Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#else
        generator->m_exc_state.exc_type = EXC_TYPE( thread_state );
        if ( generator->m_exc_state.exc_type == Py_None ) generator->m_exc_state.exc_type = NULL;
        Py_XINCREF( generator->m_exc_state.exc_type );
        generator->m_exc_state.exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_value );
        generator->m_exc_state.exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_traceback );
#endif
    }

#endif

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_int_arg_1;
        PyObject *tmp_source_name_1;
        if ( PyCell_GET( generator->m_closure[0] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 752;
            generator_heap->type_description_1 = "cooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = PyCell_GET( generator->m_closure[0] );
        tmp_int_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_network_address );
        if ( tmp_int_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 752;
            generator_heap->type_description_1 = "cooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_1 = PyNumber_Int( tmp_int_arg_1 );
        Py_DECREF( tmp_int_arg_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 752;
            generator_heap->type_description_1 = "cooo";
            goto frame_exception_exit_1;
        }
        assert( generator_heap->var_network == NULL );
        generator_heap->var_network = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_int_arg_2;
        PyObject *tmp_source_name_2;
        if ( PyCell_GET( generator->m_closure[0] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 753;
            generator_heap->type_description_1 = "cooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = PyCell_GET( generator->m_closure[0] );
        tmp_int_arg_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_broadcast_address );
        if ( tmp_int_arg_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 753;
            generator_heap->type_description_1 = "cooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_2 = PyNumber_Int( tmp_int_arg_2 );
        Py_DECREF( tmp_int_arg_2 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 753;
            generator_heap->type_description_1 = "cooo";
            goto frame_exception_exit_1;
        }
        assert( generator_heap->var_broadcast == NULL );
        generator_heap->var_broadcast = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_range );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__compat_range );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "global name '%s' is not defined", "_compat_range" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 754;
            generator_heap->type_description_1 = "cooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( generator_heap->var_network );
        tmp_args_element_name_1 = generator_heap->var_network;
        CHECK_OBJECT( generator_heap->var_broadcast );
        tmp_left_name_1 = generator_heap->var_broadcast;
        tmp_right_name_1 = const_int_pos_1;
        tmp_args_element_name_2 = BINARY_OPERATION_ADD_OBJECT_INT( tmp_left_name_1, tmp_right_name_1 );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 754;
            generator_heap->type_description_1 = "cooo";
            goto frame_exception_exit_1;
        }
        generator->m_frame->m_frame.f_lineno = 754;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_iter_arg_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_iter_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 754;
            generator_heap->type_description_1 = "cooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_3 = MAKE_ITERATOR( tmp_iter_arg_1 );
        Py_DECREF( tmp_iter_arg_1 );
        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 754;
            generator_heap->type_description_1 = "cooo";
            goto frame_exception_exit_1;
        }
        assert( generator_heap->tmp_for_loop_1__for_iterator == NULL );
        generator_heap->tmp_for_loop_1__for_iterator = tmp_assign_source_3;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_4;
        CHECK_OBJECT( generator_heap->tmp_for_loop_1__for_iterator );
        tmp_next_source_1 = generator_heap->tmp_for_loop_1__for_iterator;
        tmp_assign_source_4 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_4 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
                generator_heap->type_description_1 = "cooo";
                generator_heap->exception_lineno = 754;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_for_loop_1__iter_value;
            generator_heap->tmp_for_loop_1__iter_value = tmp_assign_source_4;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_5;
        CHECK_OBJECT( generator_heap->tmp_for_loop_1__iter_value );
        tmp_assign_source_5 = generator_heap->tmp_for_loop_1__iter_value;
        {
            PyObject *old = generator_heap->var_x;
            generator_heap->var_x = tmp_assign_source_5;
            Py_INCREF( generator_heap->var_x );
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_expression_name_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_3;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        if ( PyCell_GET( generator->m_closure[0] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 755;
            generator_heap->type_description_1 = "cooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_1 = PyCell_GET( generator->m_closure[0] );
        CHECK_OBJECT( generator_heap->var_x );
        tmp_args_element_name_3 = generator_heap->var_x;
        generator->m_frame->m_frame.f_lineno = 755;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_expression_name_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain__address_class, call_args );
        }

        if ( tmp_expression_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 755;
            generator_heap->type_description_1 = "cooo";
            goto try_except_handler_2;
        }
        Nuitka_PreserveHeap( generator_heap->yield_tmps, &tmp_called_instance_1, sizeof(PyObject *), &tmp_args_element_name_3, sizeof(PyObject *), NULL );
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        Nuitka_RestoreHeap( generator_heap->yield_tmps, &tmp_called_instance_1, sizeof(PyObject *), &tmp_args_element_name_3, sizeof(PyObject *), NULL );
        if ( yield_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 755;
            generator_heap->type_description_1 = "cooo";
            goto try_except_handler_2;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


        generator_heap->exception_lineno = 754;
        generator_heap->type_description_1 = "cooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->tmp_for_loop_1__iter_value );
    generator_heap->tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)generator_heap->tmp_for_loop_1__for_iterator );
    Py_DECREF( generator_heap->tmp_for_loop_1__for_iterator );
    generator_heap->tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( generator_heap->exception_type ) )
    {
        if ( generator_heap->exception_tb == NULL )
        {
            generator_heap->exception_tb = MAKE_TRACEBACK( generator->m_frame, generator_heap->exception_lineno );
        }
        else if ( generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            generator_heap->exception_tb = ADD_TRACEBACK( generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            generator->m_closure[0],
            generator_heap->var_broadcast,
            generator_heap->var_x,
            generator_heap->var_network
        );


        // Release cached frame.
        if ( generator->m_frame == cache_m_frame )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_m_frame = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->var_broadcast );
    generator_heap->var_broadcast = NULL;

    Py_XDECREF( generator_heap->var_x );
    generator_heap->var_x = NULL;

    Py_XDECREF( generator_heap->var_network );
    generator_heap->var_network = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:
    try_end_2:;
    Py_XDECREF( generator_heap->tmp_for_loop_1__iter_value );
    generator_heap->tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)generator_heap->tmp_for_loop_1__for_iterator );
    Py_DECREF( generator_heap->tmp_for_loop_1__for_iterator );
    generator_heap->tmp_for_loop_1__for_iterator = NULL;

    CHECK_OBJECT( (PyObject *)generator_heap->var_broadcast );
    Py_DECREF( generator_heap->var_broadcast );
    generator_heap->var_broadcast = NULL;

    Py_XDECREF( generator_heap->var_x );
    generator_heap->var_x = NULL;

    CHECK_OBJECT( (PyObject *)generator_heap->var_network );
    Py_DECREF( generator_heap->var_network );
    generator_heap->var_network = NULL;



    return NULL;

    function_exception_exit:
    assert( generator_heap->exception_type );
    RESTORE_ERROR_OCCURRED( generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb );

    return NULL;

}

static PyObject *ipaddress$$$function_51___iter__$$$genobj_1___iter___maker( void )
{
    return Nuitka_Generator_New(
        ipaddress$$$function_51___iter__$$$genobj_1___iter___context,
        module_ipaddress,
        const_str_plain___iter__,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_a9c87da975507046d881307a08716b6a,
        1,
        sizeof(struct ipaddress$$$function_51___iter__$$$genobj_1___iter___locals)
    );
}


static PyObject *impl_ipaddress$$$function_52___getitem__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_n = python_pars[ 1 ];
    PyObject *var_broadcast = NULL;
    PyObject *var_network = NULL;
    struct Nuitka_FrameObject *frame_f7f38e383ec02fe43d0b472cb99f0b76;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_f7f38e383ec02fe43d0b472cb99f0b76 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f7f38e383ec02fe43d0b472cb99f0b76, codeobj_f7f38e383ec02fe43d0b472cb99f0b76, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_f7f38e383ec02fe43d0b472cb99f0b76 = cache_frame_f7f38e383ec02fe43d0b472cb99f0b76;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f7f38e383ec02fe43d0b472cb99f0b76 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f7f38e383ec02fe43d0b472cb99f0b76 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_int_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_int_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_network_address );
        if ( tmp_int_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 758;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_1 = PyNumber_Int( tmp_int_arg_1 );
        Py_DECREF( tmp_int_arg_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 758;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_network == NULL );
        var_network = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_int_arg_2;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_int_arg_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_broadcast_address );
        if ( tmp_int_arg_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 759;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_2 = PyNumber_Int( tmp_int_arg_2 );
        Py_DECREF( tmp_int_arg_2 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 759;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_broadcast == NULL );
        var_broadcast = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( par_n );
        tmp_compexpr_left_1 = par_n;
        tmp_compexpr_right_1 = const_int_0;
        tmp_res = RICH_COMPARE_BOOL_GTE_OBJECT_INT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 760;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            CHECK_OBJECT( var_network );
            tmp_left_name_1 = var_network;
            CHECK_OBJECT( par_n );
            tmp_right_name_1 = par_n;
            tmp_compexpr_left_2 = BINARY_OPERATION_ADD_OBJECT_OBJECT( tmp_left_name_1, tmp_right_name_1 );
            if ( tmp_compexpr_left_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 761;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_broadcast );
            tmp_compexpr_right_2 = var_broadcast;
            tmp_res = RICH_COMPARE_BOOL_GT_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
            Py_DECREF( tmp_compexpr_left_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 761;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_raise_type_1;
                PyObject *tmp_make_exception_arg_1;
                tmp_make_exception_arg_1 = const_unicode_digest_7945ccf9bf2a22958263bad0bfe452b2;
                frame_f7f38e383ec02fe43d0b472cb99f0b76->m_frame.f_lineno = 762;
                {
                    PyObject *call_args[] = { tmp_make_exception_arg_1 };
                    tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_IndexError, call_args );
                }

                assert( !(tmp_raise_type_1 == NULL) );
                exception_type = tmp_raise_type_1;
                exception_lineno = 762;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            branch_no_2:;
        }
        {
            PyObject *tmp_called_name_1;
            PyObject *tmp_source_name_3;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_left_name_2;
            PyObject *tmp_right_name_2;
            CHECK_OBJECT( par_self );
            tmp_source_name_3 = par_self;
            tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__address_class );
            if ( tmp_called_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 763;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_network );
            tmp_left_name_2 = var_network;
            CHECK_OBJECT( par_n );
            tmp_right_name_2 = par_n;
            tmp_args_element_name_1 = BINARY_OPERATION_ADD_OBJECT_OBJECT( tmp_left_name_2, tmp_right_name_2 );
            if ( tmp_args_element_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_1 );

                exception_lineno = 763;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            frame_f7f38e383ec02fe43d0b472cb99f0b76->m_frame.f_lineno = 763;
            {
                PyObject *call_args[] = { tmp_args_element_name_1 };
                tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
            }

            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_1 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 763;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_left_name_3;
            PyObject *tmp_right_name_3;
            CHECK_OBJECT( par_n );
            tmp_left_name_3 = par_n;
            tmp_right_name_3 = const_int_pos_1;
            tmp_result = BINARY_OPERATION_ADD_OBJECT_INT_INPLACE( &tmp_left_name_3, tmp_right_name_3 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 765;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            tmp_assign_source_3 = tmp_left_name_3;
            par_n = tmp_assign_source_3;

        }
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            PyObject *tmp_left_name_4;
            PyObject *tmp_right_name_4;
            CHECK_OBJECT( var_broadcast );
            tmp_left_name_4 = var_broadcast;
            CHECK_OBJECT( par_n );
            tmp_right_name_4 = par_n;
            tmp_compexpr_left_3 = BINARY_OPERATION_ADD_OBJECT_OBJECT( tmp_left_name_4, tmp_right_name_4 );
            if ( tmp_compexpr_left_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 766;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_network );
            tmp_compexpr_right_3 = var_network;
            tmp_res = RICH_COMPARE_BOOL_LT_OBJECT_OBJECT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
            Py_DECREF( tmp_compexpr_left_3 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 766;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_3;
            }
            else
            {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_raise_type_2;
                PyObject *tmp_make_exception_arg_2;
                tmp_make_exception_arg_2 = const_unicode_digest_7945ccf9bf2a22958263bad0bfe452b2;
                frame_f7f38e383ec02fe43d0b472cb99f0b76->m_frame.f_lineno = 767;
                {
                    PyObject *call_args[] = { tmp_make_exception_arg_2 };
                    tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_IndexError, call_args );
                }

                assert( !(tmp_raise_type_2 == NULL) );
                exception_type = tmp_raise_type_2;
                exception_lineno = 767;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            branch_no_3:;
        }
        {
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_4;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_left_name_5;
            PyObject *tmp_right_name_5;
            CHECK_OBJECT( par_self );
            tmp_source_name_4 = par_self;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__address_class );
            if ( tmp_called_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 768;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_broadcast );
            tmp_left_name_5 = var_broadcast;
            CHECK_OBJECT( par_n );
            tmp_right_name_5 = par_n;
            tmp_args_element_name_2 = BINARY_OPERATION_ADD_OBJECT_OBJECT( tmp_left_name_5, tmp_right_name_5 );
            if ( tmp_args_element_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_2 );

                exception_lineno = 768;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            frame_f7f38e383ec02fe43d0b472cb99f0b76->m_frame.f_lineno = 768;
            {
                PyObject *call_args[] = { tmp_args_element_name_2 };
                tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
            }

            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_2 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 768;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f7f38e383ec02fe43d0b472cb99f0b76 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_f7f38e383ec02fe43d0b472cb99f0b76 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f7f38e383ec02fe43d0b472cb99f0b76 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f7f38e383ec02fe43d0b472cb99f0b76, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f7f38e383ec02fe43d0b472cb99f0b76->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f7f38e383ec02fe43d0b472cb99f0b76, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f7f38e383ec02fe43d0b472cb99f0b76,
        type_description_1,
        par_self,
        par_n,
        var_broadcast,
        var_network
    );


    // Release cached frame.
    if ( frame_f7f38e383ec02fe43d0b472cb99f0b76 == cache_frame_f7f38e383ec02fe43d0b472cb99f0b76 )
    {
        Py_DECREF( frame_f7f38e383ec02fe43d0b472cb99f0b76 );
    }
    cache_frame_f7f38e383ec02fe43d0b472cb99f0b76 = NULL;

    assertFrameObject( frame_f7f38e383ec02fe43d0b472cb99f0b76 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_52___getitem__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_broadcast );
    Py_DECREF( var_broadcast );
    var_broadcast = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_network );
    Py_DECREF( var_network );
    var_network = NULL;

    CHECK_OBJECT( (PyObject *)par_n );
    Py_DECREF( par_n );
    par_n = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_broadcast );
    var_broadcast = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_network );
    var_network = NULL;

    CHECK_OBJECT( (PyObject *)par_n );
    Py_DECREF( par_n );
    par_n = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_52___getitem__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_53___lt__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_fa3a1065a48af6021c6b23a77663b3d5;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_fa3a1065a48af6021c6b23a77663b3d5 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_fa3a1065a48af6021c6b23a77663b3d5, codeobj_fa3a1065a48af6021c6b23a77663b3d5, module_ipaddress, sizeof(void *)+sizeof(void *) );
    frame_fa3a1065a48af6021c6b23a77663b3d5 = cache_frame_fa3a1065a48af6021c6b23a77663b3d5;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_fa3a1065a48af6021c6b23a77663b3d5 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_fa3a1065a48af6021c6b23a77663b3d5 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_other );
        tmp_isinstance_inst_1 = par_other;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__IPAddressBase );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__IPAddressBase );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_IPAddressBase" );
            exception_tb = NULL;

            exception_lineno = 771;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 771;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 771;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_NotImplemented;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_2;
        PyObject *tmp_isinstance_inst_2;
        PyObject *tmp_isinstance_cls_2;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT( par_other );
        tmp_isinstance_inst_2 = par_other;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__BaseNetwork );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__BaseNetwork );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_BaseNetwork" );
            exception_tb = NULL;

            exception_lineno = 773;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_2 = tmp_mvar_value_2;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 773;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_2 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 773;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            PyObject *tmp_tuple_element_1;
            tmp_left_name_1 = const_unicode_digest_ce28e1a0d596488778adc7f428c3ab1f;
            CHECK_OBJECT( par_self );
            tmp_tuple_element_1 = par_self;
            tmp_right_name_1 = PyTuple_New( 2 );
            Py_INCREF( tmp_tuple_element_1 );
            PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
            CHECK_OBJECT( par_other );
            tmp_tuple_element_1 = par_other;
            Py_INCREF( tmp_tuple_element_1 );
            PyTuple_SET_ITEM( tmp_right_name_1, 1, tmp_tuple_element_1 );
            tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
            Py_DECREF( tmp_right_name_1 );
            if ( tmp_make_exception_arg_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 774;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            frame_fa3a1065a48af6021c6b23a77663b3d5->m_frame.f_lineno = 774;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            Py_DECREF( tmp_make_exception_arg_1 );
            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 774;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__version );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 776;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_other );
        tmp_source_name_2 = par_other;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__version );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_1 );

            exception_lineno = 776;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 776;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_make_exception_arg_2;
            PyObject *tmp_left_name_2;
            PyObject *tmp_right_name_2;
            PyObject *tmp_tuple_element_2;
            tmp_left_name_2 = const_unicode_digest_e922c2e07060bd895f3f403962951e84;
            CHECK_OBJECT( par_self );
            tmp_tuple_element_2 = par_self;
            tmp_right_name_2 = PyTuple_New( 2 );
            Py_INCREF( tmp_tuple_element_2 );
            PyTuple_SET_ITEM( tmp_right_name_2, 0, tmp_tuple_element_2 );
            CHECK_OBJECT( par_other );
            tmp_tuple_element_2 = par_other;
            Py_INCREF( tmp_tuple_element_2 );
            PyTuple_SET_ITEM( tmp_right_name_2, 1, tmp_tuple_element_2 );
            tmp_make_exception_arg_2 = BINARY_OPERATION_REMAINDER( tmp_left_name_2, tmp_right_name_2 );
            Py_DECREF( tmp_right_name_2 );
            if ( tmp_make_exception_arg_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 777;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            frame_fa3a1065a48af6021c6b23a77663b3d5->m_frame.f_lineno = 777;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_2 };
                tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            Py_DECREF( tmp_make_exception_arg_2 );
            assert( !(tmp_raise_type_2 == NULL) );
            exception_type = tmp_raise_type_2;
            exception_lineno = 777;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_3:;
    }
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_source_name_4;
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_network_address );
        if ( tmp_compexpr_left_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 779;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_other );
        tmp_source_name_4 = par_other;
        tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_network_address );
        if ( tmp_compexpr_right_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_2 );

            exception_lineno = 779;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        Py_DECREF( tmp_compexpr_left_2 );
        Py_DECREF( tmp_compexpr_right_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 779;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_4 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_4;
        }
        else
        {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            PyObject *tmp_source_name_5;
            PyObject *tmp_source_name_6;
            CHECK_OBJECT( par_self );
            tmp_source_name_5 = par_self;
            tmp_compexpr_left_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_network_address );
            if ( tmp_compexpr_left_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 780;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_other );
            tmp_source_name_6 = par_other;
            tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_network_address );
            if ( tmp_compexpr_right_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_compexpr_left_3 );

                exception_lineno = 780;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            tmp_return_value = RICH_COMPARE_LT_OBJECT_OBJECT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
            Py_DECREF( tmp_compexpr_left_3 );
            Py_DECREF( tmp_compexpr_right_3 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 780;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_no_4:;
    }
    {
        nuitka_bool tmp_condition_result_5;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        PyObject *tmp_source_name_7;
        PyObject *tmp_source_name_8;
        CHECK_OBJECT( par_self );
        tmp_source_name_7 = par_self;
        tmp_compexpr_left_4 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_netmask );
        if ( tmp_compexpr_left_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 781;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_other );
        tmp_source_name_8 = par_other;
        tmp_compexpr_right_4 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_netmask );
        if ( tmp_compexpr_right_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_4 );

            exception_lineno = 781;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_4, tmp_compexpr_right_4 );
        Py_DECREF( tmp_compexpr_left_4 );
        Py_DECREF( tmp_compexpr_right_4 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 781;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_5 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_5;
        }
        else
        {
            goto branch_no_5;
        }
        branch_yes_5:;
        {
            PyObject *tmp_compexpr_left_5;
            PyObject *tmp_compexpr_right_5;
            PyObject *tmp_source_name_9;
            PyObject *tmp_source_name_10;
            CHECK_OBJECT( par_self );
            tmp_source_name_9 = par_self;
            tmp_compexpr_left_5 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_netmask );
            if ( tmp_compexpr_left_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 782;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_other );
            tmp_source_name_10 = par_other;
            tmp_compexpr_right_5 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_netmask );
            if ( tmp_compexpr_right_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_compexpr_left_5 );

                exception_lineno = 782;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            tmp_return_value = RICH_COMPARE_LT_OBJECT_OBJECT( tmp_compexpr_left_5, tmp_compexpr_right_5 );
            Py_DECREF( tmp_compexpr_left_5 );
            Py_DECREF( tmp_compexpr_right_5 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 782;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_no_5:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fa3a1065a48af6021c6b23a77663b3d5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_fa3a1065a48af6021c6b23a77663b3d5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fa3a1065a48af6021c6b23a77663b3d5 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_fa3a1065a48af6021c6b23a77663b3d5, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_fa3a1065a48af6021c6b23a77663b3d5->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_fa3a1065a48af6021c6b23a77663b3d5, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_fa3a1065a48af6021c6b23a77663b3d5,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_fa3a1065a48af6021c6b23a77663b3d5 == cache_frame_fa3a1065a48af6021c6b23a77663b3d5 )
    {
        Py_DECREF( frame_fa3a1065a48af6021c6b23a77663b3d5 );
    }
    cache_frame_fa3a1065a48af6021c6b23a77663b3d5 = NULL;

    assertFrameObject( frame_fa3a1065a48af6021c6b23a77663b3d5 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_False;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_53___lt__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_53___lt__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_54___eq__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_f9185ed1a170c02330bb8fd2e8d972c3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_f9185ed1a170c02330bb8fd2e8d972c3 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f9185ed1a170c02330bb8fd2e8d972c3, codeobj_f9185ed1a170c02330bb8fd2e8d972c3, module_ipaddress, sizeof(void *)+sizeof(void *) );
    frame_f9185ed1a170c02330bb8fd2e8d972c3 = cache_frame_f9185ed1a170c02330bb8fd2e8d972c3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f9185ed1a170c02330bb8fd2e8d972c3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f9185ed1a170c02330bb8fd2e8d972c3 ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    {
        int tmp_and_left_truth_1;
        PyObject *tmp_and_left_value_1;
        PyObject *tmp_and_right_value_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        int tmp_and_left_truth_2;
        PyObject *tmp_and_left_value_2;
        PyObject *tmp_and_right_value_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_source_name_4;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_int_arg_1;
        PyObject *tmp_source_name_5;
        PyObject *tmp_int_arg_2;
        PyObject *tmp_source_name_6;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__version );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 787;
            type_description_1 = "oo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( par_other );
        tmp_source_name_2 = par_other;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__version );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_1 );

            exception_lineno = 787;
            type_description_1 = "oo";
            goto try_except_handler_2;
        }
        tmp_and_left_value_1 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_and_left_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 787;
            type_description_1 = "oo";
            goto try_except_handler_2;
        }
        tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
        if ( tmp_and_left_truth_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_and_left_value_1 );

            exception_lineno = 789;
            type_description_1 = "oo";
            goto try_except_handler_2;
        }
        if ( tmp_and_left_truth_1 == 1 )
        {
            goto and_right_1;
        }
        else
        {
            goto and_left_1;
        }
        and_right_1:;
        Py_DECREF( tmp_and_left_value_1 );
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_network_address );
        if ( tmp_compexpr_left_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 788;
            type_description_1 = "oo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( par_other );
        tmp_source_name_4 = par_other;
        tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_network_address );
        if ( tmp_compexpr_right_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_2 );

            exception_lineno = 788;
            type_description_1 = "oo";
            goto try_except_handler_2;
        }
        tmp_and_left_value_2 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        Py_DECREF( tmp_compexpr_left_2 );
        Py_DECREF( tmp_compexpr_right_2 );
        if ( tmp_and_left_value_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 788;
            type_description_1 = "oo";
            goto try_except_handler_2;
        }
        tmp_and_left_truth_2 = CHECK_IF_TRUE( tmp_and_left_value_2 );
        if ( tmp_and_left_truth_2 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_and_left_value_2 );

            exception_lineno = 789;
            type_description_1 = "oo";
            goto try_except_handler_2;
        }
        if ( tmp_and_left_truth_2 == 1 )
        {
            goto and_right_2;
        }
        else
        {
            goto and_left_2;
        }
        and_right_2:;
        Py_DECREF( tmp_and_left_value_2 );
        CHECK_OBJECT( par_self );
        tmp_source_name_5 = par_self;
        tmp_int_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_netmask );
        if ( tmp_int_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 789;
            type_description_1 = "oo";
            goto try_except_handler_2;
        }
        tmp_compexpr_left_3 = PyNumber_Int( tmp_int_arg_1 );
        Py_DECREF( tmp_int_arg_1 );
        if ( tmp_compexpr_left_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 789;
            type_description_1 = "oo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( par_other );
        tmp_source_name_6 = par_other;
        tmp_int_arg_2 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_netmask );
        if ( tmp_int_arg_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_3 );

            exception_lineno = 789;
            type_description_1 = "oo";
            goto try_except_handler_2;
        }
        tmp_compexpr_right_3 = PyNumber_Int( tmp_int_arg_2 );
        Py_DECREF( tmp_int_arg_2 );
        if ( tmp_compexpr_right_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_3 );

            exception_lineno = 789;
            type_description_1 = "oo";
            goto try_except_handler_2;
        }
        tmp_and_right_value_2 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
        Py_DECREF( tmp_compexpr_left_3 );
        Py_DECREF( tmp_compexpr_right_3 );
        if ( tmp_and_right_value_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 789;
            type_description_1 = "oo";
            goto try_except_handler_2;
        }
        tmp_and_right_value_1 = tmp_and_right_value_2;
        goto and_end_2;
        and_left_2:;
        tmp_and_right_value_1 = tmp_and_left_value_2;
        and_end_2:;
        tmp_return_value = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_return_value = tmp_and_left_value_1;
        and_end_1:;
        goto frame_return_exit_1;
    }
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_54___eq__ );
    return NULL;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_f9185ed1a170c02330bb8fd2e8d972c3 );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_f9185ed1a170c02330bb8fd2e8d972c3, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_f9185ed1a170c02330bb8fd2e8d972c3, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        tmp_compexpr_left_4 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_4 = PyExc_AttributeError;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_4, tmp_compexpr_right_4 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 790;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_NotImplemented;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        goto branch_end_1;
        branch_no_1:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 786;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_f9185ed1a170c02330bb8fd2e8d972c3->m_frame) frame_f9185ed1a170c02330bb8fd2e8d972c3->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
        branch_end_1:;
    }
    // End of try:

#if 1
    RESTORE_FRAME_EXCEPTION( frame_f9185ed1a170c02330bb8fd2e8d972c3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_f9185ed1a170c02330bb8fd2e8d972c3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_f9185ed1a170c02330bb8fd2e8d972c3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f9185ed1a170c02330bb8fd2e8d972c3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f9185ed1a170c02330bb8fd2e8d972c3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f9185ed1a170c02330bb8fd2e8d972c3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f9185ed1a170c02330bb8fd2e8d972c3,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_f9185ed1a170c02330bb8fd2e8d972c3 == cache_frame_f9185ed1a170c02330bb8fd2e8d972c3 )
    {
        Py_DECREF( frame_f9185ed1a170c02330bb8fd2e8d972c3 );
    }
    cache_frame_f9185ed1a170c02330bb8fd2e8d972c3 = NULL;

    assertFrameObject( frame_f9185ed1a170c02330bb8fd2e8d972c3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_54___eq__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_54___eq__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_55___hash__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_4b9e696776a8e3a1391c605ab86d1016;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_4b9e696776a8e3a1391c605ab86d1016 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_4b9e696776a8e3a1391c605ab86d1016, codeobj_4b9e696776a8e3a1391c605ab86d1016, module_ipaddress, sizeof(void *) );
    frame_4b9e696776a8e3a1391c605ab86d1016 = cache_frame_4b9e696776a8e3a1391c605ab86d1016;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_4b9e696776a8e3a1391c605ab86d1016 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_4b9e696776a8e3a1391c605ab86d1016 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_hash_arg_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_int_arg_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_int_arg_2;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_int_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_network_address );
        if ( tmp_int_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 794;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = PyNumber_Int( tmp_int_arg_1 );
        Py_DECREF( tmp_int_arg_1 );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 794;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_int_arg_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_netmask );
        if ( tmp_int_arg_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_left_name_1 );

            exception_lineno = 794;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_1 = PyNumber_Int( tmp_int_arg_2 );
        Py_DECREF( tmp_int_arg_2 );
        if ( tmp_right_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_left_name_1 );

            exception_lineno = 794;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_hash_arg_1 = BINARY_OPERATION( PyNumber_Xor, tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_left_name_1 );
        Py_DECREF( tmp_right_name_1 );
        if ( tmp_hash_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 794;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = BUILTIN_HASH( tmp_hash_arg_1 );
        Py_DECREF( tmp_hash_arg_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 794;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4b9e696776a8e3a1391c605ab86d1016 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_4b9e696776a8e3a1391c605ab86d1016 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4b9e696776a8e3a1391c605ab86d1016 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_4b9e696776a8e3a1391c605ab86d1016, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_4b9e696776a8e3a1391c605ab86d1016->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_4b9e696776a8e3a1391c605ab86d1016, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4b9e696776a8e3a1391c605ab86d1016,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_4b9e696776a8e3a1391c605ab86d1016 == cache_frame_4b9e696776a8e3a1391c605ab86d1016 )
    {
        Py_DECREF( frame_4b9e696776a8e3a1391c605ab86d1016 );
    }
    cache_frame_4b9e696776a8e3a1391c605ab86d1016 = NULL;

    assertFrameObject( frame_4b9e696776a8e3a1391c605ab86d1016 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_55___hash__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_55___hash__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_56___contains__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *tmp_comparison_chain_1__comparison_result = NULL;
    PyObject *tmp_comparison_chain_1__operand_2 = NULL;
    struct Nuitka_FrameObject *frame_75cfc528ffb67ea8d2c84948eee1df0b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_75cfc528ffb67ea8d2c84948eee1df0b = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_75cfc528ffb67ea8d2c84948eee1df0b, codeobj_75cfc528ffb67ea8d2c84948eee1df0b, module_ipaddress, sizeof(void *)+sizeof(void *) );
    frame_75cfc528ffb67ea8d2c84948eee1df0b = cache_frame_75cfc528ffb67ea8d2c84948eee1df0b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_75cfc528ffb67ea8d2c84948eee1df0b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_75cfc528ffb67ea8d2c84948eee1df0b ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__version );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 798;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_other );
        tmp_source_name_2 = par_other;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__version );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_1 );

            exception_lineno = 798;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 798;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_False;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_other );
        tmp_isinstance_inst_1 = par_other;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__BaseNetwork );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__BaseNetwork );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_BaseNetwork" );
            exception_tb = NULL;

            exception_lineno = 801;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 801;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        tmp_return_value = Py_False;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        goto branch_end_2;
        branch_no_2:;
        // Tried code:
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_int_arg_1;
            PyObject *tmp_source_name_3;
            CHECK_OBJECT( par_other );
            tmp_source_name_3 = par_other;
            tmp_int_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__ip );
            if ( tmp_int_arg_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 806;
                type_description_1 = "oo";
                goto try_except_handler_2;
            }
            tmp_assign_source_1 = PyNumber_Int( tmp_int_arg_1 );
            Py_DECREF( tmp_int_arg_1 );
            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 806;
                type_description_1 = "oo";
                goto try_except_handler_2;
            }
            assert( tmp_comparison_chain_1__operand_2 == NULL );
            tmp_comparison_chain_1__operand_2 = tmp_assign_source_1;
        }
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_int_arg_2;
            PyObject *tmp_source_name_4;
            CHECK_OBJECT( par_self );
            tmp_source_name_4 = par_self;
            tmp_int_arg_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_network_address );
            if ( tmp_int_arg_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 806;
                type_description_1 = "oo";
                goto try_except_handler_2;
            }
            tmp_compexpr_left_2 = PyNumber_Int( tmp_int_arg_2 );
            Py_DECREF( tmp_int_arg_2 );
            if ( tmp_compexpr_left_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 806;
                type_description_1 = "oo";
                goto try_except_handler_2;
            }
            CHECK_OBJECT( tmp_comparison_chain_1__operand_2 );
            tmp_compexpr_right_2 = tmp_comparison_chain_1__operand_2;
            tmp_assign_source_2 = RICH_COMPARE_LTE_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
            Py_DECREF( tmp_compexpr_left_2 );
            if ( tmp_assign_source_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 806;
                type_description_1 = "oo";
                goto try_except_handler_2;
            }
            assert( tmp_comparison_chain_1__comparison_result == NULL );
            tmp_comparison_chain_1__comparison_result = tmp_assign_source_2;
        }
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_operand_name_1;
            CHECK_OBJECT( tmp_comparison_chain_1__comparison_result );
            tmp_operand_name_1 = tmp_comparison_chain_1__comparison_result;
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 806;
                type_description_1 = "oo";
                goto try_except_handler_2;
            }
            tmp_condition_result_3 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_3;
            }
            else
            {
                goto branch_no_3;
            }
            branch_yes_3:;
            CHECK_OBJECT( tmp_comparison_chain_1__comparison_result );
            tmp_return_value = tmp_comparison_chain_1__comparison_result;
            Py_INCREF( tmp_return_value );
            goto try_return_handler_2;
            branch_no_3:;
        }
        {
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            PyObject *tmp_int_arg_3;
            PyObject *tmp_source_name_5;
            CHECK_OBJECT( tmp_comparison_chain_1__operand_2 );
            tmp_compexpr_left_3 = tmp_comparison_chain_1__operand_2;
            CHECK_OBJECT( par_self );
            tmp_source_name_5 = par_self;
            tmp_int_arg_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_broadcast_address );
            if ( tmp_int_arg_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 807;
                type_description_1 = "oo";
                goto try_except_handler_2;
            }
            tmp_compexpr_right_3 = PyNumber_Int( tmp_int_arg_3 );
            Py_DECREF( tmp_int_arg_3 );
            if ( tmp_compexpr_right_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 807;
                type_description_1 = "oo";
                goto try_except_handler_2;
            }
            tmp_return_value = RICH_COMPARE_LTE_OBJECT_OBJECT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
            Py_DECREF( tmp_compexpr_right_3 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 806;
                type_description_1 = "oo";
                goto try_except_handler_2;
            }
            goto try_return_handler_2;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ipaddress$$$function_56___contains__ );
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        CHECK_OBJECT( (PyObject *)tmp_comparison_chain_1__operand_2 );
        Py_DECREF( tmp_comparison_chain_1__operand_2 );
        tmp_comparison_chain_1__operand_2 = NULL;

        CHECK_OBJECT( (PyObject *)tmp_comparison_chain_1__comparison_result );
        Py_DECREF( tmp_comparison_chain_1__comparison_result );
        tmp_comparison_chain_1__comparison_result = NULL;

        goto outline_result_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF( tmp_comparison_chain_1__operand_2 );
        tmp_comparison_chain_1__operand_2 = NULL;

        Py_XDECREF( tmp_comparison_chain_1__comparison_result );
        tmp_comparison_chain_1__comparison_result = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto frame_exception_exit_1;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( ipaddress$$$function_56___contains__ );
        return NULL;
        outline_result_1:;
        goto frame_return_exit_1;
        branch_end_2:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_75cfc528ffb67ea8d2c84948eee1df0b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_75cfc528ffb67ea8d2c84948eee1df0b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_75cfc528ffb67ea8d2c84948eee1df0b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_75cfc528ffb67ea8d2c84948eee1df0b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_75cfc528ffb67ea8d2c84948eee1df0b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_75cfc528ffb67ea8d2c84948eee1df0b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_75cfc528ffb67ea8d2c84948eee1df0b,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_75cfc528ffb67ea8d2c84948eee1df0b == cache_frame_75cfc528ffb67ea8d2c84948eee1df0b )
    {
        Py_DECREF( frame_75cfc528ffb67ea8d2c84948eee1df0b );
    }
    cache_frame_75cfc528ffb67ea8d2c84948eee1df0b = NULL;

    assertFrameObject( frame_75cfc528ffb67ea8d2c84948eee1df0b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_56___contains__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_56___contains__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_57_overlaps( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_65a481757749f9bfb65fbb716f6aa9b0;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_65a481757749f9bfb65fbb716f6aa9b0 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_65a481757749f9bfb65fbb716f6aa9b0, codeobj_65a481757749f9bfb65fbb716f6aa9b0, module_ipaddress, sizeof(void *)+sizeof(void *) );
    frame_65a481757749f9bfb65fbb716f6aa9b0 = cache_frame_65a481757749f9bfb65fbb716f6aa9b0;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_65a481757749f9bfb65fbb716f6aa9b0 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_65a481757749f9bfb65fbb716f6aa9b0 ) == 2 ); // Frame stack

    // Framed code:
    {
        int tmp_or_left_truth_1;
        PyObject *tmp_or_left_value_1;
        PyObject *tmp_or_right_value_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        int tmp_or_left_truth_2;
        PyObject *tmp_or_left_value_2;
        PyObject *tmp_or_right_value_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_2;
        int tmp_or_left_truth_3;
        PyObject *tmp_or_left_value_3;
        PyObject *tmp_or_right_value_3;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_source_name_3;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        PyObject *tmp_source_name_4;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_network_address );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 811;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_other );
        tmp_compexpr_right_1 = par_other;
        tmp_res = PySequence_Contains( tmp_compexpr_right_1, tmp_compexpr_left_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 811;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_or_left_value_1 = ( tmp_res == 1 ) ? Py_True : Py_False;
        tmp_or_left_truth_1 = CHECK_IF_TRUE( tmp_or_left_value_1 );
        if ( tmp_or_left_truth_1 == 1 )
        {
            goto or_left_1;
        }
        else
        {
            goto or_right_1;
        }
        or_right_1:;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_broadcast_address );
        if ( tmp_compexpr_left_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 812;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_other );
        tmp_compexpr_right_2 = par_other;
        tmp_res = PySequence_Contains( tmp_compexpr_right_2, tmp_compexpr_left_2 );
        Py_DECREF( tmp_compexpr_left_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 812;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_or_left_value_2 = ( tmp_res == 1 ) ? Py_True : Py_False;
        tmp_or_left_truth_2 = CHECK_IF_TRUE( tmp_or_left_value_2 );
        if ( tmp_or_left_truth_2 == 1 )
        {
            goto or_left_2;
        }
        else
        {
            goto or_right_2;
        }
        or_right_2:;
        CHECK_OBJECT( par_other );
        tmp_source_name_3 = par_other;
        tmp_compexpr_left_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_network_address );
        if ( tmp_compexpr_left_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 813;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_compexpr_right_3 = par_self;
        tmp_res = PySequence_Contains( tmp_compexpr_right_3, tmp_compexpr_left_3 );
        Py_DECREF( tmp_compexpr_left_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 813;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_or_left_value_3 = ( tmp_res == 1 ) ? Py_True : Py_False;
        tmp_or_left_truth_3 = CHECK_IF_TRUE( tmp_or_left_value_3 );
        if ( tmp_or_left_truth_3 == 1 )
        {
            goto or_left_3;
        }
        else
        {
            goto or_right_3;
        }
        or_right_3:;
        CHECK_OBJECT( par_other );
        tmp_source_name_4 = par_other;
        tmp_compexpr_left_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_broadcast_address );
        if ( tmp_compexpr_left_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 814;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_compexpr_right_4 = par_self;
        tmp_res = PySequence_Contains( tmp_compexpr_right_4, tmp_compexpr_left_4 );
        Py_DECREF( tmp_compexpr_left_4 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 814;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_or_right_value_3 = ( tmp_res == 1 ) ? Py_True : Py_False;
        tmp_or_right_value_2 = tmp_or_right_value_3;
        goto or_end_3;
        or_left_3:;
        tmp_or_right_value_2 = tmp_or_left_value_3;
        or_end_3:;
        tmp_or_right_value_1 = tmp_or_right_value_2;
        goto or_end_2;
        or_left_2:;
        tmp_or_right_value_1 = tmp_or_left_value_2;
        or_end_2:;
        tmp_return_value = tmp_or_right_value_1;
        goto or_end_1;
        or_left_1:;
        tmp_return_value = tmp_or_left_value_1;
        or_end_1:;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_65a481757749f9bfb65fbb716f6aa9b0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_65a481757749f9bfb65fbb716f6aa9b0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_65a481757749f9bfb65fbb716f6aa9b0 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_65a481757749f9bfb65fbb716f6aa9b0, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_65a481757749f9bfb65fbb716f6aa9b0->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_65a481757749f9bfb65fbb716f6aa9b0, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_65a481757749f9bfb65fbb716f6aa9b0,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_65a481757749f9bfb65fbb716f6aa9b0 == cache_frame_65a481757749f9bfb65fbb716f6aa9b0 )
    {
        Py_DECREF( frame_65a481757749f9bfb65fbb716f6aa9b0 );
    }
    cache_frame_65a481757749f9bfb65fbb716f6aa9b0 = NULL;

    assertFrameObject( frame_65a481757749f9bfb65fbb716f6aa9b0 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_57_overlaps );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_57_overlaps );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_58_broadcast_address( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_x = NULL;
    struct Nuitka_FrameObject *frame_39e15cae3809f0757e14fe4a7c9b7fa2;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_39e15cae3809f0757e14fe4a7c9b7fa2 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_39e15cae3809f0757e14fe4a7c9b7fa2, codeobj_39e15cae3809f0757e14fe4a7c9b7fa2, module_ipaddress, sizeof(void *)+sizeof(void *) );
    frame_39e15cae3809f0757e14fe4a7c9b7fa2 = cache_frame_39e15cae3809f0757e14fe4a7c9b7fa2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_39e15cae3809f0757e14fe4a7c9b7fa2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_39e15cae3809f0757e14fe4a7c9b7fa2 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__cache );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 818;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_39e15cae3809f0757e14fe4a7c9b7fa2->m_frame.f_lineno = 818;
        tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_get, &PyTuple_GET_ITEM( const_tuple_unicode_plain_broadcast_address_tuple, 0 ) );

        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 818;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert( var_x == NULL );
        var_x = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( var_x );
        tmp_compexpr_left_1 = var_x;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_called_name_1;
            PyObject *tmp_source_name_2;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_left_name_1;
            PyObject *tmp_int_arg_1;
            PyObject *tmp_source_name_3;
            PyObject *tmp_right_name_1;
            PyObject *tmp_int_arg_2;
            PyObject *tmp_source_name_4;
            CHECK_OBJECT( par_self );
            tmp_source_name_2 = par_self;
            tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__address_class );
            if ( tmp_called_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 820;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_source_name_3 = par_self;
            tmp_int_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_network_address );
            if ( tmp_int_arg_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_1 );

                exception_lineno = 820;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            tmp_left_name_1 = PyNumber_Int( tmp_int_arg_1 );
            Py_DECREF( tmp_int_arg_1 );
            if ( tmp_left_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_1 );

                exception_lineno = 820;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_source_name_4 = par_self;
            tmp_int_arg_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_hostmask );
            if ( tmp_int_arg_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_1 );
                Py_DECREF( tmp_left_name_1 );

                exception_lineno = 821;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            tmp_right_name_1 = PyNumber_Int( tmp_int_arg_2 );
            Py_DECREF( tmp_int_arg_2 );
            if ( tmp_right_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_1 );
                Py_DECREF( tmp_left_name_1 );

                exception_lineno = 821;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            tmp_args_element_name_1 = BINARY_OPERATION( PyNumber_Or, tmp_left_name_1, tmp_right_name_1 );
            Py_DECREF( tmp_left_name_1 );
            Py_DECREF( tmp_right_name_1 );
            if ( tmp_args_element_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_1 );

                exception_lineno = 820;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            frame_39e15cae3809f0757e14fe4a7c9b7fa2->m_frame.f_lineno = 820;
            {
                PyObject *call_args[] = { tmp_args_element_name_1 };
                tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
            }

            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_1 );
            if ( tmp_assign_source_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 820;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = var_x;
                assert( old != NULL );
                var_x = tmp_assign_source_2;
                Py_DECREF( old );
            }

        }
        {
            PyObject *tmp_ass_subvalue_1;
            PyObject *tmp_ass_subscribed_1;
            PyObject *tmp_source_name_5;
            PyObject *tmp_ass_subscript_1;
            CHECK_OBJECT( var_x );
            tmp_ass_subvalue_1 = var_x;
            CHECK_OBJECT( par_self );
            tmp_source_name_5 = par_self;
            tmp_ass_subscribed_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__cache );
            if ( tmp_ass_subscribed_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 822;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            tmp_ass_subscript_1 = const_unicode_plain_broadcast_address;
            tmp_result = SET_SUBSCRIPT( tmp_ass_subscribed_1, tmp_ass_subscript_1, tmp_ass_subvalue_1 );
            Py_DECREF( tmp_ass_subscribed_1 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 822;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
        }
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_39e15cae3809f0757e14fe4a7c9b7fa2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_39e15cae3809f0757e14fe4a7c9b7fa2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_39e15cae3809f0757e14fe4a7c9b7fa2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_39e15cae3809f0757e14fe4a7c9b7fa2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_39e15cae3809f0757e14fe4a7c9b7fa2, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_39e15cae3809f0757e14fe4a7c9b7fa2,
        type_description_1,
        par_self,
        var_x
    );


    // Release cached frame.
    if ( frame_39e15cae3809f0757e14fe4a7c9b7fa2 == cache_frame_39e15cae3809f0757e14fe4a7c9b7fa2 )
    {
        Py_DECREF( frame_39e15cae3809f0757e14fe4a7c9b7fa2 );
    }
    cache_frame_39e15cae3809f0757e14fe4a7c9b7fa2 = NULL;

    assertFrameObject( frame_39e15cae3809f0757e14fe4a7c9b7fa2 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_x );
    tmp_return_value = var_x;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_58_broadcast_address );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_x );
    Py_DECREF( var_x );
    var_x = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_x );
    var_x = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_58_broadcast_address );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_59_hostmask( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_x = NULL;
    struct Nuitka_FrameObject *frame_9be0c556551336fa7c7c00a3df4577e6;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_9be0c556551336fa7c7c00a3df4577e6 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9be0c556551336fa7c7c00a3df4577e6, codeobj_9be0c556551336fa7c7c00a3df4577e6, module_ipaddress, sizeof(void *)+sizeof(void *) );
    frame_9be0c556551336fa7c7c00a3df4577e6 = cache_frame_9be0c556551336fa7c7c00a3df4577e6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9be0c556551336fa7c7c00a3df4577e6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9be0c556551336fa7c7c00a3df4577e6 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__cache );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 827;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_9be0c556551336fa7c7c00a3df4577e6->m_frame.f_lineno = 827;
        tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_get, &PyTuple_GET_ITEM( const_tuple_unicode_plain_hostmask_tuple, 0 ) );

        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 827;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert( var_x == NULL );
        var_x = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( var_x );
        tmp_compexpr_left_1 = var_x;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_called_name_1;
            PyObject *tmp_source_name_2;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_left_name_1;
            PyObject *tmp_int_arg_1;
            PyObject *tmp_source_name_3;
            PyObject *tmp_right_name_1;
            PyObject *tmp_source_name_4;
            CHECK_OBJECT( par_self );
            tmp_source_name_2 = par_self;
            tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__address_class );
            if ( tmp_called_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 829;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_source_name_3 = par_self;
            tmp_int_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_netmask );
            if ( tmp_int_arg_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_1 );

                exception_lineno = 829;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            tmp_left_name_1 = PyNumber_Int( tmp_int_arg_1 );
            Py_DECREF( tmp_int_arg_1 );
            if ( tmp_left_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_1 );

                exception_lineno = 829;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_source_name_4 = par_self;
            tmp_right_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__ALL_ONES );
            if ( tmp_right_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_1 );
                Py_DECREF( tmp_left_name_1 );

                exception_lineno = 829;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            tmp_args_element_name_1 = BINARY_OPERATION( PyNumber_Xor, tmp_left_name_1, tmp_right_name_1 );
            Py_DECREF( tmp_left_name_1 );
            Py_DECREF( tmp_right_name_1 );
            if ( tmp_args_element_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_1 );

                exception_lineno = 829;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            frame_9be0c556551336fa7c7c00a3df4577e6->m_frame.f_lineno = 829;
            {
                PyObject *call_args[] = { tmp_args_element_name_1 };
                tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
            }

            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_1 );
            if ( tmp_assign_source_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 829;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = var_x;
                assert( old != NULL );
                var_x = tmp_assign_source_2;
                Py_DECREF( old );
            }

        }
        {
            PyObject *tmp_ass_subvalue_1;
            PyObject *tmp_ass_subscribed_1;
            PyObject *tmp_source_name_5;
            PyObject *tmp_ass_subscript_1;
            CHECK_OBJECT( var_x );
            tmp_ass_subvalue_1 = var_x;
            CHECK_OBJECT( par_self );
            tmp_source_name_5 = par_self;
            tmp_ass_subscribed_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__cache );
            if ( tmp_ass_subscribed_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 830;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            tmp_ass_subscript_1 = const_unicode_plain_hostmask;
            tmp_result = SET_SUBSCRIPT( tmp_ass_subscribed_1, tmp_ass_subscript_1, tmp_ass_subvalue_1 );
            Py_DECREF( tmp_ass_subscribed_1 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 830;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
        }
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9be0c556551336fa7c7c00a3df4577e6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9be0c556551336fa7c7c00a3df4577e6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9be0c556551336fa7c7c00a3df4577e6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9be0c556551336fa7c7c00a3df4577e6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9be0c556551336fa7c7c00a3df4577e6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9be0c556551336fa7c7c00a3df4577e6,
        type_description_1,
        par_self,
        var_x
    );


    // Release cached frame.
    if ( frame_9be0c556551336fa7c7c00a3df4577e6 == cache_frame_9be0c556551336fa7c7c00a3df4577e6 )
    {
        Py_DECREF( frame_9be0c556551336fa7c7c00a3df4577e6 );
    }
    cache_frame_9be0c556551336fa7c7c00a3df4577e6 = NULL;

    assertFrameObject( frame_9be0c556551336fa7c7c00a3df4577e6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_x );
    tmp_return_value = var_x;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_59_hostmask );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_x );
    Py_DECREF( var_x );
    var_x = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_x );
    var_x = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_59_hostmask );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_60_with_prefixlen( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_e20490aef3e0cf3e11cbb7c3de926018;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_e20490aef3e0cf3e11cbb7c3de926018 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e20490aef3e0cf3e11cbb7c3de926018, codeobj_e20490aef3e0cf3e11cbb7c3de926018, module_ipaddress, sizeof(void *) );
    frame_e20490aef3e0cf3e11cbb7c3de926018 = cache_frame_e20490aef3e0cf3e11cbb7c3de926018;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e20490aef3e0cf3e11cbb7c3de926018 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e20490aef3e0cf3e11cbb7c3de926018 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        tmp_left_name_1 = const_unicode_digest_6a98397c0892ba5e9c29046762cbb9d8;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_network_address );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 835;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_1 = PyTuple_New( 2 );
        PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__prefixlen );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_right_name_1 );

            exception_lineno = 835;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM( tmp_right_name_1, 1, tmp_tuple_element_1 );
        tmp_return_value = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_right_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 835;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e20490aef3e0cf3e11cbb7c3de926018 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_e20490aef3e0cf3e11cbb7c3de926018 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e20490aef3e0cf3e11cbb7c3de926018 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e20490aef3e0cf3e11cbb7c3de926018, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e20490aef3e0cf3e11cbb7c3de926018->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e20490aef3e0cf3e11cbb7c3de926018, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e20490aef3e0cf3e11cbb7c3de926018,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_e20490aef3e0cf3e11cbb7c3de926018 == cache_frame_e20490aef3e0cf3e11cbb7c3de926018 )
    {
        Py_DECREF( frame_e20490aef3e0cf3e11cbb7c3de926018 );
    }
    cache_frame_e20490aef3e0cf3e11cbb7c3de926018 = NULL;

    assertFrameObject( frame_e20490aef3e0cf3e11cbb7c3de926018 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_60_with_prefixlen );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_60_with_prefixlen );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_61_with_netmask( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_a77ea2ed442180f359e7236fa03ce30e;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_a77ea2ed442180f359e7236fa03ce30e = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a77ea2ed442180f359e7236fa03ce30e, codeobj_a77ea2ed442180f359e7236fa03ce30e, module_ipaddress, sizeof(void *) );
    frame_a77ea2ed442180f359e7236fa03ce30e = cache_frame_a77ea2ed442180f359e7236fa03ce30e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a77ea2ed442180f359e7236fa03ce30e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a77ea2ed442180f359e7236fa03ce30e ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        tmp_left_name_1 = const_unicode_digest_3f6240938cc8b4c3691344def7c310a8;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_network_address );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 839;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_1 = PyTuple_New( 2 );
        PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_netmask );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_right_name_1 );

            exception_lineno = 839;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM( tmp_right_name_1, 1, tmp_tuple_element_1 );
        tmp_return_value = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_right_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 839;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a77ea2ed442180f359e7236fa03ce30e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_a77ea2ed442180f359e7236fa03ce30e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a77ea2ed442180f359e7236fa03ce30e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a77ea2ed442180f359e7236fa03ce30e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a77ea2ed442180f359e7236fa03ce30e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a77ea2ed442180f359e7236fa03ce30e, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a77ea2ed442180f359e7236fa03ce30e,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_a77ea2ed442180f359e7236fa03ce30e == cache_frame_a77ea2ed442180f359e7236fa03ce30e )
    {
        Py_DECREF( frame_a77ea2ed442180f359e7236fa03ce30e );
    }
    cache_frame_a77ea2ed442180f359e7236fa03ce30e = NULL;

    assertFrameObject( frame_a77ea2ed442180f359e7236fa03ce30e );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_61_with_netmask );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_61_with_netmask );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_62_with_hostmask( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_558a53c8ca1440f3014f54f358619139;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_558a53c8ca1440f3014f54f358619139 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_558a53c8ca1440f3014f54f358619139, codeobj_558a53c8ca1440f3014f54f358619139, module_ipaddress, sizeof(void *) );
    frame_558a53c8ca1440f3014f54f358619139 = cache_frame_558a53c8ca1440f3014f54f358619139;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_558a53c8ca1440f3014f54f358619139 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_558a53c8ca1440f3014f54f358619139 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        tmp_left_name_1 = const_unicode_digest_3f6240938cc8b4c3691344def7c310a8;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_network_address );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 843;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_1 = PyTuple_New( 2 );
        PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_hostmask );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_right_name_1 );

            exception_lineno = 843;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM( tmp_right_name_1, 1, tmp_tuple_element_1 );
        tmp_return_value = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_right_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 843;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_558a53c8ca1440f3014f54f358619139 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_558a53c8ca1440f3014f54f358619139 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_558a53c8ca1440f3014f54f358619139 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_558a53c8ca1440f3014f54f358619139, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_558a53c8ca1440f3014f54f358619139->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_558a53c8ca1440f3014f54f358619139, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_558a53c8ca1440f3014f54f358619139,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_558a53c8ca1440f3014f54f358619139 == cache_frame_558a53c8ca1440f3014f54f358619139 )
    {
        Py_DECREF( frame_558a53c8ca1440f3014f54f358619139 );
    }
    cache_frame_558a53c8ca1440f3014f54f358619139 = NULL;

    assertFrameObject( frame_558a53c8ca1440f3014f54f358619139 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_62_with_hostmask );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_62_with_hostmask );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_63_num_addresses( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_35f2f0b4833eb4d15fba0bdc439d87e6;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_35f2f0b4833eb4d15fba0bdc439d87e6 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_35f2f0b4833eb4d15fba0bdc439d87e6, codeobj_35f2f0b4833eb4d15fba0bdc439d87e6, module_ipaddress, sizeof(void *) );
    frame_35f2f0b4833eb4d15fba0bdc439d87e6 = cache_frame_35f2f0b4833eb4d15fba0bdc439d87e6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_35f2f0b4833eb4d15fba0bdc439d87e6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_35f2f0b4833eb4d15fba0bdc439d87e6 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_int_arg_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_int_arg_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_right_name_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_int_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_broadcast_address );
        if ( tmp_int_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 848;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_left_name_2 = PyNumber_Int( tmp_int_arg_1 );
        Py_DECREF( tmp_int_arg_1 );
        if ( tmp_left_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 848;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_int_arg_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_network_address );
        if ( tmp_int_arg_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_left_name_2 );

            exception_lineno = 848;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_1 = PyNumber_Int( tmp_int_arg_2 );
        Py_DECREF( tmp_int_arg_2 );
        if ( tmp_right_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_left_name_2 );

            exception_lineno = 848;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = BINARY_OPERATION_SUB( tmp_left_name_2, tmp_right_name_1 );
        Py_DECREF( tmp_left_name_2 );
        Py_DECREF( tmp_right_name_1 );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 848;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_2 = const_int_pos_1;
        tmp_return_value = BINARY_OPERATION_ADD_OBJECT_INT( tmp_left_name_1, tmp_right_name_2 );
        Py_DECREF( tmp_left_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 848;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_35f2f0b4833eb4d15fba0bdc439d87e6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_35f2f0b4833eb4d15fba0bdc439d87e6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_35f2f0b4833eb4d15fba0bdc439d87e6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_35f2f0b4833eb4d15fba0bdc439d87e6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_35f2f0b4833eb4d15fba0bdc439d87e6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_35f2f0b4833eb4d15fba0bdc439d87e6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_35f2f0b4833eb4d15fba0bdc439d87e6,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_35f2f0b4833eb4d15fba0bdc439d87e6 == cache_frame_35f2f0b4833eb4d15fba0bdc439d87e6 )
    {
        Py_DECREF( frame_35f2f0b4833eb4d15fba0bdc439d87e6 );
    }
    cache_frame_35f2f0b4833eb4d15fba0bdc439d87e6 = NULL;

    assertFrameObject( frame_35f2f0b4833eb4d15fba0bdc439d87e6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_63_num_addresses );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_63_num_addresses );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_64__address_class( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_msg = NULL;
    struct Nuitka_FrameObject *frame_f78f9052a3f53d3f5f58402f6adb4944;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_f78f9052a3f53d3f5f58402f6adb4944 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f78f9052a3f53d3f5f58402f6adb4944, codeobj_f78f9052a3f53d3f5f58402f6adb4944, module_ipaddress, sizeof(void *)+sizeof(void *) );
    frame_f78f9052a3f53d3f5f58402f6adb4944 = cache_frame_f78f9052a3f53d3f5f58402f6adb4944;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f78f9052a3f53d3f5f58402f6adb4944 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f78f9052a3f53d3f5f58402f6adb4944 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_type_arg_1;
        tmp_left_name_1 = const_unicode_digest_ac7f50929eae86b4966b77df5788b37d;
        CHECK_OBJECT( par_self );
        tmp_type_arg_1 = par_self;
        tmp_tuple_element_1 = BUILTIN_TYPE1( tmp_type_arg_1 );
        assert( !(tmp_tuple_element_1 == NULL) );
        tmp_right_name_1 = PyTuple_New( 1 );
        PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
        tmp_assign_source_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_right_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 855;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert( var_msg == NULL );
        var_msg = tmp_assign_source_1;
    }
    {
        PyObject *tmp_raise_type_1;
        PyObject *tmp_make_exception_arg_1;
        CHECK_OBJECT( var_msg );
        tmp_make_exception_arg_1 = var_msg;
        frame_f78f9052a3f53d3f5f58402f6adb4944->m_frame.f_lineno = 856;
        {
            PyObject *call_args[] = { tmp_make_exception_arg_1 };
            tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_NotImplementedError, call_args );
        }

        assert( !(tmp_raise_type_1 == NULL) );
        exception_type = tmp_raise_type_1;
        exception_lineno = 856;
        RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f78f9052a3f53d3f5f58402f6adb4944 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f78f9052a3f53d3f5f58402f6adb4944 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f78f9052a3f53d3f5f58402f6adb4944, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f78f9052a3f53d3f5f58402f6adb4944->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f78f9052a3f53d3f5f58402f6adb4944, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f78f9052a3f53d3f5f58402f6adb4944,
        type_description_1,
        par_self,
        var_msg
    );


    // Release cached frame.
    if ( frame_f78f9052a3f53d3f5f58402f6adb4944 == cache_frame_f78f9052a3f53d3f5f58402f6adb4944 )
    {
        Py_DECREF( frame_f78f9052a3f53d3f5f58402f6adb4944 );
    }
    cache_frame_f78f9052a3f53d3f5f58402f6adb4944 = NULL;

    assertFrameObject( frame_f78f9052a3f53d3f5f58402f6adb4944 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_64__address_class );
    return NULL;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_msg );
    var_msg = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_64__address_class );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

}


static PyObject *impl_ipaddress$$$function_65_prefixlen( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_02eb5158aaf36af6a20d27401bd96db3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_02eb5158aaf36af6a20d27401bd96db3 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_02eb5158aaf36af6a20d27401bd96db3, codeobj_02eb5158aaf36af6a20d27401bd96db3, module_ipaddress, sizeof(void *) );
    frame_02eb5158aaf36af6a20d27401bd96db3 = cache_frame_02eb5158aaf36af6a20d27401bd96db3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_02eb5158aaf36af6a20d27401bd96db3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_02eb5158aaf36af6a20d27401bd96db3 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__prefixlen );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 860;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_02eb5158aaf36af6a20d27401bd96db3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_02eb5158aaf36af6a20d27401bd96db3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_02eb5158aaf36af6a20d27401bd96db3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_02eb5158aaf36af6a20d27401bd96db3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_02eb5158aaf36af6a20d27401bd96db3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_02eb5158aaf36af6a20d27401bd96db3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_02eb5158aaf36af6a20d27401bd96db3,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_02eb5158aaf36af6a20d27401bd96db3 == cache_frame_02eb5158aaf36af6a20d27401bd96db3 )
    {
        Py_DECREF( frame_02eb5158aaf36af6a20d27401bd96db3 );
    }
    cache_frame_02eb5158aaf36af6a20d27401bd96db3 = NULL;

    assertFrameObject( frame_02eb5158aaf36af6a20d27401bd96db3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_65_prefixlen );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_65_prefixlen );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_66_address_exclude( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1( python_pars[ 0 ] );
    struct Nuitka_CellObject *par_other = PyCell_NEW1( python_pars[ 1 ] );
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    // Tried code:
    tmp_return_value = ipaddress$$$function_66_address_exclude$$$genobj_1_address_exclude_maker();

    ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[0] = par_other;
    Py_INCREF( ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[0] );
    ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[1] = par_self;
    Py_INCREF( ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[1] );


    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_66_address_exclude );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_66_address_exclude );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}



struct ipaddress$$$function_66_address_exclude$$$genobj_1_address_exclude_locals {
    PyObject *var_s2;
    PyObject *var_s1;
    PyObject *tmp_tuple_unpack_1__element_1;
    PyObject *tmp_tuple_unpack_1__element_2;
    PyObject *tmp_tuple_unpack_1__source_iter;
    PyObject *tmp_tuple_unpack_2__element_1;
    PyObject *tmp_tuple_unpack_2__element_2;
    PyObject *tmp_tuple_unpack_2__source_iter;
    PyObject *tmp_tuple_unpack_3__element_1;
    PyObject *tmp_tuple_unpack_3__element_2;
    PyObject *tmp_tuple_unpack_3__source_iter;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    int tmp_res;
    PyObject *tmp_iterator_attempt;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    int exception_keeper_lineno_4;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    int exception_keeper_lineno_5;
    PyObject *exception_keeper_type_6;
    PyObject *exception_keeper_value_6;
    PyTracebackObject *exception_keeper_tb_6;
    int exception_keeper_lineno_6;
    PyObject *exception_keeper_type_7;
    PyObject *exception_keeper_value_7;
    PyTracebackObject *exception_keeper_tb_7;
    int exception_keeper_lineno_7;
};

static PyObject *ipaddress$$$function_66_address_exclude$$$genobj_1_address_exclude_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Heap access if used.
    struct ipaddress$$$function_66_address_exclude$$$genobj_1_address_exclude_locals *generator_heap = (struct ipaddress$$$function_66_address_exclude$$$genobj_1_address_exclude_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 4: goto yield_return_4;
    case 3: goto yield_return_3;
    case 2: goto yield_return_2;
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_s2 = NULL;
    generator_heap->var_s1 = NULL;
    generator_heap->tmp_tuple_unpack_1__element_1 = NULL;
    generator_heap->tmp_tuple_unpack_1__element_2 = NULL;
    generator_heap->tmp_tuple_unpack_1__source_iter = NULL;
    generator_heap->tmp_tuple_unpack_2__element_1 = NULL;
    generator_heap->tmp_tuple_unpack_2__element_2 = NULL;
    generator_heap->tmp_tuple_unpack_2__source_iter = NULL;
    generator_heap->tmp_tuple_unpack_3__element_1 = NULL;
    generator_heap->tmp_tuple_unpack_3__element_2 = NULL;
    generator_heap->tmp_tuple_unpack_3__source_iter = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_m_frame, codeobj_3769b2c4ffdc7c3f9f9b4dbc1cef7e71, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

#if PYTHON_VERSION < 370
        generator->m_frame->m_frame.f_exc_type = EXC_TYPE( thread_state );
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
        Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#else
        generator->m_exc_state.exc_type = EXC_TYPE( thread_state );
        if ( generator->m_exc_state.exc_type == Py_None ) generator->m_exc_state.exc_type = NULL;
        Py_XINCREF( generator->m_exc_state.exc_type );
        generator->m_exc_state.exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_value );
        generator->m_exc_state.exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_traceback );
#endif
    }

#endif

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        if ( PyCell_GET( generator->m_closure[1] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 898;
            generator_heap->type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = PyCell_GET( generator->m_closure[1] );
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__version );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 898;
            generator_heap->type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }
        if ( PyCell_GET( generator->m_closure[0] ) == NULL )
        {
            Py_DECREF( tmp_compexpr_left_1 );
            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "other" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 898;
            generator_heap->type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = PyCell_GET( generator->m_closure[0] );
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__version );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
            Py_DECREF( tmp_compexpr_left_1 );

            generator_heap->exception_lineno = 898;
            generator_heap->type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_operand_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 898;
            generator_heap->type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }
        generator_heap->tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        Py_DECREF( tmp_operand_name_1 );
        if ( generator_heap->tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 898;
            generator_heap->type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( generator_heap->tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            PyObject *tmp_tuple_element_1;
            tmp_left_name_1 = const_unicode_digest_e922c2e07060bd895f3f403962951e84;
            if ( PyCell_GET( generator->m_closure[1] ) == NULL )
            {

                generator_heap->exception_type = PyExc_NameError;
                Py_INCREF( generator_heap->exception_type );
                generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
                generator_heap->exception_tb = NULL;

                generator_heap->exception_lineno = 900;
                generator_heap->type_description_1 = "ccoo";
                goto frame_exception_exit_1;
            }

            tmp_tuple_element_1 = PyCell_GET( generator->m_closure[1] );
            tmp_right_name_1 = PyTuple_New( 2 );
            Py_INCREF( tmp_tuple_element_1 );
            PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
            if ( PyCell_GET( generator->m_closure[0] ) == NULL )
            {
                Py_DECREF( tmp_right_name_1 );
                generator_heap->exception_type = PyExc_NameError;
                Py_INCREF( generator_heap->exception_type );
                generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "other" );
                generator_heap->exception_tb = NULL;

                generator_heap->exception_lineno = 900;
                generator_heap->type_description_1 = "ccoo";
                goto frame_exception_exit_1;
            }

            tmp_tuple_element_1 = PyCell_GET( generator->m_closure[0] );
            Py_INCREF( tmp_tuple_element_1 );
            PyTuple_SET_ITEM( tmp_right_name_1, 1, tmp_tuple_element_1 );
            tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
            Py_DECREF( tmp_right_name_1 );
            if ( tmp_make_exception_arg_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


                generator_heap->exception_lineno = 899;
                generator_heap->type_description_1 = "ccoo";
                goto frame_exception_exit_1;
            }
            generator->m_frame->m_frame.f_lineno = 899;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            Py_DECREF( tmp_make_exception_arg_1 );
            assert( !(tmp_raise_type_1 == NULL) );
            generator_heap->exception_type = tmp_raise_type_1;
            generator_heap->exception_lineno = 899;
            RAISE_EXCEPTION_WITH_TYPE( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
            generator_heap->type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_2;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        if ( PyCell_GET( generator->m_closure[0] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "other" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 902;
            generator_heap->type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_inst_1 = PyCell_GET( generator->m_closure[0] );
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__BaseNetwork );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__BaseNetwork );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "global name '%s' is not defined", "_BaseNetwork" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 902;
            generator_heap->type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        generator_heap->tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( generator_heap->tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 902;
            generator_heap->type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_2 = ( generator_heap->tmp_res != 0 ) ? Py_True : Py_False;
        generator_heap->tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        if ( generator_heap->tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 902;
            generator_heap->type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( generator_heap->tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_make_exception_arg_2;
            PyObject *tmp_left_name_2;
            PyObject *tmp_right_name_2;
            tmp_left_name_2 = const_unicode_digest_adc545fc78271f8a7bba433d2d4f8995;
            if ( PyCell_GET( generator->m_closure[0] ) == NULL )
            {

                generator_heap->exception_type = PyExc_NameError;
                Py_INCREF( generator_heap->exception_type );
                generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "other" );
                generator_heap->exception_tb = NULL;

                generator_heap->exception_lineno = 903;
                generator_heap->type_description_1 = "ccoo";
                goto frame_exception_exit_1;
            }

            tmp_right_name_2 = PyCell_GET( generator->m_closure[0] );
            tmp_make_exception_arg_2 = BINARY_OPERATION_REMAINDER( tmp_left_name_2, tmp_right_name_2 );
            if ( tmp_make_exception_arg_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


                generator_heap->exception_lineno = 903;
                generator_heap->type_description_1 = "ccoo";
                goto frame_exception_exit_1;
            }
            generator->m_frame->m_frame.f_lineno = 903;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_2 };
                tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            Py_DECREF( tmp_make_exception_arg_2 );
            assert( !(tmp_raise_type_2 == NULL) );
            generator_heap->exception_type = tmp_raise_type_2;
            generator_heap->exception_lineno = 903;
            RAISE_EXCEPTION_WITH_TYPE( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
            generator_heap->type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_operand_name_3;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_args_element_name_1;
        if ( PyCell_GET( generator->m_closure[0] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "other" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 905;
            generator_heap->type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = PyCell_GET( generator->m_closure[0] );
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_subnet_of );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 905;
            generator_heap->type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }
        if ( PyCell_GET( generator->m_closure[1] ) == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 905;
            generator_heap->type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = PyCell_GET( generator->m_closure[1] );
        generator->m_frame->m_frame.f_lineno = 905;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_operand_name_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        if ( tmp_operand_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 905;
            generator_heap->type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }
        generator_heap->tmp_res = CHECK_IF_TRUE( tmp_operand_name_3 );
        Py_DECREF( tmp_operand_name_3 );
        if ( generator_heap->tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 905;
            generator_heap->type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = ( generator_heap->tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_raise_type_3;
            PyObject *tmp_make_exception_arg_3;
            PyObject *tmp_left_name_3;
            PyObject *tmp_right_name_3;
            PyObject *tmp_tuple_element_2;
            tmp_left_name_3 = const_unicode_digest_5efcd38faf89c403a070f9e85430b29c;
            if ( PyCell_GET( generator->m_closure[0] ) == NULL )
            {

                generator_heap->exception_type = PyExc_NameError;
                Py_INCREF( generator_heap->exception_type );
                generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "other" );
                generator_heap->exception_tb = NULL;

                generator_heap->exception_lineno = 906;
                generator_heap->type_description_1 = "ccoo";
                goto frame_exception_exit_1;
            }

            tmp_tuple_element_2 = PyCell_GET( generator->m_closure[0] );
            tmp_right_name_3 = PyTuple_New( 2 );
            Py_INCREF( tmp_tuple_element_2 );
            PyTuple_SET_ITEM( tmp_right_name_3, 0, tmp_tuple_element_2 );
            if ( PyCell_GET( generator->m_closure[1] ) == NULL )
            {
                Py_DECREF( tmp_right_name_3 );
                generator_heap->exception_type = PyExc_NameError;
                Py_INCREF( generator_heap->exception_type );
                generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
                generator_heap->exception_tb = NULL;

                generator_heap->exception_lineno = 906;
                generator_heap->type_description_1 = "ccoo";
                goto frame_exception_exit_1;
            }

            tmp_tuple_element_2 = PyCell_GET( generator->m_closure[1] );
            Py_INCREF( tmp_tuple_element_2 );
            PyTuple_SET_ITEM( tmp_right_name_3, 1, tmp_tuple_element_2 );
            tmp_make_exception_arg_3 = BINARY_OPERATION_REMAINDER( tmp_left_name_3, tmp_right_name_3 );
            Py_DECREF( tmp_right_name_3 );
            if ( tmp_make_exception_arg_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


                generator_heap->exception_lineno = 906;
                generator_heap->type_description_1 = "ccoo";
                goto frame_exception_exit_1;
            }
            generator->m_frame->m_frame.f_lineno = 906;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_3 };
                tmp_raise_type_3 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            Py_DECREF( tmp_make_exception_arg_3 );
            assert( !(tmp_raise_type_3 == NULL) );
            generator_heap->exception_type = tmp_raise_type_3;
            generator_heap->exception_lineno = 906;
            RAISE_EXCEPTION_WITH_TYPE( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
            generator_heap->type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }
        branch_no_3:;
    }
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        if ( PyCell_GET( generator->m_closure[0] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "other" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 907;
            generator_heap->type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_left_2 = PyCell_GET( generator->m_closure[0] );
        if ( PyCell_GET( generator->m_closure[1] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 907;
            generator_heap->type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_2 = PyCell_GET( generator->m_closure[1] );
        generator_heap->tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        if ( generator_heap->tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 907;
            generator_heap->type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_4 = ( generator_heap->tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_4;
        }
        else
        {
            goto branch_no_4;
        }
        branch_yes_4:;
        goto frame_return_exit_1;
        branch_no_4:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_left_name_4;
        PyObject *tmp_right_name_4;
        PyObject *tmp_tuple_element_3;
        PyObject *tmp_source_name_5;
        PyObject *tmp_source_name_6;
        if ( PyCell_GET( generator->m_closure[0] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "other" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 911;
            generator_heap->type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = PyCell_GET( generator->m_closure[0] );
        tmp_called_name_2 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_4 );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 911;
            generator_heap->type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_4 = const_unicode_digest_3f6240938cc8b4c3691344def7c310a8;
        if ( PyCell_GET( generator->m_closure[0] ) == NULL )
        {
            Py_DECREF( tmp_called_name_2 );
            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "other" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 911;
            generator_heap->type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = PyCell_GET( generator->m_closure[0] );
        tmp_tuple_element_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_network_address );
        if ( tmp_tuple_element_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
            Py_DECREF( tmp_called_name_2 );

            generator_heap->exception_lineno = 911;
            generator_heap->type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }
        tmp_right_name_4 = PyTuple_New( 2 );
        PyTuple_SET_ITEM( tmp_right_name_4, 0, tmp_tuple_element_3 );
        if ( PyCell_GET( generator->m_closure[0] ) == NULL )
        {
            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_right_name_4 );
            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "other" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 912;
            generator_heap->type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = PyCell_GET( generator->m_closure[0] );
        tmp_tuple_element_3 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_prefixlen );
        if ( tmp_tuple_element_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_right_name_4 );

            generator_heap->exception_lineno = 912;
            generator_heap->type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM( tmp_right_name_4, 1, tmp_tuple_element_3 );
        tmp_args_element_name_2 = BINARY_OPERATION_REMAINDER( tmp_left_name_4, tmp_right_name_4 );
        Py_DECREF( tmp_right_name_4 );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
            Py_DECREF( tmp_called_name_2 );

            generator_heap->exception_lineno = 911;
            generator_heap->type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }
        generator->m_frame->m_frame.f_lineno = 911;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 911;
            generator_heap->type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = PyCell_GET( generator->m_closure[0] );
            PyCell_SET( generator->m_closure[0], tmp_assign_source_1 );
            Py_XDECREF( old );
        }

    }
    // Tried code:
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_called_instance_1;
        if ( PyCell_GET( generator->m_closure[1] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 914;
            generator_heap->type_description_1 = "ccoo";
            goto try_except_handler_2;
        }

        tmp_called_instance_1 = PyCell_GET( generator->m_closure[1] );
        generator->m_frame->m_frame.f_lineno = 914;
        tmp_iter_arg_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_subnets );
        if ( tmp_iter_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 914;
            generator_heap->type_description_1 = "ccoo";
            goto try_except_handler_2;
        }
        tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
        Py_DECREF( tmp_iter_arg_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 914;
            generator_heap->type_description_1 = "ccoo";
            goto try_except_handler_2;
        }
        assert( generator_heap->tmp_tuple_unpack_1__source_iter == NULL );
        generator_heap->tmp_tuple_unpack_1__source_iter = tmp_assign_source_2;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_unpack_1;
        CHECK_OBJECT( generator_heap->tmp_tuple_unpack_1__source_iter );
        tmp_unpack_1 = generator_heap->tmp_tuple_unpack_1__source_iter;
        tmp_assign_source_3 = UNPACK_NEXT( tmp_unpack_1, 0 );
        if ( tmp_assign_source_3 == NULL )
        {
            if ( !ERROR_OCCURRED() )
            {
                generator_heap->exception_type = PyExc_StopIteration;
                Py_INCREF( generator_heap->exception_type );
                generator_heap->exception_value = NULL;
                generator_heap->exception_tb = NULL;
            }
            else
            {
                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
            }


            generator_heap->type_description_1 = "ccoo";
            generator_heap->exception_lineno = 914;
            goto try_except_handler_3;
        }
        assert( generator_heap->tmp_tuple_unpack_1__element_1 == NULL );
        generator_heap->tmp_tuple_unpack_1__element_1 = tmp_assign_source_3;
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_unpack_2;
        CHECK_OBJECT( generator_heap->tmp_tuple_unpack_1__source_iter );
        tmp_unpack_2 = generator_heap->tmp_tuple_unpack_1__source_iter;
        tmp_assign_source_4 = UNPACK_NEXT( tmp_unpack_2, 1 );
        if ( tmp_assign_source_4 == NULL )
        {
            if ( !ERROR_OCCURRED() )
            {
                generator_heap->exception_type = PyExc_StopIteration;
                Py_INCREF( generator_heap->exception_type );
                generator_heap->exception_value = NULL;
                generator_heap->exception_tb = NULL;
            }
            else
            {
                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
            }


            generator_heap->type_description_1 = "ccoo";
            generator_heap->exception_lineno = 914;
            goto try_except_handler_3;
        }
        assert( generator_heap->tmp_tuple_unpack_1__element_2 == NULL );
        generator_heap->tmp_tuple_unpack_1__element_2 = tmp_assign_source_4;
    }
    {
        PyObject *tmp_iterator_name_1;
        CHECK_OBJECT( generator_heap->tmp_tuple_unpack_1__source_iter );
        tmp_iterator_name_1 = generator_heap->tmp_tuple_unpack_1__source_iter;
        // Check if iterator has left-over elements.
        CHECK_OBJECT( tmp_iterator_name_1 ); assert( HAS_ITERNEXT( tmp_iterator_name_1 ) );

        generator_heap->tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_1 )->tp_iternext)( tmp_iterator_name_1 );

        if (likely( generator_heap->tmp_iterator_attempt == NULL ))
        {
            PyObject *error = GET_ERROR_OCCURRED();

            if ( error != NULL )
            {
                if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
                {
                    CLEAR_ERROR_OCCURRED();
                }
                else
                {
                    FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );

                    generator_heap->type_description_1 = "ccoo";
                    generator_heap->exception_lineno = 914;
                    goto try_except_handler_3;
                }
            }
        }
        else
        {
            Py_DECREF( generator_heap->tmp_iterator_attempt );

            // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
            PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 2)" );
#endif
            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );

            generator_heap->type_description_1 = "ccoo";
            generator_heap->exception_lineno = 914;
            goto try_except_handler_3;
        }
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)generator_heap->tmp_tuple_unpack_1__source_iter );
    Py_DECREF( generator_heap->tmp_tuple_unpack_1__source_iter );
    generator_heap->tmp_tuple_unpack_1__source_iter = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto try_except_handler_2;
    // End of try:
    try_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->tmp_tuple_unpack_1__element_1 );
    generator_heap->tmp_tuple_unpack_1__element_1 = NULL;

    Py_XDECREF( generator_heap->tmp_tuple_unpack_1__element_2 );
    generator_heap->tmp_tuple_unpack_1__element_2 = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    CHECK_OBJECT( (PyObject *)generator_heap->tmp_tuple_unpack_1__source_iter );
    Py_DECREF( generator_heap->tmp_tuple_unpack_1__source_iter );
    generator_heap->tmp_tuple_unpack_1__source_iter = NULL;

    {
        PyObject *tmp_assign_source_5;
        CHECK_OBJECT( generator_heap->tmp_tuple_unpack_1__element_1 );
        tmp_assign_source_5 = generator_heap->tmp_tuple_unpack_1__element_1;
        assert( generator_heap->var_s1 == NULL );
        Py_INCREF( tmp_assign_source_5 );
        generator_heap->var_s1 = tmp_assign_source_5;
    }
    Py_XDECREF( generator_heap->tmp_tuple_unpack_1__element_1 );
    generator_heap->tmp_tuple_unpack_1__element_1 = NULL;

    {
        PyObject *tmp_assign_source_6;
        CHECK_OBJECT( generator_heap->tmp_tuple_unpack_1__element_2 );
        tmp_assign_source_6 = generator_heap->tmp_tuple_unpack_1__element_2;
        assert( generator_heap->var_s2 == NULL );
        Py_INCREF( tmp_assign_source_6 );
        generator_heap->var_s2 = tmp_assign_source_6;
    }
    Py_XDECREF( generator_heap->tmp_tuple_unpack_1__element_2 );
    generator_heap->tmp_tuple_unpack_1__element_2 = NULL;

    loop_start_1:;
    {
        nuitka_bool tmp_condition_result_5;
        PyObject *tmp_operand_name_4;
        int tmp_and_left_truth_1;
        PyObject *tmp_and_left_value_1;
        PyObject *tmp_and_right_value_1;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        if ( generator_heap->var_s1 == NULL )
        {

            generator_heap->exception_type = PyExc_UnboundLocalError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "s1" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 915;
            generator_heap->type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_left_3 = generator_heap->var_s1;
        CHECK_OBJECT( PyCell_GET( generator->m_closure[0] ) );
        tmp_compexpr_right_3 = PyCell_GET( generator->m_closure[0] );
        tmp_and_left_value_1 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
        if ( tmp_and_left_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 915;
            generator_heap->type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
        if ( tmp_and_left_truth_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
            Py_DECREF( tmp_and_left_value_1 );

            generator_heap->exception_lineno = 915;
            generator_heap->type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }
        if ( tmp_and_left_truth_1 == 1 )
        {
            goto and_right_1;
        }
        else
        {
            goto and_left_1;
        }
        and_right_1:;
        Py_DECREF( tmp_and_left_value_1 );
        if ( generator_heap->var_s2 == NULL )
        {

            generator_heap->exception_type = PyExc_UnboundLocalError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "s2" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 915;
            generator_heap->type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_left_4 = generator_heap->var_s2;
        CHECK_OBJECT( PyCell_GET( generator->m_closure[0] ) );
        tmp_compexpr_right_4 = PyCell_GET( generator->m_closure[0] );
        tmp_and_right_value_1 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_4, tmp_compexpr_right_4 );
        if ( tmp_and_right_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 915;
            generator_heap->type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_4 = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_operand_name_4 = tmp_and_left_value_1;
        and_end_1:;
        generator_heap->tmp_res = CHECK_IF_TRUE( tmp_operand_name_4 );
        Py_DECREF( tmp_operand_name_4 );
        if ( generator_heap->tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 915;
            generator_heap->type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_5 = ( generator_heap->tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_5;
        }
        else
        {
            goto branch_no_5;
        }
        branch_yes_5:;
        goto loop_end_1;
        branch_no_5:;
    }
    {
        nuitka_bool tmp_condition_result_6;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_7;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        int tmp_truth_name_1;
        CHECK_OBJECT( PyCell_GET( generator->m_closure[0] ) );
        tmp_source_name_7 = PyCell_GET( generator->m_closure[0] );
        tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_subnet_of );
        if ( tmp_called_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 916;
            generator_heap->type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }
        if ( generator_heap->var_s1 == NULL )
        {
            Py_DECREF( tmp_called_name_3 );
            generator_heap->exception_type = PyExc_UnboundLocalError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "s1" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 916;
            generator_heap->type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_3 = generator_heap->var_s1;
        generator->m_frame->m_frame.f_lineno = 916;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_called_name_3 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 916;
            generator_heap->type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE( tmp_call_result_1 );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
            Py_DECREF( tmp_call_result_1 );

            generator_heap->exception_lineno = 916;
            generator_heap->type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_6 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_call_result_1 );
        if ( tmp_condition_result_6 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_6;
        }
        else
        {
            goto branch_no_6;
        }
        branch_yes_6:;
        {
            PyObject *tmp_expression_name_1;
            NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
            if ( generator_heap->var_s2 == NULL )
            {

                generator_heap->exception_type = PyExc_UnboundLocalError;
                Py_INCREF( generator_heap->exception_type );
                generator_heap->exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "s2" );
                generator_heap->exception_tb = NULL;

                generator_heap->exception_lineno = 917;
                generator_heap->type_description_1 = "ccoo";
                goto frame_exception_exit_1;
            }

            tmp_expression_name_1 = generator_heap->var_s2;
            Py_INCREF( tmp_expression_name_1 );
            Nuitka_PreserveHeap( generator_heap->yield_tmps, &tmp_condition_result_6, sizeof(nuitka_bool), &tmp_called_name_3, sizeof(PyObject *), &tmp_source_name_7, sizeof(PyObject *), &tmp_call_result_1, sizeof(PyObject *), &tmp_args_element_name_3, sizeof(PyObject *), &tmp_truth_name_1, sizeof(int), NULL );
            generator->m_yield_return_index = 1;
            return tmp_expression_name_1;
            yield_return_1:
            Nuitka_RestoreHeap( generator_heap->yield_tmps, &tmp_condition_result_6, sizeof(nuitka_bool), &tmp_called_name_3, sizeof(PyObject *), &tmp_source_name_7, sizeof(PyObject *), &tmp_call_result_1, sizeof(PyObject *), &tmp_args_element_name_3, sizeof(PyObject *), &tmp_truth_name_1, sizeof(int), NULL );
            if ( yield_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


                generator_heap->exception_lineno = 917;
                generator_heap->type_description_1 = "ccoo";
                goto frame_exception_exit_1;
            }
            tmp_yield_result_1 = yield_return_value;
        }
        // Tried code:
        {
            PyObject *tmp_assign_source_7;
            PyObject *tmp_iter_arg_2;
            PyObject *tmp_called_instance_2;
            if ( generator_heap->var_s1 == NULL )
            {

                generator_heap->exception_type = PyExc_UnboundLocalError;
                Py_INCREF( generator_heap->exception_type );
                generator_heap->exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "s1" );
                generator_heap->exception_tb = NULL;

                generator_heap->exception_lineno = 918;
                generator_heap->type_description_1 = "ccoo";
                goto try_except_handler_4;
            }

            tmp_called_instance_2 = generator_heap->var_s1;
            generator->m_frame->m_frame.f_lineno = 918;
            tmp_iter_arg_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_subnets );
            if ( tmp_iter_arg_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


                generator_heap->exception_lineno = 918;
                generator_heap->type_description_1 = "ccoo";
                goto try_except_handler_4;
            }
            tmp_assign_source_7 = MAKE_ITERATOR( tmp_iter_arg_2 );
            Py_DECREF( tmp_iter_arg_2 );
            if ( tmp_assign_source_7 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


                generator_heap->exception_lineno = 918;
                generator_heap->type_description_1 = "ccoo";
                goto try_except_handler_4;
            }
            {
                PyObject *old = generator_heap->tmp_tuple_unpack_2__source_iter;
                generator_heap->tmp_tuple_unpack_2__source_iter = tmp_assign_source_7;
                Py_XDECREF( old );
            }

        }
        // Tried code:
        {
            PyObject *tmp_assign_source_8;
            PyObject *tmp_unpack_3;
            CHECK_OBJECT( generator_heap->tmp_tuple_unpack_2__source_iter );
            tmp_unpack_3 = generator_heap->tmp_tuple_unpack_2__source_iter;
            tmp_assign_source_8 = UNPACK_NEXT( tmp_unpack_3, 0 );
            if ( tmp_assign_source_8 == NULL )
            {
                if ( !ERROR_OCCURRED() )
                {
                    generator_heap->exception_type = PyExc_StopIteration;
                    Py_INCREF( generator_heap->exception_type );
                    generator_heap->exception_value = NULL;
                    generator_heap->exception_tb = NULL;
                }
                else
                {
                    FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
                }


                generator_heap->type_description_1 = "ccoo";
                generator_heap->exception_lineno = 918;
                goto try_except_handler_5;
            }
            {
                PyObject *old = generator_heap->tmp_tuple_unpack_2__element_1;
                generator_heap->tmp_tuple_unpack_2__element_1 = tmp_assign_source_8;
                Py_XDECREF( old );
            }

        }
        {
            PyObject *tmp_assign_source_9;
            PyObject *tmp_unpack_4;
            CHECK_OBJECT( generator_heap->tmp_tuple_unpack_2__source_iter );
            tmp_unpack_4 = generator_heap->tmp_tuple_unpack_2__source_iter;
            tmp_assign_source_9 = UNPACK_NEXT( tmp_unpack_4, 1 );
            if ( tmp_assign_source_9 == NULL )
            {
                if ( !ERROR_OCCURRED() )
                {
                    generator_heap->exception_type = PyExc_StopIteration;
                    Py_INCREF( generator_heap->exception_type );
                    generator_heap->exception_value = NULL;
                    generator_heap->exception_tb = NULL;
                }
                else
                {
                    FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
                }


                generator_heap->type_description_1 = "ccoo";
                generator_heap->exception_lineno = 918;
                goto try_except_handler_5;
            }
            {
                PyObject *old = generator_heap->tmp_tuple_unpack_2__element_2;
                generator_heap->tmp_tuple_unpack_2__element_2 = tmp_assign_source_9;
                Py_XDECREF( old );
            }

        }
        {
            PyObject *tmp_iterator_name_2;
            CHECK_OBJECT( generator_heap->tmp_tuple_unpack_2__source_iter );
            tmp_iterator_name_2 = generator_heap->tmp_tuple_unpack_2__source_iter;
            // Check if iterator has left-over elements.
            CHECK_OBJECT( tmp_iterator_name_2 ); assert( HAS_ITERNEXT( tmp_iterator_name_2 ) );

            generator_heap->tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_2 )->tp_iternext)( tmp_iterator_name_2 );

            if (likely( generator_heap->tmp_iterator_attempt == NULL ))
            {
                PyObject *error = GET_ERROR_OCCURRED();

                if ( error != NULL )
                {
                    if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
                    {
                        CLEAR_ERROR_OCCURRED();
                    }
                    else
                    {
                        FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );

                        generator_heap->type_description_1 = "ccoo";
                        generator_heap->exception_lineno = 918;
                        goto try_except_handler_5;
                    }
                }
            }
            else
            {
                Py_DECREF( generator_heap->tmp_iterator_attempt );

                // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
                PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
                PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 2)" );
#endif
                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );

                generator_heap->type_description_1 = "ccoo";
                generator_heap->exception_lineno = 918;
                goto try_except_handler_5;
            }
        }
        goto try_end_3;
        // Exception handler code:
        try_except_handler_5:;
        generator_heap->exception_keeper_type_3 = generator_heap->exception_type;
        generator_heap->exception_keeper_value_3 = generator_heap->exception_value;
        generator_heap->exception_keeper_tb_3 = generator_heap->exception_tb;
        generator_heap->exception_keeper_lineno_3 = generator_heap->exception_lineno;
        generator_heap->exception_type = NULL;
        generator_heap->exception_value = NULL;
        generator_heap->exception_tb = NULL;
        generator_heap->exception_lineno = 0;

        CHECK_OBJECT( (PyObject *)generator_heap->tmp_tuple_unpack_2__source_iter );
        Py_DECREF( generator_heap->tmp_tuple_unpack_2__source_iter );
        generator_heap->tmp_tuple_unpack_2__source_iter = NULL;

        // Re-raise.
        generator_heap->exception_type = generator_heap->exception_keeper_type_3;
        generator_heap->exception_value = generator_heap->exception_keeper_value_3;
        generator_heap->exception_tb = generator_heap->exception_keeper_tb_3;
        generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_3;

        goto try_except_handler_4;
        // End of try:
        try_end_3:;
        goto try_end_4;
        // Exception handler code:
        try_except_handler_4:;
        generator_heap->exception_keeper_type_4 = generator_heap->exception_type;
        generator_heap->exception_keeper_value_4 = generator_heap->exception_value;
        generator_heap->exception_keeper_tb_4 = generator_heap->exception_tb;
        generator_heap->exception_keeper_lineno_4 = generator_heap->exception_lineno;
        generator_heap->exception_type = NULL;
        generator_heap->exception_value = NULL;
        generator_heap->exception_tb = NULL;
        generator_heap->exception_lineno = 0;

        Py_XDECREF( generator_heap->tmp_tuple_unpack_2__element_1 );
        generator_heap->tmp_tuple_unpack_2__element_1 = NULL;

        Py_XDECREF( generator_heap->tmp_tuple_unpack_2__element_2 );
        generator_heap->tmp_tuple_unpack_2__element_2 = NULL;

        // Re-raise.
        generator_heap->exception_type = generator_heap->exception_keeper_type_4;
        generator_heap->exception_value = generator_heap->exception_keeper_value_4;
        generator_heap->exception_tb = generator_heap->exception_keeper_tb_4;
        generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_4;

        goto frame_exception_exit_1;
        // End of try:
        try_end_4:;
        CHECK_OBJECT( (PyObject *)generator_heap->tmp_tuple_unpack_2__source_iter );
        Py_DECREF( generator_heap->tmp_tuple_unpack_2__source_iter );
        generator_heap->tmp_tuple_unpack_2__source_iter = NULL;

        {
            PyObject *tmp_assign_source_10;
            CHECK_OBJECT( generator_heap->tmp_tuple_unpack_2__element_1 );
            tmp_assign_source_10 = generator_heap->tmp_tuple_unpack_2__element_1;
            {
                PyObject *old = generator_heap->var_s1;
                generator_heap->var_s1 = tmp_assign_source_10;
                Py_INCREF( generator_heap->var_s1 );
                Py_XDECREF( old );
            }

        }
        Py_XDECREF( generator_heap->tmp_tuple_unpack_2__element_1 );
        generator_heap->tmp_tuple_unpack_2__element_1 = NULL;

        {
            PyObject *tmp_assign_source_11;
            CHECK_OBJECT( generator_heap->tmp_tuple_unpack_2__element_2 );
            tmp_assign_source_11 = generator_heap->tmp_tuple_unpack_2__element_2;
            {
                PyObject *old = generator_heap->var_s2;
                generator_heap->var_s2 = tmp_assign_source_11;
                Py_INCREF( generator_heap->var_s2 );
                Py_XDECREF( old );
            }

        }
        Py_XDECREF( generator_heap->tmp_tuple_unpack_2__element_2 );
        generator_heap->tmp_tuple_unpack_2__element_2 = NULL;

        goto branch_end_6;
        branch_no_6:;
        {
            nuitka_bool tmp_condition_result_7;
            PyObject *tmp_called_name_4;
            PyObject *tmp_source_name_8;
            PyObject *tmp_call_result_2;
            PyObject *tmp_args_element_name_4;
            int tmp_truth_name_2;
            CHECK_OBJECT( PyCell_GET( generator->m_closure[0] ) );
            tmp_source_name_8 = PyCell_GET( generator->m_closure[0] );
            tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_subnet_of );
            if ( tmp_called_name_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


                generator_heap->exception_lineno = 919;
                generator_heap->type_description_1 = "ccoo";
                goto frame_exception_exit_1;
            }
            if ( generator_heap->var_s2 == NULL )
            {
                Py_DECREF( tmp_called_name_4 );
                generator_heap->exception_type = PyExc_UnboundLocalError;
                Py_INCREF( generator_heap->exception_type );
                generator_heap->exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "s2" );
                generator_heap->exception_tb = NULL;

                generator_heap->exception_lineno = 919;
                generator_heap->type_description_1 = "ccoo";
                goto frame_exception_exit_1;
            }

            tmp_args_element_name_4 = generator_heap->var_s2;
            generator->m_frame->m_frame.f_lineno = 919;
            {
                PyObject *call_args[] = { tmp_args_element_name_4 };
                tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
            }

            Py_DECREF( tmp_called_name_4 );
            if ( tmp_call_result_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


                generator_heap->exception_lineno = 919;
                generator_heap->type_description_1 = "ccoo";
                goto frame_exception_exit_1;
            }
            tmp_truth_name_2 = CHECK_IF_TRUE( tmp_call_result_2 );
            if ( tmp_truth_name_2 == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
                Py_DECREF( tmp_call_result_2 );

                generator_heap->exception_lineno = 919;
                generator_heap->type_description_1 = "ccoo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_7 = tmp_truth_name_2 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            Py_DECREF( tmp_call_result_2 );
            if ( tmp_condition_result_7 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_7;
            }
            else
            {
                goto branch_no_7;
            }
            branch_yes_7:;
            {
                PyObject *tmp_expression_name_2;
                NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_2;
                if ( generator_heap->var_s1 == NULL )
                {

                    generator_heap->exception_type = PyExc_UnboundLocalError;
                    Py_INCREF( generator_heap->exception_type );
                    generator_heap->exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "s1" );
                    generator_heap->exception_tb = NULL;

                    generator_heap->exception_lineno = 920;
                    generator_heap->type_description_1 = "ccoo";
                    goto frame_exception_exit_1;
                }

                tmp_expression_name_2 = generator_heap->var_s1;
                Py_INCREF( tmp_expression_name_2 );
                Nuitka_PreserveHeap( generator_heap->yield_tmps, &tmp_condition_result_6, sizeof(nuitka_bool), &tmp_called_name_3, sizeof(PyObject *), &tmp_source_name_7, sizeof(PyObject *), &tmp_call_result_1, sizeof(PyObject *), &tmp_args_element_name_3, sizeof(PyObject *), &tmp_truth_name_1, sizeof(int), &tmp_condition_result_7, sizeof(nuitka_bool), &tmp_called_name_4, sizeof(PyObject *), &tmp_source_name_8, sizeof(PyObject *), &tmp_call_result_2, sizeof(PyObject *), &tmp_args_element_name_4, sizeof(PyObject *), &tmp_truth_name_2, sizeof(int), NULL );
                generator->m_yield_return_index = 2;
                return tmp_expression_name_2;
                yield_return_2:
                Nuitka_RestoreHeap( generator_heap->yield_tmps, &tmp_condition_result_6, sizeof(nuitka_bool), &tmp_called_name_3, sizeof(PyObject *), &tmp_source_name_7, sizeof(PyObject *), &tmp_call_result_1, sizeof(PyObject *), &tmp_args_element_name_3, sizeof(PyObject *), &tmp_truth_name_1, sizeof(int), &tmp_condition_result_7, sizeof(nuitka_bool), &tmp_called_name_4, sizeof(PyObject *), &tmp_source_name_8, sizeof(PyObject *), &tmp_call_result_2, sizeof(PyObject *), &tmp_args_element_name_4, sizeof(PyObject *), &tmp_truth_name_2, sizeof(int), NULL );
                if ( yield_return_value == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


                    generator_heap->exception_lineno = 920;
                    generator_heap->type_description_1 = "ccoo";
                    goto frame_exception_exit_1;
                }
                tmp_yield_result_2 = yield_return_value;
            }
            // Tried code:
            {
                PyObject *tmp_assign_source_12;
                PyObject *tmp_iter_arg_3;
                PyObject *tmp_called_instance_3;
                if ( generator_heap->var_s2 == NULL )
                {

                    generator_heap->exception_type = PyExc_UnboundLocalError;
                    Py_INCREF( generator_heap->exception_type );
                    generator_heap->exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "s2" );
                    generator_heap->exception_tb = NULL;

                    generator_heap->exception_lineno = 921;
                    generator_heap->type_description_1 = "ccoo";
                    goto try_except_handler_6;
                }

                tmp_called_instance_3 = generator_heap->var_s2;
                generator->m_frame->m_frame.f_lineno = 921;
                tmp_iter_arg_3 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_subnets );
                if ( tmp_iter_arg_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


                    generator_heap->exception_lineno = 921;
                    generator_heap->type_description_1 = "ccoo";
                    goto try_except_handler_6;
                }
                tmp_assign_source_12 = MAKE_ITERATOR( tmp_iter_arg_3 );
                Py_DECREF( tmp_iter_arg_3 );
                if ( tmp_assign_source_12 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


                    generator_heap->exception_lineno = 921;
                    generator_heap->type_description_1 = "ccoo";
                    goto try_except_handler_6;
                }
                {
                    PyObject *old = generator_heap->tmp_tuple_unpack_3__source_iter;
                    generator_heap->tmp_tuple_unpack_3__source_iter = tmp_assign_source_12;
                    Py_XDECREF( old );
                }

            }
            // Tried code:
            {
                PyObject *tmp_assign_source_13;
                PyObject *tmp_unpack_5;
                CHECK_OBJECT( generator_heap->tmp_tuple_unpack_3__source_iter );
                tmp_unpack_5 = generator_heap->tmp_tuple_unpack_3__source_iter;
                tmp_assign_source_13 = UNPACK_NEXT( tmp_unpack_5, 0 );
                if ( tmp_assign_source_13 == NULL )
                {
                    if ( !ERROR_OCCURRED() )
                    {
                        generator_heap->exception_type = PyExc_StopIteration;
                        Py_INCREF( generator_heap->exception_type );
                        generator_heap->exception_value = NULL;
                        generator_heap->exception_tb = NULL;
                    }
                    else
                    {
                        FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
                    }


                    generator_heap->type_description_1 = "ccoo";
                    generator_heap->exception_lineno = 921;
                    goto try_except_handler_7;
                }
                {
                    PyObject *old = generator_heap->tmp_tuple_unpack_3__element_1;
                    generator_heap->tmp_tuple_unpack_3__element_1 = tmp_assign_source_13;
                    Py_XDECREF( old );
                }

            }
            {
                PyObject *tmp_assign_source_14;
                PyObject *tmp_unpack_6;
                CHECK_OBJECT( generator_heap->tmp_tuple_unpack_3__source_iter );
                tmp_unpack_6 = generator_heap->tmp_tuple_unpack_3__source_iter;
                tmp_assign_source_14 = UNPACK_NEXT( tmp_unpack_6, 1 );
                if ( tmp_assign_source_14 == NULL )
                {
                    if ( !ERROR_OCCURRED() )
                    {
                        generator_heap->exception_type = PyExc_StopIteration;
                        Py_INCREF( generator_heap->exception_type );
                        generator_heap->exception_value = NULL;
                        generator_heap->exception_tb = NULL;
                    }
                    else
                    {
                        FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
                    }


                    generator_heap->type_description_1 = "ccoo";
                    generator_heap->exception_lineno = 921;
                    goto try_except_handler_7;
                }
                {
                    PyObject *old = generator_heap->tmp_tuple_unpack_3__element_2;
                    generator_heap->tmp_tuple_unpack_3__element_2 = tmp_assign_source_14;
                    Py_XDECREF( old );
                }

            }
            {
                PyObject *tmp_iterator_name_3;
                CHECK_OBJECT( generator_heap->tmp_tuple_unpack_3__source_iter );
                tmp_iterator_name_3 = generator_heap->tmp_tuple_unpack_3__source_iter;
                // Check if iterator has left-over elements.
                CHECK_OBJECT( tmp_iterator_name_3 ); assert( HAS_ITERNEXT( tmp_iterator_name_3 ) );

                generator_heap->tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_3 )->tp_iternext)( tmp_iterator_name_3 );

                if (likely( generator_heap->tmp_iterator_attempt == NULL ))
                {
                    PyObject *error = GET_ERROR_OCCURRED();

                    if ( error != NULL )
                    {
                        if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
                        {
                            CLEAR_ERROR_OCCURRED();
                        }
                        else
                        {
                            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );

                            generator_heap->type_description_1 = "ccoo";
                            generator_heap->exception_lineno = 921;
                            goto try_except_handler_7;
                        }
                    }
                }
                else
                {
                    Py_DECREF( generator_heap->tmp_iterator_attempt );

                    // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
                    PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
                    PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 2)" );
#endif
                    FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );

                    generator_heap->type_description_1 = "ccoo";
                    generator_heap->exception_lineno = 921;
                    goto try_except_handler_7;
                }
            }
            goto try_end_5;
            // Exception handler code:
            try_except_handler_7:;
            generator_heap->exception_keeper_type_5 = generator_heap->exception_type;
            generator_heap->exception_keeper_value_5 = generator_heap->exception_value;
            generator_heap->exception_keeper_tb_5 = generator_heap->exception_tb;
            generator_heap->exception_keeper_lineno_5 = generator_heap->exception_lineno;
            generator_heap->exception_type = NULL;
            generator_heap->exception_value = NULL;
            generator_heap->exception_tb = NULL;
            generator_heap->exception_lineno = 0;

            CHECK_OBJECT( (PyObject *)generator_heap->tmp_tuple_unpack_3__source_iter );
            Py_DECREF( generator_heap->tmp_tuple_unpack_3__source_iter );
            generator_heap->tmp_tuple_unpack_3__source_iter = NULL;

            // Re-raise.
            generator_heap->exception_type = generator_heap->exception_keeper_type_5;
            generator_heap->exception_value = generator_heap->exception_keeper_value_5;
            generator_heap->exception_tb = generator_heap->exception_keeper_tb_5;
            generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_5;

            goto try_except_handler_6;
            // End of try:
            try_end_5:;
            goto try_end_6;
            // Exception handler code:
            try_except_handler_6:;
            generator_heap->exception_keeper_type_6 = generator_heap->exception_type;
            generator_heap->exception_keeper_value_6 = generator_heap->exception_value;
            generator_heap->exception_keeper_tb_6 = generator_heap->exception_tb;
            generator_heap->exception_keeper_lineno_6 = generator_heap->exception_lineno;
            generator_heap->exception_type = NULL;
            generator_heap->exception_value = NULL;
            generator_heap->exception_tb = NULL;
            generator_heap->exception_lineno = 0;

            Py_XDECREF( generator_heap->tmp_tuple_unpack_3__element_1 );
            generator_heap->tmp_tuple_unpack_3__element_1 = NULL;

            Py_XDECREF( generator_heap->tmp_tuple_unpack_3__element_2 );
            generator_heap->tmp_tuple_unpack_3__element_2 = NULL;

            // Re-raise.
            generator_heap->exception_type = generator_heap->exception_keeper_type_6;
            generator_heap->exception_value = generator_heap->exception_keeper_value_6;
            generator_heap->exception_tb = generator_heap->exception_keeper_tb_6;
            generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_6;

            goto frame_exception_exit_1;
            // End of try:
            try_end_6:;
            CHECK_OBJECT( (PyObject *)generator_heap->tmp_tuple_unpack_3__source_iter );
            Py_DECREF( generator_heap->tmp_tuple_unpack_3__source_iter );
            generator_heap->tmp_tuple_unpack_3__source_iter = NULL;

            {
                PyObject *tmp_assign_source_15;
                CHECK_OBJECT( generator_heap->tmp_tuple_unpack_3__element_1 );
                tmp_assign_source_15 = generator_heap->tmp_tuple_unpack_3__element_1;
                {
                    PyObject *old = generator_heap->var_s1;
                    generator_heap->var_s1 = tmp_assign_source_15;
                    Py_INCREF( generator_heap->var_s1 );
                    Py_XDECREF( old );
                }

            }
            Py_XDECREF( generator_heap->tmp_tuple_unpack_3__element_1 );
            generator_heap->tmp_tuple_unpack_3__element_1 = NULL;

            {
                PyObject *tmp_assign_source_16;
                CHECK_OBJECT( generator_heap->tmp_tuple_unpack_3__element_2 );
                tmp_assign_source_16 = generator_heap->tmp_tuple_unpack_3__element_2;
                {
                    PyObject *old = generator_heap->var_s2;
                    generator_heap->var_s2 = tmp_assign_source_16;
                    Py_INCREF( generator_heap->var_s2 );
                    Py_XDECREF( old );
                }

            }
            Py_XDECREF( generator_heap->tmp_tuple_unpack_3__element_2 );
            generator_heap->tmp_tuple_unpack_3__element_2 = NULL;

            goto branch_end_7;
            branch_no_7:;
            {
                PyObject *tmp_raise_type_4;
                PyObject *tmp_make_exception_arg_4;
                PyObject *tmp_left_name_5;
                PyObject *tmp_right_name_5;
                PyObject *tmp_tuple_element_4;
                tmp_left_name_5 = const_unicode_digest_98e0e324ddb3d7c17b2d051bf721997b;
                if ( generator_heap->var_s1 == NULL )
                {

                    generator_heap->exception_type = PyExc_UnboundLocalError;
                    Py_INCREF( generator_heap->exception_type );
                    generator_heap->exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "s1" );
                    generator_heap->exception_tb = NULL;

                    generator_heap->exception_lineno = 926;
                    generator_heap->type_description_1 = "ccoo";
                    goto frame_exception_exit_1;
                }

                tmp_tuple_element_4 = generator_heap->var_s1;
                tmp_right_name_5 = PyTuple_New( 3 );
                Py_INCREF( tmp_tuple_element_4 );
                PyTuple_SET_ITEM( tmp_right_name_5, 0, tmp_tuple_element_4 );
                if ( generator_heap->var_s2 == NULL )
                {
                    Py_DECREF( tmp_right_name_5 );
                    generator_heap->exception_type = PyExc_UnboundLocalError;
                    Py_INCREF( generator_heap->exception_type );
                    generator_heap->exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "s2" );
                    generator_heap->exception_tb = NULL;

                    generator_heap->exception_lineno = 926;
                    generator_heap->type_description_1 = "ccoo";
                    goto frame_exception_exit_1;
                }

                tmp_tuple_element_4 = generator_heap->var_s2;
                Py_INCREF( tmp_tuple_element_4 );
                PyTuple_SET_ITEM( tmp_right_name_5, 1, tmp_tuple_element_4 );
                CHECK_OBJECT( PyCell_GET( generator->m_closure[0] ) );
                tmp_tuple_element_4 = PyCell_GET( generator->m_closure[0] );
                Py_INCREF( tmp_tuple_element_4 );
                PyTuple_SET_ITEM( tmp_right_name_5, 2, tmp_tuple_element_4 );
                tmp_make_exception_arg_4 = BINARY_OPERATION_REMAINDER( tmp_left_name_5, tmp_right_name_5 );
                Py_DECREF( tmp_right_name_5 );
                if ( tmp_make_exception_arg_4 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


                    generator_heap->exception_lineno = 924;
                    generator_heap->type_description_1 = "ccoo";
                    goto frame_exception_exit_1;
                }
                generator->m_frame->m_frame.f_lineno = 924;
                {
                    PyObject *call_args[] = { tmp_make_exception_arg_4 };
                    tmp_raise_type_4 = CALL_FUNCTION_WITH_ARGS1( PyExc_AssertionError, call_args );
                }

                Py_DECREF( tmp_make_exception_arg_4 );
                assert( !(tmp_raise_type_4 == NULL) );
                generator_heap->exception_type = tmp_raise_type_4;
                generator_heap->exception_lineno = 924;
                RAISE_EXCEPTION_WITH_TYPE( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
                generator_heap->type_description_1 = "ccoo";
                goto frame_exception_exit_1;
            }
            branch_end_7:;
        }
        branch_end_6:;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


        generator_heap->exception_lineno = 915;
        generator_heap->type_description_1 = "ccoo";
        goto frame_exception_exit_1;
    }
    goto loop_start_1;
    loop_end_1:;
    {
        nuitka_bool tmp_condition_result_8;
        PyObject *tmp_compexpr_left_5;
        PyObject *tmp_compexpr_right_5;
        if ( generator_heap->var_s1 == NULL )
        {

            generator_heap->exception_type = PyExc_UnboundLocalError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "s1" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 927;
            generator_heap->type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_left_5 = generator_heap->var_s1;
        CHECK_OBJECT( PyCell_GET( generator->m_closure[0] ) );
        tmp_compexpr_right_5 = PyCell_GET( generator->m_closure[0] );
        generator_heap->tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_5, tmp_compexpr_right_5 );
        if ( generator_heap->tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 927;
            generator_heap->type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_8 = ( generator_heap->tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_8 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_8;
        }
        else
        {
            goto branch_no_8;
        }
        branch_yes_8:;
        {
            PyObject *tmp_expression_name_3;
            NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_3;
            if ( generator_heap->var_s2 == NULL )
            {

                generator_heap->exception_type = PyExc_UnboundLocalError;
                Py_INCREF( generator_heap->exception_type );
                generator_heap->exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "s2" );
                generator_heap->exception_tb = NULL;

                generator_heap->exception_lineno = 928;
                generator_heap->type_description_1 = "ccoo";
                goto frame_exception_exit_1;
            }

            tmp_expression_name_3 = generator_heap->var_s2;
            Py_INCREF( tmp_expression_name_3 );
            Nuitka_PreserveHeap( generator_heap->yield_tmps, &tmp_condition_result_8, sizeof(nuitka_bool), &tmp_compexpr_left_5, sizeof(PyObject *), &tmp_compexpr_right_5, sizeof(PyObject *), NULL );
            generator->m_yield_return_index = 3;
            return tmp_expression_name_3;
            yield_return_3:
            Nuitka_RestoreHeap( generator_heap->yield_tmps, &tmp_condition_result_8, sizeof(nuitka_bool), &tmp_compexpr_left_5, sizeof(PyObject *), &tmp_compexpr_right_5, sizeof(PyObject *), NULL );
            if ( yield_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


                generator_heap->exception_lineno = 928;
                generator_heap->type_description_1 = "ccoo";
                goto frame_exception_exit_1;
            }
            tmp_yield_result_3 = yield_return_value;
        }
        goto branch_end_8;
        branch_no_8:;
        {
            nuitka_bool tmp_condition_result_9;
            PyObject *tmp_compexpr_left_6;
            PyObject *tmp_compexpr_right_6;
            if ( generator_heap->var_s2 == NULL )
            {

                generator_heap->exception_type = PyExc_UnboundLocalError;
                Py_INCREF( generator_heap->exception_type );
                generator_heap->exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "s2" );
                generator_heap->exception_tb = NULL;

                generator_heap->exception_lineno = 929;
                generator_heap->type_description_1 = "ccoo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_left_6 = generator_heap->var_s2;
            CHECK_OBJECT( PyCell_GET( generator->m_closure[0] ) );
            tmp_compexpr_right_6 = PyCell_GET( generator->m_closure[0] );
            generator_heap->tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_6, tmp_compexpr_right_6 );
            if ( generator_heap->tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


                generator_heap->exception_lineno = 929;
                generator_heap->type_description_1 = "ccoo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_9 = ( generator_heap->tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_9 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_9;
            }
            else
            {
                goto branch_no_9;
            }
            branch_yes_9:;
            {
                PyObject *tmp_expression_name_4;
                NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_4;
                if ( generator_heap->var_s1 == NULL )
                {

                    generator_heap->exception_type = PyExc_UnboundLocalError;
                    Py_INCREF( generator_heap->exception_type );
                    generator_heap->exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "s1" );
                    generator_heap->exception_tb = NULL;

                    generator_heap->exception_lineno = 930;
                    generator_heap->type_description_1 = "ccoo";
                    goto frame_exception_exit_1;
                }

                tmp_expression_name_4 = generator_heap->var_s1;
                Py_INCREF( tmp_expression_name_4 );
                Nuitka_PreserveHeap( generator_heap->yield_tmps, &tmp_condition_result_8, sizeof(nuitka_bool), &tmp_compexpr_left_5, sizeof(PyObject *), &tmp_compexpr_right_5, sizeof(PyObject *), &tmp_condition_result_9, sizeof(nuitka_bool), &tmp_compexpr_left_6, sizeof(PyObject *), &tmp_compexpr_right_6, sizeof(PyObject *), NULL );
                generator->m_yield_return_index = 4;
                return tmp_expression_name_4;
                yield_return_4:
                Nuitka_RestoreHeap( generator_heap->yield_tmps, &tmp_condition_result_8, sizeof(nuitka_bool), &tmp_compexpr_left_5, sizeof(PyObject *), &tmp_compexpr_right_5, sizeof(PyObject *), &tmp_condition_result_9, sizeof(nuitka_bool), &tmp_compexpr_left_6, sizeof(PyObject *), &tmp_compexpr_right_6, sizeof(PyObject *), NULL );
                if ( yield_return_value == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


                    generator_heap->exception_lineno = 930;
                    generator_heap->type_description_1 = "ccoo";
                    goto frame_exception_exit_1;
                }
                tmp_yield_result_4 = yield_return_value;
            }
            goto branch_end_9;
            branch_no_9:;
            {
                PyObject *tmp_raise_type_5;
                PyObject *tmp_make_exception_arg_5;
                PyObject *tmp_left_name_6;
                PyObject *tmp_right_name_6;
                PyObject *tmp_tuple_element_5;
                tmp_left_name_6 = const_unicode_digest_98e0e324ddb3d7c17b2d051bf721997b;
                if ( generator_heap->var_s1 == NULL )
                {

                    generator_heap->exception_type = PyExc_UnboundLocalError;
                    Py_INCREF( generator_heap->exception_type );
                    generator_heap->exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "s1" );
                    generator_heap->exception_tb = NULL;

                    generator_heap->exception_lineno = 935;
                    generator_heap->type_description_1 = "ccoo";
                    goto frame_exception_exit_1;
                }

                tmp_tuple_element_5 = generator_heap->var_s1;
                tmp_right_name_6 = PyTuple_New( 3 );
                Py_INCREF( tmp_tuple_element_5 );
                PyTuple_SET_ITEM( tmp_right_name_6, 0, tmp_tuple_element_5 );
                if ( generator_heap->var_s2 == NULL )
                {
                    Py_DECREF( tmp_right_name_6 );
                    generator_heap->exception_type = PyExc_UnboundLocalError;
                    Py_INCREF( generator_heap->exception_type );
                    generator_heap->exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "s2" );
                    generator_heap->exception_tb = NULL;

                    generator_heap->exception_lineno = 935;
                    generator_heap->type_description_1 = "ccoo";
                    goto frame_exception_exit_1;
                }

                tmp_tuple_element_5 = generator_heap->var_s2;
                Py_INCREF( tmp_tuple_element_5 );
                PyTuple_SET_ITEM( tmp_right_name_6, 1, tmp_tuple_element_5 );
                CHECK_OBJECT( PyCell_GET( generator->m_closure[0] ) );
                tmp_tuple_element_5 = PyCell_GET( generator->m_closure[0] );
                Py_INCREF( tmp_tuple_element_5 );
                PyTuple_SET_ITEM( tmp_right_name_6, 2, tmp_tuple_element_5 );
                tmp_make_exception_arg_5 = BINARY_OPERATION_REMAINDER( tmp_left_name_6, tmp_right_name_6 );
                Py_DECREF( tmp_right_name_6 );
                if ( tmp_make_exception_arg_5 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


                    generator_heap->exception_lineno = 933;
                    generator_heap->type_description_1 = "ccoo";
                    goto frame_exception_exit_1;
                }
                generator->m_frame->m_frame.f_lineno = 933;
                {
                    PyObject *call_args[] = { tmp_make_exception_arg_5 };
                    tmp_raise_type_5 = CALL_FUNCTION_WITH_ARGS1( PyExc_AssertionError, call_args );
                }

                Py_DECREF( tmp_make_exception_arg_5 );
                assert( !(tmp_raise_type_5 == NULL) );
                generator_heap->exception_type = tmp_raise_type_5;
                generator_heap->exception_lineno = 933;
                RAISE_EXCEPTION_WITH_TYPE( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
                generator_heap->type_description_1 = "ccoo";
                goto frame_exception_exit_1;
            }
            branch_end_9:;
        }
        branch_end_8:;
    }

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_return_exit_1:;

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );
    goto function_return_exit;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( generator_heap->exception_type ) )
    {
        if ( generator_heap->exception_tb == NULL )
        {
            generator_heap->exception_tb = MAKE_TRACEBACK( generator->m_frame, generator_heap->exception_lineno );
        }
        else if ( generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            generator_heap->exception_tb = ADD_TRACEBACK( generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            generator->m_closure[1],
            generator->m_closure[0],
            generator_heap->var_s2,
            generator_heap->var_s1
        );


        // Release cached frame.
        if ( generator->m_frame == cache_m_frame )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_m_frame = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_7;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_7 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_7 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_7 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_7 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->var_s2 );
    generator_heap->var_s2 = NULL;

    Py_XDECREF( generator_heap->var_s1 );
    generator_heap->var_s1 = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_7;
    generator_heap->exception_value = generator_heap->exception_keeper_value_7;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_7;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_7;

    goto function_exception_exit;
    // End of try:
    try_end_7:;
    Py_XDECREF( generator_heap->var_s2 );
    generator_heap->var_s2 = NULL;

    Py_XDECREF( generator_heap->var_s1 );
    generator_heap->var_s1 = NULL;



    return NULL;

    function_exception_exit:
    assert( generator_heap->exception_type );
    RESTORE_ERROR_OCCURRED( generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb );

    return NULL;
    // The above won't return, but we need to make it clear to the compiler
    // as well, or else it will complain and/or generate inferior code.
    assert(false);
    return NULL;

    function_return_exit:
#if PYTHON_VERSION >= 300
    generator->m_returned = None;
#endif

    return NULL;

}

static PyObject *ipaddress$$$function_66_address_exclude$$$genobj_1_address_exclude_maker( void )
{
    return Nuitka_Generator_New(
        ipaddress$$$function_66_address_exclude$$$genobj_1_address_exclude_context,
        module_ipaddress,
        const_str_plain_address_exclude,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_3769b2c4ffdc7c3f9f9b4dbc1cef7e71,
        2,
        sizeof(struct ipaddress$$$function_66_address_exclude$$$genobj_1_address_exclude_locals)
    );
}


static PyObject *impl_ipaddress$$$function_67_compare_networks( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_c45d853a29dec1f0248c5e593abb118c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_c45d853a29dec1f0248c5e593abb118c = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c45d853a29dec1f0248c5e593abb118c, codeobj_c45d853a29dec1f0248c5e593abb118c, module_ipaddress, sizeof(void *)+sizeof(void *) );
    frame_c45d853a29dec1f0248c5e593abb118c = cache_frame_c45d853a29dec1f0248c5e593abb118c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c45d853a29dec1f0248c5e593abb118c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c45d853a29dec1f0248c5e593abb118c ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__version );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 970;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_other );
        tmp_source_name_2 = par_other;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__version );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_1 );

            exception_lineno = 970;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 970;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            PyObject *tmp_tuple_element_1;
            tmp_left_name_1 = const_unicode_digest_ce28e1a0d596488778adc7f428c3ab1f;
            CHECK_OBJECT( par_self );
            tmp_tuple_element_1 = par_self;
            tmp_right_name_1 = PyTuple_New( 2 );
            Py_INCREF( tmp_tuple_element_1 );
            PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
            CHECK_OBJECT( par_other );
            tmp_tuple_element_1 = par_other;
            Py_INCREF( tmp_tuple_element_1 );
            PyTuple_SET_ITEM( tmp_right_name_1, 1, tmp_tuple_element_1 );
            tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
            Py_DECREF( tmp_right_name_1 );
            if ( tmp_make_exception_arg_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 971;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            frame_c45d853a29dec1f0248c5e593abb118c->m_frame.f_lineno = 971;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            Py_DECREF( tmp_make_exception_arg_1 );
            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 971;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_source_name_4;
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_network_address );
        if ( tmp_compexpr_left_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 974;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_other );
        tmp_source_name_4 = par_other;
        tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_network_address );
        if ( tmp_compexpr_right_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_2 );

            exception_lineno = 974;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_LT_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        Py_DECREF( tmp_compexpr_left_2 );
        Py_DECREF( tmp_compexpr_right_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 974;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        tmp_return_value = const_int_neg_1;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_2:;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_source_name_5;
        PyObject *tmp_source_name_6;
        CHECK_OBJECT( par_self );
        tmp_source_name_5 = par_self;
        tmp_compexpr_left_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_network_address );
        if ( tmp_compexpr_left_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 976;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_other );
        tmp_source_name_6 = par_other;
        tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_network_address );
        if ( tmp_compexpr_right_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_3 );

            exception_lineno = 976;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_GT_OBJECT_OBJECT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
        Py_DECREF( tmp_compexpr_left_3 );
        Py_DECREF( tmp_compexpr_right_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 976;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        tmp_return_value = const_int_pos_1;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_3:;
    }
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        PyObject *tmp_source_name_7;
        PyObject *tmp_source_name_8;
        CHECK_OBJECT( par_self );
        tmp_source_name_7 = par_self;
        tmp_compexpr_left_4 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_netmask );
        if ( tmp_compexpr_left_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 979;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_other );
        tmp_source_name_8 = par_other;
        tmp_compexpr_right_4 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_netmask );
        if ( tmp_compexpr_right_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_4 );

            exception_lineno = 979;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_LT_OBJECT_OBJECT( tmp_compexpr_left_4, tmp_compexpr_right_4 );
        Py_DECREF( tmp_compexpr_left_4 );
        Py_DECREF( tmp_compexpr_right_4 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 979;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_4 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_4;
        }
        else
        {
            goto branch_no_4;
        }
        branch_yes_4:;
        tmp_return_value = const_int_neg_1;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_4:;
    }
    {
        nuitka_bool tmp_condition_result_5;
        PyObject *tmp_compexpr_left_5;
        PyObject *tmp_compexpr_right_5;
        PyObject *tmp_source_name_9;
        PyObject *tmp_source_name_10;
        CHECK_OBJECT( par_self );
        tmp_source_name_9 = par_self;
        tmp_compexpr_left_5 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_netmask );
        if ( tmp_compexpr_left_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 981;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_other );
        tmp_source_name_10 = par_other;
        tmp_compexpr_right_5 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_netmask );
        if ( tmp_compexpr_right_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_5 );

            exception_lineno = 981;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_GT_OBJECT_OBJECT( tmp_compexpr_left_5, tmp_compexpr_right_5 );
        Py_DECREF( tmp_compexpr_left_5 );
        Py_DECREF( tmp_compexpr_right_5 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 981;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_5 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_5;
        }
        else
        {
            goto branch_no_5;
        }
        branch_yes_5:;
        tmp_return_value = const_int_pos_1;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_5:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c45d853a29dec1f0248c5e593abb118c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_c45d853a29dec1f0248c5e593abb118c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c45d853a29dec1f0248c5e593abb118c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c45d853a29dec1f0248c5e593abb118c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c45d853a29dec1f0248c5e593abb118c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c45d853a29dec1f0248c5e593abb118c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c45d853a29dec1f0248c5e593abb118c,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_c45d853a29dec1f0248c5e593abb118c == cache_frame_c45d853a29dec1f0248c5e593abb118c )
    {
        Py_DECREF( frame_c45d853a29dec1f0248c5e593abb118c );
    }
    cache_frame_c45d853a29dec1f0248c5e593abb118c = NULL;

    assertFrameObject( frame_c45d853a29dec1f0248c5e593abb118c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = const_int_0;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_67_compare_networks );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_67_compare_networks );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_68__get_networks_key( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_8f1a1dcf125472cc5e5562ccf9d75921;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_8f1a1dcf125472cc5e5562ccf9d75921 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8f1a1dcf125472cc5e5562ccf9d75921, codeobj_8f1a1dcf125472cc5e5562ccf9d75921, module_ipaddress, sizeof(void *) );
    frame_8f1a1dcf125472cc5e5562ccf9d75921 = cache_frame_8f1a1dcf125472cc5e5562ccf9d75921;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8f1a1dcf125472cc5e5562ccf9d75921 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8f1a1dcf125472cc5e5562ccf9d75921 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_source_name_3;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__version );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 993;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = PyTuple_New( 3 );
        PyTuple_SET_ITEM( tmp_return_value, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_network_address );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_return_value );

            exception_lineno = 993;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM( tmp_return_value, 1, tmp_tuple_element_1 );
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_netmask );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_return_value );

            exception_lineno = 993;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM( tmp_return_value, 2, tmp_tuple_element_1 );
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8f1a1dcf125472cc5e5562ccf9d75921 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_8f1a1dcf125472cc5e5562ccf9d75921 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8f1a1dcf125472cc5e5562ccf9d75921 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8f1a1dcf125472cc5e5562ccf9d75921, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8f1a1dcf125472cc5e5562ccf9d75921->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8f1a1dcf125472cc5e5562ccf9d75921, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8f1a1dcf125472cc5e5562ccf9d75921,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_8f1a1dcf125472cc5e5562ccf9d75921 == cache_frame_8f1a1dcf125472cc5e5562ccf9d75921 )
    {
        Py_DECREF( frame_8f1a1dcf125472cc5e5562ccf9d75921 );
    }
    cache_frame_8f1a1dcf125472cc5e5562ccf9d75921 = NULL;

    assertFrameObject( frame_8f1a1dcf125472cc5e5562ccf9d75921 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_68__get_networks_key );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_68__get_networks_key );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_69_subnets( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1( python_pars[ 0 ] );
    struct Nuitka_CellObject *par_prefixlen_diff = PyCell_NEW1( python_pars[ 1 ] );
    struct Nuitka_CellObject *par_new_prefix = PyCell_NEW1( python_pars[ 2 ] );
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    // Tried code:
    tmp_return_value = ipaddress$$$function_69_subnets$$$genobj_1_subnets_maker();

    ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[0] = par_new_prefix;
    Py_INCREF( ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[0] );
    ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[1] = par_prefixlen_diff;
    Py_INCREF( ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[1] );
    ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[2] = par_self;
    Py_INCREF( ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[2] );


    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_69_subnets );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_new_prefix );
    Py_DECREF( par_new_prefix );
    par_new_prefix = NULL;

    CHECK_OBJECT( (PyObject *)par_prefixlen_diff );
    Py_DECREF( par_prefixlen_diff );
    par_prefixlen_diff = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_new_prefix );
    Py_DECREF( par_new_prefix );
    par_new_prefix = NULL;

    CHECK_OBJECT( (PyObject *)par_prefixlen_diff );
    Py_DECREF( par_prefixlen_diff );
    par_prefixlen_diff = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_69_subnets );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}



struct ipaddress$$$function_69_subnets$$$genobj_1_subnets_locals {
    PyObject *var_end;
    PyObject *var_new_addr;
    PyObject *var_new_prefixlen;
    PyObject *var_current;
    PyObject *var_start;
    PyObject *var_step;
    PyObject *tmp_for_loop_1__for_iterator;
    PyObject *tmp_for_loop_1__iter_value;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    int tmp_res;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
};

static PyObject *ipaddress$$$function_69_subnets$$$genobj_1_subnets_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Heap access if used.
    struct ipaddress$$$function_69_subnets$$$genobj_1_subnets_locals *generator_heap = (struct ipaddress$$$function_69_subnets$$$genobj_1_subnets_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 2: goto yield_return_2;
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_end = NULL;
    generator_heap->var_new_addr = NULL;
    generator_heap->var_new_prefixlen = NULL;
    generator_heap->var_current = NULL;
    generator_heap->var_start = NULL;
    generator_heap->var_step = NULL;
    generator_heap->tmp_for_loop_1__for_iterator = NULL;
    generator_heap->tmp_for_loop_1__iter_value = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_m_frame, codeobj_afd3bfdaef11bbc48af0b7dfa76ee499, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

#if PYTHON_VERSION < 370
        generator->m_frame->m_frame.f_exc_type = EXC_TYPE( thread_state );
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
        Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#else
        generator->m_exc_state.exc_type = EXC_TYPE( thread_state );
        if ( generator->m_exc_state.exc_type == Py_None ) generator->m_exc_state.exc_type = NULL;
        Py_XINCREF( generator->m_exc_state.exc_type );
        generator->m_exc_state.exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_value );
        generator->m_exc_state.exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_traceback );
#endif
    }

#endif

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        if ( PyCell_GET( generator->m_closure[2] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 1021;
            generator_heap->type_description_1 = "cccoooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = PyCell_GET( generator->m_closure[2] );
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__prefixlen );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 1021;
            generator_heap->type_description_1 = "cccoooooo";
            goto frame_exception_exit_1;
        }
        if ( PyCell_GET( generator->m_closure[2] ) == NULL )
        {
            Py_DECREF( tmp_compexpr_left_1 );
            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 1021;
            generator_heap->type_description_1 = "cccoooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = PyCell_GET( generator->m_closure[2] );
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__max_prefixlen );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
            Py_DECREF( tmp_compexpr_left_1 );

            generator_heap->exception_lineno = 1021;
            generator_heap->type_description_1 = "cccoooooo";
            goto frame_exception_exit_1;
        }
        generator_heap->tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( generator_heap->tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 1021;
            generator_heap->type_description_1 = "cccoooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( generator_heap->tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_expression_name_1;
            NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
            if ( PyCell_GET( generator->m_closure[2] ) == NULL )
            {

                generator_heap->exception_type = PyExc_NameError;
                Py_INCREF( generator_heap->exception_type );
                generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
                generator_heap->exception_tb = NULL;

                generator_heap->exception_lineno = 1022;
                generator_heap->type_description_1 = "cccoooooo";
                goto frame_exception_exit_1;
            }

            tmp_expression_name_1 = PyCell_GET( generator->m_closure[2] );
            Py_INCREF( tmp_expression_name_1 );
            Nuitka_PreserveHeap( generator_heap->yield_tmps, &tmp_condition_result_1, sizeof(nuitka_bool), &tmp_compexpr_left_1, sizeof(PyObject *), &tmp_compexpr_right_1, sizeof(PyObject *), &tmp_source_name_1, sizeof(PyObject *), &tmp_source_name_2, sizeof(PyObject *), NULL );
            generator->m_yield_return_index = 1;
            return tmp_expression_name_1;
            yield_return_1:
            Nuitka_RestoreHeap( generator_heap->yield_tmps, &tmp_condition_result_1, sizeof(nuitka_bool), &tmp_compexpr_left_1, sizeof(PyObject *), &tmp_compexpr_right_1, sizeof(PyObject *), &tmp_source_name_1, sizeof(PyObject *), &tmp_source_name_2, sizeof(PyObject *), NULL );
            if ( yield_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


                generator_heap->exception_lineno = 1022;
                generator_heap->type_description_1 = "cccoooooo";
                goto frame_exception_exit_1;
            }
            tmp_yield_result_1 = yield_return_value;
        }
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        if ( PyCell_GET( generator->m_closure[0] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "new_prefix" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 1025;
            generator_heap->type_description_1 = "cccoooooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_left_2 = PyCell_GET( generator->m_closure[0] );
        tmp_compexpr_right_2 = Py_None;
        tmp_condition_result_2 = ( tmp_compexpr_left_2 != tmp_compexpr_right_2 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            PyObject *tmp_source_name_3;
            if ( PyCell_GET( generator->m_closure[0] ) == NULL )
            {

                generator_heap->exception_type = PyExc_NameError;
                Py_INCREF( generator_heap->exception_type );
                generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "new_prefix" );
                generator_heap->exception_tb = NULL;

                generator_heap->exception_lineno = 1026;
                generator_heap->type_description_1 = "cccoooooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_left_3 = PyCell_GET( generator->m_closure[0] );
            if ( PyCell_GET( generator->m_closure[2] ) == NULL )
            {

                generator_heap->exception_type = PyExc_NameError;
                Py_INCREF( generator_heap->exception_type );
                generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
                generator_heap->exception_tb = NULL;

                generator_heap->exception_lineno = 1026;
                generator_heap->type_description_1 = "cccoooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_3 = PyCell_GET( generator->m_closure[2] );
            tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__prefixlen );
            if ( tmp_compexpr_right_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


                generator_heap->exception_lineno = 1026;
                generator_heap->type_description_1 = "cccoooooo";
                goto frame_exception_exit_1;
            }
            generator_heap->tmp_res = RICH_COMPARE_BOOL_LT_OBJECT_OBJECT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
            Py_DECREF( tmp_compexpr_right_3 );
            if ( generator_heap->tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


                generator_heap->exception_lineno = 1026;
                generator_heap->type_description_1 = "cccoooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_3 = ( generator_heap->tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_3;
            }
            else
            {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_raise_type_1;
                PyObject *tmp_make_exception_arg_1;
                tmp_make_exception_arg_1 = const_unicode_digest_f5f271ff00e96b68abb5b126c6b3f130;
                generator->m_frame->m_frame.f_lineno = 1027;
                {
                    PyObject *call_args[] = { tmp_make_exception_arg_1 };
                    tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
                }

                assert( !(tmp_raise_type_1 == NULL) );
                generator_heap->exception_type = tmp_raise_type_1;
                generator_heap->exception_lineno = 1027;
                RAISE_EXCEPTION_WITH_TYPE( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
                generator_heap->type_description_1 = "cccoooooo";
                goto frame_exception_exit_1;
            }
            branch_no_3:;
        }
        {
            nuitka_bool tmp_condition_result_4;
            PyObject *tmp_compexpr_left_4;
            PyObject *tmp_compexpr_right_4;
            if ( PyCell_GET( generator->m_closure[1] ) == NULL )
            {

                generator_heap->exception_type = PyExc_NameError;
                Py_INCREF( generator_heap->exception_type );
                generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "prefixlen_diff" );
                generator_heap->exception_tb = NULL;

                generator_heap->exception_lineno = 1028;
                generator_heap->type_description_1 = "cccoooooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_left_4 = PyCell_GET( generator->m_closure[1] );
            tmp_compexpr_right_4 = const_int_pos_1;
            generator_heap->tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_INT( tmp_compexpr_left_4, tmp_compexpr_right_4 );
            if ( generator_heap->tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


                generator_heap->exception_lineno = 1028;
                generator_heap->type_description_1 = "cccoooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_4 = ( generator_heap->tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_4;
            }
            else
            {
                goto branch_no_4;
            }
            branch_yes_4:;
            {
                PyObject *tmp_raise_type_2;
                PyObject *tmp_make_exception_arg_2;
                tmp_make_exception_arg_2 = const_unicode_digest_786511cd0da76607fa48edaa91095b3b;
                generator->m_frame->m_frame.f_lineno = 1029;
                {
                    PyObject *call_args[] = { tmp_make_exception_arg_2 };
                    tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
                }

                assert( !(tmp_raise_type_2 == NULL) );
                generator_heap->exception_type = tmp_raise_type_2;
                generator_heap->exception_lineno = 1029;
                RAISE_EXCEPTION_WITH_TYPE( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
                generator_heap->type_description_1 = "cccoooooo";
                goto frame_exception_exit_1;
            }
            branch_no_4:;
        }
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            PyObject *tmp_source_name_4;
            if ( PyCell_GET( generator->m_closure[0] ) == NULL )
            {

                generator_heap->exception_type = PyExc_NameError;
                Py_INCREF( generator_heap->exception_type );
                generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "new_prefix" );
                generator_heap->exception_tb = NULL;

                generator_heap->exception_lineno = 1030;
                generator_heap->type_description_1 = "cccoooooo";
                goto frame_exception_exit_1;
            }

            tmp_left_name_1 = PyCell_GET( generator->m_closure[0] );
            if ( PyCell_GET( generator->m_closure[2] ) == NULL )
            {

                generator_heap->exception_type = PyExc_NameError;
                Py_INCREF( generator_heap->exception_type );
                generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
                generator_heap->exception_tb = NULL;

                generator_heap->exception_lineno = 1030;
                generator_heap->type_description_1 = "cccoooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_4 = PyCell_GET( generator->m_closure[2] );
            tmp_right_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__prefixlen );
            if ( tmp_right_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


                generator_heap->exception_lineno = 1030;
                generator_heap->type_description_1 = "cccoooooo";
                goto frame_exception_exit_1;
            }
            tmp_assign_source_1 = BINARY_OPERATION_SUB( tmp_left_name_1, tmp_right_name_1 );
            Py_DECREF( tmp_right_name_1 );
            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


                generator_heap->exception_lineno = 1030;
                generator_heap->type_description_1 = "cccoooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = PyCell_GET( generator->m_closure[1] );
                PyCell_SET( generator->m_closure[1], tmp_assign_source_1 );
                Py_XDECREF( old );
            }

        }
        branch_no_2:;
    }
    {
        nuitka_bool tmp_condition_result_5;
        PyObject *tmp_compexpr_left_5;
        PyObject *tmp_compexpr_right_5;
        if ( PyCell_GET( generator->m_closure[1] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "prefixlen_diff" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 1032;
            generator_heap->type_description_1 = "cccoooooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_left_5 = PyCell_GET( generator->m_closure[1] );
        tmp_compexpr_right_5 = const_int_0;
        generator_heap->tmp_res = RICH_COMPARE_BOOL_LT_OBJECT_INT( tmp_compexpr_left_5, tmp_compexpr_right_5 );
        if ( generator_heap->tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 1032;
            generator_heap->type_description_1 = "cccoooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_5 = ( generator_heap->tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_5;
        }
        else
        {
            goto branch_no_5;
        }
        branch_yes_5:;
        {
            PyObject *tmp_raise_type_3;
            PyObject *tmp_make_exception_arg_3;
            tmp_make_exception_arg_3 = const_unicode_digest_0b68f1d1670be58439f575ba680b882d;
            generator->m_frame->m_frame.f_lineno = 1033;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_3 };
                tmp_raise_type_3 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_3 == NULL) );
            generator_heap->exception_type = tmp_raise_type_3;
            generator_heap->exception_lineno = 1033;
            RAISE_EXCEPTION_WITH_TYPE( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
            generator_heap->type_description_1 = "cccoooooo";
            goto frame_exception_exit_1;
        }
        branch_no_5:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_left_name_2;
        PyObject *tmp_source_name_5;
        PyObject *tmp_right_name_2;
        if ( PyCell_GET( generator->m_closure[2] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 1034;
            generator_heap->type_description_1 = "cccoooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = PyCell_GET( generator->m_closure[2] );
        tmp_left_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__prefixlen );
        if ( tmp_left_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 1034;
            generator_heap->type_description_1 = "cccoooooo";
            goto frame_exception_exit_1;
        }
        if ( PyCell_GET( generator->m_closure[1] ) == NULL )
        {
            Py_DECREF( tmp_left_name_2 );
            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "prefixlen_diff" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 1034;
            generator_heap->type_description_1 = "cccoooooo";
            goto frame_exception_exit_1;
        }

        tmp_right_name_2 = PyCell_GET( generator->m_closure[1] );
        tmp_assign_source_2 = BINARY_OPERATION_ADD_OBJECT_OBJECT( tmp_left_name_2, tmp_right_name_2 );
        Py_DECREF( tmp_left_name_2 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 1034;
            generator_heap->type_description_1 = "cccoooooo";
            goto frame_exception_exit_1;
        }
        assert( generator_heap->var_new_prefixlen == NULL );
        generator_heap->var_new_prefixlen = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_6;
        PyObject *tmp_compexpr_left_6;
        PyObject *tmp_compexpr_right_6;
        PyObject *tmp_source_name_6;
        CHECK_OBJECT( generator_heap->var_new_prefixlen );
        tmp_compexpr_left_6 = generator_heap->var_new_prefixlen;
        if ( PyCell_GET( generator->m_closure[2] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 1036;
            generator_heap->type_description_1 = "cccoooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = PyCell_GET( generator->m_closure[2] );
        tmp_compexpr_right_6 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__max_prefixlen );
        if ( tmp_compexpr_right_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 1036;
            generator_heap->type_description_1 = "cccoooooo";
            goto frame_exception_exit_1;
        }
        generator_heap->tmp_res = RICH_COMPARE_BOOL_GT_OBJECT_OBJECT( tmp_compexpr_left_6, tmp_compexpr_right_6 );
        Py_DECREF( tmp_compexpr_right_6 );
        if ( generator_heap->tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 1036;
            generator_heap->type_description_1 = "cccoooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_6 = ( generator_heap->tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_6 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_6;
        }
        else
        {
            goto branch_no_6;
        }
        branch_yes_6:;
        {
            PyObject *tmp_raise_type_4;
            PyObject *tmp_make_exception_arg_4;
            PyObject *tmp_left_name_3;
            PyObject *tmp_right_name_3;
            PyObject *tmp_tuple_element_1;
            tmp_left_name_3 = const_unicode_digest_6621db75e8d93f052f1819be23d20ce6;
            CHECK_OBJECT( generator_heap->var_new_prefixlen );
            tmp_tuple_element_1 = generator_heap->var_new_prefixlen;
            tmp_right_name_3 = PyTuple_New( 2 );
            Py_INCREF( tmp_tuple_element_1 );
            PyTuple_SET_ITEM( tmp_right_name_3, 0, tmp_tuple_element_1 );
            if ( PyCell_GET( generator->m_closure[2] ) == NULL )
            {
                Py_DECREF( tmp_right_name_3 );
                generator_heap->exception_type = PyExc_NameError;
                Py_INCREF( generator_heap->exception_type );
                generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
                generator_heap->exception_tb = NULL;

                generator_heap->exception_lineno = 1039;
                generator_heap->type_description_1 = "cccoooooo";
                goto frame_exception_exit_1;
            }

            tmp_tuple_element_1 = PyCell_GET( generator->m_closure[2] );
            Py_INCREF( tmp_tuple_element_1 );
            PyTuple_SET_ITEM( tmp_right_name_3, 1, tmp_tuple_element_1 );
            tmp_make_exception_arg_4 = BINARY_OPERATION_REMAINDER( tmp_left_name_3, tmp_right_name_3 );
            Py_DECREF( tmp_right_name_3 );
            if ( tmp_make_exception_arg_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


                generator_heap->exception_lineno = 1038;
                generator_heap->type_description_1 = "cccoooooo";
                goto frame_exception_exit_1;
            }
            generator->m_frame->m_frame.f_lineno = 1037;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_4 };
                tmp_raise_type_4 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            Py_DECREF( tmp_make_exception_arg_4 );
            assert( !(tmp_raise_type_4 == NULL) );
            generator_heap->exception_type = tmp_raise_type_4;
            generator_heap->exception_lineno = 1037;
            RAISE_EXCEPTION_WITH_TYPE( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
            generator_heap->type_description_1 = "cccoooooo";
            goto frame_exception_exit_1;
        }
        branch_no_6:;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_int_arg_1;
        PyObject *tmp_source_name_7;
        if ( PyCell_GET( generator->m_closure[2] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 1041;
            generator_heap->type_description_1 = "cccoooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_7 = PyCell_GET( generator->m_closure[2] );
        tmp_int_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_network_address );
        if ( tmp_int_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 1041;
            generator_heap->type_description_1 = "cccoooooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_3 = PyNumber_Int( tmp_int_arg_1 );
        Py_DECREF( tmp_int_arg_1 );
        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 1041;
            generator_heap->type_description_1 = "cccoooooo";
            goto frame_exception_exit_1;
        }
        assert( generator_heap->var_start == NULL );
        generator_heap->var_start = tmp_assign_source_3;
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_left_name_4;
        PyObject *tmp_int_arg_2;
        PyObject *tmp_source_name_8;
        PyObject *tmp_right_name_4;
        if ( PyCell_GET( generator->m_closure[2] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 1042;
            generator_heap->type_description_1 = "cccoooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_8 = PyCell_GET( generator->m_closure[2] );
        tmp_int_arg_2 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_broadcast_address );
        if ( tmp_int_arg_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 1042;
            generator_heap->type_description_1 = "cccoooooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_4 = PyNumber_Int( tmp_int_arg_2 );
        Py_DECREF( tmp_int_arg_2 );
        if ( tmp_left_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 1042;
            generator_heap->type_description_1 = "cccoooooo";
            goto frame_exception_exit_1;
        }
        tmp_right_name_4 = const_int_pos_1;
        tmp_assign_source_4 = BINARY_OPERATION_ADD_OBJECT_INT( tmp_left_name_4, tmp_right_name_4 );
        Py_DECREF( tmp_left_name_4 );
        if ( tmp_assign_source_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 1042;
            generator_heap->type_description_1 = "cccoooooo";
            goto frame_exception_exit_1;
        }
        assert( generator_heap->var_end == NULL );
        generator_heap->var_end = tmp_assign_source_4;
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_left_name_5;
        PyObject *tmp_left_name_6;
        PyObject *tmp_int_arg_3;
        PyObject *tmp_source_name_9;
        PyObject *tmp_right_name_5;
        PyObject *tmp_right_name_6;
        if ( PyCell_GET( generator->m_closure[2] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 1043;
            generator_heap->type_description_1 = "cccoooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_9 = PyCell_GET( generator->m_closure[2] );
        tmp_int_arg_3 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_hostmask );
        if ( tmp_int_arg_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 1043;
            generator_heap->type_description_1 = "cccoooooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_6 = PyNumber_Int( tmp_int_arg_3 );
        Py_DECREF( tmp_int_arg_3 );
        if ( tmp_left_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 1043;
            generator_heap->type_description_1 = "cccoooooo";
            goto frame_exception_exit_1;
        }
        tmp_right_name_5 = const_int_pos_1;
        tmp_left_name_5 = BINARY_OPERATION_ADD_OBJECT_INT( tmp_left_name_6, tmp_right_name_5 );
        Py_DECREF( tmp_left_name_6 );
        if ( tmp_left_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 1043;
            generator_heap->type_description_1 = "cccoooooo";
            goto frame_exception_exit_1;
        }
        if ( PyCell_GET( generator->m_closure[1] ) == NULL )
        {
            Py_DECREF( tmp_left_name_5 );
            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "prefixlen_diff" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 1043;
            generator_heap->type_description_1 = "cccoooooo";
            goto frame_exception_exit_1;
        }

        tmp_right_name_6 = PyCell_GET( generator->m_closure[1] );
        tmp_assign_source_5 = BINARY_OPERATION( PyNumber_Rshift, tmp_left_name_5, tmp_right_name_6 );
        Py_DECREF( tmp_left_name_5 );
        if ( tmp_assign_source_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 1043;
            generator_heap->type_description_1 = "cccoooooo";
            goto frame_exception_exit_1;
        }
        assert( generator_heap->var_step == NULL );
        generator_heap->var_step = tmp_assign_source_5;
    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_range );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__compat_range );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "global name '%s' is not defined", "_compat_range" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 1044;
            generator_heap->type_description_1 = "cccoooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( generator_heap->var_start );
        tmp_args_element_name_1 = generator_heap->var_start;
        CHECK_OBJECT( generator_heap->var_end );
        tmp_args_element_name_2 = generator_heap->var_end;
        CHECK_OBJECT( generator_heap->var_step );
        tmp_args_element_name_3 = generator_heap->var_step;
        generator->m_frame->m_frame.f_lineno = 1044;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_iter_arg_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
        }

        if ( tmp_iter_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 1044;
            generator_heap->type_description_1 = "cccoooooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_6 = MAKE_ITERATOR( tmp_iter_arg_1 );
        Py_DECREF( tmp_iter_arg_1 );
        if ( tmp_assign_source_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 1044;
            generator_heap->type_description_1 = "cccoooooo";
            goto frame_exception_exit_1;
        }
        assert( generator_heap->tmp_for_loop_1__for_iterator == NULL );
        generator_heap->tmp_for_loop_1__for_iterator = tmp_assign_source_6;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_7;
        CHECK_OBJECT( generator_heap->tmp_for_loop_1__for_iterator );
        tmp_next_source_1 = generator_heap->tmp_for_loop_1__for_iterator;
        tmp_assign_source_7 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_7 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
                generator_heap->type_description_1 = "cccoooooo";
                generator_heap->exception_lineno = 1044;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_for_loop_1__iter_value;
            generator_heap->tmp_for_loop_1__iter_value = tmp_assign_source_7;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_8;
        CHECK_OBJECT( generator_heap->tmp_for_loop_1__iter_value );
        tmp_assign_source_8 = generator_heap->tmp_for_loop_1__iter_value;
        {
            PyObject *old = generator_heap->var_new_addr;
            generator_heap->var_new_addr = tmp_assign_source_8;
            Py_INCREF( generator_heap->var_new_addr );
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_9;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_10;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_tuple_element_2;
        if ( PyCell_GET( generator->m_closure[2] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 1045;
            generator_heap->type_description_1 = "cccoooooo";
            goto try_except_handler_2;
        }

        tmp_source_name_10 = PyCell_GET( generator->m_closure[2] );
        tmp_called_name_2 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_10 );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 1045;
            generator_heap->type_description_1 = "cccoooooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( generator_heap->var_new_addr );
        tmp_tuple_element_2 = generator_heap->var_new_addr;
        tmp_args_element_name_4 = PyTuple_New( 2 );
        Py_INCREF( tmp_tuple_element_2 );
        PyTuple_SET_ITEM( tmp_args_element_name_4, 0, tmp_tuple_element_2 );
        CHECK_OBJECT( generator_heap->var_new_prefixlen );
        tmp_tuple_element_2 = generator_heap->var_new_prefixlen;
        Py_INCREF( tmp_tuple_element_2 );
        PyTuple_SET_ITEM( tmp_args_element_name_4, 1, tmp_tuple_element_2 );
        generator->m_frame->m_frame.f_lineno = 1045;
        {
            PyObject *call_args[] = { tmp_args_element_name_4 };
            tmp_assign_source_9 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_4 );
        if ( tmp_assign_source_9 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 1045;
            generator_heap->type_description_1 = "cccoooooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = generator_heap->var_current;
            generator_heap->var_current = tmp_assign_source_9;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_expression_name_2;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_2;
        CHECK_OBJECT( generator_heap->var_current );
        tmp_expression_name_2 = generator_heap->var_current;
        Py_INCREF( tmp_expression_name_2 );
        generator->m_yield_return_index = 2;
        return tmp_expression_name_2;
        yield_return_2:
        if ( yield_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 1046;
            generator_heap->type_description_1 = "cccoooooo";
            goto try_except_handler_2;
        }
        tmp_yield_result_2 = yield_return_value;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


        generator_heap->exception_lineno = 1044;
        generator_heap->type_description_1 = "cccoooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->tmp_for_loop_1__iter_value );
    generator_heap->tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)generator_heap->tmp_for_loop_1__for_iterator );
    Py_DECREF( generator_heap->tmp_for_loop_1__for_iterator );
    generator_heap->tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_return_exit_1:;

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );
    goto function_return_exit;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( generator_heap->exception_type ) )
    {
        if ( generator_heap->exception_tb == NULL )
        {
            generator_heap->exception_tb = MAKE_TRACEBACK( generator->m_frame, generator_heap->exception_lineno );
        }
        else if ( generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            generator_heap->exception_tb = ADD_TRACEBACK( generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            generator->m_closure[2],
            generator->m_closure[1],
            generator->m_closure[0],
            generator_heap->var_end,
            generator_heap->var_new_addr,
            generator_heap->var_new_prefixlen,
            generator_heap->var_current,
            generator_heap->var_start,
            generator_heap->var_step
        );


        // Release cached frame.
        if ( generator->m_frame == cache_m_frame )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_m_frame = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->var_end );
    generator_heap->var_end = NULL;

    Py_XDECREF( generator_heap->var_new_addr );
    generator_heap->var_new_addr = NULL;

    Py_XDECREF( generator_heap->var_new_prefixlen );
    generator_heap->var_new_prefixlen = NULL;

    Py_XDECREF( generator_heap->var_current );
    generator_heap->var_current = NULL;

    Py_XDECREF( generator_heap->var_start );
    generator_heap->var_start = NULL;

    Py_XDECREF( generator_heap->var_step );
    generator_heap->var_step = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:
    try_end_2:;
    Py_XDECREF( generator_heap->tmp_for_loop_1__iter_value );
    generator_heap->tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)generator_heap->tmp_for_loop_1__for_iterator );
    Py_DECREF( generator_heap->tmp_for_loop_1__for_iterator );
    generator_heap->tmp_for_loop_1__for_iterator = NULL;

    CHECK_OBJECT( (PyObject *)generator_heap->var_end );
    Py_DECREF( generator_heap->var_end );
    generator_heap->var_end = NULL;

    Py_XDECREF( generator_heap->var_new_addr );
    generator_heap->var_new_addr = NULL;

    CHECK_OBJECT( (PyObject *)generator_heap->var_new_prefixlen );
    Py_DECREF( generator_heap->var_new_prefixlen );
    generator_heap->var_new_prefixlen = NULL;

    Py_XDECREF( generator_heap->var_current );
    generator_heap->var_current = NULL;

    CHECK_OBJECT( (PyObject *)generator_heap->var_start );
    Py_DECREF( generator_heap->var_start );
    generator_heap->var_start = NULL;

    CHECK_OBJECT( (PyObject *)generator_heap->var_step );
    Py_DECREF( generator_heap->var_step );
    generator_heap->var_step = NULL;



    return NULL;

    function_exception_exit:
    assert( generator_heap->exception_type );
    RESTORE_ERROR_OCCURRED( generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb );

    return NULL;
    // The above won't return, but we need to make it clear to the compiler
    // as well, or else it will complain and/or generate inferior code.
    assert(false);
    return NULL;

    function_return_exit:
#if PYTHON_VERSION >= 300
    generator->m_returned = None;
#endif

    return NULL;

}

static PyObject *ipaddress$$$function_69_subnets$$$genobj_1_subnets_maker( void )
{
    return Nuitka_Generator_New(
        ipaddress$$$function_69_subnets$$$genobj_1_subnets_context,
        module_ipaddress,
        const_str_plain_subnets,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_afd3bfdaef11bbc48af0b7dfa76ee499,
        3,
        sizeof(struct ipaddress$$$function_69_subnets$$$genobj_1_subnets_locals)
    );
}


static PyObject *impl_ipaddress$$$function_70_supernet( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_prefixlen_diff = python_pars[ 1 ];
    PyObject *par_new_prefix = python_pars[ 2 ];
    PyObject *var_new_prefixlen = NULL;
    struct Nuitka_FrameObject *frame_40865f494124bd7ebca7599fd819457c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_40865f494124bd7ebca7599fd819457c = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_40865f494124bd7ebca7599fd819457c, codeobj_40865f494124bd7ebca7599fd819457c, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_40865f494124bd7ebca7599fd819457c = cache_frame_40865f494124bd7ebca7599fd819457c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_40865f494124bd7ebca7599fd819457c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_40865f494124bd7ebca7599fd819457c ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__prefixlen );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1069;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = const_int_0;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_INT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1069;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        CHECK_OBJECT( par_self );
        tmp_return_value = par_self;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        CHECK_OBJECT( par_new_prefix );
        tmp_compexpr_left_2 = par_new_prefix;
        tmp_compexpr_right_2 = Py_None;
        tmp_condition_result_2 = ( tmp_compexpr_left_2 != tmp_compexpr_right_2 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            PyObject *tmp_source_name_2;
            CHECK_OBJECT( par_new_prefix );
            tmp_compexpr_left_3 = par_new_prefix;
            CHECK_OBJECT( par_self );
            tmp_source_name_2 = par_self;
            tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__prefixlen );
            if ( tmp_compexpr_right_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1073;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            tmp_res = RICH_COMPARE_BOOL_GT_OBJECT_OBJECT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
            Py_DECREF( tmp_compexpr_right_3 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1073;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_3;
            }
            else
            {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_raise_type_1;
                PyObject *tmp_make_exception_arg_1;
                tmp_make_exception_arg_1 = const_unicode_digest_11db8dad0fdf85c306f5f6455601667d;
                frame_40865f494124bd7ebca7599fd819457c->m_frame.f_lineno = 1074;
                {
                    PyObject *call_args[] = { tmp_make_exception_arg_1 };
                    tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
                }

                assert( !(tmp_raise_type_1 == NULL) );
                exception_type = tmp_raise_type_1;
                exception_lineno = 1074;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            branch_no_3:;
        }
        {
            nuitka_bool tmp_condition_result_4;
            PyObject *tmp_compexpr_left_4;
            PyObject *tmp_compexpr_right_4;
            CHECK_OBJECT( par_prefixlen_diff );
            tmp_compexpr_left_4 = par_prefixlen_diff;
            tmp_compexpr_right_4 = const_int_pos_1;
            tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_INT( tmp_compexpr_left_4, tmp_compexpr_right_4 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1075;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_4 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_4;
            }
            else
            {
                goto branch_no_4;
            }
            branch_yes_4:;
            {
                PyObject *tmp_raise_type_2;
                PyObject *tmp_make_exception_arg_2;
                tmp_make_exception_arg_2 = const_unicode_digest_786511cd0da76607fa48edaa91095b3b;
                frame_40865f494124bd7ebca7599fd819457c->m_frame.f_lineno = 1076;
                {
                    PyObject *call_args[] = { tmp_make_exception_arg_2 };
                    tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
                }

                assert( !(tmp_raise_type_2 == NULL) );
                exception_type = tmp_raise_type_2;
                exception_lineno = 1076;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            branch_no_4:;
        }
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_left_name_1;
            PyObject *tmp_source_name_3;
            PyObject *tmp_right_name_1;
            CHECK_OBJECT( par_self );
            tmp_source_name_3 = par_self;
            tmp_left_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__prefixlen );
            if ( tmp_left_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1077;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_new_prefix );
            tmp_right_name_1 = par_new_prefix;
            tmp_assign_source_1 = BINARY_OPERATION_SUB( tmp_left_name_1, tmp_right_name_1 );
            Py_DECREF( tmp_left_name_1 );
            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1077;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_prefixlen_diff;
                assert( old != NULL );
                par_prefixlen_diff = tmp_assign_source_1;
                Py_DECREF( old );
            }

        }
        branch_no_2:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_left_name_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_right_name_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_4 = par_self;
        tmp_left_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_prefixlen );
        if ( tmp_left_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1079;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_prefixlen_diff );
        tmp_right_name_2 = par_prefixlen_diff;
        tmp_assign_source_2 = BINARY_OPERATION_SUB( tmp_left_name_2, tmp_right_name_2 );
        Py_DECREF( tmp_left_name_2 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1079;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_new_prefixlen == NULL );
        var_new_prefixlen = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_5;
        PyObject *tmp_compexpr_left_5;
        PyObject *tmp_compexpr_right_5;
        CHECK_OBJECT( var_new_prefixlen );
        tmp_compexpr_left_5 = var_new_prefixlen;
        tmp_compexpr_right_5 = const_int_0;
        tmp_res = RICH_COMPARE_BOOL_LT_OBJECT_INT( tmp_compexpr_left_5, tmp_compexpr_right_5 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1080;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_5 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_5;
        }
        else
        {
            goto branch_no_5;
        }
        branch_yes_5:;
        {
            PyObject *tmp_raise_type_3;
            PyObject *tmp_make_exception_arg_3;
            PyObject *tmp_left_name_3;
            PyObject *tmp_right_name_3;
            PyObject *tmp_tuple_element_1;
            PyObject *tmp_source_name_5;
            tmp_left_name_3 = const_unicode_digest_7322ea8f60136157d13c0a45146fd35a;
            CHECK_OBJECT( par_self );
            tmp_source_name_5 = par_self;
            tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_prefixlen );
            if ( tmp_tuple_element_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1083;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            tmp_right_name_3 = PyTuple_New( 2 );
            PyTuple_SET_ITEM( tmp_right_name_3, 0, tmp_tuple_element_1 );
            CHECK_OBJECT( par_prefixlen_diff );
            tmp_tuple_element_1 = par_prefixlen_diff;
            Py_INCREF( tmp_tuple_element_1 );
            PyTuple_SET_ITEM( tmp_right_name_3, 1, tmp_tuple_element_1 );
            tmp_make_exception_arg_3 = BINARY_OPERATION_REMAINDER( tmp_left_name_3, tmp_right_name_3 );
            Py_DECREF( tmp_right_name_3 );
            if ( tmp_make_exception_arg_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1082;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            frame_40865f494124bd7ebca7599fd819457c->m_frame.f_lineno = 1081;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_3 };
                tmp_raise_type_3 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            Py_DECREF( tmp_make_exception_arg_3 );
            assert( !(tmp_raise_type_3 == NULL) );
            exception_type = tmp_raise_type_3;
            exception_lineno = 1081;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        branch_no_5:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_6;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_tuple_element_2;
        PyObject *tmp_left_name_4;
        PyObject *tmp_int_arg_1;
        PyObject *tmp_source_name_7;
        PyObject *tmp_right_name_4;
        PyObject *tmp_left_name_5;
        PyObject *tmp_int_arg_2;
        PyObject *tmp_source_name_8;
        PyObject *tmp_right_name_5;
        CHECK_OBJECT( par_self );
        tmp_source_name_6 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_6 );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1084;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_7 = par_self;
        tmp_int_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_network_address );
        if ( tmp_int_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1085;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_4 = PyNumber_Int( tmp_int_arg_1 );
        Py_DECREF( tmp_int_arg_1 );
        if ( tmp_left_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1085;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_8 = par_self;
        tmp_int_arg_2 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_netmask );
        if ( tmp_int_arg_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_left_name_4 );

            exception_lineno = 1085;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_5 = PyNumber_Int( tmp_int_arg_2 );
        Py_DECREF( tmp_int_arg_2 );
        if ( tmp_left_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_left_name_4 );

            exception_lineno = 1085;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_prefixlen_diff );
        tmp_right_name_5 = par_prefixlen_diff;
        tmp_right_name_4 = BINARY_OPERATION( PyNumber_Lshift, tmp_left_name_5, tmp_right_name_5 );
        Py_DECREF( tmp_left_name_5 );
        if ( tmp_right_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_left_name_4 );

            exception_lineno = 1085;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_tuple_element_2 = BINARY_OPERATION( PyNumber_And, tmp_left_name_4, tmp_right_name_4 );
        Py_DECREF( tmp_left_name_4 );
        Py_DECREF( tmp_right_name_4 );
        if ( tmp_tuple_element_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1085;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_1 = PyTuple_New( 2 );
        PyTuple_SET_ITEM( tmp_args_element_name_1, 0, tmp_tuple_element_2 );
        CHECK_OBJECT( var_new_prefixlen );
        tmp_tuple_element_2 = var_new_prefixlen;
        Py_INCREF( tmp_tuple_element_2 );
        PyTuple_SET_ITEM( tmp_args_element_name_1, 1, tmp_tuple_element_2 );
        frame_40865f494124bd7ebca7599fd819457c->m_frame.f_lineno = 1084;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1084;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_40865f494124bd7ebca7599fd819457c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_40865f494124bd7ebca7599fd819457c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_40865f494124bd7ebca7599fd819457c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_40865f494124bd7ebca7599fd819457c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_40865f494124bd7ebca7599fd819457c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_40865f494124bd7ebca7599fd819457c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_40865f494124bd7ebca7599fd819457c,
        type_description_1,
        par_self,
        par_prefixlen_diff,
        par_new_prefix,
        var_new_prefixlen
    );


    // Release cached frame.
    if ( frame_40865f494124bd7ebca7599fd819457c == cache_frame_40865f494124bd7ebca7599fd819457c )
    {
        Py_DECREF( frame_40865f494124bd7ebca7599fd819457c );
    }
    cache_frame_40865f494124bd7ebca7599fd819457c = NULL;

    assertFrameObject( frame_40865f494124bd7ebca7599fd819457c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_70_supernet );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_new_prefix );
    Py_DECREF( par_new_prefix );
    par_new_prefix = NULL;

    Py_XDECREF( var_new_prefixlen );
    var_new_prefixlen = NULL;

    Py_XDECREF( par_prefixlen_diff );
    par_prefixlen_diff = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_new_prefix );
    Py_DECREF( par_new_prefix );
    par_new_prefix = NULL;

    Py_XDECREF( var_new_prefixlen );
    var_new_prefixlen = NULL;

    Py_XDECREF( par_prefixlen_diff );
    par_prefixlen_diff = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_70_supernet );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_71_is_multicast( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_1f58a578c801456122b311c4e070e4c5;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_1f58a578c801456122b311c4e070e4c5 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1f58a578c801456122b311c4e070e4c5, codeobj_1f58a578c801456122b311c4e070e4c5, module_ipaddress, sizeof(void *) );
    frame_1f58a578c801456122b311c4e070e4c5 = cache_frame_1f58a578c801456122b311c4e070e4c5;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1f58a578c801456122b311c4e070e4c5 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1f58a578c801456122b311c4e070e4c5 ) == 2 ); // Frame stack

    // Framed code:
    {
        int tmp_and_left_truth_1;
        PyObject *tmp_and_left_value_1;
        PyObject *tmp_and_right_value_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_source_name_4;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_network_address );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1098;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_is_multicast );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_and_left_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1098;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
        if ( tmp_and_left_truth_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_and_left_value_1 );

            exception_lineno = 1099;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        if ( tmp_and_left_truth_1 == 1 )
        {
            goto and_right_1;
        }
        else
        {
            goto and_left_1;
        }
        and_right_1:;
        Py_DECREF( tmp_and_left_value_1 );
        CHECK_OBJECT( par_self );
        tmp_source_name_4 = par_self;
        tmp_source_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_broadcast_address );
        if ( tmp_source_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1099;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_is_multicast );
        Py_DECREF( tmp_source_name_3 );
        if ( tmp_and_right_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1099;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_return_value = tmp_and_left_value_1;
        and_end_1:;
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1f58a578c801456122b311c4e070e4c5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_1f58a578c801456122b311c4e070e4c5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1f58a578c801456122b311c4e070e4c5 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1f58a578c801456122b311c4e070e4c5, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1f58a578c801456122b311c4e070e4c5->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1f58a578c801456122b311c4e070e4c5, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1f58a578c801456122b311c4e070e4c5,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_1f58a578c801456122b311c4e070e4c5 == cache_frame_1f58a578c801456122b311c4e070e4c5 )
    {
        Py_DECREF( frame_1f58a578c801456122b311c4e070e4c5 );
    }
    cache_frame_1f58a578c801456122b311c4e070e4c5 = NULL;

    assertFrameObject( frame_1f58a578c801456122b311c4e070e4c5 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_71_is_multicast );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_71_is_multicast );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_72_subnet_of( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_c403847f283cf7a81a7cf711a02170ce;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_c403847f283cf7a81a7cf711a02170ce = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c403847f283cf7a81a7cf711a02170ce, codeobj_c403847f283cf7a81a7cf711a02170ce, module_ipaddress, sizeof(void *)+sizeof(void *) );
    frame_c403847f283cf7a81a7cf711a02170ce = cache_frame_c403847f283cf7a81a7cf711a02170ce;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c403847f283cf7a81a7cf711a02170ce );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c403847f283cf7a81a7cf711a02170ce ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__version );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1103;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_other );
        tmp_source_name_2 = par_other;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__version );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_1 );

            exception_lineno = 1103;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1103;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_False;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        int tmp_and_left_truth_1;
        nuitka_bool tmp_and_left_value_1;
        nuitka_bool tmp_and_right_value_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_attribute_name_1;
        PyObject *tmp_source_name_4;
        PyObject *tmp_attribute_name_2;
        CHECK_OBJECT( par_other );
        tmp_source_name_3 = par_other;
        tmp_attribute_name_1 = const_unicode_plain_network_address;
        tmp_res = BUILTIN_HASATTR_BOOL( tmp_source_name_3, tmp_attribute_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1106;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_1 = tmp_and_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_and_left_truth_1 == 1 )
        {
            goto and_right_1;
        }
        else
        {
            goto and_left_1;
        }
        and_right_1:;
        CHECK_OBJECT( par_other );
        tmp_source_name_4 = par_other;
        tmp_attribute_name_2 = const_unicode_plain_broadcast_address;
        tmp_res = BUILTIN_HASATTR_BOOL( tmp_source_name_4, tmp_attribute_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1107;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_condition_result_2 = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_condition_result_2 = tmp_and_left_value_1;
        and_end_1:;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            int tmp_and_left_truth_2;
            PyObject *tmp_and_left_value_2;
            PyObject *tmp_and_right_value_2;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_source_name_5;
            PyObject *tmp_source_name_6;
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            PyObject *tmp_source_name_7;
            PyObject *tmp_source_name_8;
            CHECK_OBJECT( par_other );
            tmp_source_name_5 = par_other;
            tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_network_address );
            if ( tmp_compexpr_left_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1108;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_source_name_6 = par_self;
            tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_network_address );
            if ( tmp_compexpr_right_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_compexpr_left_2 );

                exception_lineno = 1108;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            tmp_and_left_value_2 = RICH_COMPARE_LTE_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
            Py_DECREF( tmp_compexpr_left_2 );
            Py_DECREF( tmp_compexpr_right_2 );
            if ( tmp_and_left_value_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1108;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            tmp_and_left_truth_2 = CHECK_IF_TRUE( tmp_and_left_value_2 );
            if ( tmp_and_left_truth_2 == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_and_left_value_2 );

                exception_lineno = 1109;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            if ( tmp_and_left_truth_2 == 1 )
            {
                goto and_right_2;
            }
            else
            {
                goto and_left_2;
            }
            and_right_2:;
            Py_DECREF( tmp_and_left_value_2 );
            CHECK_OBJECT( par_other );
            tmp_source_name_7 = par_other;
            tmp_compexpr_left_3 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_broadcast_address );
            if ( tmp_compexpr_left_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1109;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_source_name_8 = par_self;
            tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_broadcast_address );
            if ( tmp_compexpr_right_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_compexpr_left_3 );

                exception_lineno = 1109;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            tmp_and_right_value_2 = RICH_COMPARE_GTE_OBJECT_OBJECT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
            Py_DECREF( tmp_compexpr_left_3 );
            Py_DECREF( tmp_compexpr_right_3 );
            if ( tmp_and_right_value_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1109;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            tmp_return_value = tmp_and_right_value_2;
            goto and_end_2;
            and_left_2:;
            tmp_return_value = tmp_and_left_value_2;
            and_end_2:;
            goto frame_return_exit_1;
        }
        goto branch_end_2;
        branch_no_2:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            PyObject *tmp_type_arg_1;
            tmp_left_name_1 = const_unicode_digest_e987769ab2a30dcd5958c4d8a8f94f4e;
            CHECK_OBJECT( par_other );
            tmp_type_arg_1 = par_other;
            tmp_right_name_1 = BUILTIN_TYPE1( tmp_type_arg_1 );
            assert( !(tmp_right_name_1 == NULL) );
            tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
            Py_DECREF( tmp_right_name_1 );
            if ( tmp_make_exception_arg_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1112;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            frame_c403847f283cf7a81a7cf711a02170ce->m_frame.f_lineno = 1112;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            Py_DECREF( tmp_make_exception_arg_1 );
            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1112;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_end_2:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c403847f283cf7a81a7cf711a02170ce );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_c403847f283cf7a81a7cf711a02170ce );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c403847f283cf7a81a7cf711a02170ce );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c403847f283cf7a81a7cf711a02170ce, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c403847f283cf7a81a7cf711a02170ce->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c403847f283cf7a81a7cf711a02170ce, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c403847f283cf7a81a7cf711a02170ce,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_c403847f283cf7a81a7cf711a02170ce == cache_frame_c403847f283cf7a81a7cf711a02170ce )
    {
        Py_DECREF( frame_c403847f283cf7a81a7cf711a02170ce );
    }
    cache_frame_c403847f283cf7a81a7cf711a02170ce = NULL;

    assertFrameObject( frame_c403847f283cf7a81a7cf711a02170ce );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_72_subnet_of );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_72_subnet_of );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_73_supernet_of( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_1f679a65df6468242fd0f036feae969e;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_1f679a65df6468242fd0f036feae969e = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1f679a65df6468242fd0f036feae969e, codeobj_1f679a65df6468242fd0f036feae969e, module_ipaddress, sizeof(void *)+sizeof(void *) );
    frame_1f679a65df6468242fd0f036feae969e = cache_frame_1f679a65df6468242fd0f036feae969e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1f679a65df6468242fd0f036feae969e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1f679a65df6468242fd0f036feae969e ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__version );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1117;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_other );
        tmp_source_name_2 = par_other;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__version );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_1 );

            exception_lineno = 1117;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1117;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_False;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        int tmp_and_left_truth_1;
        nuitka_bool tmp_and_left_value_1;
        nuitka_bool tmp_and_right_value_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_attribute_name_1;
        PyObject *tmp_source_name_4;
        PyObject *tmp_attribute_name_2;
        CHECK_OBJECT( par_other );
        tmp_source_name_3 = par_other;
        tmp_attribute_name_1 = const_unicode_plain_network_address;
        tmp_res = BUILTIN_HASATTR_BOOL( tmp_source_name_3, tmp_attribute_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1120;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_1 = tmp_and_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_and_left_truth_1 == 1 )
        {
            goto and_right_1;
        }
        else
        {
            goto and_left_1;
        }
        and_right_1:;
        CHECK_OBJECT( par_other );
        tmp_source_name_4 = par_other;
        tmp_attribute_name_2 = const_unicode_plain_broadcast_address;
        tmp_res = BUILTIN_HASATTR_BOOL( tmp_source_name_4, tmp_attribute_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1121;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_condition_result_2 = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_condition_result_2 = tmp_and_left_value_1;
        and_end_1:;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            int tmp_and_left_truth_2;
            PyObject *tmp_and_left_value_2;
            PyObject *tmp_and_right_value_2;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_source_name_5;
            PyObject *tmp_source_name_6;
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            PyObject *tmp_source_name_7;
            PyObject *tmp_source_name_8;
            CHECK_OBJECT( par_other );
            tmp_source_name_5 = par_other;
            tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_network_address );
            if ( tmp_compexpr_left_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1122;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_source_name_6 = par_self;
            tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_network_address );
            if ( tmp_compexpr_right_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_compexpr_left_2 );

                exception_lineno = 1122;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            tmp_and_left_value_2 = RICH_COMPARE_GTE_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
            Py_DECREF( tmp_compexpr_left_2 );
            Py_DECREF( tmp_compexpr_right_2 );
            if ( tmp_and_left_value_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1122;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            tmp_and_left_truth_2 = CHECK_IF_TRUE( tmp_and_left_value_2 );
            if ( tmp_and_left_truth_2 == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_and_left_value_2 );

                exception_lineno = 1123;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            if ( tmp_and_left_truth_2 == 1 )
            {
                goto and_right_2;
            }
            else
            {
                goto and_left_2;
            }
            and_right_2:;
            Py_DECREF( tmp_and_left_value_2 );
            CHECK_OBJECT( par_other );
            tmp_source_name_7 = par_other;
            tmp_compexpr_left_3 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_broadcast_address );
            if ( tmp_compexpr_left_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1123;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_source_name_8 = par_self;
            tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_broadcast_address );
            if ( tmp_compexpr_right_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_compexpr_left_3 );

                exception_lineno = 1123;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            tmp_and_right_value_2 = RICH_COMPARE_LTE_OBJECT_OBJECT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
            Py_DECREF( tmp_compexpr_left_3 );
            Py_DECREF( tmp_compexpr_right_3 );
            if ( tmp_and_right_value_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1123;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            tmp_return_value = tmp_and_right_value_2;
            goto and_end_2;
            and_left_2:;
            tmp_return_value = tmp_and_left_value_2;
            and_end_2:;
            goto frame_return_exit_1;
        }
        goto branch_end_2;
        branch_no_2:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            PyObject *tmp_type_arg_1;
            tmp_left_name_1 = const_unicode_digest_e987769ab2a30dcd5958c4d8a8f94f4e;
            CHECK_OBJECT( par_other );
            tmp_type_arg_1 = par_other;
            tmp_right_name_1 = BUILTIN_TYPE1( tmp_type_arg_1 );
            assert( !(tmp_right_name_1 == NULL) );
            tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
            Py_DECREF( tmp_right_name_1 );
            if ( tmp_make_exception_arg_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1126;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            frame_1f679a65df6468242fd0f036feae969e->m_frame.f_lineno = 1126;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            Py_DECREF( tmp_make_exception_arg_1 );
            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1126;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_end_2:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1f679a65df6468242fd0f036feae969e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_1f679a65df6468242fd0f036feae969e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1f679a65df6468242fd0f036feae969e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1f679a65df6468242fd0f036feae969e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1f679a65df6468242fd0f036feae969e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1f679a65df6468242fd0f036feae969e, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1f679a65df6468242fd0f036feae969e,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_1f679a65df6468242fd0f036feae969e == cache_frame_1f679a65df6468242fd0f036feae969e )
    {
        Py_DECREF( frame_1f679a65df6468242fd0f036feae969e );
    }
    cache_frame_1f679a65df6468242fd0f036feae969e = NULL;

    assertFrameObject( frame_1f679a65df6468242fd0f036feae969e );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_73_supernet_of );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_73_supernet_of );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_74_is_reserved( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_7a258d001059db6f4e3d220e0e99a1a2;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_7a258d001059db6f4e3d220e0e99a1a2 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_7a258d001059db6f4e3d220e0e99a1a2, codeobj_7a258d001059db6f4e3d220e0e99a1a2, module_ipaddress, sizeof(void *) );
    frame_7a258d001059db6f4e3d220e0e99a1a2 = cache_frame_7a258d001059db6f4e3d220e0e99a1a2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_7a258d001059db6f4e3d220e0e99a1a2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_7a258d001059db6f4e3d220e0e99a1a2 ) == 2 ); // Frame stack

    // Framed code:
    {
        int tmp_and_left_truth_1;
        PyObject *tmp_and_left_value_1;
        PyObject *tmp_and_right_value_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_source_name_4;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_network_address );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1138;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_is_reserved );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_and_left_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1138;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
        if ( tmp_and_left_truth_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_and_left_value_1 );

            exception_lineno = 1139;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        if ( tmp_and_left_truth_1 == 1 )
        {
            goto and_right_1;
        }
        else
        {
            goto and_left_1;
        }
        and_right_1:;
        Py_DECREF( tmp_and_left_value_1 );
        CHECK_OBJECT( par_self );
        tmp_source_name_4 = par_self;
        tmp_source_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_broadcast_address );
        if ( tmp_source_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1139;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_is_reserved );
        Py_DECREF( tmp_source_name_3 );
        if ( tmp_and_right_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1139;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_return_value = tmp_and_left_value_1;
        and_end_1:;
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7a258d001059db6f4e3d220e0e99a1a2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_7a258d001059db6f4e3d220e0e99a1a2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7a258d001059db6f4e3d220e0e99a1a2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_7a258d001059db6f4e3d220e0e99a1a2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_7a258d001059db6f4e3d220e0e99a1a2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_7a258d001059db6f4e3d220e0e99a1a2, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7a258d001059db6f4e3d220e0e99a1a2,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_7a258d001059db6f4e3d220e0e99a1a2 == cache_frame_7a258d001059db6f4e3d220e0e99a1a2 )
    {
        Py_DECREF( frame_7a258d001059db6f4e3d220e0e99a1a2 );
    }
    cache_frame_7a258d001059db6f4e3d220e0e99a1a2 = NULL;

    assertFrameObject( frame_7a258d001059db6f4e3d220e0e99a1a2 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_74_is_reserved );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_74_is_reserved );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_75_is_link_local( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_1e777b2cca1fdd718c4873963deb0023;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_1e777b2cca1fdd718c4873963deb0023 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1e777b2cca1fdd718c4873963deb0023, codeobj_1e777b2cca1fdd718c4873963deb0023, module_ipaddress, sizeof(void *) );
    frame_1e777b2cca1fdd718c4873963deb0023 = cache_frame_1e777b2cca1fdd718c4873963deb0023;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1e777b2cca1fdd718c4873963deb0023 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1e777b2cca1fdd718c4873963deb0023 ) == 2 ); // Frame stack

    // Framed code:
    {
        int tmp_and_left_truth_1;
        PyObject *tmp_and_left_value_1;
        PyObject *tmp_and_right_value_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_source_name_4;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_network_address );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1149;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_is_link_local );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_and_left_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1149;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
        if ( tmp_and_left_truth_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_and_left_value_1 );

            exception_lineno = 1150;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        if ( tmp_and_left_truth_1 == 1 )
        {
            goto and_right_1;
        }
        else
        {
            goto and_left_1;
        }
        and_right_1:;
        Py_DECREF( tmp_and_left_value_1 );
        CHECK_OBJECT( par_self );
        tmp_source_name_4 = par_self;
        tmp_source_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_broadcast_address );
        if ( tmp_source_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1150;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_is_link_local );
        Py_DECREF( tmp_source_name_3 );
        if ( tmp_and_right_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1150;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_return_value = tmp_and_left_value_1;
        and_end_1:;
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1e777b2cca1fdd718c4873963deb0023 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_1e777b2cca1fdd718c4873963deb0023 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1e777b2cca1fdd718c4873963deb0023 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1e777b2cca1fdd718c4873963deb0023, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1e777b2cca1fdd718c4873963deb0023->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1e777b2cca1fdd718c4873963deb0023, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1e777b2cca1fdd718c4873963deb0023,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_1e777b2cca1fdd718c4873963deb0023 == cache_frame_1e777b2cca1fdd718c4873963deb0023 )
    {
        Py_DECREF( frame_1e777b2cca1fdd718c4873963deb0023 );
    }
    cache_frame_1e777b2cca1fdd718c4873963deb0023 = NULL;

    assertFrameObject( frame_1e777b2cca1fdd718c4873963deb0023 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_75_is_link_local );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_75_is_link_local );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_76_is_private( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_adc6579a2d3fee5fb2a17b97524c1b54;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_adc6579a2d3fee5fb2a17b97524c1b54 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_adc6579a2d3fee5fb2a17b97524c1b54, codeobj_adc6579a2d3fee5fb2a17b97524c1b54, module_ipaddress, sizeof(void *) );
    frame_adc6579a2d3fee5fb2a17b97524c1b54 = cache_frame_adc6579a2d3fee5fb2a17b97524c1b54;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_adc6579a2d3fee5fb2a17b97524c1b54 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_adc6579a2d3fee5fb2a17b97524c1b54 ) == 2 ); // Frame stack

    // Framed code:
    {
        int tmp_and_left_truth_1;
        PyObject *tmp_and_left_value_1;
        PyObject *tmp_and_right_value_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_source_name_4;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_network_address );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1161;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_is_private );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_and_left_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1161;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
        if ( tmp_and_left_truth_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_and_left_value_1 );

            exception_lineno = 1162;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        if ( tmp_and_left_truth_1 == 1 )
        {
            goto and_right_1;
        }
        else
        {
            goto and_left_1;
        }
        and_right_1:;
        Py_DECREF( tmp_and_left_value_1 );
        CHECK_OBJECT( par_self );
        tmp_source_name_4 = par_self;
        tmp_source_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_broadcast_address );
        if ( tmp_source_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1162;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_is_private );
        Py_DECREF( tmp_source_name_3 );
        if ( tmp_and_right_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1162;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_return_value = tmp_and_left_value_1;
        and_end_1:;
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_adc6579a2d3fee5fb2a17b97524c1b54 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_adc6579a2d3fee5fb2a17b97524c1b54 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_adc6579a2d3fee5fb2a17b97524c1b54 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_adc6579a2d3fee5fb2a17b97524c1b54, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_adc6579a2d3fee5fb2a17b97524c1b54->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_adc6579a2d3fee5fb2a17b97524c1b54, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_adc6579a2d3fee5fb2a17b97524c1b54,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_adc6579a2d3fee5fb2a17b97524c1b54 == cache_frame_adc6579a2d3fee5fb2a17b97524c1b54 )
    {
        Py_DECREF( frame_adc6579a2d3fee5fb2a17b97524c1b54 );
    }
    cache_frame_adc6579a2d3fee5fb2a17b97524c1b54 = NULL;

    assertFrameObject( frame_adc6579a2d3fee5fb2a17b97524c1b54 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_76_is_private );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_76_is_private );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_77_is_global( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_797202885290d9baeb7f5a55e4fd22c5;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_797202885290d9baeb7f5a55e4fd22c5 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_797202885290d9baeb7f5a55e4fd22c5, codeobj_797202885290d9baeb7f5a55e4fd22c5, module_ipaddress, sizeof(void *) );
    frame_797202885290d9baeb7f5a55e4fd22c5 = cache_frame_797202885290d9baeb7f5a55e4fd22c5;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_797202885290d9baeb7f5a55e4fd22c5 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_797202885290d9baeb7f5a55e4fd22c5 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_operand_name_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_operand_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_is_private );
        if ( tmp_operand_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1173;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        Py_DECREF( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1173;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = ( tmp_res == 0 ) ? Py_True : Py_False;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_797202885290d9baeb7f5a55e4fd22c5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_797202885290d9baeb7f5a55e4fd22c5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_797202885290d9baeb7f5a55e4fd22c5 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_797202885290d9baeb7f5a55e4fd22c5, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_797202885290d9baeb7f5a55e4fd22c5->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_797202885290d9baeb7f5a55e4fd22c5, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_797202885290d9baeb7f5a55e4fd22c5,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_797202885290d9baeb7f5a55e4fd22c5 == cache_frame_797202885290d9baeb7f5a55e4fd22c5 )
    {
        Py_DECREF( frame_797202885290d9baeb7f5a55e4fd22c5 );
    }
    cache_frame_797202885290d9baeb7f5a55e4fd22c5 = NULL;

    assertFrameObject( frame_797202885290d9baeb7f5a55e4fd22c5 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_77_is_global );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_77_is_global );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_78_is_unspecified( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_f8fcc3c4ac09b355399d18350c5a9f23;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_f8fcc3c4ac09b355399d18350c5a9f23 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f8fcc3c4ac09b355399d18350c5a9f23, codeobj_f8fcc3c4ac09b355399d18350c5a9f23, module_ipaddress, sizeof(void *) );
    frame_f8fcc3c4ac09b355399d18350c5a9f23 = cache_frame_f8fcc3c4ac09b355399d18350c5a9f23;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f8fcc3c4ac09b355399d18350c5a9f23 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f8fcc3c4ac09b355399d18350c5a9f23 ) == 2 ); // Frame stack

    // Framed code:
    {
        int tmp_and_left_truth_1;
        PyObject *tmp_and_left_value_1;
        PyObject *tmp_and_right_value_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_source_name_4;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_network_address );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1184;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_is_unspecified );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_and_left_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1184;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
        if ( tmp_and_left_truth_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_and_left_value_1 );

            exception_lineno = 1185;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        if ( tmp_and_left_truth_1 == 1 )
        {
            goto and_right_1;
        }
        else
        {
            goto and_left_1;
        }
        and_right_1:;
        Py_DECREF( tmp_and_left_value_1 );
        CHECK_OBJECT( par_self );
        tmp_source_name_4 = par_self;
        tmp_source_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_broadcast_address );
        if ( tmp_source_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1185;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_is_unspecified );
        Py_DECREF( tmp_source_name_3 );
        if ( tmp_and_right_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1185;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_return_value = tmp_and_left_value_1;
        and_end_1:;
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f8fcc3c4ac09b355399d18350c5a9f23 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_f8fcc3c4ac09b355399d18350c5a9f23 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f8fcc3c4ac09b355399d18350c5a9f23 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f8fcc3c4ac09b355399d18350c5a9f23, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f8fcc3c4ac09b355399d18350c5a9f23->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f8fcc3c4ac09b355399d18350c5a9f23, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f8fcc3c4ac09b355399d18350c5a9f23,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_f8fcc3c4ac09b355399d18350c5a9f23 == cache_frame_f8fcc3c4ac09b355399d18350c5a9f23 )
    {
        Py_DECREF( frame_f8fcc3c4ac09b355399d18350c5a9f23 );
    }
    cache_frame_f8fcc3c4ac09b355399d18350c5a9f23 = NULL;

    assertFrameObject( frame_f8fcc3c4ac09b355399d18350c5a9f23 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_78_is_unspecified );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_78_is_unspecified );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_79_is_loopback( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_c66eb78bb605c988fc86c10da130d5b9;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_c66eb78bb605c988fc86c10da130d5b9 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c66eb78bb605c988fc86c10da130d5b9, codeobj_c66eb78bb605c988fc86c10da130d5b9, module_ipaddress, sizeof(void *) );
    frame_c66eb78bb605c988fc86c10da130d5b9 = cache_frame_c66eb78bb605c988fc86c10da130d5b9;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c66eb78bb605c988fc86c10da130d5b9 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c66eb78bb605c988fc86c10da130d5b9 ) == 2 ); // Frame stack

    // Framed code:
    {
        int tmp_and_left_truth_1;
        PyObject *tmp_and_left_value_1;
        PyObject *tmp_and_right_value_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_source_name_4;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_network_address );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1196;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_is_loopback );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_and_left_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1196;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
        if ( tmp_and_left_truth_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_and_left_value_1 );

            exception_lineno = 1197;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        if ( tmp_and_left_truth_1 == 1 )
        {
            goto and_right_1;
        }
        else
        {
            goto and_left_1;
        }
        and_right_1:;
        Py_DECREF( tmp_and_left_value_1 );
        CHECK_OBJECT( par_self );
        tmp_source_name_4 = par_self;
        tmp_source_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_broadcast_address );
        if ( tmp_source_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1197;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_is_loopback );
        Py_DECREF( tmp_source_name_3 );
        if ( tmp_and_right_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1197;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_return_value = tmp_and_left_value_1;
        and_end_1:;
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c66eb78bb605c988fc86c10da130d5b9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_c66eb78bb605c988fc86c10da130d5b9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c66eb78bb605c988fc86c10da130d5b9 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c66eb78bb605c988fc86c10da130d5b9, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c66eb78bb605c988fc86c10da130d5b9->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c66eb78bb605c988fc86c10da130d5b9, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c66eb78bb605c988fc86c10da130d5b9,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_c66eb78bb605c988fc86c10da130d5b9 == cache_frame_c66eb78bb605c988fc86c10da130d5b9 )
    {
        Py_DECREF( frame_c66eb78bb605c988fc86c10da130d5b9 );
    }
    cache_frame_c66eb78bb605c988fc86c10da130d5b9 = NULL;

    assertFrameObject( frame_c66eb78bb605c988fc86c10da130d5b9 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_79_is_loopback );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_79_is_loopback );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_80__explode_shorthand_ip_string( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_73951747500cefaada7ce57eac2afc74;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_73951747500cefaada7ce57eac2afc74 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_73951747500cefaada7ce57eac2afc74, codeobj_73951747500cefaada7ce57eac2afc74, module_ipaddress, sizeof(void *) );
    frame_73951747500cefaada7ce57eac2afc74 = cache_frame_73951747500cefaada7ce57eac2afc74;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_73951747500cefaada7ce57eac2afc74 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_73951747500cefaada7ce57eac2afc74 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_str );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__compat_str );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_compat_str" );
            exception_tb = NULL;

            exception_lineno = 1224;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_self );
        tmp_args_element_name_1 = par_self;
        frame_73951747500cefaada7ce57eac2afc74->m_frame.f_lineno = 1224;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1224;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_73951747500cefaada7ce57eac2afc74 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_73951747500cefaada7ce57eac2afc74 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_73951747500cefaada7ce57eac2afc74 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_73951747500cefaada7ce57eac2afc74, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_73951747500cefaada7ce57eac2afc74->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_73951747500cefaada7ce57eac2afc74, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_73951747500cefaada7ce57eac2afc74,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_73951747500cefaada7ce57eac2afc74 == cache_frame_73951747500cefaada7ce57eac2afc74 )
    {
        Py_DECREF( frame_73951747500cefaada7ce57eac2afc74 );
    }
    cache_frame_73951747500cefaada7ce57eac2afc74 = NULL;

    assertFrameObject( frame_73951747500cefaada7ce57eac2afc74 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_80__explode_shorthand_ip_string );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_80__explode_shorthand_ip_string );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_81__make_netmask( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_arg = python_pars[ 1 ];
    PyObject *var_prefixlen = NULL;
    PyObject *var_netmask = NULL;
    struct Nuitka_FrameObject *frame_f6ab1da534820a295432dc985ea5c721;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    bool tmp_result;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_f6ab1da534820a295432dc985ea5c721 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f6ab1da534820a295432dc985ea5c721, codeobj_f6ab1da534820a295432dc985ea5c721, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_f6ab1da534820a295432dc985ea5c721 = cache_frame_f6ab1da534820a295432dc985ea5c721;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f6ab1da534820a295432dc985ea5c721 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f6ab1da534820a295432dc985ea5c721 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_arg );
        tmp_compexpr_left_1 = par_arg;
        CHECK_OBJECT( par_cls );
        tmp_source_name_1 = par_cls;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__netmask_cache );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1235;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_res = PySequence_Contains( tmp_compexpr_right_1, tmp_compexpr_left_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1235;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_isinstance_inst_1;
            PyObject *tmp_isinstance_cls_1;
            PyObject *tmp_mvar_value_1;
            CHECK_OBJECT( par_arg );
            tmp_isinstance_inst_1 = par_arg;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_int_types );

            if (unlikely( tmp_mvar_value_1 == NULL ))
            {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__compat_int_types );
            }

            if ( tmp_mvar_value_1 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_compat_int_types" );
                exception_tb = NULL;

                exception_lineno = 1236;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_isinstance_cls_1 = tmp_mvar_value_1;
            tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1236;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_assign_source_1;
                CHECK_OBJECT( par_arg );
                tmp_assign_source_1 = par_arg;
                assert( var_prefixlen == NULL );
                Py_INCREF( tmp_assign_source_1 );
                var_prefixlen = tmp_assign_source_1;
            }
            goto branch_end_2;
            branch_no_2:;
            // Tried code:
            {
                PyObject *tmp_assign_source_2;
                PyObject *tmp_called_instance_1;
                PyObject *tmp_args_element_name_1;
                CHECK_OBJECT( par_cls );
                tmp_called_instance_1 = par_cls;
                CHECK_OBJECT( par_arg );
                tmp_args_element_name_1 = par_arg;
                frame_f6ab1da534820a295432dc985ea5c721->m_frame.f_lineno = 1241;
                {
                    PyObject *call_args[] = { tmp_args_element_name_1 };
                    tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain__prefix_from_prefix_string, call_args );
                }

                if ( tmp_assign_source_2 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1241;
                    type_description_1 = "oooo";
                    goto try_except_handler_2;
                }
                assert( var_prefixlen == NULL );
                var_prefixlen = tmp_assign_source_2;
            }
            goto try_end_1;
            // Exception handler code:
            try_except_handler_2:;
            exception_keeper_type_1 = exception_type;
            exception_keeper_value_1 = exception_value;
            exception_keeper_tb_1 = exception_tb;
            exception_keeper_lineno_1 = exception_lineno;
            exception_type = NULL;
            exception_value = NULL;
            exception_tb = NULL;
            exception_lineno = 0;

            // Preserve existing published exception.
            PRESERVE_FRAME_EXCEPTION( frame_f6ab1da534820a295432dc985ea5c721 );
            if ( exception_keeper_tb_1 == NULL )
            {
                exception_keeper_tb_1 = MAKE_TRACEBACK( frame_f6ab1da534820a295432dc985ea5c721, exception_keeper_lineno_1 );
            }
            else if ( exception_keeper_lineno_1 != 0 )
            {
                exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_f6ab1da534820a295432dc985ea5c721, exception_keeper_lineno_1 );
            }

            NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
            PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
            {
                nuitka_bool tmp_condition_result_3;
                PyObject *tmp_compexpr_left_2;
                PyObject *tmp_compexpr_right_2;
                PyObject *tmp_mvar_value_2;
                tmp_compexpr_left_2 = EXC_TYPE(PyThreadState_GET());
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_NetmaskValueError );

                if (unlikely( tmp_mvar_value_2 == NULL ))
                {
                    tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NetmaskValueError );
                }

                if ( tmp_mvar_value_2 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "NetmaskValueError" );
                    exception_tb = NULL;

                    exception_lineno = 1242;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }

                tmp_compexpr_right_2 = tmp_mvar_value_2;
                tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_2, tmp_compexpr_right_2 );
                if ( tmp_res == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1242;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
                {
                    goto branch_yes_3;
                }
                else
                {
                    goto branch_no_3;
                }
                branch_yes_3:;
                {
                    PyObject *tmp_assign_source_3;
                    PyObject *tmp_called_instance_2;
                    PyObject *tmp_args_element_name_2;
                    CHECK_OBJECT( par_cls );
                    tmp_called_instance_2 = par_cls;
                    CHECK_OBJECT( par_arg );
                    tmp_args_element_name_2 = par_arg;
                    frame_f6ab1da534820a295432dc985ea5c721->m_frame.f_lineno = 1245;
                    {
                        PyObject *call_args[] = { tmp_args_element_name_2 };
                        tmp_assign_source_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain__prefix_from_ip_string, call_args );
                    }

                    if ( tmp_assign_source_3 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 1245;
                        type_description_1 = "oooo";
                        goto frame_exception_exit_1;
                    }
                    assert( var_prefixlen == NULL );
                    var_prefixlen = tmp_assign_source_3;
                }
                goto branch_end_3;
                branch_no_3:;
                tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                if (unlikely( tmp_result == false ))
                {
                    exception_lineno = 1239;
                }

                if (exception_tb && exception_tb->tb_frame == &frame_f6ab1da534820a295432dc985ea5c721->m_frame) frame_f6ab1da534820a295432dc985ea5c721->m_frame.f_lineno = exception_tb->tb_lineno;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
                branch_end_3:;
            }
            goto try_end_1;
            // exception handler codes exits in all cases
            NUITKA_CANNOT_GET_HERE( ipaddress$$$function_81__make_netmask );
            return NULL;
            // End of try:
            try_end_1:;
            branch_end_2:;
        }
        {
            PyObject *tmp_assign_source_4;
            PyObject *tmp_called_name_1;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_args_element_name_3;
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_2;
            PyObject *tmp_args_element_name_4;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Address );

            if (unlikely( tmp_mvar_value_3 == NULL ))
            {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Address );
            }

            if ( tmp_mvar_value_3 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv4Address" );
                exception_tb = NULL;

                exception_lineno = 1246;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_1 = tmp_mvar_value_3;
            CHECK_OBJECT( par_cls );
            tmp_source_name_2 = par_cls;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ip_int_from_prefix );
            if ( tmp_called_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1246;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            if ( var_prefixlen == NULL )
            {
                Py_DECREF( tmp_called_name_2 );
                exception_type = PyExc_UnboundLocalError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "prefixlen" );
                exception_tb = NULL;

                exception_lineno = 1246;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_args_element_name_4 = var_prefixlen;
            frame_f6ab1da534820a295432dc985ea5c721->m_frame.f_lineno = 1246;
            {
                PyObject *call_args[] = { tmp_args_element_name_4 };
                tmp_args_element_name_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
            }

            Py_DECREF( tmp_called_name_2 );
            if ( tmp_args_element_name_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1246;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            frame_f6ab1da534820a295432dc985ea5c721->m_frame.f_lineno = 1246;
            {
                PyObject *call_args[] = { tmp_args_element_name_3 };
                tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
            }

            Py_DECREF( tmp_args_element_name_3 );
            if ( tmp_assign_source_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1246;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            assert( var_netmask == NULL );
            var_netmask = tmp_assign_source_4;
        }
        {
            PyObject *tmp_ass_subvalue_1;
            PyObject *tmp_tuple_element_1;
            PyObject *tmp_ass_subscribed_1;
            PyObject *tmp_source_name_3;
            PyObject *tmp_ass_subscript_1;
            CHECK_OBJECT( var_netmask );
            tmp_tuple_element_1 = var_netmask;
            tmp_ass_subvalue_1 = PyTuple_New( 2 );
            Py_INCREF( tmp_tuple_element_1 );
            PyTuple_SET_ITEM( tmp_ass_subvalue_1, 0, tmp_tuple_element_1 );
            if ( var_prefixlen == NULL )
            {
                Py_DECREF( tmp_ass_subvalue_1 );
                exception_type = PyExc_UnboundLocalError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "prefixlen" );
                exception_tb = NULL;

                exception_lineno = 1247;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_tuple_element_1 = var_prefixlen;
            Py_INCREF( tmp_tuple_element_1 );
            PyTuple_SET_ITEM( tmp_ass_subvalue_1, 1, tmp_tuple_element_1 );
            CHECK_OBJECT( par_cls );
            tmp_source_name_3 = par_cls;
            tmp_ass_subscribed_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__netmask_cache );
            if ( tmp_ass_subscribed_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_ass_subvalue_1 );

                exception_lineno = 1247;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_arg );
            tmp_ass_subscript_1 = par_arg;
            tmp_result = SET_SUBSCRIPT( tmp_ass_subscribed_1, tmp_ass_subscript_1, tmp_ass_subvalue_1 );
            Py_DECREF( tmp_ass_subscribed_1 );
            Py_DECREF( tmp_ass_subvalue_1 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1247;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_source_name_4;
        PyObject *tmp_subscript_name_1;
        CHECK_OBJECT( par_cls );
        tmp_source_name_4 = par_cls;
        tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__netmask_cache );
        if ( tmp_subscribed_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1248;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_arg );
        tmp_subscript_name_1 = par_arg;
        tmp_return_value = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
        Py_DECREF( tmp_subscribed_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1248;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 1
    RESTORE_FRAME_EXCEPTION( frame_f6ab1da534820a295432dc985ea5c721 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_f6ab1da534820a295432dc985ea5c721 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_f6ab1da534820a295432dc985ea5c721 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f6ab1da534820a295432dc985ea5c721, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f6ab1da534820a295432dc985ea5c721->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f6ab1da534820a295432dc985ea5c721, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f6ab1da534820a295432dc985ea5c721,
        type_description_1,
        par_cls,
        par_arg,
        var_prefixlen,
        var_netmask
    );


    // Release cached frame.
    if ( frame_f6ab1da534820a295432dc985ea5c721 == cache_frame_f6ab1da534820a295432dc985ea5c721 )
    {
        Py_DECREF( frame_f6ab1da534820a295432dc985ea5c721 );
    }
    cache_frame_f6ab1da534820a295432dc985ea5c721 = NULL;

    assertFrameObject( frame_f6ab1da534820a295432dc985ea5c721 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_81__make_netmask );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_prefixlen );
    var_prefixlen = NULL;

    Py_XDECREF( var_netmask );
    var_netmask = NULL;

    CHECK_OBJECT( (PyObject *)par_arg );
    Py_DECREF( par_arg );
    par_arg = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_prefixlen );
    var_prefixlen = NULL;

    Py_XDECREF( var_netmask );
    var_netmask = NULL;

    CHECK_OBJECT( (PyObject *)par_arg );
    Py_DECREF( par_arg );
    par_arg = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_81__make_netmask );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_82__ip_int_from_string( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_ip_str = python_pars[ 1 ];
    PyObject *var_exc = NULL;
    PyObject *var_octets = NULL;
    struct Nuitka_FrameObject *frame_aef582dae391f517bebe2068da97cde0;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    int tmp_res;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_aef582dae391f517bebe2068da97cde0 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_aef582dae391f517bebe2068da97cde0, codeobj_aef582dae391f517bebe2068da97cde0, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_aef582dae391f517bebe2068da97cde0 = cache_frame_aef582dae391f517bebe2068da97cde0;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_aef582dae391f517bebe2068da97cde0 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_aef582dae391f517bebe2068da97cde0 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        CHECK_OBJECT( par_ip_str );
        tmp_operand_name_1 = par_ip_str;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1264;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_called_name_1;
            PyObject *tmp_mvar_value_1;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_AddressValueError );

            if (unlikely( tmp_mvar_value_1 == NULL ))
            {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AddressValueError );
            }

            if ( tmp_mvar_value_1 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "AddressValueError" );
                exception_tb = NULL;

                exception_lineno = 1265;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_1 = tmp_mvar_value_1;
            frame_aef582dae391f517bebe2068da97cde0->m_frame.f_lineno = 1265;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, &PyTuple_GET_ITEM( const_tuple_unicode_digest_6bc44a3bd13949ad6cfa5e1484201995_tuple, 0 ) );

            if ( tmp_raise_type_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1265;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            exception_type = tmp_raise_type_1;
            exception_lineno = 1265;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        CHECK_OBJECT( par_ip_str );
        tmp_called_instance_1 = par_ip_str;
        frame_aef582dae391f517bebe2068da97cde0->m_frame.f_lineno = 1267;
        tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_split, &PyTuple_GET_ITEM( const_tuple_unicode_dot_tuple, 0 ) );

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1267;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_octets == NULL );
        var_octets = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_len_arg_1;
        CHECK_OBJECT( var_octets );
        tmp_len_arg_1 = var_octets;
        tmp_compexpr_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1268;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = const_int_pos_4;
        tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_INT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        assert( !(tmp_res == -1) );
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_called_name_2;
            PyObject *tmp_mvar_value_2;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_AddressValueError );

            if (unlikely( tmp_mvar_value_2 == NULL ))
            {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AddressValueError );
            }

            if ( tmp_mvar_value_2 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "AddressValueError" );
                exception_tb = NULL;

                exception_lineno = 1269;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_2 = tmp_mvar_value_2;
            tmp_left_name_1 = const_unicode_digest_c50e4b7ca59e04bf8bf40c8c074f23f7;
            CHECK_OBJECT( par_ip_str );
            tmp_right_name_1 = par_ip_str;
            tmp_args_element_name_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
            if ( tmp_args_element_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1269;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            frame_aef582dae391f517bebe2068da97cde0->m_frame.f_lineno = 1269;
            {
                PyObject *call_args[] = { tmp_args_element_name_1 };
                tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
            }

            Py_DECREF( tmp_args_element_name_1 );
            if ( tmp_raise_type_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1269;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            exception_type = tmp_raise_type_2;
            exception_lineno = 1269;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    // Tried code:
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_called_name_4;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_int_from_byte_vals );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__compat_int_from_byte_vals );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_compat_int_from_byte_vals" );
            exception_tb = NULL;

            exception_lineno = 1272;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }

        tmp_called_name_3 = tmp_mvar_value_3;
        tmp_called_name_4 = LOOKUP_BUILTIN( const_str_plain_map );
        assert( tmp_called_name_4 != NULL );
        CHECK_OBJECT( par_cls );
        tmp_source_name_1 = par_cls;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__parse_octet );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1273;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( var_octets );
        tmp_args_element_name_4 = var_octets;
        frame_aef582dae391f517bebe2068da97cde0->m_frame.f_lineno = 1273;
        {
            PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_args_element_name_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
        }

        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1273;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        tmp_args_element_name_5 = const_unicode_plain_big;
        frame_aef582dae391f517bebe2068da97cde0->m_frame.f_lineno = 1272;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_5 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1272;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        goto frame_return_exit_1;
    }
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_82__ip_int_from_string );
    return NULL;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_aef582dae391f517bebe2068da97cde0 );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_aef582dae391f517bebe2068da97cde0, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_aef582dae391f517bebe2068da97cde0, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        tmp_compexpr_left_2 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_2 = PyExc_ValueError;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1274;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_assign_source_2;
            tmp_assign_source_2 = EXC_VALUE(PyThreadState_GET());
            assert( var_exc == NULL );
            Py_INCREF( tmp_assign_source_2 );
            var_exc = tmp_assign_source_2;
        }
        {
            PyObject *tmp_raise_type_3;
            PyObject *tmp_called_name_5;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_args_element_name_6;
            PyObject *tmp_left_name_2;
            PyObject *tmp_right_name_2;
            PyObject *tmp_tuple_element_1;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_AddressValueError );

            if (unlikely( tmp_mvar_value_4 == NULL ))
            {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AddressValueError );
            }

            if ( tmp_mvar_value_4 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "AddressValueError" );
                exception_tb = NULL;

                exception_lineno = 1275;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_5 = tmp_mvar_value_4;
            tmp_left_name_2 = const_unicode_digest_3d11cbcbf80fa8d2b7c658c556c6918d;
            CHECK_OBJECT( var_exc );
            tmp_tuple_element_1 = var_exc;
            tmp_right_name_2 = PyTuple_New( 2 );
            Py_INCREF( tmp_tuple_element_1 );
            PyTuple_SET_ITEM( tmp_right_name_2, 0, tmp_tuple_element_1 );
            CHECK_OBJECT( par_ip_str );
            tmp_tuple_element_1 = par_ip_str;
            Py_INCREF( tmp_tuple_element_1 );
            PyTuple_SET_ITEM( tmp_right_name_2, 1, tmp_tuple_element_1 );
            tmp_args_element_name_6 = BINARY_OPERATION_REMAINDER( tmp_left_name_2, tmp_right_name_2 );
            Py_DECREF( tmp_right_name_2 );
            if ( tmp_args_element_name_6 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1275;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            frame_aef582dae391f517bebe2068da97cde0->m_frame.f_lineno = 1275;
            {
                PyObject *call_args[] = { tmp_args_element_name_6 };
                tmp_raise_type_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
            }

            Py_DECREF( tmp_args_element_name_6 );
            if ( tmp_raise_type_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1275;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            exception_type = tmp_raise_type_3;
            exception_lineno = 1275;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        goto branch_end_3;
        branch_no_3:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 1271;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_aef582dae391f517bebe2068da97cde0->m_frame) frame_aef582dae391f517bebe2068da97cde0->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
        branch_end_3:;
    }
    // End of try:

#if 1
    RESTORE_FRAME_EXCEPTION( frame_aef582dae391f517bebe2068da97cde0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_aef582dae391f517bebe2068da97cde0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_aef582dae391f517bebe2068da97cde0 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_aef582dae391f517bebe2068da97cde0, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_aef582dae391f517bebe2068da97cde0->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_aef582dae391f517bebe2068da97cde0, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_aef582dae391f517bebe2068da97cde0,
        type_description_1,
        par_cls,
        par_ip_str,
        var_exc,
        var_octets
    );


    // Release cached frame.
    if ( frame_aef582dae391f517bebe2068da97cde0 == cache_frame_aef582dae391f517bebe2068da97cde0 )
    {
        Py_DECREF( frame_aef582dae391f517bebe2068da97cde0 );
    }
    cache_frame_aef582dae391f517bebe2068da97cde0 = NULL;

    assertFrameObject( frame_aef582dae391f517bebe2068da97cde0 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_82__ip_int_from_string );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_ip_str );
    Py_DECREF( par_ip_str );
    par_ip_str = NULL;

    CHECK_OBJECT( (PyObject *)var_octets );
    Py_DECREF( var_octets );
    var_octets = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_ip_str );
    Py_DECREF( par_ip_str );
    par_ip_str = NULL;

    Py_XDECREF( var_exc );
    var_exc = NULL;

    Py_XDECREF( var_octets );
    var_octets = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_82__ip_int_from_string );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_83__parse_octet( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_octet_str = python_pars[ 1 ];
    PyObject *var_octet_int = NULL;
    struct Nuitka_FrameObject *frame_779fd7a0aab1f3b76d0239378711294e;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    int tmp_res;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_779fd7a0aab1f3b76d0239378711294e = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_779fd7a0aab1f3b76d0239378711294e, codeobj_779fd7a0aab1f3b76d0239378711294e, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_779fd7a0aab1f3b76d0239378711294e = cache_frame_779fd7a0aab1f3b76d0239378711294e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_779fd7a0aab1f3b76d0239378711294e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_779fd7a0aab1f3b76d0239378711294e ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        CHECK_OBJECT( par_octet_str );
        tmp_operand_name_1 = par_octet_str;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1291;
            type_description_1 = "ooNo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_unicode_digest_e9ecc59b2023c50be0d8f9a9c8aa42f1;
            frame_779fd7a0aab1f3b76d0239378711294e->m_frame.f_lineno = 1292;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1292;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooNo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_2;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT( par_cls );
        tmp_source_name_1 = par_cls;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__DECIMAL_DIGITS );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1294;
            type_description_1 = "ooNo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_octet_str );
        tmp_args_element_name_1 = par_octet_str;
        frame_779fd7a0aab1f3b76d0239378711294e->m_frame.f_lineno = 1294;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_operand_name_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_issuperset, call_args );
        }

        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_operand_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1294;
            type_description_1 = "ooNo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        Py_DECREF( tmp_operand_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1294;
            type_description_1 = "ooNo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_make_exception_arg_2;
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            tmp_left_name_1 = const_unicode_digest_90bd5c6e55bae17fe8d70044d13f64fa;
            CHECK_OBJECT( par_octet_str );
            tmp_right_name_1 = par_octet_str;
            tmp_make_exception_arg_2 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
            if ( tmp_make_exception_arg_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1296;
                type_description_1 = "ooNo";
                goto frame_exception_exit_1;
            }
            frame_779fd7a0aab1f3b76d0239378711294e->m_frame.f_lineno = 1296;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_2 };
                tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            Py_DECREF( tmp_make_exception_arg_2 );
            assert( !(tmp_raise_type_2 == NULL) );
            exception_type = tmp_raise_type_2;
            exception_lineno = 1296;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooNo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_len_arg_1;
        CHECK_OBJECT( par_octet_str );
        tmp_len_arg_1 = par_octet_str;
        tmp_compexpr_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1299;
            type_description_1 = "ooNo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = const_int_pos_3;
        tmp_res = RICH_COMPARE_BOOL_GT_OBJECT_INT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        assert( !(tmp_res == -1) );
        tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_raise_type_3;
            PyObject *tmp_make_exception_arg_3;
            PyObject *tmp_left_name_2;
            PyObject *tmp_right_name_2;
            tmp_left_name_2 = const_unicode_digest_745ce1754600cbf1b6a077d5f3024b91;
            CHECK_OBJECT( par_octet_str );
            tmp_right_name_2 = par_octet_str;
            tmp_make_exception_arg_3 = BINARY_OPERATION_REMAINDER( tmp_left_name_2, tmp_right_name_2 );
            if ( tmp_make_exception_arg_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1301;
                type_description_1 = "ooNo";
                goto frame_exception_exit_1;
            }
            frame_779fd7a0aab1f3b76d0239378711294e->m_frame.f_lineno = 1301;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_3 };
                tmp_raise_type_3 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            Py_DECREF( tmp_make_exception_arg_3 );
            assert( !(tmp_raise_type_3 == NULL) );
            exception_type = tmp_raise_type_3;
            exception_lineno = 1301;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooNo";
            goto frame_exception_exit_1;
        }
        branch_no_3:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_value_name_1;
        PyObject *tmp_base_name_1;
        CHECK_OBJECT( par_octet_str );
        tmp_value_name_1 = par_octet_str;
        tmp_base_name_1 = const_int_pos_10;
        tmp_assign_source_1 = TO_INT2( tmp_value_name_1, tmp_base_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1303;
            type_description_1 = "ooNo";
            goto frame_exception_exit_1;
        }
        assert( var_octet_int == NULL );
        var_octet_int = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_4;
        int tmp_and_left_truth_1;
        nuitka_bool tmp_and_left_value_1;
        nuitka_bool tmp_and_right_value_1;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_subscript_name_1;
        CHECK_OBJECT( var_octet_int );
        tmp_compexpr_left_2 = var_octet_int;
        tmp_compexpr_right_2 = const_int_pos_7;
        tmp_res = RICH_COMPARE_BOOL_GT_OBJECT_INT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        assert( !(tmp_res == -1) );
        tmp_and_left_value_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_1 = tmp_and_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_and_left_truth_1 == 1 )
        {
            goto and_right_1;
        }
        else
        {
            goto and_left_1;
        }
        and_right_1:;
        CHECK_OBJECT( par_octet_str );
        tmp_subscribed_name_1 = par_octet_str;
        tmp_subscript_name_1 = const_int_0;
        tmp_compexpr_left_3 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_1, tmp_subscript_name_1, 0 );
        if ( tmp_compexpr_left_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1307;
            type_description_1 = "ooNo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_3 = const_unicode_plain_0;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
        Py_DECREF( tmp_compexpr_left_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1307;
            type_description_1 = "ooNo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_condition_result_4 = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_condition_result_4 = tmp_and_left_value_1;
        and_end_1:;
        if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_4;
        }
        else
        {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_raise_type_4;
            PyObject *tmp_make_exception_arg_4;
            PyObject *tmp_left_name_3;
            PyObject *tmp_right_name_3;
            tmp_left_name_3 = const_unicode_digest_fd94faa8eb259b55b9c302cc8ca594ce;
            CHECK_OBJECT( par_octet_str );
            tmp_right_name_3 = par_octet_str;
            tmp_make_exception_arg_4 = BINARY_OPERATION_REMAINDER( tmp_left_name_3, tmp_right_name_3 );
            if ( tmp_make_exception_arg_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1309;
                type_description_1 = "ooNo";
                goto frame_exception_exit_1;
            }
            frame_779fd7a0aab1f3b76d0239378711294e->m_frame.f_lineno = 1309;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_4 };
                tmp_raise_type_4 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            Py_DECREF( tmp_make_exception_arg_4 );
            assert( !(tmp_raise_type_4 == NULL) );
            exception_type = tmp_raise_type_4;
            exception_lineno = 1309;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooNo";
            goto frame_exception_exit_1;
        }
        branch_no_4:;
    }
    {
        nuitka_bool tmp_condition_result_5;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        CHECK_OBJECT( var_octet_int );
        tmp_compexpr_left_4 = var_octet_int;
        tmp_compexpr_right_4 = const_int_pos_255;
        tmp_res = RICH_COMPARE_BOOL_GT_OBJECT_INT( tmp_compexpr_left_4, tmp_compexpr_right_4 );
        assert( !(tmp_res == -1) );
        tmp_condition_result_5 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_5;
        }
        else
        {
            goto branch_no_5;
        }
        branch_yes_5:;
        {
            PyObject *tmp_raise_type_5;
            PyObject *tmp_make_exception_arg_5;
            PyObject *tmp_left_name_4;
            PyObject *tmp_right_name_4;
            tmp_left_name_4 = const_unicode_digest_c9ae6211eac82f0120b847f4c6f27bb3;
            CHECK_OBJECT( var_octet_int );
            tmp_right_name_4 = var_octet_int;
            tmp_make_exception_arg_5 = BINARY_OPERATION_REMAINDER( tmp_left_name_4, tmp_right_name_4 );
            if ( tmp_make_exception_arg_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1311;
                type_description_1 = "ooNo";
                goto frame_exception_exit_1;
            }
            frame_779fd7a0aab1f3b76d0239378711294e->m_frame.f_lineno = 1311;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_5 };
                tmp_raise_type_5 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            Py_DECREF( tmp_make_exception_arg_5 );
            assert( !(tmp_raise_type_5 == NULL) );
            exception_type = tmp_raise_type_5;
            exception_lineno = 1311;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooNo";
            goto frame_exception_exit_1;
        }
        branch_no_5:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_779fd7a0aab1f3b76d0239378711294e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_779fd7a0aab1f3b76d0239378711294e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_779fd7a0aab1f3b76d0239378711294e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_779fd7a0aab1f3b76d0239378711294e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_779fd7a0aab1f3b76d0239378711294e, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_779fd7a0aab1f3b76d0239378711294e,
        type_description_1,
        par_cls,
        par_octet_str,
        NULL,
        var_octet_int
    );


    // Release cached frame.
    if ( frame_779fd7a0aab1f3b76d0239378711294e == cache_frame_779fd7a0aab1f3b76d0239378711294e )
    {
        Py_DECREF( frame_779fd7a0aab1f3b76d0239378711294e );
    }
    cache_frame_779fd7a0aab1f3b76d0239378711294e = NULL;

    assertFrameObject( frame_779fd7a0aab1f3b76d0239378711294e );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_octet_int );
    tmp_return_value = var_octet_int;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_83__parse_octet );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_octet_str );
    Py_DECREF( par_octet_str );
    par_octet_str = NULL;

    CHECK_OBJECT( (PyObject *)var_octet_int );
    Py_DECREF( var_octet_int );
    var_octet_int = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_octet_str );
    Py_DECREF( par_octet_str );
    par_octet_str = NULL;

    Py_XDECREF( var_octet_int );
    var_octet_int = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_83__parse_octet );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_84__string_from_ip_int( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_ip_int = python_pars[ 1 ];
    PyObject *tmp_genexpr_1__$0 = NULL;
    struct Nuitka_FrameObject *frame_965a59153c45ade1eb4421df6ac0207d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_965a59153c45ade1eb4421df6ac0207d = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_965a59153c45ade1eb4421df6ac0207d, codeobj_965a59153c45ade1eb4421df6ac0207d, module_ipaddress, sizeof(void *)+sizeof(void *) );
    frame_965a59153c45ade1eb4421df6ac0207d = cache_frame_965a59153c45ade1eb4421df6ac0207d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_965a59153c45ade1eb4421df6ac0207d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_965a59153c45ade1eb4421df6ac0207d ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        tmp_source_name_1 = const_unicode_dot;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_join );
        assert( !(tmp_called_name_1 == NULL) );
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_iter_arg_1;
            PyObject *tmp_called_name_2;
            PyObject *tmp_mvar_value_1;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_args_element_name_3;
            PyObject *tmp_args_element_name_4;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_to_bytes );

            if (unlikely( tmp_mvar_value_1 == NULL ))
            {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__compat_to_bytes );
            }

            if ( tmp_mvar_value_1 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_compat_to_bytes" );
                exception_tb = NULL;

                exception_lineno = 1328;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_2 = tmp_mvar_value_1;
            CHECK_OBJECT( par_ip_int );
            tmp_args_element_name_2 = par_ip_int;
            tmp_args_element_name_3 = const_int_pos_4;
            tmp_args_element_name_4 = const_unicode_plain_big;
            frame_965a59153c45ade1eb4421df6ac0207d->m_frame.f_lineno = 1328;
            {
                PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4 };
                tmp_iter_arg_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_2, call_args );
            }

            if ( tmp_iter_arg_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1328;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
            Py_DECREF( tmp_iter_arg_1 );
            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1325;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            assert( tmp_genexpr_1__$0 == NULL );
            tmp_genexpr_1__$0 = tmp_assign_source_1;
        }
        // Tried code:
        tmp_args_element_name_1 = ipaddress$$$function_84__string_from_ip_int$$$genexpr_1_genexpr_maker();

        ((struct Nuitka_GeneratorObject *)tmp_args_element_name_1)->m_closure[0] = PyCell_NEW0( tmp_genexpr_1__$0 );


        goto try_return_handler_2;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ipaddress$$$function_84__string_from_ip_int );
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
        Py_DECREF( tmp_genexpr_1__$0 );
        tmp_genexpr_1__$0 = NULL;

        goto outline_result_1;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
        Py_DECREF( tmp_genexpr_1__$0 );
        tmp_genexpr_1__$0 = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( ipaddress$$$function_84__string_from_ip_int );
        return NULL;
        outline_result_1:;
        frame_965a59153c45ade1eb4421df6ac0207d->m_frame.f_lineno = 1325;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1325;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_965a59153c45ade1eb4421df6ac0207d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_965a59153c45ade1eb4421df6ac0207d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_965a59153c45ade1eb4421df6ac0207d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_965a59153c45ade1eb4421df6ac0207d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_965a59153c45ade1eb4421df6ac0207d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_965a59153c45ade1eb4421df6ac0207d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_965a59153c45ade1eb4421df6ac0207d,
        type_description_1,
        par_cls,
        par_ip_int
    );


    // Release cached frame.
    if ( frame_965a59153c45ade1eb4421df6ac0207d == cache_frame_965a59153c45ade1eb4421df6ac0207d )
    {
        Py_DECREF( frame_965a59153c45ade1eb4421df6ac0207d );
    }
    cache_frame_965a59153c45ade1eb4421df6ac0207d = NULL;

    assertFrameObject( frame_965a59153c45ade1eb4421df6ac0207d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_84__string_from_ip_int );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_ip_int );
    Py_DECREF( par_ip_int );
    par_ip_int = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_ip_int );
    Py_DECREF( par_ip_int );
    par_ip_int = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_84__string_from_ip_int );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}



struct ipaddress$$$function_84__string_from_ip_int$$$genexpr_1_genexpr_locals {
    PyObject *var_b;
    PyObject *tmp_iter_value_0;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    int tmp_res;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
};

static PyObject *ipaddress$$$function_84__string_from_ip_int$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Heap access if used.
    struct ipaddress$$$function_84__string_from_ip_int$$$genexpr_1_genexpr_locals *generator_heap = (struct ipaddress$$$function_84__string_from_ip_int$$$genexpr_1_genexpr_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_b = NULL;
    generator_heap->tmp_iter_value_0 = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_m_frame, codeobj_d505756ffecce6e65ef4e3ecec46e18a, module_ipaddress, sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

#if PYTHON_VERSION < 370
        generator->m_frame->m_frame.f_exc_type = EXC_TYPE( thread_state );
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
        Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#else
        generator->m_exc_state.exc_type = EXC_TYPE( thread_state );
        if ( generator->m_exc_state.exc_type == Py_None ) generator->m_exc_state.exc_type = NULL;
        Py_XINCREF( generator->m_exc_state.exc_type );
        generator->m_exc_state.exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_value );
        generator->m_exc_state.exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_traceback );
#endif
    }

#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_1;
        CHECK_OBJECT( PyCell_GET( generator->m_closure[0] ) );
        tmp_next_source_1 = PyCell_GET( generator->m_closure[0] );
        tmp_assign_source_1 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
                generator_heap->type_description_1 = "No";
                generator_heap->exception_lineno = 1325;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_iter_value_0;
            generator_heap->tmp_iter_value_0 = tmp_assign_source_1;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT( generator_heap->tmp_iter_value_0 );
        tmp_assign_source_2 = generator_heap->tmp_iter_value_0;
        {
            PyObject *old = generator_heap->var_b;
            generator_heap->var_b = tmp_assign_source_2;
            Py_INCREF( generator_heap->var_b );
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_expression_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_subscript_name_1;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_str );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__compat_str );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "global name '%s' is not defined", "_compat_str" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 1325;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( generator_heap->var_b );
        tmp_isinstance_inst_1 = generator_heap->var_b;
        tmp_isinstance_cls_1 = (PyObject *)&PyString_Type;
        generator_heap->tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( generator_heap->tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 1326;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_condition_result_1 = ( generator_heap->tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_1;
        }
        else
        {
            goto condexpr_false_1;
        }
        condexpr_true_1:;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_struct );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_struct );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "global name '%s' is not defined", "struct" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 1325;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }

        tmp_called_instance_1 = tmp_mvar_value_2;
        tmp_args_element_name_2 = const_str_digest_11a7e09c00a35df5b21f6600c68e78d8;
        CHECK_OBJECT( generator_heap->var_b );
        tmp_args_element_name_3 = generator_heap->var_b;
        generator->m_frame->m_frame.f_lineno = 1325;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_subscribed_name_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_unpack, call_args );
        }

        if ( tmp_subscribed_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 1325;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_subscript_name_1 = const_int_0;
        tmp_args_element_name_1 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_1, tmp_subscript_name_1, 0 );
        Py_DECREF( tmp_subscribed_name_1 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 1325;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        goto condexpr_end_1;
        condexpr_false_1:;
        CHECK_OBJECT( generator_heap->var_b );
        tmp_args_element_name_1 = generator_heap->var_b;
        Py_INCREF( tmp_args_element_name_1 );
        condexpr_end_1:;
        generator->m_frame->m_frame.f_lineno = 1325;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_expression_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_expression_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 1325;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        Nuitka_PreserveHeap( generator_heap->yield_tmps, &tmp_called_name_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), &tmp_args_element_name_1, sizeof(PyObject *), &tmp_condition_result_1, sizeof(nuitka_bool), &tmp_isinstance_inst_1, sizeof(PyObject *), &tmp_isinstance_cls_1, sizeof(PyObject *), &tmp_subscribed_name_1, sizeof(PyObject *), &tmp_called_instance_1, sizeof(PyObject *), &tmp_mvar_value_2, sizeof(PyObject *), &tmp_args_element_name_2, sizeof(PyObject *), &tmp_args_element_name_3, sizeof(PyObject *), &tmp_subscript_name_1, sizeof(PyObject *), NULL );
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        Nuitka_RestoreHeap( generator_heap->yield_tmps, &tmp_called_name_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), &tmp_args_element_name_1, sizeof(PyObject *), &tmp_condition_result_1, sizeof(nuitka_bool), &tmp_isinstance_inst_1, sizeof(PyObject *), &tmp_isinstance_cls_1, sizeof(PyObject *), &tmp_subscribed_name_1, sizeof(PyObject *), &tmp_called_instance_1, sizeof(PyObject *), &tmp_mvar_value_2, sizeof(PyObject *), &tmp_args_element_name_2, sizeof(PyObject *), &tmp_args_element_name_3, sizeof(PyObject *), &tmp_subscript_name_1, sizeof(PyObject *), NULL );
        if ( yield_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 1325;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


        generator_heap->exception_lineno = 1325;
        generator_heap->type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->tmp_iter_value_0 );
    generator_heap->tmp_iter_value_0 = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( generator_heap->exception_type ) )
    {
        if ( generator_heap->exception_tb == NULL )
        {
            generator_heap->exception_tb = MAKE_TRACEBACK( generator->m_frame, generator_heap->exception_lineno );
        }
        else if ( generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            generator_heap->exception_tb = ADD_TRACEBACK( generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            NULL,
            generator_heap->var_b
        );


        // Release cached frame.
        if ( generator->m_frame == cache_m_frame )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_m_frame = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->var_b );
    generator_heap->var_b = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:
    try_end_2:;
    Py_XDECREF( generator_heap->tmp_iter_value_0 );
    generator_heap->tmp_iter_value_0 = NULL;

    Py_XDECREF( generator_heap->var_b );
    generator_heap->var_b = NULL;



    return NULL;

    function_exception_exit:
    assert( generator_heap->exception_type );
    RESTORE_ERROR_OCCURRED( generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb );

    return NULL;

}

static PyObject *ipaddress$$$function_84__string_from_ip_int$$$genexpr_1_genexpr_maker( void )
{
    return Nuitka_Generator_New(
        ipaddress$$$function_84__string_from_ip_int$$$genexpr_1_genexpr_context,
        module_ipaddress,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_d505756ffecce6e65ef4e3ecec46e18a,
        1,
        sizeof(struct ipaddress$$$function_84__string_from_ip_int$$$genexpr_1_genexpr_locals)
    );
}


static PyObject *impl_ipaddress$$$function_85__is_hostmask( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_ip_str = python_pars[ 1 ];
    PyObject *var_parts = NULL;
    PyObject *var_bits = NULL;
    PyObject *var_x = NULL;
    PyObject *tmp_list_contraction_1__$0 = NULL;
    PyObject *tmp_list_contraction_1__contraction_result = NULL;
    PyObject *tmp_list_contraction_1__iter_value_0 = NULL;
    struct Nuitka_FrameObject *frame_0acab394733e19c6ca20d33f8286a543;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_return_value = NULL;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_0acab394733e19c6ca20d33f8286a543 = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0acab394733e19c6ca20d33f8286a543, codeobj_0acab394733e19c6ca20d33f8286a543, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_0acab394733e19c6ca20d33f8286a543 = cache_frame_0acab394733e19c6ca20d33f8286a543;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0acab394733e19c6ca20d33f8286a543 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0acab394733e19c6ca20d33f8286a543 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        CHECK_OBJECT( par_ip_str );
        tmp_called_instance_1 = par_ip_str;
        frame_0acab394733e19c6ca20d33f8286a543->m_frame.f_lineno = 1340;
        tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_split, &PyTuple_GET_ITEM( const_tuple_unicode_dot_tuple, 0 ) );

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1340;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( var_bits == NULL );
        var_bits = tmp_assign_source_1;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_2;
        // Tried code:
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_iter_arg_1;
            PyObject *tmp_called_name_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            tmp_called_name_1 = LOOKUP_BUILTIN( const_str_plain_map );
            assert( tmp_called_name_1 != NULL );
            tmp_args_element_name_1 = (PyObject *)&PyInt_Type;
            CHECK_OBJECT( var_bits );
            tmp_args_element_name_2 = var_bits;
            frame_0acab394733e19c6ca20d33f8286a543->m_frame.f_lineno = 1342;
            {
                PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
                tmp_iter_arg_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
            }

            if ( tmp_iter_arg_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1342;
                type_description_1 = "ooooo";
                goto try_except_handler_3;
            }
            tmp_assign_source_3 = MAKE_ITERATOR( tmp_iter_arg_1 );
            Py_DECREF( tmp_iter_arg_1 );
            if ( tmp_assign_source_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1342;
                type_description_1 = "ooooo";
                goto try_except_handler_3;
            }
            assert( tmp_list_contraction_1__$0 == NULL );
            tmp_list_contraction_1__$0 = tmp_assign_source_3;
        }
        {
            PyObject *tmp_assign_source_4;
            tmp_assign_source_4 = PyList_New( 0 );
            assert( tmp_list_contraction_1__contraction_result == NULL );
            tmp_list_contraction_1__contraction_result = tmp_assign_source_4;
        }
        loop_start_1:;
        {
            PyObject *tmp_next_source_1;
            PyObject *tmp_assign_source_5;
            CHECK_OBJECT( tmp_list_contraction_1__$0 );
            tmp_next_source_1 = tmp_list_contraction_1__$0;
            tmp_assign_source_5 = ITERATOR_NEXT( tmp_next_source_1 );
            if ( tmp_assign_source_5 == NULL )
            {
                if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
                {

                    goto loop_end_1;
                }
                else
                {

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    type_description_1 = "ooooo";
                    exception_lineno = 1342;
                    goto try_except_handler_3;
                }
            }

            {
                PyObject *old = tmp_list_contraction_1__iter_value_0;
                tmp_list_contraction_1__iter_value_0 = tmp_assign_source_5;
                Py_XDECREF( old );
            }

        }
        {
            PyObject *tmp_assign_source_6;
            CHECK_OBJECT( tmp_list_contraction_1__iter_value_0 );
            tmp_assign_source_6 = tmp_list_contraction_1__iter_value_0;
            {
                PyObject *old = var_x;
                var_x = tmp_assign_source_6;
                Py_INCREF( var_x );
                Py_XDECREF( old );
            }

        }
        {
            nuitka_bool tmp_condition_result_1;
            PyObject *tmp_compexpr_left_1;
            PyObject *tmp_compexpr_right_1;
            PyObject *tmp_source_name_1;
            CHECK_OBJECT( var_x );
            tmp_compexpr_left_1 = var_x;
            CHECK_OBJECT( par_self );
            tmp_source_name_1 = par_self;
            tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__valid_mask_octets );
            if ( tmp_compexpr_right_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1342;
                type_description_1 = "ooooo";
                goto try_except_handler_3;
            }
            tmp_res = PySequence_Contains( tmp_compexpr_right_1, tmp_compexpr_left_1 );
            Py_DECREF( tmp_compexpr_right_1 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1342;
                type_description_1 = "ooooo";
                goto try_except_handler_3;
            }
            tmp_condition_result_1 = ( tmp_res == 1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_1;
            }
            else
            {
                goto branch_no_1;
            }
            branch_yes_1:;
            {
                PyObject *tmp_append_list_1;
                PyObject *tmp_append_value_1;
                CHECK_OBJECT( tmp_list_contraction_1__contraction_result );
                tmp_append_list_1 = tmp_list_contraction_1__contraction_result;
                CHECK_OBJECT( var_x );
                tmp_append_value_1 = var_x;
                assert( PyList_Check( tmp_append_list_1 ) );
                tmp_res = PyList_Append( tmp_append_list_1, tmp_append_value_1 );
                if ( tmp_res == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1342;
                    type_description_1 = "ooooo";
                    goto try_except_handler_3;
                }
            }
            branch_no_1:;
        }
        if ( CONSIDER_THREADING() == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1342;
            type_description_1 = "ooooo";
            goto try_except_handler_3;
        }
        goto loop_start_1;
        loop_end_1:;
        CHECK_OBJECT( tmp_list_contraction_1__contraction_result );
        tmp_assign_source_2 = tmp_list_contraction_1__contraction_result;
        Py_INCREF( tmp_assign_source_2 );
        goto try_return_handler_3;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ipaddress$$$function_85__is_hostmask );
        return NULL;
        // Return handler code:
        try_return_handler_3:;
        CHECK_OBJECT( (PyObject *)tmp_list_contraction_1__$0 );
        Py_DECREF( tmp_list_contraction_1__$0 );
        tmp_list_contraction_1__$0 = NULL;

        CHECK_OBJECT( (PyObject *)tmp_list_contraction_1__contraction_result );
        Py_DECREF( tmp_list_contraction_1__contraction_result );
        tmp_list_contraction_1__contraction_result = NULL;

        Py_XDECREF( tmp_list_contraction_1__iter_value_0 );
        tmp_list_contraction_1__iter_value_0 = NULL;

        goto outline_result_1;
        // Exception handler code:
        try_except_handler_3:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF( tmp_list_contraction_1__$0 );
        tmp_list_contraction_1__$0 = NULL;

        Py_XDECREF( tmp_list_contraction_1__contraction_result );
        tmp_list_contraction_1__contraction_result = NULL;

        Py_XDECREF( tmp_list_contraction_1__iter_value_0 );
        tmp_list_contraction_1__iter_value_0 = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto try_except_handler_2;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( ipaddress$$$function_85__is_hostmask );
        return NULL;
        outline_result_1:;
        assert( var_parts == NULL );
        var_parts = tmp_assign_source_2;
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_0acab394733e19c6ca20d33f8286a543 );
    if ( exception_keeper_tb_2 == NULL )
    {
        exception_keeper_tb_2 = MAKE_TRACEBACK( frame_0acab394733e19c6ca20d33f8286a543, exception_keeper_lineno_2 );
    }
    else if ( exception_keeper_lineno_2 != 0 )
    {
        exception_keeper_tb_2 = ADD_TRACEBACK( exception_keeper_tb_2, frame_0acab394733e19c6ca20d33f8286a543, exception_keeper_lineno_2 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_2, &exception_keeper_value_2, &exception_keeper_tb_2 );
    PUBLISH_EXCEPTION( &exception_keeper_type_2, &exception_keeper_value_2, &exception_keeper_tb_2 );
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        tmp_compexpr_left_2 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_2 = PyExc_ValueError;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1343;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        tmp_return_value = Py_False;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        goto branch_end_2;
        branch_no_2:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 1341;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_0acab394733e19c6ca20d33f8286a543->m_frame) frame_0acab394733e19c6ca20d33f8286a543->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
        branch_end_2:;
    }
    // End of try:
    try_end_1:;
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_len_arg_1;
        PyObject *tmp_len_arg_2;
        CHECK_OBJECT( var_parts );
        tmp_len_arg_1 = var_parts;
        tmp_compexpr_left_3 = BUILTIN_LEN( tmp_len_arg_1 );
        if ( tmp_compexpr_left_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1345;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_bits );
        tmp_len_arg_2 = var_bits;
        tmp_compexpr_right_3 = BUILTIN_LEN( tmp_len_arg_2 );
        if ( tmp_compexpr_right_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_3 );

            exception_lineno = 1345;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
        Py_DECREF( tmp_compexpr_left_3 );
        Py_DECREF( tmp_compexpr_right_3 );
        assert( !(tmp_res == -1) );
        tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        tmp_return_value = Py_False;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_3:;
    }
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_subscript_name_1;
        PyObject *tmp_subscribed_name_2;
        PyObject *tmp_subscript_name_2;
        CHECK_OBJECT( var_parts );
        tmp_subscribed_name_1 = var_parts;
        tmp_subscript_name_1 = const_int_0;
        tmp_compexpr_left_4 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_1, tmp_subscript_name_1, 0 );
        if ( tmp_compexpr_left_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1347;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_parts );
        tmp_subscribed_name_2 = var_parts;
        tmp_subscript_name_2 = const_int_neg_1;
        tmp_compexpr_right_4 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_2, tmp_subscript_name_2, -1 );
        if ( tmp_compexpr_right_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_4 );

            exception_lineno = 1347;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_LT_OBJECT_OBJECT( tmp_compexpr_left_4, tmp_compexpr_right_4 );
        Py_DECREF( tmp_compexpr_left_4 );
        Py_DECREF( tmp_compexpr_right_4 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1347;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_4 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_4;
        }
        else
        {
            goto branch_no_4;
        }
        branch_yes_4:;
        tmp_return_value = Py_True;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_4:;
    }

#if 1
    RESTORE_FRAME_EXCEPTION( frame_0acab394733e19c6ca20d33f8286a543 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_0acab394733e19c6ca20d33f8286a543 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_0acab394733e19c6ca20d33f8286a543 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0acab394733e19c6ca20d33f8286a543, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0acab394733e19c6ca20d33f8286a543->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0acab394733e19c6ca20d33f8286a543, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0acab394733e19c6ca20d33f8286a543,
        type_description_1,
        par_self,
        par_ip_str,
        var_parts,
        var_bits,
        var_x
    );


    // Release cached frame.
    if ( frame_0acab394733e19c6ca20d33f8286a543 == cache_frame_0acab394733e19c6ca20d33f8286a543 )
    {
        Py_DECREF( frame_0acab394733e19c6ca20d33f8286a543 );
    }
    cache_frame_0acab394733e19c6ca20d33f8286a543 = NULL;

    assertFrameObject( frame_0acab394733e19c6ca20d33f8286a543 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_False;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_85__is_hostmask );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_ip_str );
    Py_DECREF( par_ip_str );
    par_ip_str = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_parts );
    var_parts = NULL;

    CHECK_OBJECT( (PyObject *)var_bits );
    Py_DECREF( var_bits );
    var_bits = NULL;

    Py_XDECREF( var_x );
    var_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_ip_str );
    Py_DECREF( par_ip_str );
    par_ip_str = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_parts );
    var_parts = NULL;

    Py_XDECREF( var_bits );
    var_bits = NULL;

    Py_XDECREF( var_x );
    var_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_85__is_hostmask );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_86__reverse_pointer( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_reverse_octets = NULL;
    struct Nuitka_FrameObject *frame_65bdf21fa4f2995d9cbc9d64b9242437;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_65bdf21fa4f2995d9cbc9d64b9242437 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_65bdf21fa4f2995d9cbc9d64b9242437, codeobj_65bdf21fa4f2995d9cbc9d64b9242437, module_ipaddress, sizeof(void *)+sizeof(void *) );
    frame_65bdf21fa4f2995d9cbc9d64b9242437 = cache_frame_65bdf21fa4f2995d9cbc9d64b9242437;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_65bdf21fa4f2995d9cbc9d64b9242437 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_65bdf21fa4f2995d9cbc9d64b9242437 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_subscript_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_str );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__compat_str );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_compat_str" );
            exception_tb = NULL;

            exception_lineno = 1357;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_self );
        tmp_args_element_name_1 = par_self;
        frame_65bdf21fa4f2995d9cbc9d64b9242437->m_frame.f_lineno = 1357;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_called_instance_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1357;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_65bdf21fa4f2995d9cbc9d64b9242437->m_frame.f_lineno = 1357;
        tmp_subscribed_name_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_split, &PyTuple_GET_ITEM( const_tuple_unicode_dot_tuple, 0 ) );

        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_subscribed_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1357;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_subscript_name_1 = const_slice_none_none_int_neg_1;
        tmp_assign_source_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
        Py_DECREF( tmp_subscribed_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1357;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert( var_reverse_octets == NULL );
        var_reverse_octets = tmp_assign_source_1;
    }
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_right_name_1;
        tmp_called_instance_2 = const_unicode_dot;
        CHECK_OBJECT( var_reverse_octets );
        tmp_args_element_name_2 = var_reverse_octets;
        frame_65bdf21fa4f2995d9cbc9d64b9242437->m_frame.f_lineno = 1358;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_left_name_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_join, call_args );
        }

        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1358;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_right_name_1 = const_unicode_digest_b3a9fa271b1ea846799383360611cf70;
        tmp_return_value = BINARY_OPERATION_ADD_OBJECT_UNICODE( tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_left_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1358;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_65bdf21fa4f2995d9cbc9d64b9242437 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_65bdf21fa4f2995d9cbc9d64b9242437 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_65bdf21fa4f2995d9cbc9d64b9242437 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_65bdf21fa4f2995d9cbc9d64b9242437, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_65bdf21fa4f2995d9cbc9d64b9242437->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_65bdf21fa4f2995d9cbc9d64b9242437, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_65bdf21fa4f2995d9cbc9d64b9242437,
        type_description_1,
        par_self,
        var_reverse_octets
    );


    // Release cached frame.
    if ( frame_65bdf21fa4f2995d9cbc9d64b9242437 == cache_frame_65bdf21fa4f2995d9cbc9d64b9242437 )
    {
        Py_DECREF( frame_65bdf21fa4f2995d9cbc9d64b9242437 );
    }
    cache_frame_65bdf21fa4f2995d9cbc9d64b9242437 = NULL;

    assertFrameObject( frame_65bdf21fa4f2995d9cbc9d64b9242437 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_86__reverse_pointer );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_reverse_octets );
    Py_DECREF( var_reverse_octets );
    var_reverse_octets = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_reverse_octets );
    var_reverse_octets = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_86__reverse_pointer );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_87_max_prefixlen( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_daa648eaba38dc7c040c161e27018597;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_daa648eaba38dc7c040c161e27018597 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_daa648eaba38dc7c040c161e27018597, codeobj_daa648eaba38dc7c040c161e27018597, module_ipaddress, sizeof(void *) );
    frame_daa648eaba38dc7c040c161e27018597 = cache_frame_daa648eaba38dc7c040c161e27018597;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_daa648eaba38dc7c040c161e27018597 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_daa648eaba38dc7c040c161e27018597 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__max_prefixlen );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1362;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_daa648eaba38dc7c040c161e27018597 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_daa648eaba38dc7c040c161e27018597 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_daa648eaba38dc7c040c161e27018597 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_daa648eaba38dc7c040c161e27018597, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_daa648eaba38dc7c040c161e27018597->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_daa648eaba38dc7c040c161e27018597, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_daa648eaba38dc7c040c161e27018597,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_daa648eaba38dc7c040c161e27018597 == cache_frame_daa648eaba38dc7c040c161e27018597 )
    {
        Py_DECREF( frame_daa648eaba38dc7c040c161e27018597 );
    }
    cache_frame_daa648eaba38dc7c040c161e27018597 = NULL;

    assertFrameObject( frame_daa648eaba38dc7c040c161e27018597 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_87_max_prefixlen );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_87_max_prefixlen );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_88_version( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_5beb6c0ecef6d2e4a9b887e5a1d874fe;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_5beb6c0ecef6d2e4a9b887e5a1d874fe = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5beb6c0ecef6d2e4a9b887e5a1d874fe, codeobj_5beb6c0ecef6d2e4a9b887e5a1d874fe, module_ipaddress, sizeof(void *) );
    frame_5beb6c0ecef6d2e4a9b887e5a1d874fe = cache_frame_5beb6c0ecef6d2e4a9b887e5a1d874fe;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5beb6c0ecef6d2e4a9b887e5a1d874fe );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5beb6c0ecef6d2e4a9b887e5a1d874fe ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__version );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1366;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5beb6c0ecef6d2e4a9b887e5a1d874fe );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_5beb6c0ecef6d2e4a9b887e5a1d874fe );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5beb6c0ecef6d2e4a9b887e5a1d874fe );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5beb6c0ecef6d2e4a9b887e5a1d874fe, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5beb6c0ecef6d2e4a9b887e5a1d874fe->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5beb6c0ecef6d2e4a9b887e5a1d874fe, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5beb6c0ecef6d2e4a9b887e5a1d874fe,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_5beb6c0ecef6d2e4a9b887e5a1d874fe == cache_frame_5beb6c0ecef6d2e4a9b887e5a1d874fe )
    {
        Py_DECREF( frame_5beb6c0ecef6d2e4a9b887e5a1d874fe );
    }
    cache_frame_5beb6c0ecef6d2e4a9b887e5a1d874fe = NULL;

    assertFrameObject( frame_5beb6c0ecef6d2e4a9b887e5a1d874fe );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_88_version );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_88_version );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_89___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_address = python_pars[ 1 ];
    PyObject *var_bvs = NULL;
    PyObject *var_addr_str = NULL;
    struct Nuitka_FrameObject *frame_ce30d14ef98e4b5fb4f1bbda17cb1b5e;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_ce30d14ef98e4b5fb4f1bbda17cb1b5e = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ce30d14ef98e4b5fb4f1bbda17cb1b5e, codeobj_ce30d14ef98e4b5fb4f1bbda17cb1b5e, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_ce30d14ef98e4b5fb4f1bbda17cb1b5e = cache_frame_ce30d14ef98e4b5fb4f1bbda17cb1b5e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ce30d14ef98e4b5fb4f1bbda17cb1b5e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ce30d14ef98e4b5fb4f1bbda17cb1b5e ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_address );
        tmp_isinstance_inst_1 = par_address;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_int_types );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__compat_int_types );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_compat_int_types" );
            exception_tb = NULL;

            exception_lineno = 1392;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1392;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_1;
            CHECK_OBJECT( par_self );
            tmp_called_instance_1 = par_self;
            CHECK_OBJECT( par_address );
            tmp_args_element_name_1 = par_address;
            frame_ce30d14ef98e4b5fb4f1bbda17cb1b5e->m_frame.f_lineno = 1393;
            {
                PyObject *call_args[] = { tmp_args_element_name_1 };
                tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain__check_int_address, call_args );
            }

            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1393;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        {
            PyObject *tmp_assattr_name_1;
            PyObject *tmp_assattr_target_1;
            CHECK_OBJECT( par_address );
            tmp_assattr_name_1 = par_address;
            CHECK_OBJECT( par_self );
            tmp_assattr_target_1 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__ip, tmp_assattr_name_1 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1394;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
        }
        tmp_return_value = Py_None;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_isinstance_inst_2;
        PyObject *tmp_isinstance_cls_2;
        CHECK_OBJECT( par_address );
        tmp_isinstance_inst_2 = par_address;
        tmp_isinstance_cls_2 = (PyObject *)&PyString_Type;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1398;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_called_instance_2;
            PyObject *tmp_call_result_2;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_args_element_name_3;
            CHECK_OBJECT( par_self );
            tmp_called_instance_2 = par_self;
            CHECK_OBJECT( par_address );
            tmp_args_element_name_2 = par_address;
            tmp_args_element_name_3 = const_int_pos_4;
            frame_ce30d14ef98e4b5fb4f1bbda17cb1b5e->m_frame.f_lineno = 1399;
            {
                PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
                tmp_call_result_2 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain__check_packed_address, call_args );
            }

            if ( tmp_call_result_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1399;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_2 );
        }
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_called_name_1;
            PyObject *tmp_mvar_value_2;
            PyObject *tmp_args_element_name_4;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_bytes_to_byte_vals );

            if (unlikely( tmp_mvar_value_2 == NULL ))
            {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__compat_bytes_to_byte_vals );
            }

            if ( tmp_mvar_value_2 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_compat_bytes_to_byte_vals" );
                exception_tb = NULL;

                exception_lineno = 1400;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_1 = tmp_mvar_value_2;
            CHECK_OBJECT( par_address );
            tmp_args_element_name_4 = par_address;
            frame_ce30d14ef98e4b5fb4f1bbda17cb1b5e->m_frame.f_lineno = 1400;
            {
                PyObject *call_args[] = { tmp_args_element_name_4 };
                tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
            }

            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1400;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            assert( var_bvs == NULL );
            var_bvs = tmp_assign_source_1;
        }
        {
            PyObject *tmp_assattr_name_2;
            PyObject *tmp_called_name_2;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_args_element_name_5;
            PyObject *tmp_args_element_name_6;
            PyObject *tmp_assattr_target_2;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_int_from_byte_vals );

            if (unlikely( tmp_mvar_value_3 == NULL ))
            {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__compat_int_from_byte_vals );
            }

            if ( tmp_mvar_value_3 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_compat_int_from_byte_vals" );
                exception_tb = NULL;

                exception_lineno = 1401;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_2 = tmp_mvar_value_3;
            CHECK_OBJECT( var_bvs );
            tmp_args_element_name_5 = var_bvs;
            tmp_args_element_name_6 = const_unicode_plain_big;
            frame_ce30d14ef98e4b5fb4f1bbda17cb1b5e->m_frame.f_lineno = 1401;
            {
                PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
                tmp_assattr_name_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
            }

            if ( tmp_assattr_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1401;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_assattr_target_2 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__ip, tmp_assattr_name_2 );
            Py_DECREF( tmp_assattr_name_2 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1401;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
        }
        tmp_return_value = Py_None;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_2:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_7;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_str );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__compat_str );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_compat_str" );
            exception_tb = NULL;

            exception_lineno = 1406;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_4;
        CHECK_OBJECT( par_address );
        tmp_args_element_name_7 = par_address;
        frame_ce30d14ef98e4b5fb4f1bbda17cb1b5e->m_frame.f_lineno = 1406;
        {
            PyObject *call_args[] = { tmp_args_element_name_7 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
        }

        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1406;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_addr_str == NULL );
        var_addr_str = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_compexpr_left_1 = const_unicode_chr_47;
        CHECK_OBJECT( var_addr_str );
        tmp_compexpr_right_1 = var_addr_str;
        tmp_res = PySequence_Contains( tmp_compexpr_right_1, tmp_compexpr_left_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1407;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = ( tmp_res == 1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_called_name_4;
            PyObject *tmp_mvar_value_5;
            PyObject *tmp_args_element_name_8;
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_AddressValueError );

            if (unlikely( tmp_mvar_value_5 == NULL ))
            {
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AddressValueError );
            }

            if ( tmp_mvar_value_5 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "AddressValueError" );
                exception_tb = NULL;

                exception_lineno = 1408;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_4 = tmp_mvar_value_5;
            tmp_left_name_1 = const_unicode_digest_eff0de065ad1be8ff8f4264ecac2dcba;
            CHECK_OBJECT( par_address );
            tmp_right_name_1 = par_address;
            tmp_args_element_name_8 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
            if ( tmp_args_element_name_8 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1408;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            frame_ce30d14ef98e4b5fb4f1bbda17cb1b5e->m_frame.f_lineno = 1408;
            {
                PyObject *call_args[] = { tmp_args_element_name_8 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
            }

            Py_DECREF( tmp_args_element_name_8 );
            if ( tmp_raise_type_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1408;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            exception_type = tmp_raise_type_1;
            exception_lineno = 1408;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        branch_no_3:;
    }
    {
        PyObject *tmp_assattr_name_3;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_assattr_target_3;
        CHECK_OBJECT( par_self );
        tmp_called_instance_3 = par_self;
        CHECK_OBJECT( var_addr_str );
        tmp_args_element_name_9 = var_addr_str;
        frame_ce30d14ef98e4b5fb4f1bbda17cb1b5e->m_frame.f_lineno = 1409;
        {
            PyObject *call_args[] = { tmp_args_element_name_9 };
            tmp_assattr_name_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain__ip_int_from_string, call_args );
        }

        if ( tmp_assattr_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1409;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_3 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain__ip, tmp_assattr_name_3 );
        Py_DECREF( tmp_assattr_name_3 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1409;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ce30d14ef98e4b5fb4f1bbda17cb1b5e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_ce30d14ef98e4b5fb4f1bbda17cb1b5e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ce30d14ef98e4b5fb4f1bbda17cb1b5e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ce30d14ef98e4b5fb4f1bbda17cb1b5e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ce30d14ef98e4b5fb4f1bbda17cb1b5e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ce30d14ef98e4b5fb4f1bbda17cb1b5e, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ce30d14ef98e4b5fb4f1bbda17cb1b5e,
        type_description_1,
        par_self,
        par_address,
        var_bvs,
        var_addr_str
    );


    // Release cached frame.
    if ( frame_ce30d14ef98e4b5fb4f1bbda17cb1b5e == cache_frame_ce30d14ef98e4b5fb4f1bbda17cb1b5e )
    {
        Py_DECREF( frame_ce30d14ef98e4b5fb4f1bbda17cb1b5e );
    }
    cache_frame_ce30d14ef98e4b5fb4f1bbda17cb1b5e = NULL;

    assertFrameObject( frame_ce30d14ef98e4b5fb4f1bbda17cb1b5e );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_89___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_bvs );
    var_bvs = NULL;

    Py_XDECREF( var_addr_str );
    var_addr_str = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_address );
    Py_DECREF( par_address );
    par_address = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_bvs );
    var_bvs = NULL;

    Py_XDECREF( var_addr_str );
    var_addr_str = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_address );
    Py_DECREF( par_address );
    par_address = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_89___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_90_packed( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_74f67d01bd167da0756775c14a3a8bb0;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_74f67d01bd167da0756775c14a3a8bb0 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_74f67d01bd167da0756775c14a3a8bb0, codeobj_74f67d01bd167da0756775c14a3a8bb0, module_ipaddress, sizeof(void *) );
    frame_74f67d01bd167da0756775c14a3a8bb0 = cache_frame_74f67d01bd167da0756775c14a3a8bb0;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_74f67d01bd167da0756775c14a3a8bb0 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_74f67d01bd167da0756775c14a3a8bb0 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_v4_int_to_packed );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_v4_int_to_packed );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "v4_int_to_packed" );
            exception_tb = NULL;

            exception_lineno = 1414;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__ip );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1414;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_74f67d01bd167da0756775c14a3a8bb0->m_frame.f_lineno = 1414;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1414;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_74f67d01bd167da0756775c14a3a8bb0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_74f67d01bd167da0756775c14a3a8bb0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_74f67d01bd167da0756775c14a3a8bb0 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_74f67d01bd167da0756775c14a3a8bb0, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_74f67d01bd167da0756775c14a3a8bb0->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_74f67d01bd167da0756775c14a3a8bb0, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_74f67d01bd167da0756775c14a3a8bb0,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_74f67d01bd167da0756775c14a3a8bb0 == cache_frame_74f67d01bd167da0756775c14a3a8bb0 )
    {
        Py_DECREF( frame_74f67d01bd167da0756775c14a3a8bb0 );
    }
    cache_frame_74f67d01bd167da0756775c14a3a8bb0 = NULL;

    assertFrameObject( frame_74f67d01bd167da0756775c14a3a8bb0 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_90_packed );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_90_packed );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_91_is_reserved( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_b87026341f70c04f9c8a27abe812549e;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_b87026341f70c04f9c8a27abe812549e = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b87026341f70c04f9c8a27abe812549e, codeobj_b87026341f70c04f9c8a27abe812549e, module_ipaddress, sizeof(void *) );
    frame_b87026341f70c04f9c8a27abe812549e = cache_frame_b87026341f70c04f9c8a27abe812549e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b87026341f70c04f9c8a27abe812549e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b87026341f70c04f9c8a27abe812549e ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( par_self );
        tmp_compexpr_left_1 = par_self;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__constants );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1425;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__reserved_network );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1425;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_res = PySequence_Contains( tmp_compexpr_right_1, tmp_compexpr_left_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1425;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = ( tmp_res == 1 ) ? Py_True : Py_False;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b87026341f70c04f9c8a27abe812549e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_b87026341f70c04f9c8a27abe812549e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b87026341f70c04f9c8a27abe812549e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b87026341f70c04f9c8a27abe812549e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b87026341f70c04f9c8a27abe812549e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b87026341f70c04f9c8a27abe812549e, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b87026341f70c04f9c8a27abe812549e,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_b87026341f70c04f9c8a27abe812549e == cache_frame_b87026341f70c04f9c8a27abe812549e )
    {
        Py_DECREF( frame_b87026341f70c04f9c8a27abe812549e );
    }
    cache_frame_b87026341f70c04f9c8a27abe812549e = NULL;

    assertFrameObject( frame_b87026341f70c04f9c8a27abe812549e );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_91_is_reserved );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_91_is_reserved );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_92_is_private( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1( python_pars[ 0 ] );
    PyObject *tmp_genexpr_1__$0 = NULL;
    struct Nuitka_FrameObject *frame_c3b901b102aeaad9d46e4c7384759f59;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_c3b901b102aeaad9d46e4c7384759f59 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c3b901b102aeaad9d46e4c7384759f59, codeobj_c3b901b102aeaad9d46e4c7384759f59, module_ipaddress, sizeof(void *) );
    frame_c3b901b102aeaad9d46e4c7384759f59 = cache_frame_c3b901b102aeaad9d46e4c7384759f59;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c3b901b102aeaad9d46e4c7384759f59 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c3b901b102aeaad9d46e4c7384759f59 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_1;
        tmp_called_name_1 = LOOKUP_BUILTIN( const_str_plain_any );
        assert( tmp_called_name_1 != NULL );
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_iter_arg_1;
            PyObject *tmp_source_name_1;
            PyObject *tmp_source_name_2;
            CHECK_OBJECT( PyCell_GET( par_self ) );
            tmp_source_name_2 = PyCell_GET( par_self );
            tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__constants );
            if ( tmp_source_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1436;
                type_description_1 = "c";
                goto frame_exception_exit_1;
            }
            tmp_iter_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__private_networks );
            Py_DECREF( tmp_source_name_1 );
            if ( tmp_iter_arg_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1436;
                type_description_1 = "c";
                goto frame_exception_exit_1;
            }
            tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
            Py_DECREF( tmp_iter_arg_1 );
            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1436;
                type_description_1 = "c";
                goto frame_exception_exit_1;
            }
            assert( tmp_genexpr_1__$0 == NULL );
            tmp_genexpr_1__$0 = tmp_assign_source_1;
        }
        // Tried code:
        tmp_args_element_name_1 = ipaddress$$$function_92_is_private$$$genexpr_1_genexpr_maker();

        ((struct Nuitka_GeneratorObject *)tmp_args_element_name_1)->m_closure[0] = PyCell_NEW0( tmp_genexpr_1__$0 );
        ((struct Nuitka_GeneratorObject *)tmp_args_element_name_1)->m_closure[1] = par_self;
        Py_INCREF( ((struct Nuitka_GeneratorObject *)tmp_args_element_name_1)->m_closure[1] );


        goto try_return_handler_2;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ipaddress$$$function_92_is_private );
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
        Py_DECREF( tmp_genexpr_1__$0 );
        tmp_genexpr_1__$0 = NULL;

        goto outline_result_1;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
        Py_DECREF( tmp_genexpr_1__$0 );
        tmp_genexpr_1__$0 = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( ipaddress$$$function_92_is_private );
        return NULL;
        outline_result_1:;
        frame_c3b901b102aeaad9d46e4c7384759f59->m_frame.f_lineno = 1436;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1436;
            type_description_1 = "c";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c3b901b102aeaad9d46e4c7384759f59 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_c3b901b102aeaad9d46e4c7384759f59 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c3b901b102aeaad9d46e4c7384759f59 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c3b901b102aeaad9d46e4c7384759f59, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c3b901b102aeaad9d46e4c7384759f59->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c3b901b102aeaad9d46e4c7384759f59, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c3b901b102aeaad9d46e4c7384759f59,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_c3b901b102aeaad9d46e4c7384759f59 == cache_frame_c3b901b102aeaad9d46e4c7384759f59 )
    {
        Py_DECREF( frame_c3b901b102aeaad9d46e4c7384759f59 );
    }
    cache_frame_c3b901b102aeaad9d46e4c7384759f59 = NULL;

    assertFrameObject( frame_c3b901b102aeaad9d46e4c7384759f59 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_92_is_private );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_92_is_private );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}



struct ipaddress$$$function_92_is_private$$$genexpr_1_genexpr_locals {
    PyObject *var_net;
    PyObject *tmp_iter_value_0;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    int tmp_res;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
};

static PyObject *ipaddress$$$function_92_is_private$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Heap access if used.
    struct ipaddress$$$function_92_is_private$$$genexpr_1_genexpr_locals *generator_heap = (struct ipaddress$$$function_92_is_private$$$genexpr_1_genexpr_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_net = NULL;
    generator_heap->tmp_iter_value_0 = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_m_frame, codeobj_b59b8ccabe478d9a4d3c7681e2692fa3, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

#if PYTHON_VERSION < 370
        generator->m_frame->m_frame.f_exc_type = EXC_TYPE( thread_state );
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
        Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#else
        generator->m_exc_state.exc_type = EXC_TYPE( thread_state );
        if ( generator->m_exc_state.exc_type == Py_None ) generator->m_exc_state.exc_type = NULL;
        Py_XINCREF( generator->m_exc_state.exc_type );
        generator->m_exc_state.exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_value );
        generator->m_exc_state.exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_traceback );
#endif
    }

#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_1;
        CHECK_OBJECT( PyCell_GET( generator->m_closure[0] ) );
        tmp_next_source_1 = PyCell_GET( generator->m_closure[0] );
        tmp_assign_source_1 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
                generator_heap->type_description_1 = "Noc";
                generator_heap->exception_lineno = 1436;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_iter_value_0;
            generator_heap->tmp_iter_value_0 = tmp_assign_source_1;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT( generator_heap->tmp_iter_value_0 );
        tmp_assign_source_2 = generator_heap->tmp_iter_value_0;
        {
            PyObject *old = generator_heap->var_net;
            generator_heap->var_net = tmp_assign_source_2;
            Py_INCREF( generator_heap->var_net );
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_expression_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        if ( PyCell_GET( generator->m_closure[1] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 1436;
            generator_heap->type_description_1 = "Noc";
            goto try_except_handler_2;
        }

        tmp_compexpr_left_1 = PyCell_GET( generator->m_closure[1] );
        CHECK_OBJECT( generator_heap->var_net );
        tmp_compexpr_right_1 = generator_heap->var_net;
        generator_heap->tmp_res = PySequence_Contains( tmp_compexpr_right_1, tmp_compexpr_left_1 );
        if ( generator_heap->tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 1436;
            generator_heap->type_description_1 = "Noc";
            goto try_except_handler_2;
        }
        tmp_expression_name_1 = ( generator_heap->tmp_res == 1 ) ? Py_True : Py_False;
        Py_INCREF( tmp_expression_name_1 );
        Nuitka_PreserveHeap( generator_heap->yield_tmps, &tmp_compexpr_left_1, sizeof(PyObject *), &tmp_compexpr_right_1, sizeof(PyObject *), NULL );
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        Nuitka_RestoreHeap( generator_heap->yield_tmps, &tmp_compexpr_left_1, sizeof(PyObject *), &tmp_compexpr_right_1, sizeof(PyObject *), NULL );
        if ( yield_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 1436;
            generator_heap->type_description_1 = "Noc";
            goto try_except_handler_2;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


        generator_heap->exception_lineno = 1436;
        generator_heap->type_description_1 = "Noc";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->tmp_iter_value_0 );
    generator_heap->tmp_iter_value_0 = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( generator_heap->exception_type ) )
    {
        if ( generator_heap->exception_tb == NULL )
        {
            generator_heap->exception_tb = MAKE_TRACEBACK( generator->m_frame, generator_heap->exception_lineno );
        }
        else if ( generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            generator_heap->exception_tb = ADD_TRACEBACK( generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            NULL,
            generator_heap->var_net,
            generator->m_closure[1]
        );


        // Release cached frame.
        if ( generator->m_frame == cache_m_frame )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_m_frame = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->var_net );
    generator_heap->var_net = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:
    try_end_2:;
    Py_XDECREF( generator_heap->tmp_iter_value_0 );
    generator_heap->tmp_iter_value_0 = NULL;

    Py_XDECREF( generator_heap->var_net );
    generator_heap->var_net = NULL;



    return NULL;

    function_exception_exit:
    assert( generator_heap->exception_type );
    RESTORE_ERROR_OCCURRED( generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb );

    return NULL;

}

static PyObject *ipaddress$$$function_92_is_private$$$genexpr_1_genexpr_maker( void )
{
    return Nuitka_Generator_New(
        ipaddress$$$function_92_is_private$$$genexpr_1_genexpr_context,
        module_ipaddress,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_b59b8ccabe478d9a4d3c7681e2692fa3,
        2,
        sizeof(struct ipaddress$$$function_92_is_private$$$genexpr_1_genexpr_locals)
    );
}


static PyObject *impl_ipaddress$$$function_93_is_global( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_6ef12be487ba919b62bfd71122d13134;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_6ef12be487ba919b62bfd71122d13134 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6ef12be487ba919b62bfd71122d13134, codeobj_6ef12be487ba919b62bfd71122d13134, module_ipaddress, sizeof(void *) );
    frame_6ef12be487ba919b62bfd71122d13134 = cache_frame_6ef12be487ba919b62bfd71122d13134;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6ef12be487ba919b62bfd71122d13134 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6ef12be487ba919b62bfd71122d13134 ) == 2 ); // Frame stack

    // Framed code:
    {
        int tmp_and_left_truth_1;
        PyObject *tmp_and_left_value_1;
        PyObject *tmp_and_right_value_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_source_name_3;
        CHECK_OBJECT( par_self );
        tmp_compexpr_left_1 = par_self;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__constants );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1441;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__public_network );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1441;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_res = PySequence_Contains( tmp_compexpr_right_1, tmp_compexpr_left_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1441;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_1 = ( tmp_res == 0 ) ? Py_True : Py_False;
        tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
        if ( tmp_and_left_truth_1 == 1 )
        {
            goto and_right_1;
        }
        else
        {
            goto and_left_1;
        }
        and_right_1:;
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_operand_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_is_private );
        if ( tmp_operand_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1442;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        Py_DECREF( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1442;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_1 = ( tmp_res == 0 ) ? Py_True : Py_False;
        tmp_return_value = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_return_value = tmp_and_left_value_1;
        and_end_1:;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6ef12be487ba919b62bfd71122d13134 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_6ef12be487ba919b62bfd71122d13134 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6ef12be487ba919b62bfd71122d13134 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6ef12be487ba919b62bfd71122d13134, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6ef12be487ba919b62bfd71122d13134->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6ef12be487ba919b62bfd71122d13134, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6ef12be487ba919b62bfd71122d13134,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_6ef12be487ba919b62bfd71122d13134 == cache_frame_6ef12be487ba919b62bfd71122d13134 )
    {
        Py_DECREF( frame_6ef12be487ba919b62bfd71122d13134 );
    }
    cache_frame_6ef12be487ba919b62bfd71122d13134 = NULL;

    assertFrameObject( frame_6ef12be487ba919b62bfd71122d13134 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_93_is_global );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_93_is_global );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_94_is_multicast( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_9884b10659aa16fb451f94aef6e0d207;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_9884b10659aa16fb451f94aef6e0d207 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9884b10659aa16fb451f94aef6e0d207, codeobj_9884b10659aa16fb451f94aef6e0d207, module_ipaddress, sizeof(void *) );
    frame_9884b10659aa16fb451f94aef6e0d207 = cache_frame_9884b10659aa16fb451f94aef6e0d207;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9884b10659aa16fb451f94aef6e0d207 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9884b10659aa16fb451f94aef6e0d207 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( par_self );
        tmp_compexpr_left_1 = par_self;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__constants );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1453;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__multicast_network );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1453;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_res = PySequence_Contains( tmp_compexpr_right_1, tmp_compexpr_left_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1453;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = ( tmp_res == 1 ) ? Py_True : Py_False;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9884b10659aa16fb451f94aef6e0d207 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_9884b10659aa16fb451f94aef6e0d207 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9884b10659aa16fb451f94aef6e0d207 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9884b10659aa16fb451f94aef6e0d207, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9884b10659aa16fb451f94aef6e0d207->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9884b10659aa16fb451f94aef6e0d207, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9884b10659aa16fb451f94aef6e0d207,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_9884b10659aa16fb451f94aef6e0d207 == cache_frame_9884b10659aa16fb451f94aef6e0d207 )
    {
        Py_DECREF( frame_9884b10659aa16fb451f94aef6e0d207 );
    }
    cache_frame_9884b10659aa16fb451f94aef6e0d207 = NULL;

    assertFrameObject( frame_9884b10659aa16fb451f94aef6e0d207 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_94_is_multicast );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_94_is_multicast );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_95_is_unspecified( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_2e57bd4f793084e6678d8088b4db5110;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_2e57bd4f793084e6678d8088b4db5110 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2e57bd4f793084e6678d8088b4db5110, codeobj_2e57bd4f793084e6678d8088b4db5110, module_ipaddress, sizeof(void *) );
    frame_2e57bd4f793084e6678d8088b4db5110 = cache_frame_2e57bd4f793084e6678d8088b4db5110;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2e57bd4f793084e6678d8088b4db5110 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2e57bd4f793084e6678d8088b4db5110 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( par_self );
        tmp_compexpr_left_1 = par_self;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__constants );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1464;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__unspecified_address );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1464;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1464;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2e57bd4f793084e6678d8088b4db5110 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_2e57bd4f793084e6678d8088b4db5110 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2e57bd4f793084e6678d8088b4db5110 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2e57bd4f793084e6678d8088b4db5110, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2e57bd4f793084e6678d8088b4db5110->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2e57bd4f793084e6678d8088b4db5110, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2e57bd4f793084e6678d8088b4db5110,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_2e57bd4f793084e6678d8088b4db5110 == cache_frame_2e57bd4f793084e6678d8088b4db5110 )
    {
        Py_DECREF( frame_2e57bd4f793084e6678d8088b4db5110 );
    }
    cache_frame_2e57bd4f793084e6678d8088b4db5110 = NULL;

    assertFrameObject( frame_2e57bd4f793084e6678d8088b4db5110 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_95_is_unspecified );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_95_is_unspecified );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_96_is_loopback( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_0f3c3c5183ea0c46a59155086c6f7125;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_0f3c3c5183ea0c46a59155086c6f7125 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0f3c3c5183ea0c46a59155086c6f7125, codeobj_0f3c3c5183ea0c46a59155086c6f7125, module_ipaddress, sizeof(void *) );
    frame_0f3c3c5183ea0c46a59155086c6f7125 = cache_frame_0f3c3c5183ea0c46a59155086c6f7125;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0f3c3c5183ea0c46a59155086c6f7125 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0f3c3c5183ea0c46a59155086c6f7125 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( par_self );
        tmp_compexpr_left_1 = par_self;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__constants );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1474;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__loopback_network );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1474;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_res = PySequence_Contains( tmp_compexpr_right_1, tmp_compexpr_left_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1474;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = ( tmp_res == 1 ) ? Py_True : Py_False;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0f3c3c5183ea0c46a59155086c6f7125 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_0f3c3c5183ea0c46a59155086c6f7125 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0f3c3c5183ea0c46a59155086c6f7125 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0f3c3c5183ea0c46a59155086c6f7125, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0f3c3c5183ea0c46a59155086c6f7125->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0f3c3c5183ea0c46a59155086c6f7125, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0f3c3c5183ea0c46a59155086c6f7125,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_0f3c3c5183ea0c46a59155086c6f7125 == cache_frame_0f3c3c5183ea0c46a59155086c6f7125 )
    {
        Py_DECREF( frame_0f3c3c5183ea0c46a59155086c6f7125 );
    }
    cache_frame_0f3c3c5183ea0c46a59155086c6f7125 = NULL;

    assertFrameObject( frame_0f3c3c5183ea0c46a59155086c6f7125 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_96_is_loopback );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_96_is_loopback );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_97_is_link_local( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_0c6b9c33eb0e964d2f2830e571976109;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_0c6b9c33eb0e964d2f2830e571976109 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0c6b9c33eb0e964d2f2830e571976109, codeobj_0c6b9c33eb0e964d2f2830e571976109, module_ipaddress, sizeof(void *) );
    frame_0c6b9c33eb0e964d2f2830e571976109 = cache_frame_0c6b9c33eb0e964d2f2830e571976109;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0c6b9c33eb0e964d2f2830e571976109 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0c6b9c33eb0e964d2f2830e571976109 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( par_self );
        tmp_compexpr_left_1 = par_self;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__constants );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1484;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__linklocal_network );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1484;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_res = PySequence_Contains( tmp_compexpr_right_1, tmp_compexpr_left_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1484;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = ( tmp_res == 1 ) ? Py_True : Py_False;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0c6b9c33eb0e964d2f2830e571976109 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_0c6b9c33eb0e964d2f2830e571976109 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0c6b9c33eb0e964d2f2830e571976109 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0c6b9c33eb0e964d2f2830e571976109, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0c6b9c33eb0e964d2f2830e571976109->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0c6b9c33eb0e964d2f2830e571976109, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0c6b9c33eb0e964d2f2830e571976109,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_0c6b9c33eb0e964d2f2830e571976109 == cache_frame_0c6b9c33eb0e964d2f2830e571976109 )
    {
        Py_DECREF( frame_0c6b9c33eb0e964d2f2830e571976109 );
    }
    cache_frame_0c6b9c33eb0e964d2f2830e571976109 = NULL;

    assertFrameObject( frame_0c6b9c33eb0e964d2f2830e571976109 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_97_is_link_local );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_97_is_link_local );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_98___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_address = python_pars[ 1 ];
    PyObject *var_addr = NULL;
    struct Nuitka_FrameObject *frame_bc7f8586f62fb3cbf6c042b03e688d28;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_bc7f8586f62fb3cbf6c042b03e688d28 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_bc7f8586f62fb3cbf6c042b03e688d28, codeobj_bc7f8586f62fb3cbf6c042b03e688d28, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_bc7f8586f62fb3cbf6c042b03e688d28 = cache_frame_bc7f8586f62fb3cbf6c042b03e688d28;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_bc7f8586f62fb3cbf6c042b03e688d28 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_bc7f8586f62fb3cbf6c042b03e688d28 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_address );
        tmp_isinstance_inst_1 = par_address;
        tmp_tuple_element_1 = (PyObject *)&PyString_Type;
        tmp_isinstance_cls_1 = PyTuple_New( 2 );
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_isinstance_cls_1, 0, tmp_tuple_element_1 );
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_int_types );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__compat_int_types );
        }

        if ( tmp_mvar_value_1 == NULL )
        {
            Py_DECREF( tmp_isinstance_cls_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_compat_int_types" );
            exception_tb = NULL;

            exception_lineno = 1490;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_tuple_element_1 = tmp_mvar_value_1;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_isinstance_cls_1, 1, tmp_tuple_element_1 );
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        Py_DECREF( tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1490;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_mvar_value_2;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Address );

            if (unlikely( tmp_mvar_value_2 == NULL ))
            {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Address );
            }

            if ( tmp_mvar_value_2 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv4Address" );
                exception_tb = NULL;

                exception_lineno = 1491;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_1 = tmp_mvar_value_2;
            CHECK_OBJECT( par_self );
            tmp_args_element_name_1 = par_self;
            CHECK_OBJECT( par_address );
            tmp_args_element_name_2 = par_address;
            frame_bc7f8586f62fb3cbf6c042b03e688d28->m_frame.f_lineno = 1491;
            {
                PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
                tmp_call_result_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain___init__, call_args );
            }

            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1491;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        {
            PyObject *tmp_assattr_name_1;
            PyObject *tmp_called_name_1;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_args_element_name_3;
            PyObject *tmp_source_name_1;
            PyObject *tmp_assattr_target_1;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Network );

            if (unlikely( tmp_mvar_value_3 == NULL ))
            {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Network );
            }

            if ( tmp_mvar_value_3 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv4Network" );
                exception_tb = NULL;

                exception_lineno = 1492;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_1 = tmp_mvar_value_3;
            CHECK_OBJECT( par_self );
            tmp_source_name_1 = par_self;
            tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__ip );
            if ( tmp_args_element_name_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1492;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            frame_bc7f8586f62fb3cbf6c042b03e688d28->m_frame.f_lineno = 1492;
            {
                PyObject *call_args[] = { tmp_args_element_name_3 };
                tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
            }

            Py_DECREF( tmp_args_element_name_3 );
            if ( tmp_assattr_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1492;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_assattr_target_1 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_network, tmp_assattr_name_1 );
            Py_DECREF( tmp_assattr_name_1 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1492;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
        }
        {
            PyObject *tmp_assattr_name_2;
            PyObject *tmp_source_name_2;
            PyObject *tmp_assattr_target_2;
            CHECK_OBJECT( par_self );
            tmp_source_name_2 = par_self;
            tmp_assattr_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__max_prefixlen );
            if ( tmp_assattr_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1493;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_assattr_target_2 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__prefixlen, tmp_assattr_name_2 );
            Py_DECREF( tmp_assattr_name_2 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1493;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
        }
        tmp_return_value = Py_None;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_isinstance_inst_2;
        PyObject *tmp_isinstance_cls_2;
        CHECK_OBJECT( par_address );
        tmp_isinstance_inst_2 = par_address;
        tmp_isinstance_cls_2 = (PyObject *)&PyTuple_Type;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1496;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_3;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_call_result_2;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_args_element_name_5;
            PyObject *tmp_subscribed_name_1;
            PyObject *tmp_subscript_name_1;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Address );

            if (unlikely( tmp_mvar_value_4 == NULL ))
            {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Address );
            }

            if ( tmp_mvar_value_4 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv4Address" );
                exception_tb = NULL;

                exception_lineno = 1497;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_3 = tmp_mvar_value_4;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain___init__ );
            if ( tmp_called_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1497;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_args_element_name_4 = par_self;
            CHECK_OBJECT( par_address );
            tmp_subscribed_name_1 = par_address;
            tmp_subscript_name_1 = const_int_0;
            tmp_args_element_name_5 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_1, tmp_subscript_name_1, 0 );
            if ( tmp_args_element_name_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_2 );

                exception_lineno = 1497;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            frame_bc7f8586f62fb3cbf6c042b03e688d28->m_frame.f_lineno = 1497;
            {
                PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
                tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
            }

            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_5 );
            if ( tmp_call_result_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1497;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_2 );
        }
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_compexpr_left_1;
            PyObject *tmp_compexpr_right_1;
            PyObject *tmp_len_arg_1;
            CHECK_OBJECT( par_address );
            tmp_len_arg_1 = par_address;
            tmp_compexpr_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
            if ( tmp_compexpr_left_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1498;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_compexpr_right_1 = const_int_pos_1;
            tmp_res = RICH_COMPARE_BOOL_GT_OBJECT_INT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
            Py_DECREF( tmp_compexpr_left_1 );
            assert( !(tmp_res == -1) );
            tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_3;
            }
            else
            {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_assattr_name_3;
                PyObject *tmp_int_arg_1;
                PyObject *tmp_subscribed_name_2;
                PyObject *tmp_subscript_name_2;
                PyObject *tmp_assattr_target_3;
                CHECK_OBJECT( par_address );
                tmp_subscribed_name_2 = par_address;
                tmp_subscript_name_2 = const_int_pos_1;
                tmp_int_arg_1 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_2, tmp_subscript_name_2, 1 );
                if ( tmp_int_arg_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1499;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
                tmp_assattr_name_3 = PyNumber_Int( tmp_int_arg_1 );
                Py_DECREF( tmp_int_arg_1 );
                if ( tmp_assattr_name_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1499;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
                CHECK_OBJECT( par_self );
                tmp_assattr_target_3 = par_self;
                tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain__prefixlen, tmp_assattr_name_3 );
                Py_DECREF( tmp_assattr_name_3 );
                if ( tmp_result == false )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1499;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
            }
            goto branch_end_3;
            branch_no_3:;
            {
                PyObject *tmp_assattr_name_4;
                PyObject *tmp_source_name_4;
                PyObject *tmp_assattr_target_4;
                CHECK_OBJECT( par_self );
                tmp_source_name_4 = par_self;
                tmp_assattr_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__max_prefixlen );
                if ( tmp_assattr_name_4 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1501;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
                CHECK_OBJECT( par_self );
                tmp_assattr_target_4 = par_self;
                tmp_result = SET_ATTRIBUTE( tmp_assattr_target_4, const_str_plain__prefixlen, tmp_assattr_name_4 );
                Py_DECREF( tmp_assattr_name_4 );
                if ( tmp_result == false )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1501;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
            }
            branch_end_3:;
        }
        {
            PyObject *tmp_assattr_name_5;
            PyObject *tmp_called_name_3;
            PyObject *tmp_mvar_value_5;
            PyObject *tmp_args_name_1;
            PyObject *tmp_tuple_element_2;
            PyObject *tmp_kw_name_1;
            PyObject *tmp_assattr_target_5;
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Network );

            if (unlikely( tmp_mvar_value_5 == NULL ))
            {
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Network );
            }

            if ( tmp_mvar_value_5 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv4Network" );
                exception_tb = NULL;

                exception_lineno = 1503;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_3 = tmp_mvar_value_5;
            CHECK_OBJECT( par_address );
            tmp_tuple_element_2 = par_address;
            tmp_args_name_1 = PyTuple_New( 1 );
            Py_INCREF( tmp_tuple_element_2 );
            PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_2 );
            tmp_kw_name_1 = PyDict_Copy( const_dict_23947da529d495c5b5d02e68c2d46c17 );
            frame_bc7f8586f62fb3cbf6c042b03e688d28->m_frame.f_lineno = 1503;
            tmp_assattr_name_5 = CALL_FUNCTION( tmp_called_name_3, tmp_args_name_1, tmp_kw_name_1 );
            Py_DECREF( tmp_args_name_1 );
            Py_DECREF( tmp_kw_name_1 );
            if ( tmp_assattr_name_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1503;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_assattr_target_5 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_5, const_str_plain_network, tmp_assattr_name_5 );
            Py_DECREF( tmp_assattr_name_5 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1503;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
        }
        {
            PyObject *tmp_assattr_name_6;
            PyObject *tmp_source_name_5;
            PyObject *tmp_source_name_6;
            PyObject *tmp_assattr_target_6;
            CHECK_OBJECT( par_self );
            tmp_source_name_6 = par_self;
            tmp_source_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_network );
            if ( tmp_source_name_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1504;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_assattr_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_netmask );
            Py_DECREF( tmp_source_name_5 );
            if ( tmp_assattr_name_6 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1504;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_assattr_target_6 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_6, const_str_plain_netmask, tmp_assattr_name_6 );
            Py_DECREF( tmp_assattr_name_6 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1504;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
        }
        {
            PyObject *tmp_assattr_name_7;
            PyObject *tmp_source_name_7;
            PyObject *tmp_source_name_8;
            PyObject *tmp_assattr_target_7;
            CHECK_OBJECT( par_self );
            tmp_source_name_8 = par_self;
            tmp_source_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_network );
            if ( tmp_source_name_7 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1505;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_assattr_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_hostmask );
            Py_DECREF( tmp_source_name_7 );
            if ( tmp_assattr_name_7 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1505;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_assattr_target_7 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_7, const_str_plain_hostmask, tmp_assattr_name_7 );
            Py_DECREF( tmp_assattr_name_7 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1505;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
        }
        tmp_return_value = Py_None;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_2:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_4;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_args_element_name_6;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__split_optional_netmask );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__split_optional_netmask );
        }

        if ( tmp_mvar_value_6 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_split_optional_netmask" );
            exception_tb = NULL;

            exception_lineno = 1508;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_4 = tmp_mvar_value_6;
        CHECK_OBJECT( par_address );
        tmp_args_element_name_6 = par_address;
        frame_bc7f8586f62fb3cbf6c042b03e688d28->m_frame.f_lineno = 1508;
        {
            PyObject *call_args[] = { tmp_args_element_name_6 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1508;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_addr == NULL );
        var_addr = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_5;
        PyObject *tmp_source_name_9;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_call_result_3;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_subscribed_name_3;
        PyObject *tmp_subscript_name_3;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Address );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Address );
        }

        if ( tmp_mvar_value_7 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv4Address" );
            exception_tb = NULL;

            exception_lineno = 1509;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_9 = tmp_mvar_value_7;
        tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain___init__ );
        if ( tmp_called_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1509;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_args_element_name_7 = par_self;
        CHECK_OBJECT( var_addr );
        tmp_subscribed_name_3 = var_addr;
        tmp_subscript_name_3 = const_int_0;
        tmp_args_element_name_8 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_3, tmp_subscript_name_3, 0 );
        if ( tmp_args_element_name_8 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_5 );

            exception_lineno = 1509;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_bc7f8586f62fb3cbf6c042b03e688d28->m_frame.f_lineno = 1509;
        {
            PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8 };
            tmp_call_result_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_5, call_args );
        }

        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_args_element_name_8 );
        if ( tmp_call_result_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1509;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_3 );
    }
    {
        PyObject *tmp_assattr_name_8;
        PyObject *tmp_called_name_6;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_args_name_2;
        PyObject *tmp_tuple_element_3;
        PyObject *tmp_kw_name_2;
        PyObject *tmp_assattr_target_8;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Network );

        if (unlikely( tmp_mvar_value_8 == NULL ))
        {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Network );
        }

        if ( tmp_mvar_value_8 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv4Network" );
            exception_tb = NULL;

            exception_lineno = 1511;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_6 = tmp_mvar_value_8;
        CHECK_OBJECT( par_address );
        tmp_tuple_element_3 = par_address;
        tmp_args_name_2 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_3 );
        PyTuple_SET_ITEM( tmp_args_name_2, 0, tmp_tuple_element_3 );
        tmp_kw_name_2 = PyDict_Copy( const_dict_23947da529d495c5b5d02e68c2d46c17 );
        frame_bc7f8586f62fb3cbf6c042b03e688d28->m_frame.f_lineno = 1511;
        tmp_assattr_name_8 = CALL_FUNCTION( tmp_called_name_6, tmp_args_name_2, tmp_kw_name_2 );
        Py_DECREF( tmp_args_name_2 );
        Py_DECREF( tmp_kw_name_2 );
        if ( tmp_assattr_name_8 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1511;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_8 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_8, const_str_plain_network, tmp_assattr_name_8 );
        Py_DECREF( tmp_assattr_name_8 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1511;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_9;
        PyObject *tmp_source_name_10;
        PyObject *tmp_source_name_11;
        PyObject *tmp_assattr_target_9;
        CHECK_OBJECT( par_self );
        tmp_source_name_11 = par_self;
        tmp_source_name_10 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain_network );
        if ( tmp_source_name_10 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1512;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_assattr_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain__prefixlen );
        Py_DECREF( tmp_source_name_10 );
        if ( tmp_assattr_name_9 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1512;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_9 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_9, const_str_plain__prefixlen, tmp_assattr_name_9 );
        Py_DECREF( tmp_assattr_name_9 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1512;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_10;
        PyObject *tmp_source_name_12;
        PyObject *tmp_source_name_13;
        PyObject *tmp_assattr_target_10;
        CHECK_OBJECT( par_self );
        tmp_source_name_13 = par_self;
        tmp_source_name_12 = LOOKUP_ATTRIBUTE( tmp_source_name_13, const_str_plain_network );
        if ( tmp_source_name_12 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1514;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_assattr_name_10 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain_netmask );
        Py_DECREF( tmp_source_name_12 );
        if ( tmp_assattr_name_10 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1514;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_10 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_10, const_str_plain_netmask, tmp_assattr_name_10 );
        Py_DECREF( tmp_assattr_name_10 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1514;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_11;
        PyObject *tmp_source_name_14;
        PyObject *tmp_source_name_15;
        PyObject *tmp_assattr_target_11;
        CHECK_OBJECT( par_self );
        tmp_source_name_15 = par_self;
        tmp_source_name_14 = LOOKUP_ATTRIBUTE( tmp_source_name_15, const_str_plain_network );
        if ( tmp_source_name_14 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1515;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_assattr_name_11 = LOOKUP_ATTRIBUTE( tmp_source_name_14, const_str_plain_hostmask );
        Py_DECREF( tmp_source_name_14 );
        if ( tmp_assattr_name_11 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1515;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_11 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_11, const_str_plain_hostmask, tmp_assattr_name_11 );
        Py_DECREF( tmp_assattr_name_11 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1515;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_bc7f8586f62fb3cbf6c042b03e688d28 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_bc7f8586f62fb3cbf6c042b03e688d28 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_bc7f8586f62fb3cbf6c042b03e688d28 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_bc7f8586f62fb3cbf6c042b03e688d28, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_bc7f8586f62fb3cbf6c042b03e688d28->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_bc7f8586f62fb3cbf6c042b03e688d28, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_bc7f8586f62fb3cbf6c042b03e688d28,
        type_description_1,
        par_self,
        par_address,
        var_addr
    );


    // Release cached frame.
    if ( frame_bc7f8586f62fb3cbf6c042b03e688d28 == cache_frame_bc7f8586f62fb3cbf6c042b03e688d28 )
    {
        Py_DECREF( frame_bc7f8586f62fb3cbf6c042b03e688d28 );
    }
    cache_frame_bc7f8586f62fb3cbf6c042b03e688d28 = NULL;

    assertFrameObject( frame_bc7f8586f62fb3cbf6c042b03e688d28 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_98___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_addr );
    var_addr = NULL;

    CHECK_OBJECT( (PyObject *)par_address );
    Py_DECREF( par_address );
    par_address = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_addr );
    var_addr = NULL;

    CHECK_OBJECT( (PyObject *)par_address );
    Py_DECREF( par_address );
    par_address = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_98___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_99___str__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_625cfb563c75cb0b49bcc7b223caabc6;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_625cfb563c75cb0b49bcc7b223caabc6 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_625cfb563c75cb0b49bcc7b223caabc6, codeobj_625cfb563c75cb0b49bcc7b223caabc6, module_ipaddress, sizeof(void *) );
    frame_625cfb563c75cb0b49bcc7b223caabc6 = cache_frame_625cfb563c75cb0b49bcc7b223caabc6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_625cfb563c75cb0b49bcc7b223caabc6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_625cfb563c75cb0b49bcc7b223caabc6 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_source_name_4;
        tmp_left_name_1 = const_unicode_digest_6a98397c0892ba5e9c29046762cbb9d8;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__string_from_ip_int );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1518;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ip );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1518;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_625cfb563c75cb0b49bcc7b223caabc6->m_frame.f_lineno = 1518;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_tuple_element_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1518;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_1 = PyTuple_New( 2 );
        PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( par_self );
        tmp_source_name_4 = par_self;
        tmp_source_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_network );
        if ( tmp_source_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_right_name_1 );

            exception_lineno = 1519;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_prefixlen );
        Py_DECREF( tmp_source_name_3 );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_right_name_1 );

            exception_lineno = 1519;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM( tmp_right_name_1, 1, tmp_tuple_element_1 );
        tmp_return_value = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_right_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1518;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_625cfb563c75cb0b49bcc7b223caabc6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_625cfb563c75cb0b49bcc7b223caabc6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_625cfb563c75cb0b49bcc7b223caabc6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_625cfb563c75cb0b49bcc7b223caabc6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_625cfb563c75cb0b49bcc7b223caabc6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_625cfb563c75cb0b49bcc7b223caabc6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_625cfb563c75cb0b49bcc7b223caabc6,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_625cfb563c75cb0b49bcc7b223caabc6 == cache_frame_625cfb563c75cb0b49bcc7b223caabc6 )
    {
        Py_DECREF( frame_625cfb563c75cb0b49bcc7b223caabc6 );
    }
    cache_frame_625cfb563c75cb0b49bcc7b223caabc6 = NULL;

    assertFrameObject( frame_625cfb563c75cb0b49bcc7b223caabc6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_99___str__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_99___str__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_100___eq__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *var_address_equal = NULL;
    struct Nuitka_FrameObject *frame_b79d16e0a05c525ce1a86e8fc3c4bd76;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_b79d16e0a05c525ce1a86e8fc3c4bd76 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b79d16e0a05c525ce1a86e8fc3c4bd76, codeobj_b79d16e0a05c525ce1a86e8fc3c4bd76, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_b79d16e0a05c525ce1a86e8fc3c4bd76 = cache_frame_b79d16e0a05c525ce1a86e8fc3c4bd76;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b79d16e0a05c525ce1a86e8fc3c4bd76 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b79d16e0a05c525ce1a86e8fc3c4bd76 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Address );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Address );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv4Address" );
            exception_tb = NULL;

            exception_lineno = 1522;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_self );
        tmp_args_element_name_1 = par_self;
        CHECK_OBJECT( par_other );
        tmp_args_element_name_2 = par_other;
        frame_b79d16e0a05c525ce1a86e8fc3c4bd76->m_frame.f_lineno = 1522;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain___eq__, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1522;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_address_equal == NULL );
        var_address_equal = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_or_left_truth_1;
        nuitka_bool tmp_or_left_value_1;
        nuitka_bool tmp_or_right_value_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( var_address_equal );
        tmp_operand_name_1 = var_address_equal;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1523;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_or_left_value_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_or_left_truth_1 = tmp_or_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_or_left_truth_1 == 1 )
        {
            goto or_left_1;
        }
        else
        {
            goto or_right_1;
        }
        or_right_1:;
        CHECK_OBJECT( var_address_equal );
        tmp_compexpr_left_1 = var_address_equal;
        tmp_compexpr_right_1 = Py_NotImplemented;
        tmp_or_right_value_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_condition_result_1 = tmp_or_right_value_1;
        goto or_end_1;
        or_left_1:;
        tmp_condition_result_1 = tmp_or_left_value_1;
        or_end_1:;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        CHECK_OBJECT( var_address_equal );
        tmp_return_value = var_address_equal;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_1:;
    }
    // Tried code:
    {
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_network );
        if ( tmp_compexpr_left_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1526;
            type_description_1 = "ooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( par_other );
        tmp_source_name_2 = par_other;
        tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_network );
        if ( tmp_compexpr_right_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_2 );

            exception_lineno = 1526;
            type_description_1 = "ooo";
            goto try_except_handler_2;
        }
        tmp_return_value = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        Py_DECREF( tmp_compexpr_left_2 );
        Py_DECREF( tmp_compexpr_right_2 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1526;
            type_description_1 = "ooo";
            goto try_except_handler_2;
        }
        goto frame_return_exit_1;
    }
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_100___eq__ );
    return NULL;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_b79d16e0a05c525ce1a86e8fc3c4bd76 );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_b79d16e0a05c525ce1a86e8fc3c4bd76, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_b79d16e0a05c525ce1a86e8fc3c4bd76, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        tmp_compexpr_left_3 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_3 = PyExc_AttributeError;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_3, tmp_compexpr_right_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1527;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        tmp_return_value = Py_False;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        goto branch_end_2;
        branch_no_2:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 1525;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_b79d16e0a05c525ce1a86e8fc3c4bd76->m_frame) frame_b79d16e0a05c525ce1a86e8fc3c4bd76->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
        branch_end_2:;
    }
    // End of try:

#if 1
    RESTORE_FRAME_EXCEPTION( frame_b79d16e0a05c525ce1a86e8fc3c4bd76 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_b79d16e0a05c525ce1a86e8fc3c4bd76 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_b79d16e0a05c525ce1a86e8fc3c4bd76 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b79d16e0a05c525ce1a86e8fc3c4bd76, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b79d16e0a05c525ce1a86e8fc3c4bd76->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b79d16e0a05c525ce1a86e8fc3c4bd76, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b79d16e0a05c525ce1a86e8fc3c4bd76,
        type_description_1,
        par_self,
        par_other,
        var_address_equal
    );


    // Release cached frame.
    if ( frame_b79d16e0a05c525ce1a86e8fc3c4bd76 == cache_frame_b79d16e0a05c525ce1a86e8fc3c4bd76 )
    {
        Py_DECREF( frame_b79d16e0a05c525ce1a86e8fc3c4bd76 );
    }
    cache_frame_b79d16e0a05c525ce1a86e8fc3c4bd76 = NULL;

    assertFrameObject( frame_b79d16e0a05c525ce1a86e8fc3c4bd76 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_100___eq__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_address_equal );
    Py_DECREF( var_address_equal );
    var_address_equal = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_address_equal );
    var_address_equal = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_100___eq__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_101___lt__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *var_address_less = NULL;
    struct Nuitka_FrameObject *frame_93e6fc29e52e68bb6ff597277c93b709;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_93e6fc29e52e68bb6ff597277c93b709 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_93e6fc29e52e68bb6ff597277c93b709, codeobj_93e6fc29e52e68bb6ff597277c93b709, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_93e6fc29e52e68bb6ff597277c93b709 = cache_frame_93e6fc29e52e68bb6ff597277c93b709;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_93e6fc29e52e68bb6ff597277c93b709 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_93e6fc29e52e68bb6ff597277c93b709 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Address );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Address );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv4Address" );
            exception_tb = NULL;

            exception_lineno = 1534;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_self );
        tmp_args_element_name_1 = par_self;
        CHECK_OBJECT( par_other );
        tmp_args_element_name_2 = par_other;
        frame_93e6fc29e52e68bb6ff597277c93b709->m_frame.f_lineno = 1534;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain___lt__, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1534;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_address_less == NULL );
        var_address_less = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( var_address_less );
        tmp_compexpr_left_1 = var_address_less;
        tmp_compexpr_right_1 = Py_NotImplemented;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_NotImplemented;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_1:;
    }
    // Tried code:
    {
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_network );
        if ( tmp_compexpr_left_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1538;
            type_description_1 = "ooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( par_other );
        tmp_source_name_2 = par_other;
        tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_network );
        if ( tmp_compexpr_right_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_2 );

            exception_lineno = 1538;
            type_description_1 = "ooo";
            goto try_except_handler_2;
        }
        tmp_return_value = RICH_COMPARE_LT_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        Py_DECREF( tmp_compexpr_left_2 );
        Py_DECREF( tmp_compexpr_right_2 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1538;
            type_description_1 = "ooo";
            goto try_except_handler_2;
        }
        goto frame_return_exit_1;
    }
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_101___lt__ );
    return NULL;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_93e6fc29e52e68bb6ff597277c93b709 );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_93e6fc29e52e68bb6ff597277c93b709, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_93e6fc29e52e68bb6ff597277c93b709, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        tmp_compexpr_left_3 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_3 = PyExc_AttributeError;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_3, tmp_compexpr_right_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1539;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        tmp_return_value = Py_False;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        goto branch_end_2;
        branch_no_2:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 1537;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_93e6fc29e52e68bb6ff597277c93b709->m_frame) frame_93e6fc29e52e68bb6ff597277c93b709->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
        branch_end_2:;
    }
    // End of try:

#if 1
    RESTORE_FRAME_EXCEPTION( frame_93e6fc29e52e68bb6ff597277c93b709 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_93e6fc29e52e68bb6ff597277c93b709 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_93e6fc29e52e68bb6ff597277c93b709 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_93e6fc29e52e68bb6ff597277c93b709, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_93e6fc29e52e68bb6ff597277c93b709->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_93e6fc29e52e68bb6ff597277c93b709, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_93e6fc29e52e68bb6ff597277c93b709,
        type_description_1,
        par_self,
        par_other,
        var_address_less
    );


    // Release cached frame.
    if ( frame_93e6fc29e52e68bb6ff597277c93b709 == cache_frame_93e6fc29e52e68bb6ff597277c93b709 )
    {
        Py_DECREF( frame_93e6fc29e52e68bb6ff597277c93b709 );
    }
    cache_frame_93e6fc29e52e68bb6ff597277c93b709 = NULL;

    assertFrameObject( frame_93e6fc29e52e68bb6ff597277c93b709 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_101___lt__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    CHECK_OBJECT( (PyObject *)var_address_less );
    Py_DECREF( var_address_less );
    var_address_less = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    Py_XDECREF( var_address_less );
    var_address_less = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_101___lt__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_102___hash__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_5ab60d4e3551fabd11cba7f0c5ccf9ef;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_5ab60d4e3551fabd11cba7f0c5ccf9ef = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5ab60d4e3551fabd11cba7f0c5ccf9ef, codeobj_5ab60d4e3551fabd11cba7f0c5ccf9ef, module_ipaddress, sizeof(void *) );
    frame_5ab60d4e3551fabd11cba7f0c5ccf9ef = cache_frame_5ab60d4e3551fabd11cba7f0c5ccf9ef;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5ab60d4e3551fabd11cba7f0c5ccf9ef );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5ab60d4e3551fabd11cba7f0c5ccf9ef ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_right_name_2;
        PyObject *tmp_int_arg_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_source_name_4;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_left_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__ip );
        if ( tmp_left_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1545;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_right_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__prefixlen );
        if ( tmp_right_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_left_name_2 );

            exception_lineno = 1545;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = BINARY_OPERATION( PyNumber_Xor, tmp_left_name_2, tmp_right_name_1 );
        Py_DECREF( tmp_left_name_2 );
        Py_DECREF( tmp_right_name_1 );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1545;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_4 = par_self;
        tmp_source_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_network );
        if ( tmp_source_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_left_name_1 );

            exception_lineno = 1545;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_int_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_network_address );
        Py_DECREF( tmp_source_name_3 );
        if ( tmp_int_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_left_name_1 );

            exception_lineno = 1545;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_2 = PyNumber_Int( tmp_int_arg_1 );
        Py_DECREF( tmp_int_arg_1 );
        if ( tmp_right_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_left_name_1 );

            exception_lineno = 1545;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = BINARY_OPERATION( PyNumber_Xor, tmp_left_name_1, tmp_right_name_2 );
        Py_DECREF( tmp_left_name_1 );
        Py_DECREF( tmp_right_name_2 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1545;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5ab60d4e3551fabd11cba7f0c5ccf9ef );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_5ab60d4e3551fabd11cba7f0c5ccf9ef );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5ab60d4e3551fabd11cba7f0c5ccf9ef );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5ab60d4e3551fabd11cba7f0c5ccf9ef, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5ab60d4e3551fabd11cba7f0c5ccf9ef->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5ab60d4e3551fabd11cba7f0c5ccf9ef, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5ab60d4e3551fabd11cba7f0c5ccf9ef,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_5ab60d4e3551fabd11cba7f0c5ccf9ef == cache_frame_5ab60d4e3551fabd11cba7f0c5ccf9ef )
    {
        Py_DECREF( frame_5ab60d4e3551fabd11cba7f0c5ccf9ef );
    }
    cache_frame_5ab60d4e3551fabd11cba7f0c5ccf9ef = NULL;

    assertFrameObject( frame_5ab60d4e3551fabd11cba7f0c5ccf9ef );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_102___hash__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_102___hash__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_103_ip( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_efc26b80524c8071b2ab77bc15354df5;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_efc26b80524c8071b2ab77bc15354df5 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_efc26b80524c8071b2ab77bc15354df5, codeobj_efc26b80524c8071b2ab77bc15354df5, module_ipaddress, sizeof(void *) );
    frame_efc26b80524c8071b2ab77bc15354df5 = cache_frame_efc26b80524c8071b2ab77bc15354df5;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_efc26b80524c8071b2ab77bc15354df5 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_efc26b80524c8071b2ab77bc15354df5 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Address );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Address );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv4Address" );
            exception_tb = NULL;

            exception_lineno = 1551;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__ip );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1551;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_efc26b80524c8071b2ab77bc15354df5->m_frame.f_lineno = 1551;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1551;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_efc26b80524c8071b2ab77bc15354df5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_efc26b80524c8071b2ab77bc15354df5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_efc26b80524c8071b2ab77bc15354df5 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_efc26b80524c8071b2ab77bc15354df5, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_efc26b80524c8071b2ab77bc15354df5->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_efc26b80524c8071b2ab77bc15354df5, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_efc26b80524c8071b2ab77bc15354df5,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_efc26b80524c8071b2ab77bc15354df5 == cache_frame_efc26b80524c8071b2ab77bc15354df5 )
    {
        Py_DECREF( frame_efc26b80524c8071b2ab77bc15354df5 );
    }
    cache_frame_efc26b80524c8071b2ab77bc15354df5 = NULL;

    assertFrameObject( frame_efc26b80524c8071b2ab77bc15354df5 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_103_ip );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_103_ip );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_104_with_prefixlen( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_625df4c5b3b8890b0a4145c1af1d8553;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_625df4c5b3b8890b0a4145c1af1d8553 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_625df4c5b3b8890b0a4145c1af1d8553, codeobj_625df4c5b3b8890b0a4145c1af1d8553, module_ipaddress, sizeof(void *) );
    frame_625df4c5b3b8890b0a4145c1af1d8553 = cache_frame_625df4c5b3b8890b0a4145c1af1d8553;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_625df4c5b3b8890b0a4145c1af1d8553 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_625df4c5b3b8890b0a4145c1af1d8553 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_source_name_3;
        tmp_left_name_1 = const_unicode_digest_3f6240938cc8b4c3691344def7c310a8;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__string_from_ip_int );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1555;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ip );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1555;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_625df4c5b3b8890b0a4145c1af1d8553->m_frame.f_lineno = 1555;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_tuple_element_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1555;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_1 = PyTuple_New( 2 );
        PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__prefixlen );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_right_name_1 );

            exception_lineno = 1556;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM( tmp_right_name_1, 1, tmp_tuple_element_1 );
        tmp_return_value = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_right_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1555;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_625df4c5b3b8890b0a4145c1af1d8553 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_625df4c5b3b8890b0a4145c1af1d8553 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_625df4c5b3b8890b0a4145c1af1d8553 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_625df4c5b3b8890b0a4145c1af1d8553, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_625df4c5b3b8890b0a4145c1af1d8553->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_625df4c5b3b8890b0a4145c1af1d8553, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_625df4c5b3b8890b0a4145c1af1d8553,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_625df4c5b3b8890b0a4145c1af1d8553 == cache_frame_625df4c5b3b8890b0a4145c1af1d8553 )
    {
        Py_DECREF( frame_625df4c5b3b8890b0a4145c1af1d8553 );
    }
    cache_frame_625df4c5b3b8890b0a4145c1af1d8553 = NULL;

    assertFrameObject( frame_625df4c5b3b8890b0a4145c1af1d8553 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_104_with_prefixlen );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_104_with_prefixlen );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_105_with_netmask( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_031b9ad4d720268768a4bf8633c574fc;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_031b9ad4d720268768a4bf8633c574fc = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_031b9ad4d720268768a4bf8633c574fc, codeobj_031b9ad4d720268768a4bf8633c574fc, module_ipaddress, sizeof(void *) );
    frame_031b9ad4d720268768a4bf8633c574fc = cache_frame_031b9ad4d720268768a4bf8633c574fc;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_031b9ad4d720268768a4bf8633c574fc );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_031b9ad4d720268768a4bf8633c574fc ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_source_name_3;
        tmp_left_name_1 = const_unicode_digest_3f6240938cc8b4c3691344def7c310a8;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__string_from_ip_int );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1560;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ip );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1560;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_031b9ad4d720268768a4bf8633c574fc->m_frame.f_lineno = 1560;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_tuple_element_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1560;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_1 = PyTuple_New( 2 );
        PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_netmask );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_right_name_1 );

            exception_lineno = 1561;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM( tmp_right_name_1, 1, tmp_tuple_element_1 );
        tmp_return_value = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_right_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1560;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_031b9ad4d720268768a4bf8633c574fc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_031b9ad4d720268768a4bf8633c574fc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_031b9ad4d720268768a4bf8633c574fc );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_031b9ad4d720268768a4bf8633c574fc, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_031b9ad4d720268768a4bf8633c574fc->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_031b9ad4d720268768a4bf8633c574fc, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_031b9ad4d720268768a4bf8633c574fc,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_031b9ad4d720268768a4bf8633c574fc == cache_frame_031b9ad4d720268768a4bf8633c574fc )
    {
        Py_DECREF( frame_031b9ad4d720268768a4bf8633c574fc );
    }
    cache_frame_031b9ad4d720268768a4bf8633c574fc = NULL;

    assertFrameObject( frame_031b9ad4d720268768a4bf8633c574fc );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_105_with_netmask );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_105_with_netmask );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_106_with_hostmask( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_f5cf93a3617c153acb8c04a6ee43a9e3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_f5cf93a3617c153acb8c04a6ee43a9e3 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f5cf93a3617c153acb8c04a6ee43a9e3, codeobj_f5cf93a3617c153acb8c04a6ee43a9e3, module_ipaddress, sizeof(void *) );
    frame_f5cf93a3617c153acb8c04a6ee43a9e3 = cache_frame_f5cf93a3617c153acb8c04a6ee43a9e3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f5cf93a3617c153acb8c04a6ee43a9e3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f5cf93a3617c153acb8c04a6ee43a9e3 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_source_name_3;
        tmp_left_name_1 = const_unicode_digest_3f6240938cc8b4c3691344def7c310a8;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__string_from_ip_int );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1565;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ip );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1565;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_f5cf93a3617c153acb8c04a6ee43a9e3->m_frame.f_lineno = 1565;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_tuple_element_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1565;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_1 = PyTuple_New( 2 );
        PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_hostmask );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_right_name_1 );

            exception_lineno = 1566;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM( tmp_right_name_1, 1, tmp_tuple_element_1 );
        tmp_return_value = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_right_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1565;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f5cf93a3617c153acb8c04a6ee43a9e3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_f5cf93a3617c153acb8c04a6ee43a9e3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f5cf93a3617c153acb8c04a6ee43a9e3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f5cf93a3617c153acb8c04a6ee43a9e3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f5cf93a3617c153acb8c04a6ee43a9e3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f5cf93a3617c153acb8c04a6ee43a9e3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f5cf93a3617c153acb8c04a6ee43a9e3,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_f5cf93a3617c153acb8c04a6ee43a9e3 == cache_frame_f5cf93a3617c153acb8c04a6ee43a9e3 )
    {
        Py_DECREF( frame_f5cf93a3617c153acb8c04a6ee43a9e3 );
    }
    cache_frame_f5cf93a3617c153acb8c04a6ee43a9e3 = NULL;

    assertFrameObject( frame_f5cf93a3617c153acb8c04a6ee43a9e3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_106_with_hostmask );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_106_with_hostmask );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_107___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_address = python_pars[ 1 ];
    PyObject *par_strict = python_pars[ 2 ];
    PyObject *var_addr = NULL;
    PyObject *var_arg = NULL;
    PyObject *var_packed = NULL;
    PyObject *tmp_tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_tuple_unpack_1__source_iter = NULL;
    PyObject *tmp_tuple_unpack_2__element_1 = NULL;
    PyObject *tmp_tuple_unpack_2__element_2 = NULL;
    PyObject *tmp_tuple_unpack_2__source_iter = NULL;
    PyObject *tmp_tuple_unpack_3__element_1 = NULL;
    PyObject *tmp_tuple_unpack_3__element_2 = NULL;
    PyObject *tmp_tuple_unpack_3__source_iter = NULL;
    struct Nuitka_FrameObject *frame_fee12ae33446c0d7b04e9fde4e87b023;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_iterator_attempt;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;
    PyObject *exception_keeper_type_6;
    PyObject *exception_keeper_value_6;
    PyTracebackObject *exception_keeper_tb_6;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_6;
    static struct Nuitka_FrameObject *cache_frame_fee12ae33446c0d7b04e9fde4e87b023 = NULL;
    PyObject *exception_keeper_type_7;
    PyObject *exception_keeper_value_7;
    PyTracebackObject *exception_keeper_tb_7;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_7;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_fee12ae33446c0d7b04e9fde4e87b023, codeobj_fee12ae33446c0d7b04e9fde4e87b023, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_fee12ae33446c0d7b04e9fde4e87b023 = cache_frame_fee12ae33446c0d7b04e9fde4e87b023;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_fee12ae33446c0d7b04e9fde4e87b023 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_fee12ae33446c0d7b04e9fde4e87b023 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__BaseNetwork );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__BaseNetwork );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_BaseNetwork" );
            exception_tb = NULL;

            exception_lineno = 1621;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_self );
        tmp_args_element_name_1 = par_self;
        CHECK_OBJECT( par_address );
        tmp_args_element_name_2 = par_address;
        frame_fee12ae33446c0d7b04e9fde4e87b023->m_frame.f_lineno = 1621;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain___init__, call_args );
        }

        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1621;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT( par_address );
        tmp_isinstance_inst_1 = par_address;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_int_types );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__compat_int_types );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_compat_int_types" );
            exception_tb = NULL;

            exception_lineno = 1624;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_tuple_element_1 = tmp_mvar_value_2;
        tmp_isinstance_cls_1 = PyTuple_New( 2 );
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_isinstance_cls_1, 0, tmp_tuple_element_1 );
        tmp_tuple_element_1 = (PyObject *)&PyString_Type;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_isinstance_cls_1, 1, tmp_tuple_element_1 );
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        Py_DECREF( tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1624;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assattr_name_1;
            PyObject *tmp_called_name_1;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_args_element_name_3;
            PyObject *tmp_assattr_target_1;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Address );

            if (unlikely( tmp_mvar_value_3 == NULL ))
            {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Address );
            }

            if ( tmp_mvar_value_3 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv4Address" );
                exception_tb = NULL;

                exception_lineno = 1625;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_1 = tmp_mvar_value_3;
            CHECK_OBJECT( par_address );
            tmp_args_element_name_3 = par_address;
            frame_fee12ae33446c0d7b04e9fde4e87b023->m_frame.f_lineno = 1625;
            {
                PyObject *call_args[] = { tmp_args_element_name_3 };
                tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
            }

            if ( tmp_assattr_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1625;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_assattr_target_1 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_network_address, tmp_assattr_name_1 );
            Py_DECREF( tmp_assattr_name_1 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1625;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
        }
        // Tried code:
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_iter_arg_1;
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_1;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_source_name_2;
            CHECK_OBJECT( par_self );
            tmp_source_name_1 = par_self;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__make_netmask );
            if ( tmp_called_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1626;
                type_description_1 = "oooooo";
                goto try_except_handler_2;
            }
            CHECK_OBJECT( par_self );
            tmp_source_name_2 = par_self;
            tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__max_prefixlen );
            if ( tmp_args_element_name_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_2 );

                exception_lineno = 1627;
                type_description_1 = "oooooo";
                goto try_except_handler_2;
            }
            frame_fee12ae33446c0d7b04e9fde4e87b023->m_frame.f_lineno = 1626;
            {
                PyObject *call_args[] = { tmp_args_element_name_4 };
                tmp_iter_arg_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
            }

            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_4 );
            if ( tmp_iter_arg_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1626;
                type_description_1 = "oooooo";
                goto try_except_handler_2;
            }
            tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
            Py_DECREF( tmp_iter_arg_1 );
            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1626;
                type_description_1 = "oooooo";
                goto try_except_handler_2;
            }
            assert( tmp_tuple_unpack_1__source_iter == NULL );
            tmp_tuple_unpack_1__source_iter = tmp_assign_source_1;
        }
        // Tried code:
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_unpack_1;
            CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
            tmp_unpack_1 = tmp_tuple_unpack_1__source_iter;
            tmp_assign_source_2 = UNPACK_NEXT( tmp_unpack_1, 0 );
            if ( tmp_assign_source_2 == NULL )
            {
                if ( !ERROR_OCCURRED() )
                {
                    exception_type = PyExc_StopIteration;
                    Py_INCREF( exception_type );
                    exception_value = NULL;
                    exception_tb = NULL;
                }
                else
                {
                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                }


                type_description_1 = "oooooo";
                exception_lineno = 1626;
                goto try_except_handler_3;
            }
            assert( tmp_tuple_unpack_1__element_1 == NULL );
            tmp_tuple_unpack_1__element_1 = tmp_assign_source_2;
        }
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_unpack_2;
            CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
            tmp_unpack_2 = tmp_tuple_unpack_1__source_iter;
            tmp_assign_source_3 = UNPACK_NEXT( tmp_unpack_2, 1 );
            if ( tmp_assign_source_3 == NULL )
            {
                if ( !ERROR_OCCURRED() )
                {
                    exception_type = PyExc_StopIteration;
                    Py_INCREF( exception_type );
                    exception_value = NULL;
                    exception_tb = NULL;
                }
                else
                {
                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                }


                type_description_1 = "oooooo";
                exception_lineno = 1626;
                goto try_except_handler_3;
            }
            assert( tmp_tuple_unpack_1__element_2 == NULL );
            tmp_tuple_unpack_1__element_2 = tmp_assign_source_3;
        }
        {
            PyObject *tmp_iterator_name_1;
            CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
            tmp_iterator_name_1 = tmp_tuple_unpack_1__source_iter;
            // Check if iterator has left-over elements.
            CHECK_OBJECT( tmp_iterator_name_1 ); assert( HAS_ITERNEXT( tmp_iterator_name_1 ) );

            tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_1 )->tp_iternext)( tmp_iterator_name_1 );

            if (likely( tmp_iterator_attempt == NULL ))
            {
                PyObject *error = GET_ERROR_OCCURRED();

                if ( error != NULL )
                {
                    if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
                    {
                        CLEAR_ERROR_OCCURRED();
                    }
                    else
                    {
                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                        type_description_1 = "oooooo";
                        exception_lineno = 1626;
                        goto try_except_handler_3;
                    }
                }
            }
            else
            {
                Py_DECREF( tmp_iterator_attempt );

                // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
                PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
                PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 2)" );
#endif
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                type_description_1 = "oooooo";
                exception_lineno = 1626;
                goto try_except_handler_3;
            }
        }
        goto try_end_1;
        // Exception handler code:
        try_except_handler_3:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
        Py_DECREF( tmp_tuple_unpack_1__source_iter );
        tmp_tuple_unpack_1__source_iter = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto try_except_handler_2;
        // End of try:
        try_end_1:;
        CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
        Py_DECREF( tmp_tuple_unpack_1__source_iter );
        tmp_tuple_unpack_1__source_iter = NULL;

        {
            PyObject *tmp_assattr_name_2;
            PyObject *tmp_assattr_target_2;
            CHECK_OBJECT( tmp_tuple_unpack_1__element_1 );
            tmp_assattr_name_2 = tmp_tuple_unpack_1__element_1;
            CHECK_OBJECT( par_self );
            tmp_assattr_target_2 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain_netmask, tmp_assattr_name_2 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1626;
                type_description_1 = "oooooo";
                goto try_except_handler_2;
            }
        }
        Py_XDECREF( tmp_tuple_unpack_1__element_1 );
        tmp_tuple_unpack_1__element_1 = NULL;

        {
            PyObject *tmp_assattr_name_3;
            PyObject *tmp_assattr_target_3;
            CHECK_OBJECT( tmp_tuple_unpack_1__element_2 );
            tmp_assattr_name_3 = tmp_tuple_unpack_1__element_2;
            CHECK_OBJECT( par_self );
            tmp_assattr_target_3 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain__prefixlen, tmp_assattr_name_3 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1626;
                type_description_1 = "oooooo";
                goto try_except_handler_2;
            }
        }
        goto try_end_2;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_2 = exception_type;
        exception_keeper_value_2 = exception_value;
        exception_keeper_tb_2 = exception_tb;
        exception_keeper_lineno_2 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF( tmp_tuple_unpack_1__element_1 );
        tmp_tuple_unpack_1__element_1 = NULL;

        Py_XDECREF( tmp_tuple_unpack_1__element_2 );
        tmp_tuple_unpack_1__element_2 = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_2;
        exception_value = exception_keeper_value_2;
        exception_tb = exception_keeper_tb_2;
        exception_lineno = exception_keeper_lineno_2;

        goto frame_exception_exit_1;
        // End of try:
        try_end_2:;
        Py_XDECREF( tmp_tuple_unpack_1__element_2 );
        tmp_tuple_unpack_1__element_2 = NULL;

        tmp_return_value = Py_None;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_isinstance_inst_2;
        PyObject *tmp_isinstance_cls_2;
        CHECK_OBJECT( par_address );
        tmp_isinstance_inst_2 = par_address;
        tmp_isinstance_cls_2 = (PyObject *)&PyTuple_Type;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1631;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_compexpr_left_1;
            PyObject *tmp_compexpr_right_1;
            PyObject *tmp_len_arg_1;
            CHECK_OBJECT( par_address );
            tmp_len_arg_1 = par_address;
            tmp_compexpr_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
            if ( tmp_compexpr_left_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1632;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            tmp_compexpr_right_1 = const_int_pos_1;
            tmp_res = RICH_COMPARE_BOOL_GT_OBJECT_INT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
            Py_DECREF( tmp_compexpr_left_1 );
            assert( !(tmp_res == -1) );
            tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_3;
            }
            else
            {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_assign_source_4;
                PyObject *tmp_subscribed_name_1;
                PyObject *tmp_subscript_name_1;
                CHECK_OBJECT( par_address );
                tmp_subscribed_name_1 = par_address;
                tmp_subscript_name_1 = const_int_pos_1;
                tmp_assign_source_4 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_1, tmp_subscript_name_1, 1 );
                if ( tmp_assign_source_4 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1633;
                    type_description_1 = "oooooo";
                    goto frame_exception_exit_1;
                }
                assert( var_arg == NULL );
                var_arg = tmp_assign_source_4;
            }
            goto branch_end_3;
            branch_no_3:;
            {
                PyObject *tmp_assign_source_5;
                PyObject *tmp_source_name_3;
                CHECK_OBJECT( par_self );
                tmp_source_name_3 = par_self;
                tmp_assign_source_5 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__max_prefixlen );
                if ( tmp_assign_source_5 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1636;
                    type_description_1 = "oooooo";
                    goto frame_exception_exit_1;
                }
                assert( var_arg == NULL );
                var_arg = tmp_assign_source_5;
            }
            branch_end_3:;
        }
        {
            PyObject *tmp_assattr_name_4;
            PyObject *tmp_called_name_3;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_args_element_name_5;
            PyObject *tmp_subscribed_name_2;
            PyObject *tmp_subscript_name_2;
            PyObject *tmp_assattr_target_4;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Address );

            if (unlikely( tmp_mvar_value_4 == NULL ))
            {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Address );
            }

            if ( tmp_mvar_value_4 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv4Address" );
                exception_tb = NULL;

                exception_lineno = 1637;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_3 = tmp_mvar_value_4;
            CHECK_OBJECT( par_address );
            tmp_subscribed_name_2 = par_address;
            tmp_subscript_name_2 = const_int_0;
            tmp_args_element_name_5 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_2, tmp_subscript_name_2, 0 );
            if ( tmp_args_element_name_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1637;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            frame_fee12ae33446c0d7b04e9fde4e87b023->m_frame.f_lineno = 1637;
            {
                PyObject *call_args[] = { tmp_args_element_name_5 };
                tmp_assattr_name_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
            }

            Py_DECREF( tmp_args_element_name_5 );
            if ( tmp_assattr_name_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1637;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_assattr_target_4 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_4, const_str_plain_network_address, tmp_assattr_name_4 );
            Py_DECREF( tmp_assattr_name_4 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1637;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
        }
        // Tried code:
        {
            PyObject *tmp_assign_source_6;
            PyObject *tmp_iter_arg_2;
            PyObject *tmp_called_instance_2;
            PyObject *tmp_args_element_name_6;
            CHECK_OBJECT( par_self );
            tmp_called_instance_2 = par_self;
            CHECK_OBJECT( var_arg );
            tmp_args_element_name_6 = var_arg;
            frame_fee12ae33446c0d7b04e9fde4e87b023->m_frame.f_lineno = 1638;
            {
                PyObject *call_args[] = { tmp_args_element_name_6 };
                tmp_iter_arg_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain__make_netmask, call_args );
            }

            if ( tmp_iter_arg_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1638;
                type_description_1 = "oooooo";
                goto try_except_handler_4;
            }
            tmp_assign_source_6 = MAKE_ITERATOR( tmp_iter_arg_2 );
            Py_DECREF( tmp_iter_arg_2 );
            if ( tmp_assign_source_6 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1638;
                type_description_1 = "oooooo";
                goto try_except_handler_4;
            }
            assert( tmp_tuple_unpack_2__source_iter == NULL );
            tmp_tuple_unpack_2__source_iter = tmp_assign_source_6;
        }
        // Tried code:
        {
            PyObject *tmp_assign_source_7;
            PyObject *tmp_unpack_3;
            CHECK_OBJECT( tmp_tuple_unpack_2__source_iter );
            tmp_unpack_3 = tmp_tuple_unpack_2__source_iter;
            tmp_assign_source_7 = UNPACK_NEXT( tmp_unpack_3, 0 );
            if ( tmp_assign_source_7 == NULL )
            {
                if ( !ERROR_OCCURRED() )
                {
                    exception_type = PyExc_StopIteration;
                    Py_INCREF( exception_type );
                    exception_value = NULL;
                    exception_tb = NULL;
                }
                else
                {
                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                }


                type_description_1 = "oooooo";
                exception_lineno = 1638;
                goto try_except_handler_5;
            }
            assert( tmp_tuple_unpack_2__element_1 == NULL );
            tmp_tuple_unpack_2__element_1 = tmp_assign_source_7;
        }
        {
            PyObject *tmp_assign_source_8;
            PyObject *tmp_unpack_4;
            CHECK_OBJECT( tmp_tuple_unpack_2__source_iter );
            tmp_unpack_4 = tmp_tuple_unpack_2__source_iter;
            tmp_assign_source_8 = UNPACK_NEXT( tmp_unpack_4, 1 );
            if ( tmp_assign_source_8 == NULL )
            {
                if ( !ERROR_OCCURRED() )
                {
                    exception_type = PyExc_StopIteration;
                    Py_INCREF( exception_type );
                    exception_value = NULL;
                    exception_tb = NULL;
                }
                else
                {
                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                }


                type_description_1 = "oooooo";
                exception_lineno = 1638;
                goto try_except_handler_5;
            }
            assert( tmp_tuple_unpack_2__element_2 == NULL );
            tmp_tuple_unpack_2__element_2 = tmp_assign_source_8;
        }
        {
            PyObject *tmp_iterator_name_2;
            CHECK_OBJECT( tmp_tuple_unpack_2__source_iter );
            tmp_iterator_name_2 = tmp_tuple_unpack_2__source_iter;
            // Check if iterator has left-over elements.
            CHECK_OBJECT( tmp_iterator_name_2 ); assert( HAS_ITERNEXT( tmp_iterator_name_2 ) );

            tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_2 )->tp_iternext)( tmp_iterator_name_2 );

            if (likely( tmp_iterator_attempt == NULL ))
            {
                PyObject *error = GET_ERROR_OCCURRED();

                if ( error != NULL )
                {
                    if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
                    {
                        CLEAR_ERROR_OCCURRED();
                    }
                    else
                    {
                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                        type_description_1 = "oooooo";
                        exception_lineno = 1638;
                        goto try_except_handler_5;
                    }
                }
            }
            else
            {
                Py_DECREF( tmp_iterator_attempt );

                // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
                PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
                PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 2)" );
#endif
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                type_description_1 = "oooooo";
                exception_lineno = 1638;
                goto try_except_handler_5;
            }
        }
        goto try_end_3;
        // Exception handler code:
        try_except_handler_5:;
        exception_keeper_type_3 = exception_type;
        exception_keeper_value_3 = exception_value;
        exception_keeper_tb_3 = exception_tb;
        exception_keeper_lineno_3 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_2__source_iter );
        Py_DECREF( tmp_tuple_unpack_2__source_iter );
        tmp_tuple_unpack_2__source_iter = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_3;
        exception_value = exception_keeper_value_3;
        exception_tb = exception_keeper_tb_3;
        exception_lineno = exception_keeper_lineno_3;

        goto try_except_handler_4;
        // End of try:
        try_end_3:;
        CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_2__source_iter );
        Py_DECREF( tmp_tuple_unpack_2__source_iter );
        tmp_tuple_unpack_2__source_iter = NULL;

        {
            PyObject *tmp_assattr_name_5;
            PyObject *tmp_assattr_target_5;
            CHECK_OBJECT( tmp_tuple_unpack_2__element_1 );
            tmp_assattr_name_5 = tmp_tuple_unpack_2__element_1;
            CHECK_OBJECT( par_self );
            tmp_assattr_target_5 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_5, const_str_plain_netmask, tmp_assattr_name_5 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1638;
                type_description_1 = "oooooo";
                goto try_except_handler_4;
            }
        }
        Py_XDECREF( tmp_tuple_unpack_2__element_1 );
        tmp_tuple_unpack_2__element_1 = NULL;

        {
            PyObject *tmp_assattr_name_6;
            PyObject *tmp_assattr_target_6;
            CHECK_OBJECT( tmp_tuple_unpack_2__element_2 );
            tmp_assattr_name_6 = tmp_tuple_unpack_2__element_2;
            CHECK_OBJECT( par_self );
            tmp_assattr_target_6 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_6, const_str_plain__prefixlen, tmp_assattr_name_6 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1638;
                type_description_1 = "oooooo";
                goto try_except_handler_4;
            }
        }
        goto try_end_4;
        // Exception handler code:
        try_except_handler_4:;
        exception_keeper_type_4 = exception_type;
        exception_keeper_value_4 = exception_value;
        exception_keeper_tb_4 = exception_tb;
        exception_keeper_lineno_4 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF( tmp_tuple_unpack_2__element_1 );
        tmp_tuple_unpack_2__element_1 = NULL;

        Py_XDECREF( tmp_tuple_unpack_2__element_2 );
        tmp_tuple_unpack_2__element_2 = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_4;
        exception_value = exception_keeper_value_4;
        exception_tb = exception_keeper_tb_4;
        exception_lineno = exception_keeper_lineno_4;

        goto frame_exception_exit_1;
        // End of try:
        try_end_4:;
        Py_XDECREF( tmp_tuple_unpack_2__element_2 );
        tmp_tuple_unpack_2__element_2 = NULL;

        {
            PyObject *tmp_assign_source_9;
            PyObject *tmp_int_arg_1;
            PyObject *tmp_source_name_4;
            CHECK_OBJECT( par_self );
            tmp_source_name_4 = par_self;
            tmp_int_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_network_address );
            if ( tmp_int_arg_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1639;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            tmp_assign_source_9 = PyNumber_Int( tmp_int_arg_1 );
            Py_DECREF( tmp_int_arg_1 );
            if ( tmp_assign_source_9 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1639;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            assert( var_packed == NULL );
            var_packed = tmp_assign_source_9;
        }
        {
            nuitka_bool tmp_condition_result_4;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            PyObject *tmp_int_arg_2;
            PyObject *tmp_source_name_5;
            CHECK_OBJECT( var_packed );
            tmp_left_name_1 = var_packed;
            CHECK_OBJECT( par_self );
            tmp_source_name_5 = par_self;
            tmp_int_arg_2 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_netmask );
            if ( tmp_int_arg_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1640;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            tmp_right_name_1 = PyNumber_Int( tmp_int_arg_2 );
            Py_DECREF( tmp_int_arg_2 );
            if ( tmp_right_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1640;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            tmp_compexpr_left_2 = BINARY_OPERATION( PyNumber_And, tmp_left_name_1, tmp_right_name_1 );
            Py_DECREF( tmp_right_name_1 );
            if ( tmp_compexpr_left_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1640;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_packed );
            tmp_compexpr_right_2 = var_packed;
            tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
            Py_DECREF( tmp_compexpr_left_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1640;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_4 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_4;
            }
            else
            {
                goto branch_no_4;
            }
            branch_yes_4:;
            {
                nuitka_bool tmp_condition_result_5;
                int tmp_truth_name_1;
                CHECK_OBJECT( par_strict );
                tmp_truth_name_1 = CHECK_IF_TRUE( par_strict );
                if ( tmp_truth_name_1 == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1641;
                    type_description_1 = "oooooo";
                    goto frame_exception_exit_1;
                }
                tmp_condition_result_5 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
                {
                    goto branch_yes_5;
                }
                else
                {
                    goto branch_no_5;
                }
                branch_yes_5:;
                {
                    PyObject *tmp_raise_type_1;
                    PyObject *tmp_make_exception_arg_1;
                    PyObject *tmp_left_name_2;
                    PyObject *tmp_right_name_2;
                    tmp_left_name_2 = const_unicode_digest_9cdf3b748ac1a53affbd72eda589ecda;
                    CHECK_OBJECT( par_self );
                    tmp_right_name_2 = par_self;
                    tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_2, tmp_right_name_2 );
                    if ( tmp_make_exception_arg_1 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 1642;
                        type_description_1 = "oooooo";
                        goto frame_exception_exit_1;
                    }
                    frame_fee12ae33446c0d7b04e9fde4e87b023->m_frame.f_lineno = 1642;
                    {
                        PyObject *call_args[] = { tmp_make_exception_arg_1 };
                        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
                    }

                    Py_DECREF( tmp_make_exception_arg_1 );
                    assert( !(tmp_raise_type_1 == NULL) );
                    exception_type = tmp_raise_type_1;
                    exception_lineno = 1642;
                    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                    type_description_1 = "oooooo";
                    goto frame_exception_exit_1;
                }
                goto branch_end_5;
                branch_no_5:;
                {
                    PyObject *tmp_assattr_name_7;
                    PyObject *tmp_called_name_4;
                    PyObject *tmp_mvar_value_5;
                    PyObject *tmp_args_element_name_7;
                    PyObject *tmp_left_name_3;
                    PyObject *tmp_right_name_3;
                    PyObject *tmp_int_arg_3;
                    PyObject *tmp_source_name_6;
                    PyObject *tmp_assattr_target_7;
                    tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Address );

                    if (unlikely( tmp_mvar_value_5 == NULL ))
                    {
                        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Address );
                    }

                    if ( tmp_mvar_value_5 == NULL )
                    {

                        exception_type = PyExc_NameError;
                        Py_INCREF( exception_type );
                        exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv4Address" );
                        exception_tb = NULL;

                        exception_lineno = 1644;
                        type_description_1 = "oooooo";
                        goto frame_exception_exit_1;
                    }

                    tmp_called_name_4 = tmp_mvar_value_5;
                    CHECK_OBJECT( var_packed );
                    tmp_left_name_3 = var_packed;
                    CHECK_OBJECT( par_self );
                    tmp_source_name_6 = par_self;
                    tmp_int_arg_3 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_netmask );
                    if ( tmp_int_arg_3 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 1645;
                        type_description_1 = "oooooo";
                        goto frame_exception_exit_1;
                    }
                    tmp_right_name_3 = PyNumber_Int( tmp_int_arg_3 );
                    Py_DECREF( tmp_int_arg_3 );
                    if ( tmp_right_name_3 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 1645;
                        type_description_1 = "oooooo";
                        goto frame_exception_exit_1;
                    }
                    tmp_args_element_name_7 = BINARY_OPERATION( PyNumber_And, tmp_left_name_3, tmp_right_name_3 );
                    Py_DECREF( tmp_right_name_3 );
                    if ( tmp_args_element_name_7 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 1644;
                        type_description_1 = "oooooo";
                        goto frame_exception_exit_1;
                    }
                    frame_fee12ae33446c0d7b04e9fde4e87b023->m_frame.f_lineno = 1644;
                    {
                        PyObject *call_args[] = { tmp_args_element_name_7 };
                        tmp_assattr_name_7 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
                    }

                    Py_DECREF( tmp_args_element_name_7 );
                    if ( tmp_assattr_name_7 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 1644;
                        type_description_1 = "oooooo";
                        goto frame_exception_exit_1;
                    }
                    CHECK_OBJECT( par_self );
                    tmp_assattr_target_7 = par_self;
                    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_7, const_str_plain_network_address, tmp_assattr_name_7 );
                    Py_DECREF( tmp_assattr_name_7 );
                    if ( tmp_result == false )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 1644;
                        type_description_1 = "oooooo";
                        goto frame_exception_exit_1;
                    }
                }
                branch_end_5:;
            }
            branch_no_4:;
        }
        tmp_return_value = Py_None;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_2:;
    }
    {
        PyObject *tmp_assign_source_10;
        PyObject *tmp_called_name_5;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_args_element_name_8;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__split_optional_netmask );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__split_optional_netmask );
        }

        if ( tmp_mvar_value_6 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_split_optional_netmask" );
            exception_tb = NULL;

            exception_lineno = 1650;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_5 = tmp_mvar_value_6;
        CHECK_OBJECT( par_address );
        tmp_args_element_name_8 = par_address;
        frame_fee12ae33446c0d7b04e9fde4e87b023->m_frame.f_lineno = 1650;
        {
            PyObject *call_args[] = { tmp_args_element_name_8 };
            tmp_assign_source_10 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
        }

        if ( tmp_assign_source_10 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1650;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        assert( var_addr == NULL );
        var_addr = tmp_assign_source_10;
    }
    {
        PyObject *tmp_assattr_name_8;
        PyObject *tmp_called_name_6;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_called_name_7;
        PyObject *tmp_source_name_7;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_subscribed_name_3;
        PyObject *tmp_subscript_name_3;
        PyObject *tmp_assattr_target_8;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Address );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Address );
        }

        if ( tmp_mvar_value_7 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv4Address" );
            exception_tb = NULL;

            exception_lineno = 1651;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_6 = tmp_mvar_value_7;
        CHECK_OBJECT( par_self );
        tmp_source_name_7 = par_self;
        tmp_called_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__ip_int_from_string );
        if ( tmp_called_name_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1651;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_addr );
        tmp_subscribed_name_3 = var_addr;
        tmp_subscript_name_3 = const_int_0;
        tmp_args_element_name_10 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_3, tmp_subscript_name_3, 0 );
        if ( tmp_args_element_name_10 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_7 );

            exception_lineno = 1651;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_fee12ae33446c0d7b04e9fde4e87b023->m_frame.f_lineno = 1651;
        {
            PyObject *call_args[] = { tmp_args_element_name_10 };
            tmp_args_element_name_9 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_7, call_args );
        }

        Py_DECREF( tmp_called_name_7 );
        Py_DECREF( tmp_args_element_name_10 );
        if ( tmp_args_element_name_9 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1651;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_fee12ae33446c0d7b04e9fde4e87b023->m_frame.f_lineno = 1651;
        {
            PyObject *call_args[] = { tmp_args_element_name_9 };
            tmp_assattr_name_8 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, call_args );
        }

        Py_DECREF( tmp_args_element_name_9 );
        if ( tmp_assattr_name_8 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1651;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_8 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_8, const_str_plain_network_address, tmp_assattr_name_8 );
        Py_DECREF( tmp_assattr_name_8 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1651;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        nuitka_bool tmp_condition_result_6;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_len_arg_2;
        CHECK_OBJECT( var_addr );
        tmp_len_arg_2 = var_addr;
        tmp_compexpr_left_3 = BUILTIN_LEN( tmp_len_arg_2 );
        if ( tmp_compexpr_left_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1653;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_3 = const_int_pos_2;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_INT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
        Py_DECREF( tmp_compexpr_left_3 );
        assert( !(tmp_res == -1) );
        tmp_condition_result_6 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_6 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_6;
        }
        else
        {
            goto branch_no_6;
        }
        branch_yes_6:;
        {
            PyObject *tmp_assign_source_11;
            PyObject *tmp_subscribed_name_4;
            PyObject *tmp_subscript_name_4;
            CHECK_OBJECT( var_addr );
            tmp_subscribed_name_4 = var_addr;
            tmp_subscript_name_4 = const_int_pos_1;
            tmp_assign_source_11 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_4, tmp_subscript_name_4, 1 );
            if ( tmp_assign_source_11 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1654;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            assert( var_arg == NULL );
            var_arg = tmp_assign_source_11;
        }
        goto branch_end_6;
        branch_no_6:;
        {
            PyObject *tmp_assign_source_12;
            PyObject *tmp_source_name_8;
            CHECK_OBJECT( par_self );
            tmp_source_name_8 = par_self;
            tmp_assign_source_12 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain__max_prefixlen );
            if ( tmp_assign_source_12 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1656;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            assert( var_arg == NULL );
            var_arg = tmp_assign_source_12;
        }
        branch_end_6:;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_13;
        PyObject *tmp_iter_arg_3;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_args_element_name_11;
        CHECK_OBJECT( par_self );
        tmp_called_instance_3 = par_self;
        CHECK_OBJECT( var_arg );
        tmp_args_element_name_11 = var_arg;
        frame_fee12ae33446c0d7b04e9fde4e87b023->m_frame.f_lineno = 1657;
        {
            PyObject *call_args[] = { tmp_args_element_name_11 };
            tmp_iter_arg_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain__make_netmask, call_args );
        }

        if ( tmp_iter_arg_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1657;
            type_description_1 = "oooooo";
            goto try_except_handler_6;
        }
        tmp_assign_source_13 = MAKE_ITERATOR( tmp_iter_arg_3 );
        Py_DECREF( tmp_iter_arg_3 );
        if ( tmp_assign_source_13 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1657;
            type_description_1 = "oooooo";
            goto try_except_handler_6;
        }
        assert( tmp_tuple_unpack_3__source_iter == NULL );
        tmp_tuple_unpack_3__source_iter = tmp_assign_source_13;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_14;
        PyObject *tmp_unpack_5;
        CHECK_OBJECT( tmp_tuple_unpack_3__source_iter );
        tmp_unpack_5 = tmp_tuple_unpack_3__source_iter;
        tmp_assign_source_14 = UNPACK_NEXT( tmp_unpack_5, 0 );
        if ( tmp_assign_source_14 == NULL )
        {
            if ( !ERROR_OCCURRED() )
            {
                exception_type = PyExc_StopIteration;
                Py_INCREF( exception_type );
                exception_value = NULL;
                exception_tb = NULL;
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            }


            type_description_1 = "oooooo";
            exception_lineno = 1657;
            goto try_except_handler_7;
        }
        assert( tmp_tuple_unpack_3__element_1 == NULL );
        tmp_tuple_unpack_3__element_1 = tmp_assign_source_14;
    }
    {
        PyObject *tmp_assign_source_15;
        PyObject *tmp_unpack_6;
        CHECK_OBJECT( tmp_tuple_unpack_3__source_iter );
        tmp_unpack_6 = tmp_tuple_unpack_3__source_iter;
        tmp_assign_source_15 = UNPACK_NEXT( tmp_unpack_6, 1 );
        if ( tmp_assign_source_15 == NULL )
        {
            if ( !ERROR_OCCURRED() )
            {
                exception_type = PyExc_StopIteration;
                Py_INCREF( exception_type );
                exception_value = NULL;
                exception_tb = NULL;
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            }


            type_description_1 = "oooooo";
            exception_lineno = 1657;
            goto try_except_handler_7;
        }
        assert( tmp_tuple_unpack_3__element_2 == NULL );
        tmp_tuple_unpack_3__element_2 = tmp_assign_source_15;
    }
    {
        PyObject *tmp_iterator_name_3;
        CHECK_OBJECT( tmp_tuple_unpack_3__source_iter );
        tmp_iterator_name_3 = tmp_tuple_unpack_3__source_iter;
        // Check if iterator has left-over elements.
        CHECK_OBJECT( tmp_iterator_name_3 ); assert( HAS_ITERNEXT( tmp_iterator_name_3 ) );

        tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_3 )->tp_iternext)( tmp_iterator_name_3 );

        if (likely( tmp_iterator_attempt == NULL ))
        {
            PyObject *error = GET_ERROR_OCCURRED();

            if ( error != NULL )
            {
                if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
                {
                    CLEAR_ERROR_OCCURRED();
                }
                else
                {
                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                    type_description_1 = "oooooo";
                    exception_lineno = 1657;
                    goto try_except_handler_7;
                }
            }
        }
        else
        {
            Py_DECREF( tmp_iterator_attempt );

            // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
            PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 2)" );
#endif
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

            type_description_1 = "oooooo";
            exception_lineno = 1657;
            goto try_except_handler_7;
        }
    }
    goto try_end_5;
    // Exception handler code:
    try_except_handler_7:;
    exception_keeper_type_5 = exception_type;
    exception_keeper_value_5 = exception_value;
    exception_keeper_tb_5 = exception_tb;
    exception_keeper_lineno_5 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_3__source_iter );
    Py_DECREF( tmp_tuple_unpack_3__source_iter );
    tmp_tuple_unpack_3__source_iter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_5;
    exception_value = exception_keeper_value_5;
    exception_tb = exception_keeper_tb_5;
    exception_lineno = exception_keeper_lineno_5;

    goto try_except_handler_6;
    // End of try:
    try_end_5:;
    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_3__source_iter );
    Py_DECREF( tmp_tuple_unpack_3__source_iter );
    tmp_tuple_unpack_3__source_iter = NULL;

    {
        PyObject *tmp_assattr_name_9;
        PyObject *tmp_assattr_target_9;
        CHECK_OBJECT( tmp_tuple_unpack_3__element_1 );
        tmp_assattr_name_9 = tmp_tuple_unpack_3__element_1;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_9 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_9, const_str_plain_netmask, tmp_assattr_name_9 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1657;
            type_description_1 = "oooooo";
            goto try_except_handler_6;
        }
    }
    Py_XDECREF( tmp_tuple_unpack_3__element_1 );
    tmp_tuple_unpack_3__element_1 = NULL;

    {
        PyObject *tmp_assattr_name_10;
        PyObject *tmp_assattr_target_10;
        CHECK_OBJECT( tmp_tuple_unpack_3__element_2 );
        tmp_assattr_name_10 = tmp_tuple_unpack_3__element_2;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_10 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_10, const_str_plain__prefixlen, tmp_assattr_name_10 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1657;
            type_description_1 = "oooooo";
            goto try_except_handler_6;
        }
    }
    goto try_end_6;
    // Exception handler code:
    try_except_handler_6:;
    exception_keeper_type_6 = exception_type;
    exception_keeper_value_6 = exception_value;
    exception_keeper_tb_6 = exception_tb;
    exception_keeper_lineno_6 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_tuple_unpack_3__element_1 );
    tmp_tuple_unpack_3__element_1 = NULL;

    Py_XDECREF( tmp_tuple_unpack_3__element_2 );
    tmp_tuple_unpack_3__element_2 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_6;
    exception_value = exception_keeper_value_6;
    exception_tb = exception_keeper_tb_6;
    exception_lineno = exception_keeper_lineno_6;

    goto frame_exception_exit_1;
    // End of try:
    try_end_6:;
    Py_XDECREF( tmp_tuple_unpack_3__element_2 );
    tmp_tuple_unpack_3__element_2 = NULL;

    {
        nuitka_bool tmp_condition_result_7;
        int tmp_truth_name_2;
        CHECK_OBJECT( par_strict );
        tmp_truth_name_2 = CHECK_IF_TRUE( par_strict );
        if ( tmp_truth_name_2 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1659;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_7 = tmp_truth_name_2 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_7 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_7;
        }
        else
        {
            goto branch_no_7;
        }
        branch_yes_7:;
        {
            nuitka_bool tmp_condition_result_8;
            PyObject *tmp_compexpr_left_4;
            PyObject *tmp_compexpr_right_4;
            PyObject *tmp_called_name_8;
            PyObject *tmp_mvar_value_8;
            PyObject *tmp_args_element_name_12;
            PyObject *tmp_left_name_4;
            PyObject *tmp_int_arg_4;
            PyObject *tmp_source_name_9;
            PyObject *tmp_right_name_4;
            PyObject *tmp_int_arg_5;
            PyObject *tmp_source_name_10;
            PyObject *tmp_source_name_11;
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Address );

            if (unlikely( tmp_mvar_value_8 == NULL ))
            {
                tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Address );
            }

            if ( tmp_mvar_value_8 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv4Address" );
                exception_tb = NULL;

                exception_lineno = 1660;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_8 = tmp_mvar_value_8;
            CHECK_OBJECT( par_self );
            tmp_source_name_9 = par_self;
            tmp_int_arg_4 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_network_address );
            if ( tmp_int_arg_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1660;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            tmp_left_name_4 = PyNumber_Int( tmp_int_arg_4 );
            Py_DECREF( tmp_int_arg_4 );
            if ( tmp_left_name_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1660;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_source_name_10 = par_self;
            tmp_int_arg_5 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_netmask );
            if ( tmp_int_arg_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_left_name_4 );

                exception_lineno = 1660;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            tmp_right_name_4 = PyNumber_Int( tmp_int_arg_5 );
            Py_DECREF( tmp_int_arg_5 );
            if ( tmp_right_name_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_left_name_4 );

                exception_lineno = 1660;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            tmp_args_element_name_12 = BINARY_OPERATION( PyNumber_And, tmp_left_name_4, tmp_right_name_4 );
            Py_DECREF( tmp_left_name_4 );
            Py_DECREF( tmp_right_name_4 );
            if ( tmp_args_element_name_12 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1660;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            frame_fee12ae33446c0d7b04e9fde4e87b023->m_frame.f_lineno = 1660;
            {
                PyObject *call_args[] = { tmp_args_element_name_12 };
                tmp_compexpr_left_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_8, call_args );
            }

            Py_DECREF( tmp_args_element_name_12 );
            if ( tmp_compexpr_left_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1660;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_source_name_11 = par_self;
            tmp_compexpr_right_4 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain_network_address );
            if ( tmp_compexpr_right_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_compexpr_left_4 );

                exception_lineno = 1661;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_4, tmp_compexpr_right_4 );
            Py_DECREF( tmp_compexpr_left_4 );
            Py_DECREF( tmp_compexpr_right_4 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1660;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_8 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_8 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_8;
            }
            else
            {
                goto branch_no_8;
            }
            branch_yes_8:;
            {
                PyObject *tmp_raise_type_2;
                PyObject *tmp_make_exception_arg_2;
                PyObject *tmp_left_name_5;
                PyObject *tmp_right_name_5;
                tmp_left_name_5 = const_unicode_digest_9cdf3b748ac1a53affbd72eda589ecda;
                CHECK_OBJECT( par_self );
                tmp_right_name_5 = par_self;
                tmp_make_exception_arg_2 = BINARY_OPERATION_REMAINDER( tmp_left_name_5, tmp_right_name_5 );
                if ( tmp_make_exception_arg_2 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1662;
                    type_description_1 = "oooooo";
                    goto frame_exception_exit_1;
                }
                frame_fee12ae33446c0d7b04e9fde4e87b023->m_frame.f_lineno = 1662;
                {
                    PyObject *call_args[] = { tmp_make_exception_arg_2 };
                    tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
                }

                Py_DECREF( tmp_make_exception_arg_2 );
                assert( !(tmp_raise_type_2 == NULL) );
                exception_type = tmp_raise_type_2;
                exception_lineno = 1662;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            branch_no_8:;
        }
        branch_no_7:;
    }
    {
        PyObject *tmp_assattr_name_11;
        PyObject *tmp_called_name_9;
        PyObject *tmp_mvar_value_9;
        PyObject *tmp_args_element_name_13;
        PyObject *tmp_left_name_6;
        PyObject *tmp_int_arg_6;
        PyObject *tmp_source_name_12;
        PyObject *tmp_right_name_6;
        PyObject *tmp_int_arg_7;
        PyObject *tmp_source_name_13;
        PyObject *tmp_assattr_target_11;
        tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Address );

        if (unlikely( tmp_mvar_value_9 == NULL ))
        {
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Address );
        }

        if ( tmp_mvar_value_9 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv4Address" );
            exception_tb = NULL;

            exception_lineno = 1663;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_9 = tmp_mvar_value_9;
        CHECK_OBJECT( par_self );
        tmp_source_name_12 = par_self;
        tmp_int_arg_6 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain_network_address );
        if ( tmp_int_arg_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1663;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_6 = PyNumber_Int( tmp_int_arg_6 );
        Py_DECREF( tmp_int_arg_6 );
        if ( tmp_left_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1663;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_13 = par_self;
        tmp_int_arg_7 = LOOKUP_ATTRIBUTE( tmp_source_name_13, const_str_plain_netmask );
        if ( tmp_int_arg_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_left_name_6 );

            exception_lineno = 1664;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_right_name_6 = PyNumber_Int( tmp_int_arg_7 );
        Py_DECREF( tmp_int_arg_7 );
        if ( tmp_right_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_left_name_6 );

            exception_lineno = 1664;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_13 = BINARY_OPERATION( PyNumber_And, tmp_left_name_6, tmp_right_name_6 );
        Py_DECREF( tmp_left_name_6 );
        Py_DECREF( tmp_right_name_6 );
        if ( tmp_args_element_name_13 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1663;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_fee12ae33446c0d7b04e9fde4e87b023->m_frame.f_lineno = 1663;
        {
            PyObject *call_args[] = { tmp_args_element_name_13 };
            tmp_assattr_name_11 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_9, call_args );
        }

        Py_DECREF( tmp_args_element_name_13 );
        if ( tmp_assattr_name_11 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1663;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_11 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_11, const_str_plain_network_address, tmp_assattr_name_11 );
        Py_DECREF( tmp_assattr_name_11 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1663;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        nuitka_bool tmp_condition_result_9;
        PyObject *tmp_compexpr_left_5;
        PyObject *tmp_compexpr_right_5;
        PyObject *tmp_source_name_14;
        PyObject *tmp_left_name_7;
        PyObject *tmp_source_name_15;
        PyObject *tmp_right_name_7;
        CHECK_OBJECT( par_self );
        tmp_source_name_14 = par_self;
        tmp_compexpr_left_5 = LOOKUP_ATTRIBUTE( tmp_source_name_14, const_str_plain__prefixlen );
        if ( tmp_compexpr_left_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1666;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_15 = par_self;
        tmp_left_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_15, const_str_plain__max_prefixlen );
        if ( tmp_left_name_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_5 );

            exception_lineno = 1666;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_right_name_7 = const_int_pos_1;
        tmp_compexpr_right_5 = BINARY_OPERATION_SUB( tmp_left_name_7, tmp_right_name_7 );
        Py_DECREF( tmp_left_name_7 );
        if ( tmp_compexpr_right_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_5 );

            exception_lineno = 1666;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_5, tmp_compexpr_right_5 );
        Py_DECREF( tmp_compexpr_left_5 );
        Py_DECREF( tmp_compexpr_right_5 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1666;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_9 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_9 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_9;
        }
        else
        {
            goto branch_no_9;
        }
        branch_yes_9:;
        {
            PyObject *tmp_assattr_name_12;
            PyObject *tmp_source_name_16;
            PyObject *tmp_assattr_target_12;
            CHECK_OBJECT( par_self );
            tmp_source_name_16 = par_self;
            tmp_assattr_name_12 = LOOKUP_ATTRIBUTE( tmp_source_name_16, const_str_plain___iter__ );
            if ( tmp_assattr_name_12 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1667;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_assattr_target_12 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_12, const_str_plain_hosts, tmp_assattr_name_12 );
            Py_DECREF( tmp_assattr_name_12 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1667;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
        }
        branch_no_9:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fee12ae33446c0d7b04e9fde4e87b023 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_fee12ae33446c0d7b04e9fde4e87b023 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fee12ae33446c0d7b04e9fde4e87b023 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_fee12ae33446c0d7b04e9fde4e87b023, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_fee12ae33446c0d7b04e9fde4e87b023->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_fee12ae33446c0d7b04e9fde4e87b023, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_fee12ae33446c0d7b04e9fde4e87b023,
        type_description_1,
        par_self,
        par_address,
        par_strict,
        var_addr,
        var_arg,
        var_packed
    );


    // Release cached frame.
    if ( frame_fee12ae33446c0d7b04e9fde4e87b023 == cache_frame_fee12ae33446c0d7b04e9fde4e87b023 )
    {
        Py_DECREF( frame_fee12ae33446c0d7b04e9fde4e87b023 );
    }
    cache_frame_fee12ae33446c0d7b04e9fde4e87b023 = NULL;

    assertFrameObject( frame_fee12ae33446c0d7b04e9fde4e87b023 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_107___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_addr );
    var_addr = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_address );
    Py_DECREF( par_address );
    par_address = NULL;

    CHECK_OBJECT( (PyObject *)par_strict );
    Py_DECREF( par_strict );
    par_strict = NULL;

    Py_XDECREF( var_arg );
    var_arg = NULL;

    Py_XDECREF( var_packed );
    var_packed = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_7 = exception_type;
    exception_keeper_value_7 = exception_value;
    exception_keeper_tb_7 = exception_tb;
    exception_keeper_lineno_7 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_addr );
    var_addr = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_address );
    Py_DECREF( par_address );
    par_address = NULL;

    CHECK_OBJECT( (PyObject *)par_strict );
    Py_DECREF( par_strict );
    par_strict = NULL;

    Py_XDECREF( var_arg );
    var_arg = NULL;

    Py_XDECREF( var_packed );
    var_packed = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_7;
    exception_value = exception_keeper_value_7;
    exception_tb = exception_keeper_tb_7;
    exception_lineno = exception_keeper_lineno_7;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_107___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_108_is_global( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_8f233debdccbd7f23dd58687a18eb3c8;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_8f233debdccbd7f23dd58687a18eb3c8 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8f233debdccbd7f23dd58687a18eb3c8, codeobj_8f233debdccbd7f23dd58687a18eb3c8, module_ipaddress, sizeof(void *) );
    frame_8f233debdccbd7f23dd58687a18eb3c8 = cache_frame_8f233debdccbd7f23dd58687a18eb3c8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8f233debdccbd7f23dd58687a18eb3c8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8f233debdccbd7f23dd58687a18eb3c8 ) == 2 ); // Frame stack

    // Framed code:
    {
        int tmp_and_left_truth_1;
        PyObject *tmp_and_left_value_1;
        PyObject *tmp_and_right_value_1;
        PyObject *tmp_operand_name_1;
        int tmp_and_left_truth_2;
        PyObject *tmp_and_left_value_2;
        PyObject *tmp_and_right_value_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_operand_name_2;
        PyObject *tmp_source_name_3;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_network_address );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1678;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Network );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Network );
        }

        if ( tmp_mvar_value_1 == NULL )
        {
            Py_DECREF( tmp_compexpr_left_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv4Network" );
            exception_tb = NULL;

            exception_lineno = 1678;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        frame_8f233debdccbd7f23dd58687a18eb3c8->m_frame.f_lineno = 1678;
        tmp_compexpr_right_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, &PyTuple_GET_ITEM( const_tuple_unicode_digest_307b618e8fe3dea44ed44b7622abf36e_tuple, 0 ) );

        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_1 );

            exception_lineno = 1678;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_res = PySequence_Contains( tmp_compexpr_right_1, tmp_compexpr_left_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1678;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_2 = ( tmp_res == 1 ) ? Py_True : Py_False;
        tmp_and_left_truth_2 = CHECK_IF_TRUE( tmp_and_left_value_2 );
        if ( tmp_and_left_truth_2 == 1 )
        {
            goto and_right_2;
        }
        else
        {
            goto and_left_2;
        }
        and_right_2:;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_broadcast_address );
        if ( tmp_compexpr_left_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1679;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Network );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Network );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_compexpr_left_2 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv4Network" );
            exception_tb = NULL;

            exception_lineno = 1679;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        frame_8f233debdccbd7f23dd58687a18eb3c8->m_frame.f_lineno = 1679;
        tmp_compexpr_right_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, &PyTuple_GET_ITEM( const_tuple_unicode_digest_307b618e8fe3dea44ed44b7622abf36e_tuple, 0 ) );

        if ( tmp_compexpr_right_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_2 );

            exception_lineno = 1679;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_res = PySequence_Contains( tmp_compexpr_right_2, tmp_compexpr_left_2 );
        Py_DECREF( tmp_compexpr_left_2 );
        Py_DECREF( tmp_compexpr_right_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1679;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_2 = ( tmp_res == 1 ) ? Py_True : Py_False;
        tmp_operand_name_1 = tmp_and_right_value_2;
        goto and_end_2;
        and_left_2:;
        tmp_operand_name_1 = tmp_and_left_value_2;
        and_end_2:;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        assert( !(tmp_res == -1) );
        tmp_and_left_value_1 = ( tmp_res == 0 ) ? Py_True : Py_False;
        tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
        if ( tmp_and_left_truth_1 == 1 )
        {
            goto and_right_1;
        }
        else
        {
            goto and_left_1;
        }
        and_right_1:;
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_operand_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_is_private );
        if ( tmp_operand_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1680;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        Py_DECREF( tmp_operand_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1680;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_1 = ( tmp_res == 0 ) ? Py_True : Py_False;
        tmp_return_value = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_return_value = tmp_and_left_value_1;
        and_end_1:;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8f233debdccbd7f23dd58687a18eb3c8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_8f233debdccbd7f23dd58687a18eb3c8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8f233debdccbd7f23dd58687a18eb3c8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8f233debdccbd7f23dd58687a18eb3c8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8f233debdccbd7f23dd58687a18eb3c8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8f233debdccbd7f23dd58687a18eb3c8, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8f233debdccbd7f23dd58687a18eb3c8,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_8f233debdccbd7f23dd58687a18eb3c8 == cache_frame_8f233debdccbd7f23dd58687a18eb3c8 )
    {
        Py_DECREF( frame_8f233debdccbd7f23dd58687a18eb3c8 );
    }
    cache_frame_8f233debdccbd7f23dd58687a18eb3c8 = NULL;

    assertFrameObject( frame_8f233debdccbd7f23dd58687a18eb3c8 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_108_is_global );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_108_is_global );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_109__make_netmask( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_arg = python_pars[ 1 ];
    PyObject *var_prefixlen = NULL;
    PyObject *var_netmask = NULL;
    struct Nuitka_FrameObject *frame_ab75866f99bb0b58bdf97c9c49b3680d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_ab75866f99bb0b58bdf97c9c49b3680d = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ab75866f99bb0b58bdf97c9c49b3680d, codeobj_ab75866f99bb0b58bdf97c9c49b3680d, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_ab75866f99bb0b58bdf97c9c49b3680d = cache_frame_ab75866f99bb0b58bdf97c9c49b3680d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ab75866f99bb0b58bdf97c9c49b3680d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ab75866f99bb0b58bdf97c9c49b3680d ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_arg );
        tmp_compexpr_left_1 = par_arg;
        CHECK_OBJECT( par_cls );
        tmp_source_name_1 = par_cls;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__netmask_cache );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1747;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_res = PySequence_Contains( tmp_compexpr_right_1, tmp_compexpr_left_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1747;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_isinstance_inst_1;
            PyObject *tmp_isinstance_cls_1;
            PyObject *tmp_mvar_value_1;
            CHECK_OBJECT( par_arg );
            tmp_isinstance_inst_1 = par_arg;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_int_types );

            if (unlikely( tmp_mvar_value_1 == NULL ))
            {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__compat_int_types );
            }

            if ( tmp_mvar_value_1 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_compat_int_types" );
                exception_tb = NULL;

                exception_lineno = 1748;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_isinstance_cls_1 = tmp_mvar_value_1;
            tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1748;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_assign_source_1;
                CHECK_OBJECT( par_arg );
                tmp_assign_source_1 = par_arg;
                assert( var_prefixlen == NULL );
                Py_INCREF( tmp_assign_source_1 );
                var_prefixlen = tmp_assign_source_1;
            }
            goto branch_end_2;
            branch_no_2:;
            {
                PyObject *tmp_assign_source_2;
                PyObject *tmp_called_instance_1;
                PyObject *tmp_args_element_name_1;
                CHECK_OBJECT( par_cls );
                tmp_called_instance_1 = par_cls;
                CHECK_OBJECT( par_arg );
                tmp_args_element_name_1 = par_arg;
                frame_ab75866f99bb0b58bdf97c9c49b3680d->m_frame.f_lineno = 1751;
                {
                    PyObject *call_args[] = { tmp_args_element_name_1 };
                    tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain__prefix_from_prefix_string, call_args );
                }

                if ( tmp_assign_source_2 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1751;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                assert( var_prefixlen == NULL );
                var_prefixlen = tmp_assign_source_2;
            }
            branch_end_2:;
        }
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_called_name_1;
            PyObject *tmp_mvar_value_2;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_called_instance_2;
            PyObject *tmp_args_element_name_3;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Address );

            if (unlikely( tmp_mvar_value_2 == NULL ))
            {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Address );
            }

            if ( tmp_mvar_value_2 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv6Address" );
                exception_tb = NULL;

                exception_lineno = 1752;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_1 = tmp_mvar_value_2;
            CHECK_OBJECT( par_cls );
            tmp_called_instance_2 = par_cls;
            CHECK_OBJECT( var_prefixlen );
            tmp_args_element_name_3 = var_prefixlen;
            frame_ab75866f99bb0b58bdf97c9c49b3680d->m_frame.f_lineno = 1752;
            {
                PyObject *call_args[] = { tmp_args_element_name_3 };
                tmp_args_element_name_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain__ip_int_from_prefix, call_args );
            }

            if ( tmp_args_element_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1752;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            frame_ab75866f99bb0b58bdf97c9c49b3680d->m_frame.f_lineno = 1752;
            {
                PyObject *call_args[] = { tmp_args_element_name_2 };
                tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
            }

            Py_DECREF( tmp_args_element_name_2 );
            if ( tmp_assign_source_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1752;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            assert( var_netmask == NULL );
            var_netmask = tmp_assign_source_3;
        }
        {
            PyObject *tmp_ass_subvalue_1;
            PyObject *tmp_tuple_element_1;
            PyObject *tmp_ass_subscribed_1;
            PyObject *tmp_source_name_2;
            PyObject *tmp_ass_subscript_1;
            CHECK_OBJECT( var_netmask );
            tmp_tuple_element_1 = var_netmask;
            tmp_ass_subvalue_1 = PyTuple_New( 2 );
            Py_INCREF( tmp_tuple_element_1 );
            PyTuple_SET_ITEM( tmp_ass_subvalue_1, 0, tmp_tuple_element_1 );
            CHECK_OBJECT( var_prefixlen );
            tmp_tuple_element_1 = var_prefixlen;
            Py_INCREF( tmp_tuple_element_1 );
            PyTuple_SET_ITEM( tmp_ass_subvalue_1, 1, tmp_tuple_element_1 );
            CHECK_OBJECT( par_cls );
            tmp_source_name_2 = par_cls;
            tmp_ass_subscribed_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__netmask_cache );
            if ( tmp_ass_subscribed_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_ass_subvalue_1 );

                exception_lineno = 1753;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_arg );
            tmp_ass_subscript_1 = par_arg;
            tmp_result = SET_SUBSCRIPT( tmp_ass_subscribed_1, tmp_ass_subscript_1, tmp_ass_subvalue_1 );
            Py_DECREF( tmp_ass_subscribed_1 );
            Py_DECREF( tmp_ass_subvalue_1 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1753;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_subscript_name_1;
        CHECK_OBJECT( par_cls );
        tmp_source_name_3 = par_cls;
        tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__netmask_cache );
        if ( tmp_subscribed_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1754;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_arg );
        tmp_subscript_name_1 = par_arg;
        tmp_return_value = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
        Py_DECREF( tmp_subscribed_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1754;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ab75866f99bb0b58bdf97c9c49b3680d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_ab75866f99bb0b58bdf97c9c49b3680d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ab75866f99bb0b58bdf97c9c49b3680d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ab75866f99bb0b58bdf97c9c49b3680d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ab75866f99bb0b58bdf97c9c49b3680d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ab75866f99bb0b58bdf97c9c49b3680d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ab75866f99bb0b58bdf97c9c49b3680d,
        type_description_1,
        par_cls,
        par_arg,
        var_prefixlen,
        var_netmask
    );


    // Release cached frame.
    if ( frame_ab75866f99bb0b58bdf97c9c49b3680d == cache_frame_ab75866f99bb0b58bdf97c9c49b3680d )
    {
        Py_DECREF( frame_ab75866f99bb0b58bdf97c9c49b3680d );
    }
    cache_frame_ab75866f99bb0b58bdf97c9c49b3680d = NULL;

    assertFrameObject( frame_ab75866f99bb0b58bdf97c9c49b3680d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_109__make_netmask );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_prefixlen );
    var_prefixlen = NULL;

    Py_XDECREF( var_netmask );
    var_netmask = NULL;

    CHECK_OBJECT( (PyObject *)par_arg );
    Py_DECREF( par_arg );
    par_arg = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_prefixlen );
    var_prefixlen = NULL;

    Py_XDECREF( var_netmask );
    var_netmask = NULL;

    CHECK_OBJECT( (PyObject *)par_arg );
    Py_DECREF( par_arg );
    par_arg = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_109__make_netmask );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_110__ip_int_from_string( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_ip_str = python_pars[ 1 ];
    PyObject *var_exc = NULL;
    PyObject *var_ipv4_int = NULL;
    PyObject *var_i = NULL;
    PyObject *var_ip_int = NULL;
    PyObject *var__max_parts = NULL;
    PyObject *var_parts = NULL;
    PyObject *var_skip_index = NULL;
    PyObject *var_parts_lo = NULL;
    PyObject *var_msg = NULL;
    PyObject *var_parts_skipped = NULL;
    PyObject *var_parts_hi = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *tmp_for_loop_2__for_iterator = NULL;
    PyObject *tmp_for_loop_2__iter_value = NULL;
    PyObject *tmp_for_loop_3__for_iterator = NULL;
    PyObject *tmp_for_loop_3__iter_value = NULL;
    struct Nuitka_FrameObject *frame_f90b0be0f90a66a29fbcc60d47edce81;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    int tmp_res;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    bool tmp_result;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;
    static struct Nuitka_FrameObject *cache_frame_f90b0be0f90a66a29fbcc60d47edce81 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_6;
    PyObject *exception_keeper_value_6;
    PyTracebackObject *exception_keeper_tb_6;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_6;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f90b0be0f90a66a29fbcc60d47edce81, codeobj_f90b0be0f90a66a29fbcc60d47edce81, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_f90b0be0f90a66a29fbcc60d47edce81 = cache_frame_f90b0be0f90a66a29fbcc60d47edce81;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f90b0be0f90a66a29fbcc60d47edce81 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f90b0be0f90a66a29fbcc60d47edce81 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        CHECK_OBJECT( par_ip_str );
        tmp_operand_name_1 = par_ip_str;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1770;
            type_description_1 = "ooooooNooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_called_name_1;
            PyObject *tmp_mvar_value_1;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_AddressValueError );

            if (unlikely( tmp_mvar_value_1 == NULL ))
            {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AddressValueError );
            }

            if ( tmp_mvar_value_1 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "AddressValueError" );
                exception_tb = NULL;

                exception_lineno = 1771;
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_1 = tmp_mvar_value_1;
            frame_f90b0be0f90a66a29fbcc60d47edce81->m_frame.f_lineno = 1771;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, &PyTuple_GET_ITEM( const_tuple_unicode_digest_6bc44a3bd13949ad6cfa5e1484201995_tuple, 0 ) );

            if ( tmp_raise_type_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1771;
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }
            exception_type = tmp_raise_type_1;
            exception_lineno = 1771;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooooooNooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        CHECK_OBJECT( par_ip_str );
        tmp_called_instance_1 = par_ip_str;
        frame_f90b0be0f90a66a29fbcc60d47edce81->m_frame.f_lineno = 1773;
        tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_split, &PyTuple_GET_ITEM( const_tuple_unicode_chr_58_tuple, 0 ) );

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1773;
            type_description_1 = "ooooooNooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_parts == NULL );
        var_parts = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_len_arg_1;
        CHECK_OBJECT( var_parts );
        tmp_len_arg_1 = var_parts;
        tmp_compexpr_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1777;
            type_description_1 = "ooooooNooooooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = const_int_pos_3;
        tmp_res = RICH_COMPARE_BOOL_LT_OBJECT_INT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        assert( !(tmp_res == -1) );
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            PyObject *tmp_tuple_element_1;
            tmp_left_name_1 = const_unicode_digest_6525f1cc4fe3bcdb3c861d0842343832;
            tmp_tuple_element_1 = const_int_pos_3;
            tmp_right_name_1 = PyTuple_New( 2 );
            Py_INCREF( tmp_tuple_element_1 );
            PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
            CHECK_OBJECT( par_ip_str );
            tmp_tuple_element_1 = par_ip_str;
            Py_INCREF( tmp_tuple_element_1 );
            PyTuple_SET_ITEM( tmp_right_name_1, 1, tmp_tuple_element_1 );
            tmp_assign_source_2 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
            Py_DECREF( tmp_right_name_1 );
            if ( tmp_assign_source_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1778;
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }
            assert( var_msg == NULL );
            var_msg = tmp_assign_source_2;
        }
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_called_name_2;
            PyObject *tmp_mvar_value_2;
            PyObject *tmp_args_element_name_1;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_AddressValueError );

            if (unlikely( tmp_mvar_value_2 == NULL ))
            {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AddressValueError );
            }

            if ( tmp_mvar_value_2 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "AddressValueError" );
                exception_tb = NULL;

                exception_lineno = 1779;
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_2 = tmp_mvar_value_2;
            CHECK_OBJECT( var_msg );
            tmp_args_element_name_1 = var_msg;
            frame_f90b0be0f90a66a29fbcc60d47edce81->m_frame.f_lineno = 1779;
            {
                PyObject *call_args[] = { tmp_args_element_name_1 };
                tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
            }

            if ( tmp_raise_type_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1779;
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }
            exception_type = tmp_raise_type_2;
            exception_lineno = 1779;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooooooNooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_subscript_name_1;
        tmp_compexpr_left_2 = const_unicode_dot;
        CHECK_OBJECT( var_parts );
        tmp_subscribed_name_1 = var_parts;
        tmp_subscript_name_1 = const_int_neg_1;
        tmp_compexpr_right_2 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_1, tmp_subscript_name_1, -1 );
        if ( tmp_compexpr_right_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1782;
            type_description_1 = "ooooooNooooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = PySequence_Contains( tmp_compexpr_right_2, tmp_compexpr_left_2 );
        Py_DECREF( tmp_compexpr_right_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1782;
            type_description_1 = "ooooooNooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = ( tmp_res == 1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        // Tried code:
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_source_name_1;
            PyObject *tmp_called_name_3;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_called_instance_2;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Address );

            if (unlikely( tmp_mvar_value_3 == NULL ))
            {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Address );
            }

            if ( tmp_mvar_value_3 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv4Address" );
                exception_tb = NULL;

                exception_lineno = 1784;
                type_description_1 = "ooooooNooooooo";
                goto try_except_handler_2;
            }

            tmp_called_name_3 = tmp_mvar_value_3;
            CHECK_OBJECT( var_parts );
            tmp_called_instance_2 = var_parts;
            frame_f90b0be0f90a66a29fbcc60d47edce81->m_frame.f_lineno = 1784;
            tmp_args_element_name_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_pop );
            if ( tmp_args_element_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1784;
                type_description_1 = "ooooooNooooooo";
                goto try_except_handler_2;
            }
            frame_f90b0be0f90a66a29fbcc60d47edce81->m_frame.f_lineno = 1784;
            {
                PyObject *call_args[] = { tmp_args_element_name_2 };
                tmp_source_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
            }

            Py_DECREF( tmp_args_element_name_2 );
            if ( tmp_source_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1784;
                type_description_1 = "ooooooNooooooo";
                goto try_except_handler_2;
            }
            tmp_assign_source_3 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__ip );
            Py_DECREF( tmp_source_name_1 );
            if ( tmp_assign_source_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1784;
                type_description_1 = "ooooooNooooooo";
                goto try_except_handler_2;
            }
            assert( var_ipv4_int == NULL );
            var_ipv4_int = tmp_assign_source_3;
        }
        goto try_end_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Preserve existing published exception.
        PRESERVE_FRAME_EXCEPTION( frame_f90b0be0f90a66a29fbcc60d47edce81 );
        if ( exception_keeper_tb_1 == NULL )
        {
            exception_keeper_tb_1 = MAKE_TRACEBACK( frame_f90b0be0f90a66a29fbcc60d47edce81, exception_keeper_lineno_1 );
        }
        else if ( exception_keeper_lineno_1 != 0 )
        {
            exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_f90b0be0f90a66a29fbcc60d47edce81, exception_keeper_lineno_1 );
        }

        NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
        PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
        {
            nuitka_bool tmp_condition_result_4;
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            PyObject *tmp_mvar_value_4;
            tmp_compexpr_left_3 = EXC_TYPE(PyThreadState_GET());
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_AddressValueError );

            if (unlikely( tmp_mvar_value_4 == NULL ))
            {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AddressValueError );
            }

            if ( tmp_mvar_value_4 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "AddressValueError" );
                exception_tb = NULL;

                exception_lineno = 1785;
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_3 = tmp_mvar_value_4;
            tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_3, tmp_compexpr_right_3 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1785;
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_4 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_4;
            }
            else
            {
                goto branch_no_4;
            }
            branch_yes_4:;
            {
                PyObject *tmp_assign_source_4;
                tmp_assign_source_4 = EXC_VALUE(PyThreadState_GET());
                assert( var_exc == NULL );
                Py_INCREF( tmp_assign_source_4 );
                var_exc = tmp_assign_source_4;
            }
            {
                PyObject *tmp_raise_type_3;
                PyObject *tmp_called_name_4;
                PyObject *tmp_mvar_value_5;
                PyObject *tmp_args_element_name_3;
                PyObject *tmp_left_name_2;
                PyObject *tmp_right_name_2;
                PyObject *tmp_tuple_element_2;
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_AddressValueError );

                if (unlikely( tmp_mvar_value_5 == NULL ))
                {
                    tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AddressValueError );
                }

                if ( tmp_mvar_value_5 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "AddressValueError" );
                    exception_tb = NULL;

                    exception_lineno = 1786;
                    type_description_1 = "ooooooNooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_name_4 = tmp_mvar_value_5;
                tmp_left_name_2 = const_unicode_digest_3d11cbcbf80fa8d2b7c658c556c6918d;
                CHECK_OBJECT( var_exc );
                tmp_tuple_element_2 = var_exc;
                tmp_right_name_2 = PyTuple_New( 2 );
                Py_INCREF( tmp_tuple_element_2 );
                PyTuple_SET_ITEM( tmp_right_name_2, 0, tmp_tuple_element_2 );
                CHECK_OBJECT( par_ip_str );
                tmp_tuple_element_2 = par_ip_str;
                Py_INCREF( tmp_tuple_element_2 );
                PyTuple_SET_ITEM( tmp_right_name_2, 1, tmp_tuple_element_2 );
                tmp_args_element_name_3 = BINARY_OPERATION_REMAINDER( tmp_left_name_2, tmp_right_name_2 );
                Py_DECREF( tmp_right_name_2 );
                if ( tmp_args_element_name_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1786;
                    type_description_1 = "ooooooNooooooo";
                    goto frame_exception_exit_1;
                }
                frame_f90b0be0f90a66a29fbcc60d47edce81->m_frame.f_lineno = 1786;
                {
                    PyObject *call_args[] = { tmp_args_element_name_3 };
                    tmp_raise_type_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
                }

                Py_DECREF( tmp_args_element_name_3 );
                if ( tmp_raise_type_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1786;
                    type_description_1 = "ooooooNooooooo";
                    goto frame_exception_exit_1;
                }
                exception_type = tmp_raise_type_3;
                exception_lineno = 1786;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }
            goto branch_end_4;
            branch_no_4:;
            tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            if (unlikely( tmp_result == false ))
            {
                exception_lineno = 1783;
            }

            if (exception_tb && exception_tb->tb_frame == &frame_f90b0be0f90a66a29fbcc60d47edce81->m_frame) frame_f90b0be0f90a66a29fbcc60d47edce81->m_frame.f_lineno = exception_tb->tb_lineno;
            type_description_1 = "ooooooNooooooo";
            goto frame_exception_exit_1;
            branch_end_4:;
        }
        // End of try:
        try_end_1:;
        {
            PyObject *tmp_called_name_5;
            PyObject *tmp_source_name_2;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_left_name_3;
            PyObject *tmp_right_name_3;
            PyObject *tmp_left_name_4;
            PyObject *tmp_left_name_5;
            PyObject *tmp_right_name_4;
            PyObject *tmp_right_name_5;
            CHECK_OBJECT( var_parts );
            tmp_source_name_2 = var_parts;
            tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_append );
            if ( tmp_called_name_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1787;
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }
            tmp_left_name_3 = const_unicode_digest_1cfaa7410665eaa83a33dc9c2b2ef5a2;
            CHECK_OBJECT( var_ipv4_int );
            tmp_left_name_5 = var_ipv4_int;
            tmp_right_name_4 = const_int_pos_16;
            tmp_left_name_4 = BINARY_OPERATION( PyNumber_Rshift, tmp_left_name_5, tmp_right_name_4 );
            if ( tmp_left_name_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_5 );

                exception_lineno = 1787;
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }
            tmp_right_name_5 = const_int_pos_65535;
            tmp_right_name_3 = BINARY_OPERATION( PyNumber_And, tmp_left_name_4, tmp_right_name_5 );
            Py_DECREF( tmp_left_name_4 );
            if ( tmp_right_name_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_5 );

                exception_lineno = 1787;
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }
            tmp_args_element_name_4 = BINARY_OPERATION_REMAINDER( tmp_left_name_3, tmp_right_name_3 );
            Py_DECREF( tmp_right_name_3 );
            if ( tmp_args_element_name_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_5 );

                exception_lineno = 1787;
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }
            frame_f90b0be0f90a66a29fbcc60d47edce81->m_frame.f_lineno = 1787;
            {
                PyObject *call_args[] = { tmp_args_element_name_4 };
                tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
            }

            Py_DECREF( tmp_called_name_5 );
            Py_DECREF( tmp_args_element_name_4 );
            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1787;
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        {
            PyObject *tmp_called_name_6;
            PyObject *tmp_source_name_3;
            PyObject *tmp_call_result_2;
            PyObject *tmp_args_element_name_5;
            PyObject *tmp_left_name_6;
            PyObject *tmp_right_name_6;
            PyObject *tmp_left_name_7;
            PyObject *tmp_right_name_7;
            CHECK_OBJECT( var_parts );
            tmp_source_name_3 = var_parts;
            tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_append );
            if ( tmp_called_name_6 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1788;
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }
            tmp_left_name_6 = const_unicode_digest_1cfaa7410665eaa83a33dc9c2b2ef5a2;
            CHECK_OBJECT( var_ipv4_int );
            tmp_left_name_7 = var_ipv4_int;
            tmp_right_name_7 = const_int_pos_65535;
            tmp_right_name_6 = BINARY_OPERATION( PyNumber_And, tmp_left_name_7, tmp_right_name_7 );
            if ( tmp_right_name_6 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_6 );

                exception_lineno = 1788;
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }
            tmp_args_element_name_5 = BINARY_OPERATION_REMAINDER( tmp_left_name_6, tmp_right_name_6 );
            Py_DECREF( tmp_right_name_6 );
            if ( tmp_args_element_name_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_6 );

                exception_lineno = 1788;
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }
            frame_f90b0be0f90a66a29fbcc60d47edce81->m_frame.f_lineno = 1788;
            {
                PyObject *call_args[] = { tmp_args_element_name_5 };
                tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, call_args );
            }

            Py_DECREF( tmp_called_name_6 );
            Py_DECREF( tmp_args_element_name_5 );
            if ( tmp_call_result_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1788;
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_2 );
        }
        branch_no_3:;
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_left_name_8;
        PyObject *tmp_source_name_4;
        PyObject *tmp_right_name_8;
        CHECK_OBJECT( par_cls );
        tmp_source_name_4 = par_cls;
        tmp_left_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__HEXTET_COUNT );
        if ( tmp_left_name_8 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1793;
            type_description_1 = "ooooooNooooooo";
            goto frame_exception_exit_1;
        }
        tmp_right_name_8 = const_int_pos_1;
        tmp_assign_source_5 = BINARY_OPERATION_ADD_OBJECT_INT( tmp_left_name_8, tmp_right_name_8 );
        Py_DECREF( tmp_left_name_8 );
        if ( tmp_assign_source_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1793;
            type_description_1 = "ooooooNooooooo";
            goto frame_exception_exit_1;
        }
        assert( var__max_parts == NULL );
        var__max_parts = tmp_assign_source_5;
    }
    {
        nuitka_bool tmp_condition_result_5;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        PyObject *tmp_len_arg_2;
        CHECK_OBJECT( var_parts );
        tmp_len_arg_2 = var_parts;
        tmp_compexpr_left_4 = BUILTIN_LEN( tmp_len_arg_2 );
        if ( tmp_compexpr_left_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1794;
            type_description_1 = "ooooooNooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var__max_parts );
        tmp_compexpr_right_4 = var__max_parts;
        tmp_res = RICH_COMPARE_BOOL_GT_OBJECT_OBJECT( tmp_compexpr_left_4, tmp_compexpr_right_4 );
        Py_DECREF( tmp_compexpr_left_4 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1794;
            type_description_1 = "ooooooNooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_5 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_5;
        }
        else
        {
            goto branch_no_5;
        }
        branch_yes_5:;
        {
            PyObject *tmp_assign_source_6;
            PyObject *tmp_left_name_9;
            PyObject *tmp_right_name_9;
            PyObject *tmp_tuple_element_3;
            PyObject *tmp_left_name_10;
            PyObject *tmp_right_name_10;
            tmp_left_name_9 = const_unicode_digest_b42e9aabcda64e41c569cb9a106baed7;
            CHECK_OBJECT( var__max_parts );
            tmp_left_name_10 = var__max_parts;
            tmp_right_name_10 = const_int_pos_1;
            tmp_tuple_element_3 = BINARY_OPERATION_SUB( tmp_left_name_10, tmp_right_name_10 );
            if ( tmp_tuple_element_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1796;
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }
            tmp_right_name_9 = PyTuple_New( 2 );
            PyTuple_SET_ITEM( tmp_right_name_9, 0, tmp_tuple_element_3 );
            CHECK_OBJECT( par_ip_str );
            tmp_tuple_element_3 = par_ip_str;
            Py_INCREF( tmp_tuple_element_3 );
            PyTuple_SET_ITEM( tmp_right_name_9, 1, tmp_tuple_element_3 );
            tmp_assign_source_6 = BINARY_OPERATION_REMAINDER( tmp_left_name_9, tmp_right_name_9 );
            Py_DECREF( tmp_right_name_9 );
            if ( tmp_assign_source_6 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1795;
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }
            assert( var_msg == NULL );
            var_msg = tmp_assign_source_6;
        }
        {
            PyObject *tmp_raise_type_4;
            PyObject *tmp_called_name_7;
            PyObject *tmp_mvar_value_6;
            PyObject *tmp_args_element_name_6;
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_AddressValueError );

            if (unlikely( tmp_mvar_value_6 == NULL ))
            {
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AddressValueError );
            }

            if ( tmp_mvar_value_6 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "AddressValueError" );
                exception_tb = NULL;

                exception_lineno = 1797;
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_7 = tmp_mvar_value_6;
            CHECK_OBJECT( var_msg );
            tmp_args_element_name_6 = var_msg;
            frame_f90b0be0f90a66a29fbcc60d47edce81->m_frame.f_lineno = 1797;
            {
                PyObject *call_args[] = { tmp_args_element_name_6 };
                tmp_raise_type_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_7, call_args );
            }

            if ( tmp_raise_type_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1797;
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }
            exception_type = tmp_raise_type_4;
            exception_lineno = 1797;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooooooNooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_5:;
    }
    {
        PyObject *tmp_assign_source_7;
        tmp_assign_source_7 = Py_None;
        assert( var_skip_index == NULL );
        Py_INCREF( tmp_assign_source_7 );
        var_skip_index = tmp_assign_source_7;
    }
    {
        PyObject *tmp_assign_source_8;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_called_name_8;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_left_name_11;
        PyObject *tmp_len_arg_3;
        PyObject *tmp_right_name_11;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_range );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__compat_range );
        }

        if ( tmp_mvar_value_7 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_compat_range" );
            exception_tb = NULL;

            exception_lineno = 1802;
            type_description_1 = "ooooooNooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_8 = tmp_mvar_value_7;
        tmp_args_element_name_7 = const_int_pos_1;
        CHECK_OBJECT( var_parts );
        tmp_len_arg_3 = var_parts;
        tmp_left_name_11 = BUILTIN_LEN( tmp_len_arg_3 );
        if ( tmp_left_name_11 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1802;
            type_description_1 = "ooooooNooooooo";
            goto frame_exception_exit_1;
        }
        tmp_right_name_11 = const_int_pos_1;
        tmp_args_element_name_8 = BINARY_OPERATION_SUB( tmp_left_name_11, tmp_right_name_11 );
        Py_DECREF( tmp_left_name_11 );
        if ( tmp_args_element_name_8 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1802;
            type_description_1 = "ooooooNooooooo";
            goto frame_exception_exit_1;
        }
        frame_f90b0be0f90a66a29fbcc60d47edce81->m_frame.f_lineno = 1802;
        {
            PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8 };
            tmp_iter_arg_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_8, call_args );
        }

        Py_DECREF( tmp_args_element_name_8 );
        if ( tmp_iter_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1802;
            type_description_1 = "ooooooNooooooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_8 = MAKE_ITERATOR( tmp_iter_arg_1 );
        Py_DECREF( tmp_iter_arg_1 );
        if ( tmp_assign_source_8 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1802;
            type_description_1 = "ooooooNooooooo";
            goto frame_exception_exit_1;
        }
        assert( tmp_for_loop_1__for_iterator == NULL );
        tmp_for_loop_1__for_iterator = tmp_assign_source_8;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_9;
        CHECK_OBJECT( tmp_for_loop_1__for_iterator );
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_9 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_9 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "ooooooNooooooo";
                exception_lineno = 1802;
                goto try_except_handler_3;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_9;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_10;
        CHECK_OBJECT( tmp_for_loop_1__iter_value );
        tmp_assign_source_10 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_i;
            var_i = tmp_assign_source_10;
            Py_INCREF( var_i );
            Py_XDECREF( old );
        }

    }
    {
        nuitka_bool tmp_condition_result_6;
        PyObject *tmp_operand_name_2;
        PyObject *tmp_subscribed_name_2;
        PyObject *tmp_subscript_name_2;
        CHECK_OBJECT( var_parts );
        tmp_subscribed_name_2 = var_parts;
        CHECK_OBJECT( var_i );
        tmp_subscript_name_2 = var_i;
        tmp_operand_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
        if ( tmp_operand_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1803;
            type_description_1 = "ooooooNooooooo";
            goto try_except_handler_3;
        }
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        Py_DECREF( tmp_operand_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1803;
            type_description_1 = "ooooooNooooooo";
            goto try_except_handler_3;
        }
        tmp_condition_result_6 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_6 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_6;
        }
        else
        {
            goto branch_no_6;
        }
        branch_yes_6:;
        {
            nuitka_bool tmp_condition_result_7;
            PyObject *tmp_compexpr_left_5;
            PyObject *tmp_compexpr_right_5;
            if ( var_skip_index == NULL )
            {

                exception_type = PyExc_UnboundLocalError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "skip_index" );
                exception_tb = NULL;

                exception_lineno = 1804;
                type_description_1 = "ooooooNooooooo";
                goto try_except_handler_3;
            }

            tmp_compexpr_left_5 = var_skip_index;
            tmp_compexpr_right_5 = Py_None;
            tmp_condition_result_7 = ( tmp_compexpr_left_5 != tmp_compexpr_right_5 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_7 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_7;
            }
            else
            {
                goto branch_no_7;
            }
            branch_yes_7:;
            {
                PyObject *tmp_assign_source_11;
                PyObject *tmp_left_name_12;
                PyObject *tmp_right_name_12;
                tmp_left_name_12 = const_unicode_digest_24e54315d820212332afec6f6ec23e9d;
                CHECK_OBJECT( par_ip_str );
                tmp_right_name_12 = par_ip_str;
                tmp_assign_source_11 = BINARY_OPERATION_REMAINDER( tmp_left_name_12, tmp_right_name_12 );
                if ( tmp_assign_source_11 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1806;
                    type_description_1 = "ooooooNooooooo";
                    goto try_except_handler_3;
                }
                assert( var_msg == NULL );
                var_msg = tmp_assign_source_11;
            }
            {
                PyObject *tmp_raise_type_5;
                PyObject *tmp_called_name_9;
                PyObject *tmp_mvar_value_8;
                PyObject *tmp_args_element_name_9;
                tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_AddressValueError );

                if (unlikely( tmp_mvar_value_8 == NULL ))
                {
                    tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AddressValueError );
                }

                if ( tmp_mvar_value_8 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "AddressValueError" );
                    exception_tb = NULL;

                    exception_lineno = 1807;
                    type_description_1 = "ooooooNooooooo";
                    goto try_except_handler_3;
                }

                tmp_called_name_9 = tmp_mvar_value_8;
                CHECK_OBJECT( var_msg );
                tmp_args_element_name_9 = var_msg;
                frame_f90b0be0f90a66a29fbcc60d47edce81->m_frame.f_lineno = 1807;
                {
                    PyObject *call_args[] = { tmp_args_element_name_9 };
                    tmp_raise_type_5 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_9, call_args );
                }

                if ( tmp_raise_type_5 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1807;
                    type_description_1 = "ooooooNooooooo";
                    goto try_except_handler_3;
                }
                exception_type = tmp_raise_type_5;
                exception_lineno = 1807;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "ooooooNooooooo";
                goto try_except_handler_3;
            }
            branch_no_7:;
        }
        {
            PyObject *tmp_assign_source_12;
            CHECK_OBJECT( var_i );
            tmp_assign_source_12 = var_i;
            {
                PyObject *old = var_skip_index;
                var_skip_index = tmp_assign_source_12;
                Py_INCREF( var_skip_index );
                Py_XDECREF( old );
            }

        }
        branch_no_6:;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1802;
        type_description_1 = "ooooooNooooooo";
        goto try_except_handler_3;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    {
        nuitka_bool tmp_condition_result_8;
        PyObject *tmp_compexpr_left_6;
        PyObject *tmp_compexpr_right_6;
        if ( var_skip_index == NULL )
        {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "skip_index" );
            exception_tb = NULL;

            exception_lineno = 1812;
            type_description_1 = "ooooooNooooooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_left_6 = var_skip_index;
        tmp_compexpr_right_6 = Py_None;
        tmp_condition_result_8 = ( tmp_compexpr_left_6 != tmp_compexpr_right_6 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_8 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_8;
        }
        else
        {
            goto branch_no_8;
        }
        branch_yes_8:;
        {
            PyObject *tmp_assign_source_13;
            if ( var_skip_index == NULL )
            {

                exception_type = PyExc_UnboundLocalError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "skip_index" );
                exception_tb = NULL;

                exception_lineno = 1814;
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }

            tmp_assign_source_13 = var_skip_index;
            assert( var_parts_hi == NULL );
            Py_INCREF( tmp_assign_source_13 );
            var_parts_hi = tmp_assign_source_13;
        }
        {
            PyObject *tmp_assign_source_14;
            PyObject *tmp_left_name_13;
            PyObject *tmp_left_name_14;
            PyObject *tmp_len_arg_4;
            PyObject *tmp_right_name_13;
            PyObject *tmp_right_name_14;
            CHECK_OBJECT( var_parts );
            tmp_len_arg_4 = var_parts;
            tmp_left_name_14 = BUILTIN_LEN( tmp_len_arg_4 );
            if ( tmp_left_name_14 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1815;
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }
            if ( var_skip_index == NULL )
            {
                Py_DECREF( tmp_left_name_14 );
                exception_type = PyExc_UnboundLocalError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "skip_index" );
                exception_tb = NULL;

                exception_lineno = 1815;
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }

            tmp_right_name_13 = var_skip_index;
            tmp_left_name_13 = BINARY_OPERATION_SUB( tmp_left_name_14, tmp_right_name_13 );
            Py_DECREF( tmp_left_name_14 );
            if ( tmp_left_name_13 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1815;
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }
            tmp_right_name_14 = const_int_pos_1;
            tmp_assign_source_14 = BINARY_OPERATION_SUB( tmp_left_name_13, tmp_right_name_14 );
            Py_DECREF( tmp_left_name_13 );
            if ( tmp_assign_source_14 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1815;
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }
            assert( var_parts_lo == NULL );
            var_parts_lo = tmp_assign_source_14;
        }
        {
            nuitka_bool tmp_condition_result_9;
            PyObject *tmp_operand_name_3;
            PyObject *tmp_subscribed_name_3;
            PyObject *tmp_subscript_name_3;
            CHECK_OBJECT( var_parts );
            tmp_subscribed_name_3 = var_parts;
            tmp_subscript_name_3 = const_int_0;
            tmp_operand_name_3 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_3, tmp_subscript_name_3, 0 );
            if ( tmp_operand_name_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1816;
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_3 );
            Py_DECREF( tmp_operand_name_3 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1816;
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_9 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_9 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_9;
            }
            else
            {
                goto branch_no_9;
            }
            branch_yes_9:;
            {
                PyObject *tmp_assign_source_15;
                PyObject *tmp_left_name_15;
                PyObject *tmp_right_name_15;
                CHECK_OBJECT( var_parts_hi );
                tmp_left_name_15 = var_parts_hi;
                tmp_right_name_15 = const_int_pos_1;
                tmp_result = BINARY_OPERATION_INPLACE( PyNumber_InPlaceSubtract, &tmp_left_name_15, tmp_right_name_15 );
                if ( tmp_result == false )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1817;
                    type_description_1 = "ooooooNooooooo";
                    goto frame_exception_exit_1;
                }
                tmp_assign_source_15 = tmp_left_name_15;
                var_parts_hi = tmp_assign_source_15;

            }
            {
                nuitka_bool tmp_condition_result_10;
                int tmp_truth_name_1;
                CHECK_OBJECT( var_parts_hi );
                tmp_truth_name_1 = CHECK_IF_TRUE( var_parts_hi );
                if ( tmp_truth_name_1 == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1818;
                    type_description_1 = "ooooooNooooooo";
                    goto frame_exception_exit_1;
                }
                tmp_condition_result_10 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                if ( tmp_condition_result_10 == NUITKA_BOOL_TRUE )
                {
                    goto branch_yes_10;
                }
                else
                {
                    goto branch_no_10;
                }
                branch_yes_10:;
                {
                    PyObject *tmp_raise_type_6;
                    PyObject *tmp_called_name_10;
                    PyObject *tmp_mvar_value_9;
                    PyObject *tmp_args_element_name_10;
                    PyObject *tmp_left_name_16;
                    PyObject *tmp_right_name_16;
                    tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_AddressValueError );

                    if (unlikely( tmp_mvar_value_9 == NULL ))
                    {
                        tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AddressValueError );
                    }

                    if ( tmp_mvar_value_9 == NULL )
                    {

                        exception_type = PyExc_NameError;
                        Py_INCREF( exception_type );
                        exception_value = PyString_FromFormat( "global name '%s' is not defined", "AddressValueError" );
                        exception_tb = NULL;

                        exception_lineno = 1820;
                        type_description_1 = "ooooooNooooooo";
                        goto frame_exception_exit_1;
                    }

                    tmp_called_name_10 = tmp_mvar_value_9;
                    tmp_left_name_16 = const_unicode_digest_2cede8cd7bf3896918371527eb9b7688;
                    CHECK_OBJECT( par_ip_str );
                    tmp_right_name_16 = par_ip_str;
                    tmp_args_element_name_10 = BINARY_OPERATION_REMAINDER( tmp_left_name_16, tmp_right_name_16 );
                    if ( tmp_args_element_name_10 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 1820;
                        type_description_1 = "ooooooNooooooo";
                        goto frame_exception_exit_1;
                    }
                    frame_f90b0be0f90a66a29fbcc60d47edce81->m_frame.f_lineno = 1820;
                    {
                        PyObject *call_args[] = { tmp_args_element_name_10 };
                        tmp_raise_type_6 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_10, call_args );
                    }

                    Py_DECREF( tmp_args_element_name_10 );
                    if ( tmp_raise_type_6 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 1820;
                        type_description_1 = "ooooooNooooooo";
                        goto frame_exception_exit_1;
                    }
                    exception_type = tmp_raise_type_6;
                    exception_lineno = 1820;
                    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                    type_description_1 = "ooooooNooooooo";
                    goto frame_exception_exit_1;
                }
                branch_no_10:;
            }
            branch_no_9:;
        }
        {
            nuitka_bool tmp_condition_result_11;
            PyObject *tmp_operand_name_4;
            PyObject *tmp_subscribed_name_4;
            PyObject *tmp_subscript_name_4;
            CHECK_OBJECT( var_parts );
            tmp_subscribed_name_4 = var_parts;
            tmp_subscript_name_4 = const_int_neg_1;
            tmp_operand_name_4 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_4, tmp_subscript_name_4, -1 );
            if ( tmp_operand_name_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1821;
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_4 );
            Py_DECREF( tmp_operand_name_4 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1821;
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_11 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_11 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_11;
            }
            else
            {
                goto branch_no_11;
            }
            branch_yes_11:;
            {
                PyObject *tmp_assign_source_16;
                PyObject *tmp_left_name_17;
                PyObject *tmp_right_name_17;
                CHECK_OBJECT( var_parts_lo );
                tmp_left_name_17 = var_parts_lo;
                tmp_right_name_17 = const_int_pos_1;
                tmp_result = BINARY_OPERATION_INPLACE( PyNumber_InPlaceSubtract, &tmp_left_name_17, tmp_right_name_17 );
                if ( tmp_result == false )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1822;
                    type_description_1 = "ooooooNooooooo";
                    goto frame_exception_exit_1;
                }
                tmp_assign_source_16 = tmp_left_name_17;
                var_parts_lo = tmp_assign_source_16;

            }
            {
                nuitka_bool tmp_condition_result_12;
                int tmp_truth_name_2;
                CHECK_OBJECT( var_parts_lo );
                tmp_truth_name_2 = CHECK_IF_TRUE( var_parts_lo );
                if ( tmp_truth_name_2 == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1823;
                    type_description_1 = "ooooooNooooooo";
                    goto frame_exception_exit_1;
                }
                tmp_condition_result_12 = tmp_truth_name_2 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                if ( tmp_condition_result_12 == NUITKA_BOOL_TRUE )
                {
                    goto branch_yes_12;
                }
                else
                {
                    goto branch_no_12;
                }
                branch_yes_12:;
                {
                    PyObject *tmp_raise_type_7;
                    PyObject *tmp_called_name_11;
                    PyObject *tmp_mvar_value_10;
                    PyObject *tmp_args_element_name_11;
                    PyObject *tmp_left_name_18;
                    PyObject *tmp_right_name_18;
                    tmp_mvar_value_10 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_AddressValueError );

                    if (unlikely( tmp_mvar_value_10 == NULL ))
                    {
                        tmp_mvar_value_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AddressValueError );
                    }

                    if ( tmp_mvar_value_10 == NULL )
                    {

                        exception_type = PyExc_NameError;
                        Py_INCREF( exception_type );
                        exception_value = PyString_FromFormat( "global name '%s' is not defined", "AddressValueError" );
                        exception_tb = NULL;

                        exception_lineno = 1825;
                        type_description_1 = "ooooooNooooooo";
                        goto frame_exception_exit_1;
                    }

                    tmp_called_name_11 = tmp_mvar_value_10;
                    tmp_left_name_18 = const_unicode_digest_c18094a902653dc9c8bc33f8a5603fb5;
                    CHECK_OBJECT( par_ip_str );
                    tmp_right_name_18 = par_ip_str;
                    tmp_args_element_name_11 = BINARY_OPERATION_REMAINDER( tmp_left_name_18, tmp_right_name_18 );
                    if ( tmp_args_element_name_11 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 1825;
                        type_description_1 = "ooooooNooooooo";
                        goto frame_exception_exit_1;
                    }
                    frame_f90b0be0f90a66a29fbcc60d47edce81->m_frame.f_lineno = 1825;
                    {
                        PyObject *call_args[] = { tmp_args_element_name_11 };
                        tmp_raise_type_7 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_11, call_args );
                    }

                    Py_DECREF( tmp_args_element_name_11 );
                    if ( tmp_raise_type_7 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 1825;
                        type_description_1 = "ooooooNooooooo";
                        goto frame_exception_exit_1;
                    }
                    exception_type = tmp_raise_type_7;
                    exception_lineno = 1825;
                    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                    type_description_1 = "ooooooNooooooo";
                    goto frame_exception_exit_1;
                }
                branch_no_12:;
            }
            branch_no_11:;
        }
        {
            PyObject *tmp_assign_source_17;
            PyObject *tmp_left_name_19;
            PyObject *tmp_source_name_5;
            PyObject *tmp_right_name_19;
            PyObject *tmp_left_name_20;
            PyObject *tmp_right_name_20;
            CHECK_OBJECT( par_cls );
            tmp_source_name_5 = par_cls;
            tmp_left_name_19 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__HEXTET_COUNT );
            if ( tmp_left_name_19 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1826;
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_parts_hi );
            tmp_left_name_20 = var_parts_hi;
            CHECK_OBJECT( var_parts_lo );
            tmp_right_name_20 = var_parts_lo;
            tmp_right_name_19 = BINARY_OPERATION_ADD_OBJECT_OBJECT( tmp_left_name_20, tmp_right_name_20 );
            if ( tmp_right_name_19 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_left_name_19 );

                exception_lineno = 1826;
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }
            tmp_assign_source_17 = BINARY_OPERATION_SUB( tmp_left_name_19, tmp_right_name_19 );
            Py_DECREF( tmp_left_name_19 );
            Py_DECREF( tmp_right_name_19 );
            if ( tmp_assign_source_17 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1826;
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }
            assert( var_parts_skipped == NULL );
            var_parts_skipped = tmp_assign_source_17;
        }
        {
            nuitka_bool tmp_condition_result_13;
            PyObject *tmp_compexpr_left_7;
            PyObject *tmp_compexpr_right_7;
            CHECK_OBJECT( var_parts_skipped );
            tmp_compexpr_left_7 = var_parts_skipped;
            tmp_compexpr_right_7 = const_int_pos_1;
            tmp_res = RICH_COMPARE_BOOL_LT_OBJECT_INT( tmp_compexpr_left_7, tmp_compexpr_right_7 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1827;
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_13 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_13 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_13;
            }
            else
            {
                goto branch_no_13;
            }
            branch_yes_13:;
            {
                PyObject *tmp_raise_type_8;
                PyObject *tmp_called_name_12;
                PyObject *tmp_mvar_value_11;
                PyObject *tmp_args_element_name_12;
                PyObject *tmp_left_name_21;
                PyObject *tmp_right_name_21;
                PyObject *tmp_tuple_element_4;
                PyObject *tmp_left_name_22;
                PyObject *tmp_source_name_6;
                PyObject *tmp_right_name_22;
                tmp_mvar_value_11 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_AddressValueError );

                if (unlikely( tmp_mvar_value_11 == NULL ))
                {
                    tmp_mvar_value_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AddressValueError );
                }

                if ( tmp_mvar_value_11 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "AddressValueError" );
                    exception_tb = NULL;

                    exception_lineno = 1829;
                    type_description_1 = "ooooooNooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_name_12 = tmp_mvar_value_11;
                tmp_left_name_21 = const_unicode_digest_f46719d0b0a4fb0eb47fa9ca9304fff5;
                CHECK_OBJECT( par_cls );
                tmp_source_name_6 = par_cls;
                tmp_left_name_22 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__HEXTET_COUNT );
                if ( tmp_left_name_22 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1829;
                    type_description_1 = "ooooooNooooooo";
                    goto frame_exception_exit_1;
                }
                tmp_right_name_22 = const_int_pos_1;
                tmp_tuple_element_4 = BINARY_OPERATION_SUB( tmp_left_name_22, tmp_right_name_22 );
                Py_DECREF( tmp_left_name_22 );
                if ( tmp_tuple_element_4 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1829;
                    type_description_1 = "ooooooNooooooo";
                    goto frame_exception_exit_1;
                }
                tmp_right_name_21 = PyTuple_New( 2 );
                PyTuple_SET_ITEM( tmp_right_name_21, 0, tmp_tuple_element_4 );
                CHECK_OBJECT( par_ip_str );
                tmp_tuple_element_4 = par_ip_str;
                Py_INCREF( tmp_tuple_element_4 );
                PyTuple_SET_ITEM( tmp_right_name_21, 1, tmp_tuple_element_4 );
                tmp_args_element_name_12 = BINARY_OPERATION_REMAINDER( tmp_left_name_21, tmp_right_name_21 );
                Py_DECREF( tmp_right_name_21 );
                if ( tmp_args_element_name_12 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1829;
                    type_description_1 = "ooooooNooooooo";
                    goto frame_exception_exit_1;
                }
                frame_f90b0be0f90a66a29fbcc60d47edce81->m_frame.f_lineno = 1829;
                {
                    PyObject *call_args[] = { tmp_args_element_name_12 };
                    tmp_raise_type_8 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_12, call_args );
                }

                Py_DECREF( tmp_args_element_name_12 );
                if ( tmp_raise_type_8 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1829;
                    type_description_1 = "ooooooNooooooo";
                    goto frame_exception_exit_1;
                }
                exception_type = tmp_raise_type_8;
                exception_lineno = 1829;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }
            branch_no_13:;
        }
        goto branch_end_8;
        branch_no_8:;
        {
            nuitka_bool tmp_condition_result_14;
            PyObject *tmp_compexpr_left_8;
            PyObject *tmp_compexpr_right_8;
            PyObject *tmp_len_arg_5;
            PyObject *tmp_source_name_7;
            CHECK_OBJECT( var_parts );
            tmp_len_arg_5 = var_parts;
            tmp_compexpr_left_8 = BUILTIN_LEN( tmp_len_arg_5 );
            if ( tmp_compexpr_left_8 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1834;
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_cls );
            tmp_source_name_7 = par_cls;
            tmp_compexpr_right_8 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__HEXTET_COUNT );
            if ( tmp_compexpr_right_8 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_compexpr_left_8 );

                exception_lineno = 1834;
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }
            tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_8, tmp_compexpr_right_8 );
            Py_DECREF( tmp_compexpr_left_8 );
            Py_DECREF( tmp_compexpr_right_8 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1834;
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_14 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_14 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_14;
            }
            else
            {
                goto branch_no_14;
            }
            branch_yes_14:;
            {
                PyObject *tmp_raise_type_9;
                PyObject *tmp_called_name_13;
                PyObject *tmp_mvar_value_12;
                PyObject *tmp_args_element_name_13;
                PyObject *tmp_left_name_23;
                PyObject *tmp_right_name_23;
                PyObject *tmp_tuple_element_5;
                PyObject *tmp_source_name_8;
                tmp_mvar_value_12 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_AddressValueError );

                if (unlikely( tmp_mvar_value_12 == NULL ))
                {
                    tmp_mvar_value_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AddressValueError );
                }

                if ( tmp_mvar_value_12 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "AddressValueError" );
                    exception_tb = NULL;

                    exception_lineno = 1836;
                    type_description_1 = "ooooooNooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_name_13 = tmp_mvar_value_12;
                tmp_left_name_23 = const_unicode_digest_43b2afee270b7a4815a53cb0c30479ad;
                CHECK_OBJECT( par_cls );
                tmp_source_name_8 = par_cls;
                tmp_tuple_element_5 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain__HEXTET_COUNT );
                if ( tmp_tuple_element_5 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1836;
                    type_description_1 = "ooooooNooooooo";
                    goto frame_exception_exit_1;
                }
                tmp_right_name_23 = PyTuple_New( 2 );
                PyTuple_SET_ITEM( tmp_right_name_23, 0, tmp_tuple_element_5 );
                CHECK_OBJECT( par_ip_str );
                tmp_tuple_element_5 = par_ip_str;
                Py_INCREF( tmp_tuple_element_5 );
                PyTuple_SET_ITEM( tmp_right_name_23, 1, tmp_tuple_element_5 );
                tmp_args_element_name_13 = BINARY_OPERATION_REMAINDER( tmp_left_name_23, tmp_right_name_23 );
                Py_DECREF( tmp_right_name_23 );
                if ( tmp_args_element_name_13 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1836;
                    type_description_1 = "ooooooNooooooo";
                    goto frame_exception_exit_1;
                }
                frame_f90b0be0f90a66a29fbcc60d47edce81->m_frame.f_lineno = 1836;
                {
                    PyObject *call_args[] = { tmp_args_element_name_13 };
                    tmp_raise_type_9 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_13, call_args );
                }

                Py_DECREF( tmp_args_element_name_13 );
                if ( tmp_raise_type_9 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1836;
                    type_description_1 = "ooooooNooooooo";
                    goto frame_exception_exit_1;
                }
                exception_type = tmp_raise_type_9;
                exception_lineno = 1836;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }
            branch_no_14:;
        }
        {
            nuitka_bool tmp_condition_result_15;
            PyObject *tmp_operand_name_5;
            PyObject *tmp_subscribed_name_5;
            PyObject *tmp_subscript_name_5;
            CHECK_OBJECT( var_parts );
            tmp_subscribed_name_5 = var_parts;
            tmp_subscript_name_5 = const_int_0;
            tmp_operand_name_5 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_5, tmp_subscript_name_5, 0 );
            if ( tmp_operand_name_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1837;
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_5 );
            Py_DECREF( tmp_operand_name_5 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1837;
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_15 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_15 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_15;
            }
            else
            {
                goto branch_no_15;
            }
            branch_yes_15:;
            {
                PyObject *tmp_raise_type_10;
                PyObject *tmp_called_name_14;
                PyObject *tmp_mvar_value_13;
                PyObject *tmp_args_element_name_14;
                PyObject *tmp_left_name_24;
                PyObject *tmp_right_name_24;
                tmp_mvar_value_13 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_AddressValueError );

                if (unlikely( tmp_mvar_value_13 == NULL ))
                {
                    tmp_mvar_value_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AddressValueError );
                }

                if ( tmp_mvar_value_13 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "AddressValueError" );
                    exception_tb = NULL;

                    exception_lineno = 1839;
                    type_description_1 = "ooooooNooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_name_14 = tmp_mvar_value_13;
                tmp_left_name_24 = const_unicode_digest_2cede8cd7bf3896918371527eb9b7688;
                CHECK_OBJECT( par_ip_str );
                tmp_right_name_24 = par_ip_str;
                tmp_args_element_name_14 = BINARY_OPERATION_REMAINDER( tmp_left_name_24, tmp_right_name_24 );
                if ( tmp_args_element_name_14 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1839;
                    type_description_1 = "ooooooNooooooo";
                    goto frame_exception_exit_1;
                }
                frame_f90b0be0f90a66a29fbcc60d47edce81->m_frame.f_lineno = 1839;
                {
                    PyObject *call_args[] = { tmp_args_element_name_14 };
                    tmp_raise_type_10 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_14, call_args );
                }

                Py_DECREF( tmp_args_element_name_14 );
                if ( tmp_raise_type_10 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1839;
                    type_description_1 = "ooooooNooooooo";
                    goto frame_exception_exit_1;
                }
                exception_type = tmp_raise_type_10;
                exception_lineno = 1839;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }
            branch_no_15:;
        }
        {
            nuitka_bool tmp_condition_result_16;
            PyObject *tmp_operand_name_6;
            PyObject *tmp_subscribed_name_6;
            PyObject *tmp_subscript_name_6;
            CHECK_OBJECT( var_parts );
            tmp_subscribed_name_6 = var_parts;
            tmp_subscript_name_6 = const_int_neg_1;
            tmp_operand_name_6 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_6, tmp_subscript_name_6, -1 );
            if ( tmp_operand_name_6 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1840;
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_6 );
            Py_DECREF( tmp_operand_name_6 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1840;
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_16 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_16 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_16;
            }
            else
            {
                goto branch_no_16;
            }
            branch_yes_16:;
            {
                PyObject *tmp_raise_type_11;
                PyObject *tmp_called_name_15;
                PyObject *tmp_mvar_value_14;
                PyObject *tmp_args_element_name_15;
                PyObject *tmp_left_name_25;
                PyObject *tmp_right_name_25;
                tmp_mvar_value_14 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_AddressValueError );

                if (unlikely( tmp_mvar_value_14 == NULL ))
                {
                    tmp_mvar_value_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AddressValueError );
                }

                if ( tmp_mvar_value_14 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "AddressValueError" );
                    exception_tb = NULL;

                    exception_lineno = 1842;
                    type_description_1 = "ooooooNooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_name_15 = tmp_mvar_value_14;
                tmp_left_name_25 = const_unicode_digest_c18094a902653dc9c8bc33f8a5603fb5;
                CHECK_OBJECT( par_ip_str );
                tmp_right_name_25 = par_ip_str;
                tmp_args_element_name_15 = BINARY_OPERATION_REMAINDER( tmp_left_name_25, tmp_right_name_25 );
                if ( tmp_args_element_name_15 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1842;
                    type_description_1 = "ooooooNooooooo";
                    goto frame_exception_exit_1;
                }
                frame_f90b0be0f90a66a29fbcc60d47edce81->m_frame.f_lineno = 1842;
                {
                    PyObject *call_args[] = { tmp_args_element_name_15 };
                    tmp_raise_type_11 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_15, call_args );
                }

                Py_DECREF( tmp_args_element_name_15 );
                if ( tmp_raise_type_11 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1842;
                    type_description_1 = "ooooooNooooooo";
                    goto frame_exception_exit_1;
                }
                exception_type = tmp_raise_type_11;
                exception_lineno = 1842;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }
            branch_no_16:;
        }
        {
            PyObject *tmp_assign_source_18;
            PyObject *tmp_len_arg_6;
            CHECK_OBJECT( var_parts );
            tmp_len_arg_6 = var_parts;
            tmp_assign_source_18 = BUILTIN_LEN( tmp_len_arg_6 );
            if ( tmp_assign_source_18 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1843;
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }
            assert( var_parts_hi == NULL );
            var_parts_hi = tmp_assign_source_18;
        }
        {
            PyObject *tmp_assign_source_19;
            tmp_assign_source_19 = const_int_0;
            assert( var_parts_lo == NULL );
            Py_INCREF( tmp_assign_source_19 );
            var_parts_lo = tmp_assign_source_19;
        }
        {
            PyObject *tmp_assign_source_20;
            tmp_assign_source_20 = const_int_0;
            assert( var_parts_skipped == NULL );
            Py_INCREF( tmp_assign_source_20 );
            var_parts_skipped = tmp_assign_source_20;
        }
        branch_end_8:;
    }
    {
        PyObject *tmp_assign_source_21;
        tmp_assign_source_21 = const_int_0;
        assert( var_ip_int == NULL );
        Py_INCREF( tmp_assign_source_21 );
        var_ip_int = tmp_assign_source_21;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_22;
        PyObject *tmp_iter_arg_2;
        PyObject *tmp_range_arg_1;
        if ( var_parts_hi == NULL )
        {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "parts_hi" );
            exception_tb = NULL;

            exception_lineno = 1850;
            type_description_1 = "ooooooNooooooo";
            goto try_except_handler_4;
        }

        tmp_range_arg_1 = var_parts_hi;
        tmp_iter_arg_2 = BUILTIN_RANGE( tmp_range_arg_1 );
        if ( tmp_iter_arg_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1850;
            type_description_1 = "ooooooNooooooo";
            goto try_except_handler_4;
        }
        tmp_assign_source_22 = MAKE_ITERATOR( tmp_iter_arg_2 );
        Py_DECREF( tmp_iter_arg_2 );
        if ( tmp_assign_source_22 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1850;
            type_description_1 = "ooooooNooooooo";
            goto try_except_handler_4;
        }
        assert( tmp_for_loop_2__for_iterator == NULL );
        tmp_for_loop_2__for_iterator = tmp_assign_source_22;
    }
    // Tried code:
    loop_start_2:;
    {
        PyObject *tmp_next_source_2;
        PyObject *tmp_assign_source_23;
        CHECK_OBJECT( tmp_for_loop_2__for_iterator );
        tmp_next_source_2 = tmp_for_loop_2__for_iterator;
        tmp_assign_source_23 = ITERATOR_NEXT( tmp_next_source_2 );
        if ( tmp_assign_source_23 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_2;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "ooooooNooooooo";
                exception_lineno = 1850;
                goto try_except_handler_5;
            }
        }

        {
            PyObject *old = tmp_for_loop_2__iter_value;
            tmp_for_loop_2__iter_value = tmp_assign_source_23;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_24;
        CHECK_OBJECT( tmp_for_loop_2__iter_value );
        tmp_assign_source_24 = tmp_for_loop_2__iter_value;
        {
            PyObject *old = var_i;
            var_i = tmp_assign_source_24;
            Py_INCREF( var_i );
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_25;
        PyObject *tmp_left_name_26;
        PyObject *tmp_right_name_26;
        CHECK_OBJECT( var_ip_int );
        tmp_left_name_26 = var_ip_int;
        tmp_right_name_26 = const_int_pos_16;
        tmp_result = BINARY_OPERATION_INPLACE( PyNumber_InPlaceLshift, &tmp_left_name_26, tmp_right_name_26 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1851;
            type_description_1 = "ooooooNooooooo";
            goto try_except_handler_5;
        }
        tmp_assign_source_25 = tmp_left_name_26;
        var_ip_int = tmp_assign_source_25;

    }
    {
        PyObject *tmp_assign_source_26;
        PyObject *tmp_left_name_27;
        PyObject *tmp_right_name_27;
        PyObject *tmp_called_name_16;
        PyObject *tmp_source_name_9;
        PyObject *tmp_args_element_name_16;
        PyObject *tmp_subscribed_name_7;
        PyObject *tmp_subscript_name_7;
        CHECK_OBJECT( var_ip_int );
        tmp_left_name_27 = var_ip_int;
        CHECK_OBJECT( par_cls );
        tmp_source_name_9 = par_cls;
        tmp_called_name_16 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain__parse_hextet );
        if ( tmp_called_name_16 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1852;
            type_description_1 = "ooooooNooooooo";
            goto try_except_handler_5;
        }
        CHECK_OBJECT( var_parts );
        tmp_subscribed_name_7 = var_parts;
        CHECK_OBJECT( var_i );
        tmp_subscript_name_7 = var_i;
        tmp_args_element_name_16 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_7, tmp_subscript_name_7 );
        if ( tmp_args_element_name_16 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_16 );

            exception_lineno = 1852;
            type_description_1 = "ooooooNooooooo";
            goto try_except_handler_5;
        }
        frame_f90b0be0f90a66a29fbcc60d47edce81->m_frame.f_lineno = 1852;
        {
            PyObject *call_args[] = { tmp_args_element_name_16 };
            tmp_right_name_27 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_16, call_args );
        }

        Py_DECREF( tmp_called_name_16 );
        Py_DECREF( tmp_args_element_name_16 );
        if ( tmp_right_name_27 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1852;
            type_description_1 = "ooooooNooooooo";
            goto try_except_handler_5;
        }
        tmp_result = BINARY_OPERATION_INPLACE( PyNumber_InPlaceOr, &tmp_left_name_27, tmp_right_name_27 );
        Py_DECREF( tmp_right_name_27 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1852;
            type_description_1 = "ooooooNooooooo";
            goto try_except_handler_5;
        }
        tmp_assign_source_26 = tmp_left_name_27;
        var_ip_int = tmp_assign_source_26;

    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1850;
        type_description_1 = "ooooooNooooooo";
        goto try_except_handler_5;
    }
    goto loop_start_2;
    loop_end_2:;
    goto try_end_3;
    // Exception handler code:
    try_except_handler_5:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_2__iter_value );
    tmp_for_loop_2__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_2__for_iterator );
    Py_DECREF( tmp_for_loop_2__for_iterator );
    tmp_for_loop_2__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto try_except_handler_4;
    // End of try:
    try_end_3:;
    Py_XDECREF( tmp_for_loop_2__iter_value );
    tmp_for_loop_2__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_2__for_iterator );
    Py_DECREF( tmp_for_loop_2__for_iterator );
    tmp_for_loop_2__for_iterator = NULL;

    {
        PyObject *tmp_assign_source_27;
        PyObject *tmp_left_name_28;
        PyObject *tmp_right_name_28;
        PyObject *tmp_left_name_29;
        PyObject *tmp_right_name_29;
        CHECK_OBJECT( var_ip_int );
        tmp_left_name_28 = var_ip_int;
        tmp_left_name_29 = const_int_pos_16;
        CHECK_OBJECT( var_parts_skipped );
        tmp_right_name_29 = var_parts_skipped;
        tmp_right_name_28 = BINARY_OPERATION_MUL( tmp_left_name_29, tmp_right_name_29 );
        if ( tmp_right_name_28 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1853;
            type_description_1 = "ooooooNooooooo";
            goto try_except_handler_4;
        }
        tmp_result = BINARY_OPERATION_INPLACE( PyNumber_InPlaceLshift, &tmp_left_name_28, tmp_right_name_28 );
        Py_DECREF( tmp_right_name_28 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1853;
            type_description_1 = "ooooooNooooooo";
            goto try_except_handler_4;
        }
        tmp_assign_source_27 = tmp_left_name_28;
        var_ip_int = tmp_assign_source_27;

    }
    {
        PyObject *tmp_assign_source_28;
        PyObject *tmp_iter_arg_3;
        PyObject *tmp_range2_low_1;
        PyObject *tmp_operand_name_7;
        PyObject *tmp_range2_high_1;
        if ( var_parts_lo == NULL )
        {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "parts_lo" );
            exception_tb = NULL;

            exception_lineno = 1854;
            type_description_1 = "ooooooNooooooo";
            goto try_except_handler_4;
        }

        tmp_operand_name_7 = var_parts_lo;
        tmp_range2_low_1 = UNARY_OPERATION( PyNumber_Negative, tmp_operand_name_7 );
        if ( tmp_range2_low_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1854;
            type_description_1 = "ooooooNooooooo";
            goto try_except_handler_4;
        }
        tmp_range2_high_1 = const_int_0;
        tmp_iter_arg_3 = BUILTIN_RANGE2( tmp_range2_low_1, tmp_range2_high_1 );
        Py_DECREF( tmp_range2_low_1 );
        if ( tmp_iter_arg_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1854;
            type_description_1 = "ooooooNooooooo";
            goto try_except_handler_4;
        }
        tmp_assign_source_28 = MAKE_ITERATOR( tmp_iter_arg_3 );
        Py_DECREF( tmp_iter_arg_3 );
        if ( tmp_assign_source_28 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1854;
            type_description_1 = "ooooooNooooooo";
            goto try_except_handler_4;
        }
        assert( tmp_for_loop_3__for_iterator == NULL );
        tmp_for_loop_3__for_iterator = tmp_assign_source_28;
    }
    // Tried code:
    loop_start_3:;
    {
        PyObject *tmp_next_source_3;
        PyObject *tmp_assign_source_29;
        CHECK_OBJECT( tmp_for_loop_3__for_iterator );
        tmp_next_source_3 = tmp_for_loop_3__for_iterator;
        tmp_assign_source_29 = ITERATOR_NEXT( tmp_next_source_3 );
        if ( tmp_assign_source_29 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_3;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "ooooooNooooooo";
                exception_lineno = 1854;
                goto try_except_handler_6;
            }
        }

        {
            PyObject *old = tmp_for_loop_3__iter_value;
            tmp_for_loop_3__iter_value = tmp_assign_source_29;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_30;
        CHECK_OBJECT( tmp_for_loop_3__iter_value );
        tmp_assign_source_30 = tmp_for_loop_3__iter_value;
        {
            PyObject *old = var_i;
            var_i = tmp_assign_source_30;
            Py_INCREF( var_i );
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_31;
        PyObject *tmp_left_name_30;
        PyObject *tmp_right_name_30;
        CHECK_OBJECT( var_ip_int );
        tmp_left_name_30 = var_ip_int;
        tmp_right_name_30 = const_int_pos_16;
        tmp_result = BINARY_OPERATION_INPLACE( PyNumber_InPlaceLshift, &tmp_left_name_30, tmp_right_name_30 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1855;
            type_description_1 = "ooooooNooooooo";
            goto try_except_handler_6;
        }
        tmp_assign_source_31 = tmp_left_name_30;
        var_ip_int = tmp_assign_source_31;

    }
    {
        PyObject *tmp_assign_source_32;
        PyObject *tmp_left_name_31;
        PyObject *tmp_right_name_31;
        PyObject *tmp_called_name_17;
        PyObject *tmp_source_name_10;
        PyObject *tmp_args_element_name_17;
        PyObject *tmp_subscribed_name_8;
        PyObject *tmp_subscript_name_8;
        CHECK_OBJECT( var_ip_int );
        tmp_left_name_31 = var_ip_int;
        CHECK_OBJECT( par_cls );
        tmp_source_name_10 = par_cls;
        tmp_called_name_17 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain__parse_hextet );
        if ( tmp_called_name_17 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1856;
            type_description_1 = "ooooooNooooooo";
            goto try_except_handler_6;
        }
        CHECK_OBJECT( var_parts );
        tmp_subscribed_name_8 = var_parts;
        CHECK_OBJECT( var_i );
        tmp_subscript_name_8 = var_i;
        tmp_args_element_name_17 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_8, tmp_subscript_name_8 );
        if ( tmp_args_element_name_17 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_17 );

            exception_lineno = 1856;
            type_description_1 = "ooooooNooooooo";
            goto try_except_handler_6;
        }
        frame_f90b0be0f90a66a29fbcc60d47edce81->m_frame.f_lineno = 1856;
        {
            PyObject *call_args[] = { tmp_args_element_name_17 };
            tmp_right_name_31 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_17, call_args );
        }

        Py_DECREF( tmp_called_name_17 );
        Py_DECREF( tmp_args_element_name_17 );
        if ( tmp_right_name_31 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1856;
            type_description_1 = "ooooooNooooooo";
            goto try_except_handler_6;
        }
        tmp_result = BINARY_OPERATION_INPLACE( PyNumber_InPlaceOr, &tmp_left_name_31, tmp_right_name_31 );
        Py_DECREF( tmp_right_name_31 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1856;
            type_description_1 = "ooooooNooooooo";
            goto try_except_handler_6;
        }
        tmp_assign_source_32 = tmp_left_name_31;
        var_ip_int = tmp_assign_source_32;

    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1854;
        type_description_1 = "ooooooNooooooo";
        goto try_except_handler_6;
    }
    goto loop_start_3;
    loop_end_3:;
    goto try_end_4;
    // Exception handler code:
    try_except_handler_6:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_3__iter_value );
    tmp_for_loop_3__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_3__for_iterator );
    Py_DECREF( tmp_for_loop_3__for_iterator );
    tmp_for_loop_3__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto try_except_handler_4;
    // End of try:
    try_end_4:;
    goto try_end_5;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_5 = exception_type;
    exception_keeper_value_5 = exception_value;
    exception_keeper_tb_5 = exception_tb;
    exception_keeper_lineno_5 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_f90b0be0f90a66a29fbcc60d47edce81 );
    if ( exception_keeper_tb_5 == NULL )
    {
        exception_keeper_tb_5 = MAKE_TRACEBACK( frame_f90b0be0f90a66a29fbcc60d47edce81, exception_keeper_lineno_5 );
    }
    else if ( exception_keeper_lineno_5 != 0 )
    {
        exception_keeper_tb_5 = ADD_TRACEBACK( exception_keeper_tb_5, frame_f90b0be0f90a66a29fbcc60d47edce81, exception_keeper_lineno_5 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_5, &exception_keeper_value_5, &exception_keeper_tb_5 );
    PUBLISH_EXCEPTION( &exception_keeper_type_5, &exception_keeper_value_5, &exception_keeper_tb_5 );
    {
        nuitka_bool tmp_condition_result_17;
        PyObject *tmp_compexpr_left_9;
        PyObject *tmp_compexpr_right_9;
        tmp_compexpr_left_9 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_9 = PyExc_ValueError;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_9, tmp_compexpr_right_9 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1858;
            type_description_1 = "ooooooNooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_17 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_17 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_17;
        }
        else
        {
            goto branch_no_17;
        }
        branch_yes_17:;
        {
            PyObject *tmp_assign_source_33;
            tmp_assign_source_33 = EXC_VALUE(PyThreadState_GET());
            assert( var_exc == NULL );
            Py_INCREF( tmp_assign_source_33 );
            var_exc = tmp_assign_source_33;
        }
        {
            PyObject *tmp_raise_type_12;
            PyObject *tmp_called_name_18;
            PyObject *tmp_mvar_value_15;
            PyObject *tmp_args_element_name_18;
            PyObject *tmp_left_name_32;
            PyObject *tmp_right_name_32;
            PyObject *tmp_tuple_element_6;
            tmp_mvar_value_15 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_AddressValueError );

            if (unlikely( tmp_mvar_value_15 == NULL ))
            {
                tmp_mvar_value_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AddressValueError );
            }

            if ( tmp_mvar_value_15 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "AddressValueError" );
                exception_tb = NULL;

                exception_lineno = 1859;
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_18 = tmp_mvar_value_15;
            tmp_left_name_32 = const_unicode_digest_3d11cbcbf80fa8d2b7c658c556c6918d;
            CHECK_OBJECT( var_exc );
            tmp_tuple_element_6 = var_exc;
            tmp_right_name_32 = PyTuple_New( 2 );
            Py_INCREF( tmp_tuple_element_6 );
            PyTuple_SET_ITEM( tmp_right_name_32, 0, tmp_tuple_element_6 );
            CHECK_OBJECT( par_ip_str );
            tmp_tuple_element_6 = par_ip_str;
            Py_INCREF( tmp_tuple_element_6 );
            PyTuple_SET_ITEM( tmp_right_name_32, 1, tmp_tuple_element_6 );
            tmp_args_element_name_18 = BINARY_OPERATION_REMAINDER( tmp_left_name_32, tmp_right_name_32 );
            Py_DECREF( tmp_right_name_32 );
            if ( tmp_args_element_name_18 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1859;
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }
            frame_f90b0be0f90a66a29fbcc60d47edce81->m_frame.f_lineno = 1859;
            {
                PyObject *call_args[] = { tmp_args_element_name_18 };
                tmp_raise_type_12 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_18, call_args );
            }

            Py_DECREF( tmp_args_element_name_18 );
            if ( tmp_raise_type_12 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1859;
                type_description_1 = "ooooooNooooooo";
                goto frame_exception_exit_1;
            }
            exception_type = tmp_raise_type_12;
            exception_lineno = 1859;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooooooNooooooo";
            goto frame_exception_exit_1;
        }
        goto branch_end_17;
        branch_no_17:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 1847;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_f90b0be0f90a66a29fbcc60d47edce81->m_frame) frame_f90b0be0f90a66a29fbcc60d47edce81->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "ooooooNooooooo";
        goto frame_exception_exit_1;
        branch_end_17:;
    }
    // End of try:
    try_end_5:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_f90b0be0f90a66a29fbcc60d47edce81 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_f90b0be0f90a66a29fbcc60d47edce81 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f90b0be0f90a66a29fbcc60d47edce81, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f90b0be0f90a66a29fbcc60d47edce81->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f90b0be0f90a66a29fbcc60d47edce81, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f90b0be0f90a66a29fbcc60d47edce81,
        type_description_1,
        par_cls,
        par_ip_str,
        var_exc,
        var_ipv4_int,
        var_i,
        var_ip_int,
        NULL,
        var__max_parts,
        var_parts,
        var_skip_index,
        var_parts_lo,
        var_msg,
        var_parts_skipped,
        var_parts_hi
    );


    // Release cached frame.
    if ( frame_f90b0be0f90a66a29fbcc60d47edce81 == cache_frame_f90b0be0f90a66a29fbcc60d47edce81 )
    {
        Py_DECREF( frame_f90b0be0f90a66a29fbcc60d47edce81 );
    }
    cache_frame_f90b0be0f90a66a29fbcc60d47edce81 = NULL;

    assertFrameObject( frame_f90b0be0f90a66a29fbcc60d47edce81 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    Py_XDECREF( tmp_for_loop_3__iter_value );
    tmp_for_loop_3__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_3__for_iterator );
    Py_DECREF( tmp_for_loop_3__for_iterator );
    tmp_for_loop_3__for_iterator = NULL;

    CHECK_OBJECT( var_ip_int );
    tmp_return_value = var_ip_int;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_110__ip_int_from_string );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_ipv4_int );
    var_ipv4_int = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)var_ip_int );
    Py_DECREF( var_ip_int );
    var_ip_int = NULL;

    CHECK_OBJECT( (PyObject *)var__max_parts );
    Py_DECREF( var__max_parts );
    var__max_parts = NULL;

    CHECK_OBJECT( (PyObject *)var_parts );
    Py_DECREF( var_parts );
    var_parts = NULL;

    Py_XDECREF( var_skip_index );
    var_skip_index = NULL;

    Py_XDECREF( var_parts_lo );
    var_parts_lo = NULL;

    CHECK_OBJECT( (PyObject *)par_ip_str );
    Py_DECREF( par_ip_str );
    par_ip_str = NULL;

    CHECK_OBJECT( (PyObject *)var_parts_skipped );
    Py_DECREF( var_parts_skipped );
    var_parts_skipped = NULL;

    Py_XDECREF( var_parts_hi );
    var_parts_hi = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_6 = exception_type;
    exception_keeper_value_6 = exception_value;
    exception_keeper_tb_6 = exception_tb;
    exception_keeper_lineno_6 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_exc );
    var_exc = NULL;

    Py_XDECREF( var_ipv4_int );
    var_ipv4_int = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    Py_XDECREF( var_ip_int );
    var_ip_int = NULL;

    Py_XDECREF( var__max_parts );
    var__max_parts = NULL;

    Py_XDECREF( var_parts );
    var_parts = NULL;

    Py_XDECREF( var_skip_index );
    var_skip_index = NULL;

    Py_XDECREF( var_parts_lo );
    var_parts_lo = NULL;

    Py_XDECREF( var_msg );
    var_msg = NULL;

    CHECK_OBJECT( (PyObject *)par_ip_str );
    Py_DECREF( par_ip_str );
    par_ip_str = NULL;

    Py_XDECREF( var_parts_skipped );
    var_parts_skipped = NULL;

    Py_XDECREF( var_parts_hi );
    var_parts_hi = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_6;
    exception_value = exception_keeper_value_6;
    exception_tb = exception_keeper_tb_6;
    exception_lineno = exception_keeper_lineno_6;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_110__ip_int_from_string );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_111__parse_hextet( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_hextet_str = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_5cec4f1aab659e4de38ef9afc8d48e47;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_5cec4f1aab659e4de38ef9afc8d48e47 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5cec4f1aab659e4de38ef9afc8d48e47, codeobj_5cec4f1aab659e4de38ef9afc8d48e47, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_5cec4f1aab659e4de38ef9afc8d48e47 = cache_frame_5cec4f1aab659e4de38ef9afc8d48e47;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5cec4f1aab659e4de38ef9afc8d48e47 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5cec4f1aab659e4de38ef9afc8d48e47 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT( par_cls );
        tmp_source_name_1 = par_cls;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__HEX_DIGITS );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1877;
            type_description_1 = "ooN";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_hextet_str );
        tmp_args_element_name_1 = par_hextet_str;
        frame_5cec4f1aab659e4de38ef9afc8d48e47->m_frame.f_lineno = 1877;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_operand_name_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_issuperset, call_args );
        }

        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_operand_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1877;
            type_description_1 = "ooN";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        Py_DECREF( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1877;
            type_description_1 = "ooN";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            tmp_left_name_1 = const_unicode_digest_e117cb895af56362aabb03455887d34f;
            CHECK_OBJECT( par_hextet_str );
            tmp_right_name_1 = par_hextet_str;
            tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
            if ( tmp_make_exception_arg_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1878;
                type_description_1 = "ooN";
                goto frame_exception_exit_1;
            }
            frame_5cec4f1aab659e4de38ef9afc8d48e47->m_frame.f_lineno = 1878;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            Py_DECREF( tmp_make_exception_arg_1 );
            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1878;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooN";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_len_arg_1;
        CHECK_OBJECT( par_hextet_str );
        tmp_len_arg_1 = par_hextet_str;
        tmp_compexpr_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1881;
            type_description_1 = "ooN";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = const_int_pos_4;
        tmp_res = RICH_COMPARE_BOOL_GT_OBJECT_INT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        assert( !(tmp_res == -1) );
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_make_exception_arg_2;
            PyObject *tmp_left_name_2;
            PyObject *tmp_right_name_2;
            tmp_left_name_2 = const_unicode_digest_3b09fa45074f4957f7f10686b054a8ec;
            CHECK_OBJECT( par_hextet_str );
            tmp_right_name_2 = par_hextet_str;
            tmp_make_exception_arg_2 = BINARY_OPERATION_REMAINDER( tmp_left_name_2, tmp_right_name_2 );
            if ( tmp_make_exception_arg_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1883;
                type_description_1 = "ooN";
                goto frame_exception_exit_1;
            }
            frame_5cec4f1aab659e4de38ef9afc8d48e47->m_frame.f_lineno = 1883;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_2 };
                tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            Py_DECREF( tmp_make_exception_arg_2 );
            assert( !(tmp_raise_type_2 == NULL) );
            exception_type = tmp_raise_type_2;
            exception_lineno = 1883;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooN";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    {
        PyObject *tmp_value_name_1;
        PyObject *tmp_base_name_1;
        CHECK_OBJECT( par_hextet_str );
        tmp_value_name_1 = par_hextet_str;
        tmp_base_name_1 = const_int_pos_16;
        tmp_return_value = TO_INT2( tmp_value_name_1, tmp_base_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1885;
            type_description_1 = "ooN";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5cec4f1aab659e4de38ef9afc8d48e47 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_5cec4f1aab659e4de38ef9afc8d48e47 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5cec4f1aab659e4de38ef9afc8d48e47 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5cec4f1aab659e4de38ef9afc8d48e47, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5cec4f1aab659e4de38ef9afc8d48e47->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5cec4f1aab659e4de38ef9afc8d48e47, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5cec4f1aab659e4de38ef9afc8d48e47,
        type_description_1,
        par_cls,
        par_hextet_str,
        NULL
    );


    // Release cached frame.
    if ( frame_5cec4f1aab659e4de38ef9afc8d48e47 == cache_frame_5cec4f1aab659e4de38ef9afc8d48e47 )
    {
        Py_DECREF( frame_5cec4f1aab659e4de38ef9afc8d48e47 );
    }
    cache_frame_5cec4f1aab659e4de38ef9afc8d48e47 = NULL;

    assertFrameObject( frame_5cec4f1aab659e4de38ef9afc8d48e47 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_111__parse_hextet );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_hextet_str );
    Py_DECREF( par_hextet_str );
    par_hextet_str = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_hextet_str );
    Py_DECREF( par_hextet_str );
    par_hextet_str = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_111__parse_hextet );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_112__compress_hextets( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_hextets = python_pars[ 1 ];
    PyObject *var_index = NULL;
    PyObject *var_best_doublecolon_len = NULL;
    PyObject *var_doublecolon_len = NULL;
    PyObject *var_best_doublecolon_start = NULL;
    PyObject *var_best_doublecolon_end = NULL;
    PyObject *var_doublecolon_start = NULL;
    PyObject *var_hextet = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *tmp_tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_tuple_unpack_1__source_iter = NULL;
    struct Nuitka_FrameObject *frame_ad30372b73c3d36542e3a940af829ee7;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_iterator_attempt;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    int tmp_res;
    bool tmp_result;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_ad30372b73c3d36542e3a940af829ee7 = NULL;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;

    // Actual function body.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = const_int_neg_1;
        assert( var_best_doublecolon_start == NULL );
        Py_INCREF( tmp_assign_source_1 );
        var_best_doublecolon_start = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        tmp_assign_source_2 = const_int_0;
        assert( var_best_doublecolon_len == NULL );
        Py_INCREF( tmp_assign_source_2 );
        var_best_doublecolon_len = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        tmp_assign_source_3 = const_int_neg_1;
        assert( var_doublecolon_start == NULL );
        Py_INCREF( tmp_assign_source_3 );
        var_doublecolon_start = tmp_assign_source_3;
    }
    {
        PyObject *tmp_assign_source_4;
        tmp_assign_source_4 = const_int_0;
        assert( var_doublecolon_len == NULL );
        Py_INCREF( tmp_assign_source_4 );
        var_doublecolon_len = tmp_assign_source_4;
    }
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ad30372b73c3d36542e3a940af829ee7, codeobj_ad30372b73c3d36542e3a940af829ee7, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_ad30372b73c3d36542e3a940af829ee7 = cache_frame_ad30372b73c3d36542e3a940af829ee7;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ad30372b73c3d36542e3a940af829ee7 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ad30372b73c3d36542e3a940af829ee7 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_1;
        tmp_called_name_1 = (PyObject *)&PyEnum_Type;
        CHECK_OBJECT( par_hextets );
        tmp_args_element_name_1 = par_hextets;
        frame_ad30372b73c3d36542e3a940af829ee7->m_frame.f_lineno = 1908;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_iter_arg_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        if ( tmp_iter_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1908;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_5 = MAKE_ITERATOR( tmp_iter_arg_1 );
        Py_DECREF( tmp_iter_arg_1 );
        if ( tmp_assign_source_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1908;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert( tmp_for_loop_1__for_iterator == NULL );
        tmp_for_loop_1__for_iterator = tmp_assign_source_5;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_6;
        CHECK_OBJECT( tmp_for_loop_1__for_iterator );
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_6 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_6 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "ooooooooo";
                exception_lineno = 1908;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_6;
            Py_XDECREF( old );
        }

    }
    // Tried code:
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_iter_arg_2;
        CHECK_OBJECT( tmp_for_loop_1__iter_value );
        tmp_iter_arg_2 = tmp_for_loop_1__iter_value;
        tmp_assign_source_7 = MAKE_ITERATOR( tmp_iter_arg_2 );
        if ( tmp_assign_source_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1908;
            type_description_1 = "ooooooooo";
            goto try_except_handler_3;
        }
        {
            PyObject *old = tmp_tuple_unpack_1__source_iter;
            tmp_tuple_unpack_1__source_iter = tmp_assign_source_7;
            Py_XDECREF( old );
        }

    }
    // Tried code:
    {
        PyObject *tmp_assign_source_8;
        PyObject *tmp_unpack_1;
        CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
        tmp_unpack_1 = tmp_tuple_unpack_1__source_iter;
        tmp_assign_source_8 = UNPACK_NEXT( tmp_unpack_1, 0 );
        if ( tmp_assign_source_8 == NULL )
        {
            if ( !ERROR_OCCURRED() )
            {
                exception_type = PyExc_StopIteration;
                Py_INCREF( exception_type );
                exception_value = NULL;
                exception_tb = NULL;
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            }


            type_description_1 = "ooooooooo";
            exception_lineno = 1908;
            goto try_except_handler_4;
        }
        {
            PyObject *old = tmp_tuple_unpack_1__element_1;
            tmp_tuple_unpack_1__element_1 = tmp_assign_source_8;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_9;
        PyObject *tmp_unpack_2;
        CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
        tmp_unpack_2 = tmp_tuple_unpack_1__source_iter;
        tmp_assign_source_9 = UNPACK_NEXT( tmp_unpack_2, 1 );
        if ( tmp_assign_source_9 == NULL )
        {
            if ( !ERROR_OCCURRED() )
            {
                exception_type = PyExc_StopIteration;
                Py_INCREF( exception_type );
                exception_value = NULL;
                exception_tb = NULL;
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            }


            type_description_1 = "ooooooooo";
            exception_lineno = 1908;
            goto try_except_handler_4;
        }
        {
            PyObject *old = tmp_tuple_unpack_1__element_2;
            tmp_tuple_unpack_1__element_2 = tmp_assign_source_9;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_iterator_name_1;
        CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
        tmp_iterator_name_1 = tmp_tuple_unpack_1__source_iter;
        // Check if iterator has left-over elements.
        CHECK_OBJECT( tmp_iterator_name_1 ); assert( HAS_ITERNEXT( tmp_iterator_name_1 ) );

        tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_1 )->tp_iternext)( tmp_iterator_name_1 );

        if (likely( tmp_iterator_attempt == NULL ))
        {
            PyObject *error = GET_ERROR_OCCURRED();

            if ( error != NULL )
            {
                if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
                {
                    CLEAR_ERROR_OCCURRED();
                }
                else
                {
                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                    type_description_1 = "ooooooooo";
                    exception_lineno = 1908;
                    goto try_except_handler_4;
                }
            }
        }
        else
        {
            Py_DECREF( tmp_iterator_attempt );

            // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
            PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 2)" );
#endif
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

            type_description_1 = "ooooooooo";
            exception_lineno = 1908;
            goto try_except_handler_4;
        }
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_3;
    // End of try:
    try_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto try_except_handler_2;
    // End of try:
    try_end_2:;
    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    {
        PyObject *tmp_assign_source_10;
        CHECK_OBJECT( tmp_tuple_unpack_1__element_1 );
        tmp_assign_source_10 = tmp_tuple_unpack_1__element_1;
        {
            PyObject *old = var_index;
            var_index = tmp_assign_source_10;
            Py_INCREF( var_index );
            Py_XDECREF( old );
        }

    }
    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    {
        PyObject *tmp_assign_source_11;
        CHECK_OBJECT( tmp_tuple_unpack_1__element_2 );
        tmp_assign_source_11 = tmp_tuple_unpack_1__element_2;
        {
            PyObject *old = var_hextet;
            var_hextet = tmp_assign_source_11;
            Py_INCREF( var_hextet );
            Py_XDECREF( old );
        }

    }
    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( var_hextet );
        tmp_compexpr_left_1 = var_hextet;
        tmp_compexpr_right_1 = const_unicode_plain_0;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1909;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_12;
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            CHECK_OBJECT( var_doublecolon_len );
            tmp_left_name_1 = var_doublecolon_len;
            tmp_right_name_1 = const_int_pos_1;
            tmp_result = BINARY_OPERATION_ADD_OBJECT_INT_INPLACE( &tmp_left_name_1, tmp_right_name_1 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1910;
                type_description_1 = "ooooooooo";
                goto try_except_handler_2;
            }
            tmp_assign_source_12 = tmp_left_name_1;
            var_doublecolon_len = tmp_assign_source_12;

        }
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            if ( var_doublecolon_start == NULL )
            {

                exception_type = PyExc_UnboundLocalError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "doublecolon_start" );
                exception_tb = NULL;

                exception_lineno = 1911;
                type_description_1 = "ooooooooo";
                goto try_except_handler_2;
            }

            tmp_compexpr_left_2 = var_doublecolon_start;
            tmp_compexpr_right_2 = const_int_neg_1;
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_INT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1911;
                type_description_1 = "ooooooooo";
                goto try_except_handler_2;
            }
            tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_assign_source_13;
                CHECK_OBJECT( var_index );
                tmp_assign_source_13 = var_index;
                {
                    PyObject *old = var_doublecolon_start;
                    var_doublecolon_start = tmp_assign_source_13;
                    Py_INCREF( var_doublecolon_start );
                    Py_XDECREF( old );
                }

            }
            branch_no_2:;
        }
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            CHECK_OBJECT( var_doublecolon_len );
            tmp_compexpr_left_3 = var_doublecolon_len;
            if ( var_best_doublecolon_len == NULL )
            {

                exception_type = PyExc_UnboundLocalError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "best_doublecolon_len" );
                exception_tb = NULL;

                exception_lineno = 1914;
                type_description_1 = "ooooooooo";
                goto try_except_handler_2;
            }

            tmp_compexpr_right_3 = var_best_doublecolon_len;
            tmp_res = RICH_COMPARE_BOOL_GT_OBJECT_OBJECT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1914;
                type_description_1 = "ooooooooo";
                goto try_except_handler_2;
            }
            tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_3;
            }
            else
            {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_assign_source_14;
                CHECK_OBJECT( var_doublecolon_len );
                tmp_assign_source_14 = var_doublecolon_len;
                {
                    PyObject *old = var_best_doublecolon_len;
                    var_best_doublecolon_len = tmp_assign_source_14;
                    Py_INCREF( var_best_doublecolon_len );
                    Py_XDECREF( old );
                }

            }
            {
                PyObject *tmp_assign_source_15;
                if ( var_doublecolon_start == NULL )
                {

                    exception_type = PyExc_UnboundLocalError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "doublecolon_start" );
                    exception_tb = NULL;

                    exception_lineno = 1917;
                    type_description_1 = "ooooooooo";
                    goto try_except_handler_2;
                }

                tmp_assign_source_15 = var_doublecolon_start;
                {
                    PyObject *old = var_best_doublecolon_start;
                    var_best_doublecolon_start = tmp_assign_source_15;
                    Py_INCREF( var_best_doublecolon_start );
                    Py_XDECREF( old );
                }

            }
            branch_no_3:;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_16;
            tmp_assign_source_16 = const_int_0;
            {
                PyObject *old = var_doublecolon_len;
                assert( old != NULL );
                var_doublecolon_len = tmp_assign_source_16;
                Py_INCREF( var_doublecolon_len );
                Py_DECREF( old );
            }

        }
        {
            PyObject *tmp_assign_source_17;
            tmp_assign_source_17 = const_int_neg_1;
            {
                PyObject *old = var_doublecolon_start;
                var_doublecolon_start = tmp_assign_source_17;
                Py_INCREF( var_doublecolon_start );
                Py_XDECREF( old );
            }

        }
        branch_end_1:;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1908;
        type_description_1 = "ooooooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_3;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    try_end_3:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        if ( var_best_doublecolon_len == NULL )
        {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "best_doublecolon_len" );
            exception_tb = NULL;

            exception_lineno = 1922;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_left_4 = var_best_doublecolon_len;
        tmp_compexpr_right_4 = const_int_pos_1;
        tmp_res = RICH_COMPARE_BOOL_GT_OBJECT_INT( tmp_compexpr_left_4, tmp_compexpr_right_4 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1922;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_4 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_4;
        }
        else
        {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_assign_source_18;
            PyObject *tmp_left_name_2;
            PyObject *tmp_right_name_2;
            if ( var_best_doublecolon_start == NULL )
            {

                exception_type = PyExc_UnboundLocalError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "best_doublecolon_start" );
                exception_tb = NULL;

                exception_lineno = 1923;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_left_name_2 = var_best_doublecolon_start;
            if ( var_best_doublecolon_len == NULL )
            {

                exception_type = PyExc_UnboundLocalError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "best_doublecolon_len" );
                exception_tb = NULL;

                exception_lineno = 1924;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_right_name_2 = var_best_doublecolon_len;
            tmp_assign_source_18 = BINARY_OPERATION_ADD_OBJECT_OBJECT( tmp_left_name_2, tmp_right_name_2 );
            if ( tmp_assign_source_18 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1923;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            assert( var_best_doublecolon_end == NULL );
            var_best_doublecolon_end = tmp_assign_source_18;
        }
        {
            nuitka_bool tmp_condition_result_5;
            PyObject *tmp_compexpr_left_5;
            PyObject *tmp_compexpr_right_5;
            PyObject *tmp_len_arg_1;
            CHECK_OBJECT( var_best_doublecolon_end );
            tmp_compexpr_left_5 = var_best_doublecolon_end;
            CHECK_OBJECT( par_hextets );
            tmp_len_arg_1 = par_hextets;
            tmp_compexpr_right_5 = BUILTIN_LEN( tmp_len_arg_1 );
            if ( tmp_compexpr_right_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1926;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_5, tmp_compexpr_right_5 );
            Py_DECREF( tmp_compexpr_right_5 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1926;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_5 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_5;
            }
            else
            {
                goto branch_no_5;
            }
            branch_yes_5:;
            {
                PyObject *tmp_assign_source_19;
                PyObject *tmp_left_name_3;
                PyObject *tmp_right_name_3;
                CHECK_OBJECT( par_hextets );
                tmp_left_name_3 = par_hextets;
                tmp_right_name_3 = LIST_COPY( const_list_unicode_empty_list );
                tmp_result = BINARY_OPERATION_ADD_OBJECT_LIST_INPLACE( &tmp_left_name_3, tmp_right_name_3 );
                Py_DECREF( tmp_right_name_3 );
                if ( tmp_result == false )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1927;
                    type_description_1 = "ooooooooo";
                    goto frame_exception_exit_1;
                }
                tmp_assign_source_19 = tmp_left_name_3;
                par_hextets = tmp_assign_source_19;

            }
            branch_no_5:;
        }
        {
            PyObject *tmp_sliceass_value_1;
            PyObject *tmp_sliceass_target_1;
            PyObject *tmp_sliceass_lower_1;
            PyObject *tmp_sliceass_upper_1;
            tmp_sliceass_value_1 = LIST_COPY( const_list_unicode_empty_list );
            CHECK_OBJECT( par_hextets );
            tmp_sliceass_target_1 = par_hextets;
            if ( var_best_doublecolon_start == NULL )
            {
                Py_DECREF( tmp_sliceass_value_1 );
                exception_type = PyExc_UnboundLocalError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "best_doublecolon_start" );
                exception_tb = NULL;

                exception_lineno = 1928;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_sliceass_lower_1 = var_best_doublecolon_start;
            CHECK_OBJECT( var_best_doublecolon_end );
            tmp_sliceass_upper_1 = var_best_doublecolon_end;
            tmp_result = SET_SLICE( tmp_sliceass_target_1, tmp_sliceass_lower_1, tmp_sliceass_upper_1, tmp_sliceass_value_1 );
            Py_DECREF( tmp_sliceass_value_1 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1928;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
        }
        {
            nuitka_bool tmp_condition_result_6;
            PyObject *tmp_compexpr_left_6;
            PyObject *tmp_compexpr_right_6;
            if ( var_best_doublecolon_start == NULL )
            {

                exception_type = PyExc_UnboundLocalError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "best_doublecolon_start" );
                exception_tb = NULL;

                exception_lineno = 1930;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_left_6 = var_best_doublecolon_start;
            tmp_compexpr_right_6 = const_int_0;
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_INT( tmp_compexpr_left_6, tmp_compexpr_right_6 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1930;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_6 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_6 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_6;
            }
            else
            {
                goto branch_no_6;
            }
            branch_yes_6:;
            {
                PyObject *tmp_assign_source_20;
                PyObject *tmp_left_name_4;
                PyObject *tmp_right_name_4;
                tmp_left_name_4 = LIST_COPY( const_list_unicode_empty_list );
                CHECK_OBJECT( par_hextets );
                tmp_right_name_4 = par_hextets;
                tmp_assign_source_20 = BINARY_OPERATION_ADD_LIST_OBJECT( tmp_left_name_4, tmp_right_name_4 );
                Py_DECREF( tmp_left_name_4 );
                if ( tmp_assign_source_20 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1931;
                    type_description_1 = "ooooooooo";
                    goto frame_exception_exit_1;
                }
                {
                    PyObject *old = par_hextets;
                    assert( old != NULL );
                    par_hextets = tmp_assign_source_20;
                    Py_DECREF( old );
                }

            }
            branch_no_6:;
        }
        branch_no_4:;
    }
    if ( par_hextets == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "hextets" );
        exception_tb = NULL;

        exception_lineno = 1933;
        type_description_1 = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_return_value = par_hextets;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ad30372b73c3d36542e3a940af829ee7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_ad30372b73c3d36542e3a940af829ee7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ad30372b73c3d36542e3a940af829ee7 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ad30372b73c3d36542e3a940af829ee7, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ad30372b73c3d36542e3a940af829ee7->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ad30372b73c3d36542e3a940af829ee7, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ad30372b73c3d36542e3a940af829ee7,
        type_description_1,
        par_cls,
        par_hextets,
        var_index,
        var_best_doublecolon_len,
        var_doublecolon_len,
        var_best_doublecolon_start,
        var_best_doublecolon_end,
        var_doublecolon_start,
        var_hextet
    );


    // Release cached frame.
    if ( frame_ad30372b73c3d36542e3a940af829ee7 == cache_frame_ad30372b73c3d36542e3a940af829ee7 )
    {
        Py_DECREF( frame_ad30372b73c3d36542e3a940af829ee7 );
    }
    cache_frame_ad30372b73c3d36542e3a940af829ee7 = NULL;

    assertFrameObject( frame_ad30372b73c3d36542e3a940af829ee7 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_112__compress_hextets );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_index );
    var_index = NULL;

    Py_XDECREF( var_best_doublecolon_len );
    var_best_doublecolon_len = NULL;

    CHECK_OBJECT( (PyObject *)var_doublecolon_len );
    Py_DECREF( var_doublecolon_len );
    var_doublecolon_len = NULL;

    Py_XDECREF( var_best_doublecolon_start );
    var_best_doublecolon_start = NULL;

    Py_XDECREF( var_best_doublecolon_end );
    var_best_doublecolon_end = NULL;

    Py_XDECREF( par_hextets );
    par_hextets = NULL;

    Py_XDECREF( var_doublecolon_start );
    var_doublecolon_start = NULL;

    Py_XDECREF( var_hextet );
    var_hextet = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_index );
    var_index = NULL;

    Py_XDECREF( var_best_doublecolon_len );
    var_best_doublecolon_len = NULL;

    Py_XDECREF( var_doublecolon_len );
    var_doublecolon_len = NULL;

    Py_XDECREF( var_best_doublecolon_start );
    var_best_doublecolon_start = NULL;

    Py_XDECREF( var_best_doublecolon_end );
    var_best_doublecolon_end = NULL;

    Py_XDECREF( par_hextets );
    par_hextets = NULL;

    Py_XDECREF( var_doublecolon_start );
    var_doublecolon_start = NULL;

    Py_XDECREF( var_hextet );
    var_hextet = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_112__compress_hextets );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_113__string_from_ip_int( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_ip_int = python_pars[ 1 ];
    PyObject *var_x = NULL;
    PyObject *var_hex_str = NULL;
    PyObject *var_hextets = NULL;
    PyObject *tmp_list_contraction_1__$0 = NULL;
    PyObject *tmp_list_contraction_1__contraction_result = NULL;
    PyObject *tmp_list_contraction_1__iter_value_0 = NULL;
    struct Nuitka_FrameObject *frame_124ad0b848fffa9587184710249546c6;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_124ad0b848fffa9587184710249546c6 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_124ad0b848fffa9587184710249546c6, codeobj_124ad0b848fffa9587184710249546c6, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_124ad0b848fffa9587184710249546c6 = cache_frame_124ad0b848fffa9587184710249546c6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_124ad0b848fffa9587184710249546c6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_124ad0b848fffa9587184710249546c6 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( par_ip_int );
        tmp_compexpr_left_1 = par_ip_int;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_int_arg_1;
            PyObject *tmp_source_name_1;
            CHECK_OBJECT( par_cls );
            tmp_source_name_1 = par_cls;
            tmp_int_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__ip );
            if ( tmp_int_arg_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1950;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_assign_source_1 = PyNumber_Int( tmp_int_arg_1 );
            Py_DECREF( tmp_int_arg_1 );
            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1950;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_ip_int;
                assert( old != NULL );
                par_ip_int = tmp_assign_source_1;
                Py_DECREF( old );
            }

        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( par_ip_int );
        tmp_compexpr_left_2 = par_ip_int;
        CHECK_OBJECT( par_cls );
        tmp_source_name_2 = par_cls;
        tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ALL_ONES );
        if ( tmp_compexpr_right_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1952;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_GT_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        Py_DECREF( tmp_compexpr_right_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1952;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_unicode_digest_87736fe902d897d977541c59e5443d08;
            frame_124ad0b848fffa9587184710249546c6->m_frame.f_lineno = 1953;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1953;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        tmp_left_name_1 = const_unicode_digest_7f00060466647c49fa48da2be5e497c8;
        CHECK_OBJECT( par_ip_int );
        tmp_right_name_1 = par_ip_int;
        tmp_assign_source_2 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1955;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( var_hex_str == NULL );
        var_hex_str = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        {
            PyObject *tmp_assign_source_4;
            PyObject *tmp_iter_arg_1;
            tmp_iter_arg_1 = const_tuple_3447faa1dbe297d65e63446bccca6976_tuple;
            tmp_assign_source_4 = MAKE_ITERATOR( tmp_iter_arg_1 );
            assert( !(tmp_assign_source_4 == NULL) );
            assert( tmp_list_contraction_1__$0 == NULL );
            tmp_list_contraction_1__$0 = tmp_assign_source_4;
        }
        {
            PyObject *tmp_assign_source_5;
            tmp_assign_source_5 = PyList_New( 0 );
            assert( tmp_list_contraction_1__contraction_result == NULL );
            tmp_list_contraction_1__contraction_result = tmp_assign_source_5;
        }
        // Tried code:
        loop_start_1:;
        {
            PyObject *tmp_next_source_1;
            PyObject *tmp_assign_source_6;
            CHECK_OBJECT( tmp_list_contraction_1__$0 );
            tmp_next_source_1 = tmp_list_contraction_1__$0;
            tmp_assign_source_6 = ITERATOR_NEXT( tmp_next_source_1 );
            if ( tmp_assign_source_6 == NULL )
            {
                if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
                {

                    goto loop_end_1;
                }
                else
                {

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    type_description_1 = "ooooo";
                    exception_lineno = 1956;
                    goto try_except_handler_2;
                }
            }

            {
                PyObject *old = tmp_list_contraction_1__iter_value_0;
                tmp_list_contraction_1__iter_value_0 = tmp_assign_source_6;
                Py_XDECREF( old );
            }

        }
        {
            PyObject *tmp_assign_source_7;
            CHECK_OBJECT( tmp_list_contraction_1__iter_value_0 );
            tmp_assign_source_7 = tmp_list_contraction_1__iter_value_0;
            {
                PyObject *old = var_x;
                var_x = tmp_assign_source_7;
                Py_INCREF( var_x );
                Py_XDECREF( old );
            }

        }
        {
            PyObject *tmp_append_list_1;
            PyObject *tmp_append_value_1;
            PyObject *tmp_left_name_2;
            PyObject *tmp_right_name_2;
            PyObject *tmp_value_name_1;
            PyObject *tmp_slice_source_1;
            PyObject *tmp_slice_lower_1;
            PyObject *tmp_slice_upper_1;
            PyObject *tmp_left_name_3;
            PyObject *tmp_right_name_3;
            PyObject *tmp_base_name_1;
            CHECK_OBJECT( tmp_list_contraction_1__contraction_result );
            tmp_append_list_1 = tmp_list_contraction_1__contraction_result;
            tmp_left_name_2 = const_unicode_digest_1cfaa7410665eaa83a33dc9c2b2ef5a2;
            CHECK_OBJECT( var_hex_str );
            tmp_slice_source_1 = var_hex_str;
            CHECK_OBJECT( var_x );
            tmp_slice_lower_1 = var_x;
            CHECK_OBJECT( var_x );
            tmp_left_name_3 = var_x;
            tmp_right_name_3 = const_int_pos_4;
            tmp_slice_upper_1 = BINARY_OPERATION_ADD_OBJECT_INT( tmp_left_name_3, tmp_right_name_3 );
            if ( tmp_slice_upper_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1956;
                type_description_1 = "ooooo";
                goto try_except_handler_2;
            }
            tmp_value_name_1 = LOOKUP_SLICE( tmp_slice_source_1, tmp_slice_lower_1, tmp_slice_upper_1 );
            Py_DECREF( tmp_slice_upper_1 );
            if ( tmp_value_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1956;
                type_description_1 = "ooooo";
                goto try_except_handler_2;
            }
            tmp_base_name_1 = const_int_pos_16;
            tmp_right_name_2 = TO_INT2( tmp_value_name_1, tmp_base_name_1 );
            Py_DECREF( tmp_value_name_1 );
            if ( tmp_right_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1956;
                type_description_1 = "ooooo";
                goto try_except_handler_2;
            }
            tmp_append_value_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_2, tmp_right_name_2 );
            Py_DECREF( tmp_right_name_2 );
            if ( tmp_append_value_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1956;
                type_description_1 = "ooooo";
                goto try_except_handler_2;
            }
            assert( PyList_Check( tmp_append_list_1 ) );
            tmp_res = PyList_Append( tmp_append_list_1, tmp_append_value_1 );
            Py_DECREF( tmp_append_value_1 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1956;
                type_description_1 = "ooooo";
                goto try_except_handler_2;
            }
        }
        if ( CONSIDER_THREADING() == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1956;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }
        goto loop_start_1;
        loop_end_1:;
        CHECK_OBJECT( tmp_list_contraction_1__contraction_result );
        tmp_assign_source_3 = tmp_list_contraction_1__contraction_result;
        Py_INCREF( tmp_assign_source_3 );
        goto try_return_handler_2;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ipaddress$$$function_113__string_from_ip_int );
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        CHECK_OBJECT( (PyObject *)tmp_list_contraction_1__$0 );
        Py_DECREF( tmp_list_contraction_1__$0 );
        tmp_list_contraction_1__$0 = NULL;

        CHECK_OBJECT( (PyObject *)tmp_list_contraction_1__contraction_result );
        Py_DECREF( tmp_list_contraction_1__contraction_result );
        tmp_list_contraction_1__contraction_result = NULL;

        Py_XDECREF( tmp_list_contraction_1__iter_value_0 );
        tmp_list_contraction_1__iter_value_0 = NULL;

        goto outline_result_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        CHECK_OBJECT( (PyObject *)tmp_list_contraction_1__$0 );
        Py_DECREF( tmp_list_contraction_1__$0 );
        tmp_list_contraction_1__$0 = NULL;

        CHECK_OBJECT( (PyObject *)tmp_list_contraction_1__contraction_result );
        Py_DECREF( tmp_list_contraction_1__contraction_result );
        tmp_list_contraction_1__contraction_result = NULL;

        Py_XDECREF( tmp_list_contraction_1__iter_value_0 );
        tmp_list_contraction_1__iter_value_0 = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto frame_exception_exit_1;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( ipaddress$$$function_113__string_from_ip_int );
        return NULL;
        outline_result_1:;
        assert( var_hextets == NULL );
        var_hextets = tmp_assign_source_3;
    }
    {
        PyObject *tmp_assign_source_8;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT( par_cls );
        tmp_called_instance_1 = par_cls;
        CHECK_OBJECT( var_hextets );
        tmp_args_element_name_1 = var_hextets;
        frame_124ad0b848fffa9587184710249546c6->m_frame.f_lineno = 1958;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_8 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain__compress_hextets, call_args );
        }

        if ( tmp_assign_source_8 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1958;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = var_hextets;
            assert( old != NULL );
            var_hextets = tmp_assign_source_8;
            Py_DECREF( old );
        }

    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_args_element_name_2;
        tmp_called_instance_2 = const_unicode_chr_58;
        CHECK_OBJECT( var_hextets );
        tmp_args_element_name_2 = var_hextets;
        frame_124ad0b848fffa9587184710249546c6->m_frame.f_lineno = 1959;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_join, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1959;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_124ad0b848fffa9587184710249546c6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_124ad0b848fffa9587184710249546c6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_124ad0b848fffa9587184710249546c6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_124ad0b848fffa9587184710249546c6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_124ad0b848fffa9587184710249546c6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_124ad0b848fffa9587184710249546c6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_124ad0b848fffa9587184710249546c6,
        type_description_1,
        par_cls,
        par_ip_int,
        var_x,
        var_hex_str,
        var_hextets
    );


    // Release cached frame.
    if ( frame_124ad0b848fffa9587184710249546c6 == cache_frame_124ad0b848fffa9587184710249546c6 )
    {
        Py_DECREF( frame_124ad0b848fffa9587184710249546c6 );
    }
    cache_frame_124ad0b848fffa9587184710249546c6 = NULL;

    assertFrameObject( frame_124ad0b848fffa9587184710249546c6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_113__string_from_ip_int );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_x );
    var_x = NULL;

    CHECK_OBJECT( (PyObject *)par_ip_int );
    Py_DECREF( par_ip_int );
    par_ip_int = NULL;

    CHECK_OBJECT( (PyObject *)var_hex_str );
    Py_DECREF( var_hex_str );
    var_hex_str = NULL;

    CHECK_OBJECT( (PyObject *)var_hextets );
    Py_DECREF( var_hextets );
    var_hextets = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_x );
    var_x = NULL;

    Py_XDECREF( par_ip_int );
    par_ip_int = NULL;

    Py_XDECREF( var_hex_str );
    var_hex_str = NULL;

    Py_XDECREF( var_hextets );
    var_hextets = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_113__string_from_ip_int );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_114__explode_shorthand_ip_string( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_hex_str = NULL;
    PyObject *var_ip_int = NULL;
    PyObject *var_parts = NULL;
    PyObject *var_x = NULL;
    PyObject *var_ip_str = NULL;
    PyObject *tmp_list_contraction_1__$0 = NULL;
    PyObject *tmp_list_contraction_1__contraction_result = NULL;
    PyObject *tmp_list_contraction_1__iter_value_0 = NULL;
    struct Nuitka_FrameObject *frame_025da757111325499181d0330a4934f2;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_025da757111325499181d0330a4934f2 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_025da757111325499181d0330a4934f2, codeobj_025da757111325499181d0330a4934f2, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_025da757111325499181d0330a4934f2 = cache_frame_025da757111325499181d0330a4934f2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_025da757111325499181d0330a4934f2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_025da757111325499181d0330a4934f2 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_self );
        tmp_isinstance_inst_1 = par_self;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Network );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Network );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv6Network" );
            exception_tb = NULL;

            exception_lineno = 1971;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1971;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_called_name_1;
            PyObject *tmp_mvar_value_2;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_source_name_1;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_str );

            if (unlikely( tmp_mvar_value_2 == NULL ))
            {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__compat_str );
            }

            if ( tmp_mvar_value_2 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_compat_str" );
                exception_tb = NULL;

                exception_lineno = 1972;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_1 = tmp_mvar_value_2;
            CHECK_OBJECT( par_self );
            tmp_source_name_1 = par_self;
            tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_network_address );
            if ( tmp_args_element_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1972;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            frame_025da757111325499181d0330a4934f2->m_frame.f_lineno = 1972;
            {
                PyObject *call_args[] = { tmp_args_element_name_1 };
                tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
            }

            Py_DECREF( tmp_args_element_name_1 );
            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1972;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            assert( var_ip_str == NULL );
            var_ip_str = tmp_assign_source_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_isinstance_inst_2;
            PyObject *tmp_isinstance_cls_2;
            PyObject *tmp_mvar_value_3;
            CHECK_OBJECT( par_self );
            tmp_isinstance_inst_2 = par_self;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Interface );

            if (unlikely( tmp_mvar_value_3 == NULL ))
            {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Interface );
            }

            if ( tmp_mvar_value_3 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv6Interface" );
                exception_tb = NULL;

                exception_lineno = 1973;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }

            tmp_isinstance_cls_2 = tmp_mvar_value_3;
            tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1973;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_assign_source_2;
                PyObject *tmp_called_name_2;
                PyObject *tmp_mvar_value_4;
                PyObject *tmp_args_element_name_2;
                PyObject *tmp_source_name_2;
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_str );

                if (unlikely( tmp_mvar_value_4 == NULL ))
                {
                    tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__compat_str );
                }

                if ( tmp_mvar_value_4 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_compat_str" );
                    exception_tb = NULL;

                    exception_lineno = 1974;
                    type_description_1 = "oooooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_name_2 = tmp_mvar_value_4;
                CHECK_OBJECT( par_self );
                tmp_source_name_2 = par_self;
                tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_ip );
                if ( tmp_args_element_name_2 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1974;
                    type_description_1 = "oooooo";
                    goto frame_exception_exit_1;
                }
                frame_025da757111325499181d0330a4934f2->m_frame.f_lineno = 1974;
                {
                    PyObject *call_args[] = { tmp_args_element_name_2 };
                    tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
                }

                Py_DECREF( tmp_args_element_name_2 );
                if ( tmp_assign_source_2 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1974;
                    type_description_1 = "oooooo";
                    goto frame_exception_exit_1;
                }
                assert( var_ip_str == NULL );
                var_ip_str = tmp_assign_source_2;
            }
            goto branch_end_2;
            branch_no_2:;
            {
                PyObject *tmp_assign_source_3;
                PyObject *tmp_called_name_3;
                PyObject *tmp_mvar_value_5;
                PyObject *tmp_args_element_name_3;
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_str );

                if (unlikely( tmp_mvar_value_5 == NULL ))
                {
                    tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__compat_str );
                }

                if ( tmp_mvar_value_5 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_compat_str" );
                    exception_tb = NULL;

                    exception_lineno = 1976;
                    type_description_1 = "oooooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_name_3 = tmp_mvar_value_5;
                CHECK_OBJECT( par_self );
                tmp_args_element_name_3 = par_self;
                frame_025da757111325499181d0330a4934f2->m_frame.f_lineno = 1976;
                {
                    PyObject *call_args[] = { tmp_args_element_name_3 };
                    tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
                }

                if ( tmp_assign_source_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1976;
                    type_description_1 = "oooooo";
                    goto frame_exception_exit_1;
                }
                assert( var_ip_str == NULL );
                var_ip_str = tmp_assign_source_3;
            }
            branch_end_2:;
        }
        branch_end_1:;
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_3;
        PyObject *tmp_args_element_name_4;
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__ip_int_from_string );
        if ( tmp_called_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1978;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        if ( var_ip_str == NULL )
        {
            Py_DECREF( tmp_called_name_4 );
            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "ip_str" );
            exception_tb = NULL;

            exception_lineno = 1978;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_4 = var_ip_str;
        frame_025da757111325499181d0330a4934f2->m_frame.f_lineno = 1978;
        {
            PyObject *call_args[] = { tmp_args_element_name_4 };
            tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
        }

        Py_DECREF( tmp_called_name_4 );
        if ( tmp_assign_source_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1978;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        assert( var_ip_int == NULL );
        var_ip_int = tmp_assign_source_4;
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        tmp_left_name_1 = const_unicode_digest_7f00060466647c49fa48da2be5e497c8;
        CHECK_OBJECT( var_ip_int );
        tmp_right_name_1 = var_ip_int;
        tmp_assign_source_5 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
        if ( tmp_assign_source_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1979;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        assert( var_hex_str == NULL );
        var_hex_str = tmp_assign_source_5;
    }
    {
        PyObject *tmp_assign_source_6;
        {
            PyObject *tmp_assign_source_7;
            PyObject *tmp_iter_arg_1;
            tmp_iter_arg_1 = const_tuple_3447faa1dbe297d65e63446bccca6976_tuple;
            tmp_assign_source_7 = MAKE_ITERATOR( tmp_iter_arg_1 );
            assert( !(tmp_assign_source_7 == NULL) );
            assert( tmp_list_contraction_1__$0 == NULL );
            tmp_list_contraction_1__$0 = tmp_assign_source_7;
        }
        {
            PyObject *tmp_assign_source_8;
            tmp_assign_source_8 = PyList_New( 0 );
            assert( tmp_list_contraction_1__contraction_result == NULL );
            tmp_list_contraction_1__contraction_result = tmp_assign_source_8;
        }
        // Tried code:
        loop_start_1:;
        {
            PyObject *tmp_next_source_1;
            PyObject *tmp_assign_source_9;
            CHECK_OBJECT( tmp_list_contraction_1__$0 );
            tmp_next_source_1 = tmp_list_contraction_1__$0;
            tmp_assign_source_9 = ITERATOR_NEXT( tmp_next_source_1 );
            if ( tmp_assign_source_9 == NULL )
            {
                if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
                {

                    goto loop_end_1;
                }
                else
                {

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    type_description_1 = "oooooo";
                    exception_lineno = 1980;
                    goto try_except_handler_2;
                }
            }

            {
                PyObject *old = tmp_list_contraction_1__iter_value_0;
                tmp_list_contraction_1__iter_value_0 = tmp_assign_source_9;
                Py_XDECREF( old );
            }

        }
        {
            PyObject *tmp_assign_source_10;
            CHECK_OBJECT( tmp_list_contraction_1__iter_value_0 );
            tmp_assign_source_10 = tmp_list_contraction_1__iter_value_0;
            {
                PyObject *old = var_x;
                var_x = tmp_assign_source_10;
                Py_INCREF( var_x );
                Py_XDECREF( old );
            }

        }
        {
            PyObject *tmp_append_list_1;
            PyObject *tmp_append_value_1;
            PyObject *tmp_slice_source_1;
            PyObject *tmp_slice_lower_1;
            PyObject *tmp_slice_upper_1;
            PyObject *tmp_left_name_2;
            PyObject *tmp_right_name_2;
            CHECK_OBJECT( tmp_list_contraction_1__contraction_result );
            tmp_append_list_1 = tmp_list_contraction_1__contraction_result;
            CHECK_OBJECT( var_hex_str );
            tmp_slice_source_1 = var_hex_str;
            CHECK_OBJECT( var_x );
            tmp_slice_lower_1 = var_x;
            CHECK_OBJECT( var_x );
            tmp_left_name_2 = var_x;
            tmp_right_name_2 = const_int_pos_4;
            tmp_slice_upper_1 = BINARY_OPERATION_ADD_OBJECT_INT( tmp_left_name_2, tmp_right_name_2 );
            if ( tmp_slice_upper_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1980;
                type_description_1 = "oooooo";
                goto try_except_handler_2;
            }
            tmp_append_value_1 = LOOKUP_SLICE( tmp_slice_source_1, tmp_slice_lower_1, tmp_slice_upper_1 );
            Py_DECREF( tmp_slice_upper_1 );
            if ( tmp_append_value_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1980;
                type_description_1 = "oooooo";
                goto try_except_handler_2;
            }
            assert( PyList_Check( tmp_append_list_1 ) );
            tmp_res = PyList_Append( tmp_append_list_1, tmp_append_value_1 );
            Py_DECREF( tmp_append_value_1 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1980;
                type_description_1 = "oooooo";
                goto try_except_handler_2;
            }
        }
        if ( CONSIDER_THREADING() == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1980;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }
        goto loop_start_1;
        loop_end_1:;
        CHECK_OBJECT( tmp_list_contraction_1__contraction_result );
        tmp_assign_source_6 = tmp_list_contraction_1__contraction_result;
        Py_INCREF( tmp_assign_source_6 );
        goto try_return_handler_2;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ipaddress$$$function_114__explode_shorthand_ip_string );
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        CHECK_OBJECT( (PyObject *)tmp_list_contraction_1__$0 );
        Py_DECREF( tmp_list_contraction_1__$0 );
        tmp_list_contraction_1__$0 = NULL;

        CHECK_OBJECT( (PyObject *)tmp_list_contraction_1__contraction_result );
        Py_DECREF( tmp_list_contraction_1__contraction_result );
        tmp_list_contraction_1__contraction_result = NULL;

        Py_XDECREF( tmp_list_contraction_1__iter_value_0 );
        tmp_list_contraction_1__iter_value_0 = NULL;

        goto outline_result_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        CHECK_OBJECT( (PyObject *)tmp_list_contraction_1__$0 );
        Py_DECREF( tmp_list_contraction_1__$0 );
        tmp_list_contraction_1__$0 = NULL;

        CHECK_OBJECT( (PyObject *)tmp_list_contraction_1__contraction_result );
        Py_DECREF( tmp_list_contraction_1__contraction_result );
        tmp_list_contraction_1__contraction_result = NULL;

        Py_XDECREF( tmp_list_contraction_1__iter_value_0 );
        tmp_list_contraction_1__iter_value_0 = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto frame_exception_exit_1;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( ipaddress$$$function_114__explode_shorthand_ip_string );
        return NULL;
        outline_result_1:;
        assert( var_parts == NULL );
        var_parts = tmp_assign_source_6;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_isinstance_inst_3;
        PyObject *tmp_isinstance_cls_3;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_mvar_value_7;
        CHECK_OBJECT( par_self );
        tmp_isinstance_inst_3 = par_self;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__BaseNetwork );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__BaseNetwork );
        }

        if ( tmp_mvar_value_6 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_BaseNetwork" );
            exception_tb = NULL;

            exception_lineno = 1981;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_tuple_element_1 = tmp_mvar_value_6;
        tmp_isinstance_cls_3 = PyTuple_New( 2 );
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_isinstance_cls_3, 0, tmp_tuple_element_1 );
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Interface );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Interface );
        }

        if ( tmp_mvar_value_7 == NULL )
        {
            Py_DECREF( tmp_isinstance_cls_3 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv6Interface" );
            exception_tb = NULL;

            exception_lineno = 1981;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_tuple_element_1 = tmp_mvar_value_7;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_isinstance_cls_3, 1, tmp_tuple_element_1 );
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_3, tmp_isinstance_cls_3 );
        Py_DECREF( tmp_isinstance_cls_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1981;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_left_name_3;
            PyObject *tmp_right_name_3;
            PyObject *tmp_tuple_element_2;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_args_element_name_5;
            PyObject *tmp_source_name_4;
            tmp_left_name_3 = const_unicode_digest_6a98397c0892ba5e9c29046762cbb9d8;
            tmp_called_instance_1 = const_unicode_chr_58;
            CHECK_OBJECT( var_parts );
            tmp_args_element_name_5 = var_parts;
            frame_025da757111325499181d0330a4934f2->m_frame.f_lineno = 1982;
            {
                PyObject *call_args[] = { tmp_args_element_name_5 };
                tmp_tuple_element_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_join, call_args );
            }

            if ( tmp_tuple_element_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1982;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            tmp_right_name_3 = PyTuple_New( 2 );
            PyTuple_SET_ITEM( tmp_right_name_3, 0, tmp_tuple_element_2 );
            CHECK_OBJECT( par_self );
            tmp_source_name_4 = par_self;
            tmp_tuple_element_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__prefixlen );
            if ( tmp_tuple_element_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_right_name_3 );

                exception_lineno = 1982;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            PyTuple_SET_ITEM( tmp_right_name_3, 1, tmp_tuple_element_2 );
            tmp_return_value = BINARY_OPERATION_REMAINDER( tmp_left_name_3, tmp_right_name_3 );
            Py_DECREF( tmp_right_name_3 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1982;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_no_3:;
    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_args_element_name_6;
        tmp_called_instance_2 = const_unicode_chr_58;
        CHECK_OBJECT( var_parts );
        tmp_args_element_name_6 = var_parts;
        frame_025da757111325499181d0330a4934f2->m_frame.f_lineno = 1983;
        {
            PyObject *call_args[] = { tmp_args_element_name_6 };
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_join, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1983;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_025da757111325499181d0330a4934f2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_025da757111325499181d0330a4934f2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_025da757111325499181d0330a4934f2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_025da757111325499181d0330a4934f2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_025da757111325499181d0330a4934f2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_025da757111325499181d0330a4934f2, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_025da757111325499181d0330a4934f2,
        type_description_1,
        par_self,
        var_hex_str,
        var_ip_int,
        var_parts,
        var_x,
        var_ip_str
    );


    // Release cached frame.
    if ( frame_025da757111325499181d0330a4934f2 == cache_frame_025da757111325499181d0330a4934f2 )
    {
        Py_DECREF( frame_025da757111325499181d0330a4934f2 );
    }
    cache_frame_025da757111325499181d0330a4934f2 = NULL;

    assertFrameObject( frame_025da757111325499181d0330a4934f2 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_114__explode_shorthand_ip_string );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_hex_str );
    Py_DECREF( var_hex_str );
    var_hex_str = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_ip_int );
    Py_DECREF( var_ip_int );
    var_ip_int = NULL;

    CHECK_OBJECT( (PyObject *)var_parts );
    Py_DECREF( var_parts );
    var_parts = NULL;

    Py_XDECREF( var_x );
    var_x = NULL;

    Py_XDECREF( var_ip_str );
    var_ip_str = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_hex_str );
    var_hex_str = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_ip_int );
    var_ip_int = NULL;

    Py_XDECREF( var_parts );
    var_parts = NULL;

    Py_XDECREF( var_x );
    var_x = NULL;

    Py_XDECREF( var_ip_str );
    var_ip_str = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_114__explode_shorthand_ip_string );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_115__reverse_pointer( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_reverse_chars = NULL;
    struct Nuitka_FrameObject *frame_35b05f2076f28f93f5a20a6e91d03cdf;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_35b05f2076f28f93f5a20a6e91d03cdf = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_35b05f2076f28f93f5a20a6e91d03cdf, codeobj_35b05f2076f28f93f5a20a6e91d03cdf, module_ipaddress, sizeof(void *)+sizeof(void *) );
    frame_35b05f2076f28f93f5a20a6e91d03cdf = cache_frame_35b05f2076f28f93f5a20a6e91d03cdf;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_35b05f2076f28f93f5a20a6e91d03cdf );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_35b05f2076f28f93f5a20a6e91d03cdf ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_subscript_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_exploded );
        if ( tmp_subscribed_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1991;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_subscript_name_1 = const_slice_none_none_int_neg_1;
        tmp_called_instance_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
        Py_DECREF( tmp_subscribed_name_1 );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1991;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_35b05f2076f28f93f5a20a6e91d03cdf->m_frame.f_lineno = 1991;
        tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_replace, &PyTuple_GET_ITEM( const_tuple_unicode_chr_58_unicode_empty_tuple, 0 ) );

        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1991;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert( var_reverse_chars == NULL );
        var_reverse_chars = tmp_assign_source_1;
    }
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_right_name_1;
        tmp_called_instance_2 = const_unicode_dot;
        CHECK_OBJECT( var_reverse_chars );
        tmp_args_element_name_1 = var_reverse_chars;
        frame_35b05f2076f28f93f5a20a6e91d03cdf->m_frame.f_lineno = 1992;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_left_name_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_join, call_args );
        }

        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1992;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_right_name_1 = const_unicode_digest_2972f45afa340c1d13e07950dc835f22;
        tmp_return_value = BINARY_OPERATION_ADD_OBJECT_UNICODE( tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_left_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1992;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_35b05f2076f28f93f5a20a6e91d03cdf );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_35b05f2076f28f93f5a20a6e91d03cdf );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_35b05f2076f28f93f5a20a6e91d03cdf );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_35b05f2076f28f93f5a20a6e91d03cdf, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_35b05f2076f28f93f5a20a6e91d03cdf->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_35b05f2076f28f93f5a20a6e91d03cdf, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_35b05f2076f28f93f5a20a6e91d03cdf,
        type_description_1,
        par_self,
        var_reverse_chars
    );


    // Release cached frame.
    if ( frame_35b05f2076f28f93f5a20a6e91d03cdf == cache_frame_35b05f2076f28f93f5a20a6e91d03cdf )
    {
        Py_DECREF( frame_35b05f2076f28f93f5a20a6e91d03cdf );
    }
    cache_frame_35b05f2076f28f93f5a20a6e91d03cdf = NULL;

    assertFrameObject( frame_35b05f2076f28f93f5a20a6e91d03cdf );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_115__reverse_pointer );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_reverse_chars );
    Py_DECREF( var_reverse_chars );
    var_reverse_chars = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_reverse_chars );
    var_reverse_chars = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_115__reverse_pointer );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_116_max_prefixlen( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_f4b494f9d651886073c73f6a413cb5bc;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_f4b494f9d651886073c73f6a413cb5bc = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f4b494f9d651886073c73f6a413cb5bc, codeobj_f4b494f9d651886073c73f6a413cb5bc, module_ipaddress, sizeof(void *) );
    frame_f4b494f9d651886073c73f6a413cb5bc = cache_frame_f4b494f9d651886073c73f6a413cb5bc;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f4b494f9d651886073c73f6a413cb5bc );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f4b494f9d651886073c73f6a413cb5bc ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__max_prefixlen );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1996;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f4b494f9d651886073c73f6a413cb5bc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_f4b494f9d651886073c73f6a413cb5bc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f4b494f9d651886073c73f6a413cb5bc );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f4b494f9d651886073c73f6a413cb5bc, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f4b494f9d651886073c73f6a413cb5bc->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f4b494f9d651886073c73f6a413cb5bc, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f4b494f9d651886073c73f6a413cb5bc,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_f4b494f9d651886073c73f6a413cb5bc == cache_frame_f4b494f9d651886073c73f6a413cb5bc )
    {
        Py_DECREF( frame_f4b494f9d651886073c73f6a413cb5bc );
    }
    cache_frame_f4b494f9d651886073c73f6a413cb5bc = NULL;

    assertFrameObject( frame_f4b494f9d651886073c73f6a413cb5bc );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_116_max_prefixlen );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_116_max_prefixlen );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_117_version( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_df20c4ec324ad955944c40cd6e9c34ee;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_df20c4ec324ad955944c40cd6e9c34ee = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_df20c4ec324ad955944c40cd6e9c34ee, codeobj_df20c4ec324ad955944c40cd6e9c34ee, module_ipaddress, sizeof(void *) );
    frame_df20c4ec324ad955944c40cd6e9c34ee = cache_frame_df20c4ec324ad955944c40cd6e9c34ee;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_df20c4ec324ad955944c40cd6e9c34ee );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_df20c4ec324ad955944c40cd6e9c34ee ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__version );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2000;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_df20c4ec324ad955944c40cd6e9c34ee );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_df20c4ec324ad955944c40cd6e9c34ee );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_df20c4ec324ad955944c40cd6e9c34ee );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_df20c4ec324ad955944c40cd6e9c34ee, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_df20c4ec324ad955944c40cd6e9c34ee->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_df20c4ec324ad955944c40cd6e9c34ee, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_df20c4ec324ad955944c40cd6e9c34ee,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_df20c4ec324ad955944c40cd6e9c34ee == cache_frame_df20c4ec324ad955944c40cd6e9c34ee )
    {
        Py_DECREF( frame_df20c4ec324ad955944c40cd6e9c34ee );
    }
    cache_frame_df20c4ec324ad955944c40cd6e9c34ee = NULL;

    assertFrameObject( frame_df20c4ec324ad955944c40cd6e9c34ee );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_117_version );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_117_version );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_118___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_address = python_pars[ 1 ];
    PyObject *var_bvs = NULL;
    PyObject *var_addr_str = NULL;
    struct Nuitka_FrameObject *frame_2f7e7db6799399502d6940e3245a34c6;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_2f7e7db6799399502d6940e3245a34c6 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2f7e7db6799399502d6940e3245a34c6, codeobj_2f7e7db6799399502d6940e3245a34c6, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_2f7e7db6799399502d6940e3245a34c6 = cache_frame_2f7e7db6799399502d6940e3245a34c6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2f7e7db6799399502d6940e3245a34c6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2f7e7db6799399502d6940e3245a34c6 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_address );
        tmp_isinstance_inst_1 = par_address;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_int_types );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__compat_int_types );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_compat_int_types" );
            exception_tb = NULL;

            exception_lineno = 2027;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2027;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_1;
            CHECK_OBJECT( par_self );
            tmp_called_instance_1 = par_self;
            CHECK_OBJECT( par_address );
            tmp_args_element_name_1 = par_address;
            frame_2f7e7db6799399502d6940e3245a34c6->m_frame.f_lineno = 2028;
            {
                PyObject *call_args[] = { tmp_args_element_name_1 };
                tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain__check_int_address, call_args );
            }

            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2028;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        {
            PyObject *tmp_assattr_name_1;
            PyObject *tmp_assattr_target_1;
            CHECK_OBJECT( par_address );
            tmp_assattr_name_1 = par_address;
            CHECK_OBJECT( par_self );
            tmp_assattr_target_1 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__ip, tmp_assattr_name_1 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2029;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
        }
        tmp_return_value = Py_None;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_isinstance_inst_2;
        PyObject *tmp_isinstance_cls_2;
        CHECK_OBJECT( par_address );
        tmp_isinstance_inst_2 = par_address;
        tmp_isinstance_cls_2 = (PyObject *)&PyString_Type;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2033;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_called_instance_2;
            PyObject *tmp_call_result_2;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_args_element_name_3;
            CHECK_OBJECT( par_self );
            tmp_called_instance_2 = par_self;
            CHECK_OBJECT( par_address );
            tmp_args_element_name_2 = par_address;
            tmp_args_element_name_3 = const_int_pos_16;
            frame_2f7e7db6799399502d6940e3245a34c6->m_frame.f_lineno = 2034;
            {
                PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
                tmp_call_result_2 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain__check_packed_address, call_args );
            }

            if ( tmp_call_result_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2034;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_2 );
        }
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_called_name_1;
            PyObject *tmp_mvar_value_2;
            PyObject *tmp_args_element_name_4;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_bytes_to_byte_vals );

            if (unlikely( tmp_mvar_value_2 == NULL ))
            {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__compat_bytes_to_byte_vals );
            }

            if ( tmp_mvar_value_2 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_compat_bytes_to_byte_vals" );
                exception_tb = NULL;

                exception_lineno = 2035;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_1 = tmp_mvar_value_2;
            CHECK_OBJECT( par_address );
            tmp_args_element_name_4 = par_address;
            frame_2f7e7db6799399502d6940e3245a34c6->m_frame.f_lineno = 2035;
            {
                PyObject *call_args[] = { tmp_args_element_name_4 };
                tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
            }

            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2035;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            assert( var_bvs == NULL );
            var_bvs = tmp_assign_source_1;
        }
        {
            PyObject *tmp_assattr_name_2;
            PyObject *tmp_called_name_2;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_args_element_name_5;
            PyObject *tmp_args_element_name_6;
            PyObject *tmp_assattr_target_2;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_int_from_byte_vals );

            if (unlikely( tmp_mvar_value_3 == NULL ))
            {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__compat_int_from_byte_vals );
            }

            if ( tmp_mvar_value_3 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_compat_int_from_byte_vals" );
                exception_tb = NULL;

                exception_lineno = 2036;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_2 = tmp_mvar_value_3;
            CHECK_OBJECT( var_bvs );
            tmp_args_element_name_5 = var_bvs;
            tmp_args_element_name_6 = const_unicode_plain_big;
            frame_2f7e7db6799399502d6940e3245a34c6->m_frame.f_lineno = 2036;
            {
                PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
                tmp_assattr_name_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
            }

            if ( tmp_assattr_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2036;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_assattr_target_2 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__ip, tmp_assattr_name_2 );
            Py_DECREF( tmp_assattr_name_2 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2036;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
        }
        tmp_return_value = Py_None;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_2:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_7;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_str );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__compat_str );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_compat_str" );
            exception_tb = NULL;

            exception_lineno = 2041;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_4;
        CHECK_OBJECT( par_address );
        tmp_args_element_name_7 = par_address;
        frame_2f7e7db6799399502d6940e3245a34c6->m_frame.f_lineno = 2041;
        {
            PyObject *call_args[] = { tmp_args_element_name_7 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
        }

        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2041;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_addr_str == NULL );
        var_addr_str = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_compexpr_left_1 = const_unicode_chr_47;
        CHECK_OBJECT( var_addr_str );
        tmp_compexpr_right_1 = var_addr_str;
        tmp_res = PySequence_Contains( tmp_compexpr_right_1, tmp_compexpr_left_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2042;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = ( tmp_res == 1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_called_name_4;
            PyObject *tmp_mvar_value_5;
            PyObject *tmp_args_element_name_8;
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_AddressValueError );

            if (unlikely( tmp_mvar_value_5 == NULL ))
            {
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AddressValueError );
            }

            if ( tmp_mvar_value_5 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "AddressValueError" );
                exception_tb = NULL;

                exception_lineno = 2043;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_4 = tmp_mvar_value_5;
            tmp_left_name_1 = const_unicode_digest_eff0de065ad1be8ff8f4264ecac2dcba;
            CHECK_OBJECT( par_address );
            tmp_right_name_1 = par_address;
            tmp_args_element_name_8 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
            if ( tmp_args_element_name_8 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2043;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            frame_2f7e7db6799399502d6940e3245a34c6->m_frame.f_lineno = 2043;
            {
                PyObject *call_args[] = { tmp_args_element_name_8 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
            }

            Py_DECREF( tmp_args_element_name_8 );
            if ( tmp_raise_type_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2043;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            exception_type = tmp_raise_type_1;
            exception_lineno = 2043;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        branch_no_3:;
    }
    {
        PyObject *tmp_assattr_name_3;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_assattr_target_3;
        CHECK_OBJECT( par_self );
        tmp_called_instance_3 = par_self;
        CHECK_OBJECT( var_addr_str );
        tmp_args_element_name_9 = var_addr_str;
        frame_2f7e7db6799399502d6940e3245a34c6->m_frame.f_lineno = 2044;
        {
            PyObject *call_args[] = { tmp_args_element_name_9 };
            tmp_assattr_name_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain__ip_int_from_string, call_args );
        }

        if ( tmp_assattr_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2044;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_3 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain__ip, tmp_assattr_name_3 );
        Py_DECREF( tmp_assattr_name_3 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2044;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2f7e7db6799399502d6940e3245a34c6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_2f7e7db6799399502d6940e3245a34c6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2f7e7db6799399502d6940e3245a34c6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2f7e7db6799399502d6940e3245a34c6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2f7e7db6799399502d6940e3245a34c6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2f7e7db6799399502d6940e3245a34c6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2f7e7db6799399502d6940e3245a34c6,
        type_description_1,
        par_self,
        par_address,
        var_bvs,
        var_addr_str
    );


    // Release cached frame.
    if ( frame_2f7e7db6799399502d6940e3245a34c6 == cache_frame_2f7e7db6799399502d6940e3245a34c6 )
    {
        Py_DECREF( frame_2f7e7db6799399502d6940e3245a34c6 );
    }
    cache_frame_2f7e7db6799399502d6940e3245a34c6 = NULL;

    assertFrameObject( frame_2f7e7db6799399502d6940e3245a34c6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_118___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_bvs );
    var_bvs = NULL;

    Py_XDECREF( var_addr_str );
    var_addr_str = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_address );
    Py_DECREF( par_address );
    par_address = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_bvs );
    var_bvs = NULL;

    Py_XDECREF( var_addr_str );
    var_addr_str = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_address );
    Py_DECREF( par_address );
    par_address = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_118___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_119_packed( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_21ddc125364ef772bcb1aad81be1d95e;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_21ddc125364ef772bcb1aad81be1d95e = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_21ddc125364ef772bcb1aad81be1d95e, codeobj_21ddc125364ef772bcb1aad81be1d95e, module_ipaddress, sizeof(void *) );
    frame_21ddc125364ef772bcb1aad81be1d95e = cache_frame_21ddc125364ef772bcb1aad81be1d95e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_21ddc125364ef772bcb1aad81be1d95e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_21ddc125364ef772bcb1aad81be1d95e ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_v6_int_to_packed );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_v6_int_to_packed );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "v6_int_to_packed" );
            exception_tb = NULL;

            exception_lineno = 2049;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__ip );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2049;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_21ddc125364ef772bcb1aad81be1d95e->m_frame.f_lineno = 2049;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2049;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_21ddc125364ef772bcb1aad81be1d95e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_21ddc125364ef772bcb1aad81be1d95e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_21ddc125364ef772bcb1aad81be1d95e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_21ddc125364ef772bcb1aad81be1d95e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_21ddc125364ef772bcb1aad81be1d95e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_21ddc125364ef772bcb1aad81be1d95e, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_21ddc125364ef772bcb1aad81be1d95e,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_21ddc125364ef772bcb1aad81be1d95e == cache_frame_21ddc125364ef772bcb1aad81be1d95e )
    {
        Py_DECREF( frame_21ddc125364ef772bcb1aad81be1d95e );
    }
    cache_frame_21ddc125364ef772bcb1aad81be1d95e = NULL;

    assertFrameObject( frame_21ddc125364ef772bcb1aad81be1d95e );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_119_packed );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_119_packed );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_120_is_multicast( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_77bf576a262d37c8647e73432c32b9e8;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_77bf576a262d37c8647e73432c32b9e8 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_77bf576a262d37c8647e73432c32b9e8, codeobj_77bf576a262d37c8647e73432c32b9e8, module_ipaddress, sizeof(void *) );
    frame_77bf576a262d37c8647e73432c32b9e8 = cache_frame_77bf576a262d37c8647e73432c32b9e8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_77bf576a262d37c8647e73432c32b9e8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_77bf576a262d37c8647e73432c32b9e8 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( par_self );
        tmp_compexpr_left_1 = par_self;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__constants );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2060;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__multicast_network );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2060;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_res = PySequence_Contains( tmp_compexpr_right_1, tmp_compexpr_left_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2060;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = ( tmp_res == 1 ) ? Py_True : Py_False;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_77bf576a262d37c8647e73432c32b9e8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_77bf576a262d37c8647e73432c32b9e8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_77bf576a262d37c8647e73432c32b9e8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_77bf576a262d37c8647e73432c32b9e8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_77bf576a262d37c8647e73432c32b9e8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_77bf576a262d37c8647e73432c32b9e8, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_77bf576a262d37c8647e73432c32b9e8,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_77bf576a262d37c8647e73432c32b9e8 == cache_frame_77bf576a262d37c8647e73432c32b9e8 )
    {
        Py_DECREF( frame_77bf576a262d37c8647e73432c32b9e8 );
    }
    cache_frame_77bf576a262d37c8647e73432c32b9e8 = NULL;

    assertFrameObject( frame_77bf576a262d37c8647e73432c32b9e8 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_120_is_multicast );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_120_is_multicast );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_121_is_reserved( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1( python_pars[ 0 ] );
    PyObject *tmp_genexpr_1__$0 = NULL;
    struct Nuitka_FrameObject *frame_df336f9f31d2c5b6ff8f38a70df38b5c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_df336f9f31d2c5b6ff8f38a70df38b5c = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_df336f9f31d2c5b6ff8f38a70df38b5c, codeobj_df336f9f31d2c5b6ff8f38a70df38b5c, module_ipaddress, sizeof(void *) );
    frame_df336f9f31d2c5b6ff8f38a70df38b5c = cache_frame_df336f9f31d2c5b6ff8f38a70df38b5c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_df336f9f31d2c5b6ff8f38a70df38b5c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_df336f9f31d2c5b6ff8f38a70df38b5c ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_1;
        tmp_called_name_1 = LOOKUP_BUILTIN( const_str_plain_any );
        assert( tmp_called_name_1 != NULL );
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_iter_arg_1;
            PyObject *tmp_source_name_1;
            PyObject *tmp_source_name_2;
            CHECK_OBJECT( PyCell_GET( par_self ) );
            tmp_source_name_2 = PyCell_GET( par_self );
            tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__constants );
            if ( tmp_source_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2071;
                type_description_1 = "c";
                goto frame_exception_exit_1;
            }
            tmp_iter_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__reserved_networks );
            Py_DECREF( tmp_source_name_1 );
            if ( tmp_iter_arg_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2071;
                type_description_1 = "c";
                goto frame_exception_exit_1;
            }
            tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
            Py_DECREF( tmp_iter_arg_1 );
            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2071;
                type_description_1 = "c";
                goto frame_exception_exit_1;
            }
            assert( tmp_genexpr_1__$0 == NULL );
            tmp_genexpr_1__$0 = tmp_assign_source_1;
        }
        // Tried code:
        tmp_args_element_name_1 = ipaddress$$$function_121_is_reserved$$$genexpr_1_genexpr_maker();

        ((struct Nuitka_GeneratorObject *)tmp_args_element_name_1)->m_closure[0] = PyCell_NEW0( tmp_genexpr_1__$0 );
        ((struct Nuitka_GeneratorObject *)tmp_args_element_name_1)->m_closure[1] = par_self;
        Py_INCREF( ((struct Nuitka_GeneratorObject *)tmp_args_element_name_1)->m_closure[1] );


        goto try_return_handler_2;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ipaddress$$$function_121_is_reserved );
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
        Py_DECREF( tmp_genexpr_1__$0 );
        tmp_genexpr_1__$0 = NULL;

        goto outline_result_1;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
        Py_DECREF( tmp_genexpr_1__$0 );
        tmp_genexpr_1__$0 = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( ipaddress$$$function_121_is_reserved );
        return NULL;
        outline_result_1:;
        frame_df336f9f31d2c5b6ff8f38a70df38b5c->m_frame.f_lineno = 2071;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2071;
            type_description_1 = "c";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_df336f9f31d2c5b6ff8f38a70df38b5c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_df336f9f31d2c5b6ff8f38a70df38b5c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_df336f9f31d2c5b6ff8f38a70df38b5c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_df336f9f31d2c5b6ff8f38a70df38b5c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_df336f9f31d2c5b6ff8f38a70df38b5c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_df336f9f31d2c5b6ff8f38a70df38b5c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_df336f9f31d2c5b6ff8f38a70df38b5c,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_df336f9f31d2c5b6ff8f38a70df38b5c == cache_frame_df336f9f31d2c5b6ff8f38a70df38b5c )
    {
        Py_DECREF( frame_df336f9f31d2c5b6ff8f38a70df38b5c );
    }
    cache_frame_df336f9f31d2c5b6ff8f38a70df38b5c = NULL;

    assertFrameObject( frame_df336f9f31d2c5b6ff8f38a70df38b5c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_121_is_reserved );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_121_is_reserved );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}



struct ipaddress$$$function_121_is_reserved$$$genexpr_1_genexpr_locals {
    PyObject *var_x;
    PyObject *tmp_iter_value_0;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    int tmp_res;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
};

static PyObject *ipaddress$$$function_121_is_reserved$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Heap access if used.
    struct ipaddress$$$function_121_is_reserved$$$genexpr_1_genexpr_locals *generator_heap = (struct ipaddress$$$function_121_is_reserved$$$genexpr_1_genexpr_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_x = NULL;
    generator_heap->tmp_iter_value_0 = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_m_frame, codeobj_ca2967c7caa9f0af32a9a121041acb68, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

#if PYTHON_VERSION < 370
        generator->m_frame->m_frame.f_exc_type = EXC_TYPE( thread_state );
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
        Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#else
        generator->m_exc_state.exc_type = EXC_TYPE( thread_state );
        if ( generator->m_exc_state.exc_type == Py_None ) generator->m_exc_state.exc_type = NULL;
        Py_XINCREF( generator->m_exc_state.exc_type );
        generator->m_exc_state.exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_value );
        generator->m_exc_state.exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_traceback );
#endif
    }

#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_1;
        CHECK_OBJECT( PyCell_GET( generator->m_closure[0] ) );
        tmp_next_source_1 = PyCell_GET( generator->m_closure[0] );
        tmp_assign_source_1 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
                generator_heap->type_description_1 = "Noc";
                generator_heap->exception_lineno = 2071;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_iter_value_0;
            generator_heap->tmp_iter_value_0 = tmp_assign_source_1;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT( generator_heap->tmp_iter_value_0 );
        tmp_assign_source_2 = generator_heap->tmp_iter_value_0;
        {
            PyObject *old = generator_heap->var_x;
            generator_heap->var_x = tmp_assign_source_2;
            Py_INCREF( generator_heap->var_x );
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_expression_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        if ( PyCell_GET( generator->m_closure[1] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 2071;
            generator_heap->type_description_1 = "Noc";
            goto try_except_handler_2;
        }

        tmp_compexpr_left_1 = PyCell_GET( generator->m_closure[1] );
        CHECK_OBJECT( generator_heap->var_x );
        tmp_compexpr_right_1 = generator_heap->var_x;
        generator_heap->tmp_res = PySequence_Contains( tmp_compexpr_right_1, tmp_compexpr_left_1 );
        if ( generator_heap->tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 2071;
            generator_heap->type_description_1 = "Noc";
            goto try_except_handler_2;
        }
        tmp_expression_name_1 = ( generator_heap->tmp_res == 1 ) ? Py_True : Py_False;
        Py_INCREF( tmp_expression_name_1 );
        Nuitka_PreserveHeap( generator_heap->yield_tmps, &tmp_compexpr_left_1, sizeof(PyObject *), &tmp_compexpr_right_1, sizeof(PyObject *), NULL );
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        Nuitka_RestoreHeap( generator_heap->yield_tmps, &tmp_compexpr_left_1, sizeof(PyObject *), &tmp_compexpr_right_1, sizeof(PyObject *), NULL );
        if ( yield_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 2071;
            generator_heap->type_description_1 = "Noc";
            goto try_except_handler_2;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


        generator_heap->exception_lineno = 2071;
        generator_heap->type_description_1 = "Noc";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->tmp_iter_value_0 );
    generator_heap->tmp_iter_value_0 = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( generator_heap->exception_type ) )
    {
        if ( generator_heap->exception_tb == NULL )
        {
            generator_heap->exception_tb = MAKE_TRACEBACK( generator->m_frame, generator_heap->exception_lineno );
        }
        else if ( generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            generator_heap->exception_tb = ADD_TRACEBACK( generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            NULL,
            generator_heap->var_x,
            generator->m_closure[1]
        );


        // Release cached frame.
        if ( generator->m_frame == cache_m_frame )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_m_frame = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->var_x );
    generator_heap->var_x = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:
    try_end_2:;
    Py_XDECREF( generator_heap->tmp_iter_value_0 );
    generator_heap->tmp_iter_value_0 = NULL;

    Py_XDECREF( generator_heap->var_x );
    generator_heap->var_x = NULL;



    return NULL;

    function_exception_exit:
    assert( generator_heap->exception_type );
    RESTORE_ERROR_OCCURRED( generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb );

    return NULL;

}

static PyObject *ipaddress$$$function_121_is_reserved$$$genexpr_1_genexpr_maker( void )
{
    return Nuitka_Generator_New(
        ipaddress$$$function_121_is_reserved$$$genexpr_1_genexpr_context,
        module_ipaddress,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_ca2967c7caa9f0af32a9a121041acb68,
        2,
        sizeof(struct ipaddress$$$function_121_is_reserved$$$genexpr_1_genexpr_locals)
    );
}


static PyObject *impl_ipaddress$$$function_122_is_link_local( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_b26421f87f4a69b7ea20133c9f845414;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_b26421f87f4a69b7ea20133c9f845414 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b26421f87f4a69b7ea20133c9f845414, codeobj_b26421f87f4a69b7ea20133c9f845414, module_ipaddress, sizeof(void *) );
    frame_b26421f87f4a69b7ea20133c9f845414 = cache_frame_b26421f87f4a69b7ea20133c9f845414;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b26421f87f4a69b7ea20133c9f845414 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b26421f87f4a69b7ea20133c9f845414 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( par_self );
        tmp_compexpr_left_1 = par_self;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__constants );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2081;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__linklocal_network );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2081;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_res = PySequence_Contains( tmp_compexpr_right_1, tmp_compexpr_left_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2081;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = ( tmp_res == 1 ) ? Py_True : Py_False;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b26421f87f4a69b7ea20133c9f845414 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_b26421f87f4a69b7ea20133c9f845414 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b26421f87f4a69b7ea20133c9f845414 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b26421f87f4a69b7ea20133c9f845414, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b26421f87f4a69b7ea20133c9f845414->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b26421f87f4a69b7ea20133c9f845414, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b26421f87f4a69b7ea20133c9f845414,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_b26421f87f4a69b7ea20133c9f845414 == cache_frame_b26421f87f4a69b7ea20133c9f845414 )
    {
        Py_DECREF( frame_b26421f87f4a69b7ea20133c9f845414 );
    }
    cache_frame_b26421f87f4a69b7ea20133c9f845414 = NULL;

    assertFrameObject( frame_b26421f87f4a69b7ea20133c9f845414 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_122_is_link_local );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_122_is_link_local );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_123_is_site_local( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_fce6ccb47dffbdcbdaa4a8ce79489a77;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_fce6ccb47dffbdcbdaa4a8ce79489a77 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_fce6ccb47dffbdcbdaa4a8ce79489a77, codeobj_fce6ccb47dffbdcbdaa4a8ce79489a77, module_ipaddress, sizeof(void *) );
    frame_fce6ccb47dffbdcbdaa4a8ce79489a77 = cache_frame_fce6ccb47dffbdcbdaa4a8ce79489a77;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_fce6ccb47dffbdcbdaa4a8ce79489a77 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_fce6ccb47dffbdcbdaa4a8ce79489a77 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( par_self );
        tmp_compexpr_left_1 = par_self;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__constants );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2095;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__sitelocal_network );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2095;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_res = PySequence_Contains( tmp_compexpr_right_1, tmp_compexpr_left_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2095;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = ( tmp_res == 1 ) ? Py_True : Py_False;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fce6ccb47dffbdcbdaa4a8ce79489a77 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_fce6ccb47dffbdcbdaa4a8ce79489a77 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fce6ccb47dffbdcbdaa4a8ce79489a77 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_fce6ccb47dffbdcbdaa4a8ce79489a77, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_fce6ccb47dffbdcbdaa4a8ce79489a77->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_fce6ccb47dffbdcbdaa4a8ce79489a77, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_fce6ccb47dffbdcbdaa4a8ce79489a77,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_fce6ccb47dffbdcbdaa4a8ce79489a77 == cache_frame_fce6ccb47dffbdcbdaa4a8ce79489a77 )
    {
        Py_DECREF( frame_fce6ccb47dffbdcbdaa4a8ce79489a77 );
    }
    cache_frame_fce6ccb47dffbdcbdaa4a8ce79489a77 = NULL;

    assertFrameObject( frame_fce6ccb47dffbdcbdaa4a8ce79489a77 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_123_is_site_local );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_123_is_site_local );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_124_is_private( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1( python_pars[ 0 ] );
    PyObject *tmp_genexpr_1__$0 = NULL;
    struct Nuitka_FrameObject *frame_9c71824c4bdb84129e3146d7ba81701a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_9c71824c4bdb84129e3146d7ba81701a = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9c71824c4bdb84129e3146d7ba81701a, codeobj_9c71824c4bdb84129e3146d7ba81701a, module_ipaddress, sizeof(void *) );
    frame_9c71824c4bdb84129e3146d7ba81701a = cache_frame_9c71824c4bdb84129e3146d7ba81701a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9c71824c4bdb84129e3146d7ba81701a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9c71824c4bdb84129e3146d7ba81701a ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_1;
        tmp_called_name_1 = LOOKUP_BUILTIN( const_str_plain_any );
        assert( tmp_called_name_1 != NULL );
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_iter_arg_1;
            PyObject *tmp_source_name_1;
            PyObject *tmp_source_name_2;
            CHECK_OBJECT( PyCell_GET( par_self ) );
            tmp_source_name_2 = PyCell_GET( par_self );
            tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__constants );
            if ( tmp_source_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2106;
                type_description_1 = "c";
                goto frame_exception_exit_1;
            }
            tmp_iter_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__private_networks );
            Py_DECREF( tmp_source_name_1 );
            if ( tmp_iter_arg_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2106;
                type_description_1 = "c";
                goto frame_exception_exit_1;
            }
            tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
            Py_DECREF( tmp_iter_arg_1 );
            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2106;
                type_description_1 = "c";
                goto frame_exception_exit_1;
            }
            assert( tmp_genexpr_1__$0 == NULL );
            tmp_genexpr_1__$0 = tmp_assign_source_1;
        }
        // Tried code:
        tmp_args_element_name_1 = ipaddress$$$function_124_is_private$$$genexpr_1_genexpr_maker();

        ((struct Nuitka_GeneratorObject *)tmp_args_element_name_1)->m_closure[0] = PyCell_NEW0( tmp_genexpr_1__$0 );
        ((struct Nuitka_GeneratorObject *)tmp_args_element_name_1)->m_closure[1] = par_self;
        Py_INCREF( ((struct Nuitka_GeneratorObject *)tmp_args_element_name_1)->m_closure[1] );


        goto try_return_handler_2;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ipaddress$$$function_124_is_private );
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
        Py_DECREF( tmp_genexpr_1__$0 );
        tmp_genexpr_1__$0 = NULL;

        goto outline_result_1;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
        Py_DECREF( tmp_genexpr_1__$0 );
        tmp_genexpr_1__$0 = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( ipaddress$$$function_124_is_private );
        return NULL;
        outline_result_1:;
        frame_9c71824c4bdb84129e3146d7ba81701a->m_frame.f_lineno = 2106;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2106;
            type_description_1 = "c";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9c71824c4bdb84129e3146d7ba81701a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_9c71824c4bdb84129e3146d7ba81701a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9c71824c4bdb84129e3146d7ba81701a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9c71824c4bdb84129e3146d7ba81701a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9c71824c4bdb84129e3146d7ba81701a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9c71824c4bdb84129e3146d7ba81701a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9c71824c4bdb84129e3146d7ba81701a,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_9c71824c4bdb84129e3146d7ba81701a == cache_frame_9c71824c4bdb84129e3146d7ba81701a )
    {
        Py_DECREF( frame_9c71824c4bdb84129e3146d7ba81701a );
    }
    cache_frame_9c71824c4bdb84129e3146d7ba81701a = NULL;

    assertFrameObject( frame_9c71824c4bdb84129e3146d7ba81701a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_124_is_private );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_124_is_private );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}



struct ipaddress$$$function_124_is_private$$$genexpr_1_genexpr_locals {
    PyObject *var_net;
    PyObject *tmp_iter_value_0;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    int tmp_res;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
};

static PyObject *ipaddress$$$function_124_is_private$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Heap access if used.
    struct ipaddress$$$function_124_is_private$$$genexpr_1_genexpr_locals *generator_heap = (struct ipaddress$$$function_124_is_private$$$genexpr_1_genexpr_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_net = NULL;
    generator_heap->tmp_iter_value_0 = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_m_frame, codeobj_88ebdd67cd462602af17693d337a8582, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

#if PYTHON_VERSION < 370
        generator->m_frame->m_frame.f_exc_type = EXC_TYPE( thread_state );
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
        Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#else
        generator->m_exc_state.exc_type = EXC_TYPE( thread_state );
        if ( generator->m_exc_state.exc_type == Py_None ) generator->m_exc_state.exc_type = NULL;
        Py_XINCREF( generator->m_exc_state.exc_type );
        generator->m_exc_state.exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_value );
        generator->m_exc_state.exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_traceback );
#endif
    }

#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_1;
        CHECK_OBJECT( PyCell_GET( generator->m_closure[0] ) );
        tmp_next_source_1 = PyCell_GET( generator->m_closure[0] );
        tmp_assign_source_1 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
                generator_heap->type_description_1 = "Noc";
                generator_heap->exception_lineno = 2106;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_iter_value_0;
            generator_heap->tmp_iter_value_0 = tmp_assign_source_1;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT( generator_heap->tmp_iter_value_0 );
        tmp_assign_source_2 = generator_heap->tmp_iter_value_0;
        {
            PyObject *old = generator_heap->var_net;
            generator_heap->var_net = tmp_assign_source_2;
            Py_INCREF( generator_heap->var_net );
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_expression_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        if ( PyCell_GET( generator->m_closure[1] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 2106;
            generator_heap->type_description_1 = "Noc";
            goto try_except_handler_2;
        }

        tmp_compexpr_left_1 = PyCell_GET( generator->m_closure[1] );
        CHECK_OBJECT( generator_heap->var_net );
        tmp_compexpr_right_1 = generator_heap->var_net;
        generator_heap->tmp_res = PySequence_Contains( tmp_compexpr_right_1, tmp_compexpr_left_1 );
        if ( generator_heap->tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 2106;
            generator_heap->type_description_1 = "Noc";
            goto try_except_handler_2;
        }
        tmp_expression_name_1 = ( generator_heap->tmp_res == 1 ) ? Py_True : Py_False;
        Py_INCREF( tmp_expression_name_1 );
        Nuitka_PreserveHeap( generator_heap->yield_tmps, &tmp_compexpr_left_1, sizeof(PyObject *), &tmp_compexpr_right_1, sizeof(PyObject *), NULL );
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        Nuitka_RestoreHeap( generator_heap->yield_tmps, &tmp_compexpr_left_1, sizeof(PyObject *), &tmp_compexpr_right_1, sizeof(PyObject *), NULL );
        if ( yield_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 2106;
            generator_heap->type_description_1 = "Noc";
            goto try_except_handler_2;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


        generator_heap->exception_lineno = 2106;
        generator_heap->type_description_1 = "Noc";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->tmp_iter_value_0 );
    generator_heap->tmp_iter_value_0 = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( generator_heap->exception_type ) )
    {
        if ( generator_heap->exception_tb == NULL )
        {
            generator_heap->exception_tb = MAKE_TRACEBACK( generator->m_frame, generator_heap->exception_lineno );
        }
        else if ( generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            generator_heap->exception_tb = ADD_TRACEBACK( generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            NULL,
            generator_heap->var_net,
            generator->m_closure[1]
        );


        // Release cached frame.
        if ( generator->m_frame == cache_m_frame )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_m_frame = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->var_net );
    generator_heap->var_net = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:
    try_end_2:;
    Py_XDECREF( generator_heap->tmp_iter_value_0 );
    generator_heap->tmp_iter_value_0 = NULL;

    Py_XDECREF( generator_heap->var_net );
    generator_heap->var_net = NULL;



    return NULL;

    function_exception_exit:
    assert( generator_heap->exception_type );
    RESTORE_ERROR_OCCURRED( generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb );

    return NULL;

}

static PyObject *ipaddress$$$function_124_is_private$$$genexpr_1_genexpr_maker( void )
{
    return Nuitka_Generator_New(
        ipaddress$$$function_124_is_private$$$genexpr_1_genexpr_context,
        module_ipaddress,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_88ebdd67cd462602af17693d337a8582,
        2,
        sizeof(struct ipaddress$$$function_124_is_private$$$genexpr_1_genexpr_locals)
    );
}


static PyObject *impl_ipaddress$$$function_125_is_global( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_58f69ddfab375b10f28d409ed4e35d2f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_58f69ddfab375b10f28d409ed4e35d2f = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_58f69ddfab375b10f28d409ed4e35d2f, codeobj_58f69ddfab375b10f28d409ed4e35d2f, module_ipaddress, sizeof(void *) );
    frame_58f69ddfab375b10f28d409ed4e35d2f = cache_frame_58f69ddfab375b10f28d409ed4e35d2f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_58f69ddfab375b10f28d409ed4e35d2f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_58f69ddfab375b10f28d409ed4e35d2f ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_operand_name_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_operand_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_is_private );
        if ( tmp_operand_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2117;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        Py_DECREF( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2117;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = ( tmp_res == 0 ) ? Py_True : Py_False;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_58f69ddfab375b10f28d409ed4e35d2f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_58f69ddfab375b10f28d409ed4e35d2f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_58f69ddfab375b10f28d409ed4e35d2f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_58f69ddfab375b10f28d409ed4e35d2f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_58f69ddfab375b10f28d409ed4e35d2f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_58f69ddfab375b10f28d409ed4e35d2f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_58f69ddfab375b10f28d409ed4e35d2f,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_58f69ddfab375b10f28d409ed4e35d2f == cache_frame_58f69ddfab375b10f28d409ed4e35d2f )
    {
        Py_DECREF( frame_58f69ddfab375b10f28d409ed4e35d2f );
    }
    cache_frame_58f69ddfab375b10f28d409ed4e35d2f = NULL;

    assertFrameObject( frame_58f69ddfab375b10f28d409ed4e35d2f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_125_is_global );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_125_is_global );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_126_is_unspecified( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_b605231cd1026aa555c929e5b01f6bc1;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_b605231cd1026aa555c929e5b01f6bc1 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b605231cd1026aa555c929e5b01f6bc1, codeobj_b605231cd1026aa555c929e5b01f6bc1, module_ipaddress, sizeof(void *) );
    frame_b605231cd1026aa555c929e5b01f6bc1 = cache_frame_b605231cd1026aa555c929e5b01f6bc1;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b605231cd1026aa555c929e5b01f6bc1 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b605231cd1026aa555c929e5b01f6bc1 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__ip );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2128;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = const_int_0;
        tmp_return_value = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2128;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b605231cd1026aa555c929e5b01f6bc1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_b605231cd1026aa555c929e5b01f6bc1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b605231cd1026aa555c929e5b01f6bc1 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b605231cd1026aa555c929e5b01f6bc1, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b605231cd1026aa555c929e5b01f6bc1->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b605231cd1026aa555c929e5b01f6bc1, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b605231cd1026aa555c929e5b01f6bc1,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_b605231cd1026aa555c929e5b01f6bc1 == cache_frame_b605231cd1026aa555c929e5b01f6bc1 )
    {
        Py_DECREF( frame_b605231cd1026aa555c929e5b01f6bc1 );
    }
    cache_frame_b605231cd1026aa555c929e5b01f6bc1 = NULL;

    assertFrameObject( frame_b605231cd1026aa555c929e5b01f6bc1 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_126_is_unspecified );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_126_is_unspecified );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_127_is_loopback( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_ddad72e202b73cfe919e21d5cf44518f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_ddad72e202b73cfe919e21d5cf44518f = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ddad72e202b73cfe919e21d5cf44518f, codeobj_ddad72e202b73cfe919e21d5cf44518f, module_ipaddress, sizeof(void *) );
    frame_ddad72e202b73cfe919e21d5cf44518f = cache_frame_ddad72e202b73cfe919e21d5cf44518f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ddad72e202b73cfe919e21d5cf44518f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ddad72e202b73cfe919e21d5cf44518f ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__ip );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2139;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = const_int_pos_1;
        tmp_return_value = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2139;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ddad72e202b73cfe919e21d5cf44518f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_ddad72e202b73cfe919e21d5cf44518f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ddad72e202b73cfe919e21d5cf44518f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ddad72e202b73cfe919e21d5cf44518f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ddad72e202b73cfe919e21d5cf44518f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ddad72e202b73cfe919e21d5cf44518f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ddad72e202b73cfe919e21d5cf44518f,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_ddad72e202b73cfe919e21d5cf44518f == cache_frame_ddad72e202b73cfe919e21d5cf44518f )
    {
        Py_DECREF( frame_ddad72e202b73cfe919e21d5cf44518f );
    }
    cache_frame_ddad72e202b73cfe919e21d5cf44518f = NULL;

    assertFrameObject( frame_ddad72e202b73cfe919e21d5cf44518f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_127_is_loopback );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_127_is_loopback );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_128_ipv4_mapped( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_e78bc76a4d1feac8d2458c32bc8aaf3d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_e78bc76a4d1feac8d2458c32bc8aaf3d = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e78bc76a4d1feac8d2458c32bc8aaf3d, codeobj_e78bc76a4d1feac8d2458c32bc8aaf3d, module_ipaddress, sizeof(void *) );
    frame_e78bc76a4d1feac8d2458c32bc8aaf3d = cache_frame_e78bc76a4d1feac8d2458c32bc8aaf3d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e78bc76a4d1feac8d2458c32bc8aaf3d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e78bc76a4d1feac8d2458c32bc8aaf3d ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_right_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_left_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__ip );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2150;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_1 = const_int_pos_32;
        tmp_compexpr_left_1 = BINARY_OPERATION( PyNumber_Rshift, tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_left_name_1 );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2150;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = const_int_pos_65535;
        tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_INT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2150;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_None;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_right_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Address );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Address );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv4Address" );
            exception_tb = NULL;

            exception_lineno = 2152;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_left_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ip );
        if ( tmp_left_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2152;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_2 = const_long_pos_4294967295;
        tmp_args_element_name_1 = BINARY_OPERATION( PyNumber_And, tmp_left_name_2, tmp_right_name_2 );
        Py_DECREF( tmp_left_name_2 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2152;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_e78bc76a4d1feac8d2458c32bc8aaf3d->m_frame.f_lineno = 2152;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2152;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e78bc76a4d1feac8d2458c32bc8aaf3d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_e78bc76a4d1feac8d2458c32bc8aaf3d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e78bc76a4d1feac8d2458c32bc8aaf3d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e78bc76a4d1feac8d2458c32bc8aaf3d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e78bc76a4d1feac8d2458c32bc8aaf3d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e78bc76a4d1feac8d2458c32bc8aaf3d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e78bc76a4d1feac8d2458c32bc8aaf3d,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_e78bc76a4d1feac8d2458c32bc8aaf3d == cache_frame_e78bc76a4d1feac8d2458c32bc8aaf3d )
    {
        Py_DECREF( frame_e78bc76a4d1feac8d2458c32bc8aaf3d );
    }
    cache_frame_e78bc76a4d1feac8d2458c32bc8aaf3d = NULL;

    assertFrameObject( frame_e78bc76a4d1feac8d2458c32bc8aaf3d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_128_ipv4_mapped );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_128_ipv4_mapped );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_129_teredo( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_08fcd993c7b81e47169ff1e3992e9c4b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_08fcd993c7b81e47169ff1e3992e9c4b = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_08fcd993c7b81e47169ff1e3992e9c4b, codeobj_08fcd993c7b81e47169ff1e3992e9c4b, module_ipaddress, sizeof(void *) );
    frame_08fcd993c7b81e47169ff1e3992e9c4b = cache_frame_08fcd993c7b81e47169ff1e3992e9c4b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_08fcd993c7b81e47169ff1e3992e9c4b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_08fcd993c7b81e47169ff1e3992e9c4b ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_right_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_left_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__ip );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2164;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_1 = const_int_pos_96;
        tmp_compexpr_left_1 = BINARY_OPERATION( PyNumber_Rshift, tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_left_name_1 );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2164;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = const_int_pos_536936448;
        tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_INT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2164;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_None;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_left_name_3;
        PyObject *tmp_source_name_2;
        PyObject *tmp_right_name_2;
        PyObject *tmp_right_name_3;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_left_name_4;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_right_name_4;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Address );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Address );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv4Address" );
            exception_tb = NULL;

            exception_lineno = 2166;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_left_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ip );
        if ( tmp_left_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2166;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_2 = const_int_pos_64;
        tmp_left_name_2 = BINARY_OPERATION( PyNumber_Rshift, tmp_left_name_3, tmp_right_name_2 );
        Py_DECREF( tmp_left_name_3 );
        if ( tmp_left_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2166;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_3 = const_long_pos_4294967295;
        tmp_args_element_name_1 = BINARY_OPERATION( PyNumber_And, tmp_left_name_2, tmp_right_name_3 );
        Py_DECREF( tmp_left_name_2 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2166;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_08fcd993c7b81e47169ff1e3992e9c4b->m_frame.f_lineno = 2166;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_tuple_element_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2166;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = PyTuple_New( 2 );
        PyTuple_SET_ITEM( tmp_return_value, 0, tmp_tuple_element_1 );
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Address );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Address );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_return_value );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv4Address" );
            exception_tb = NULL;

            exception_lineno = 2167;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_operand_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__ip );
        if ( tmp_operand_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_return_value );

            exception_lineno = 2167;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_left_name_4 = UNARY_OPERATION( PyNumber_Invert, tmp_operand_name_1 );
        Py_DECREF( tmp_operand_name_1 );
        if ( tmp_left_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_return_value );

            exception_lineno = 2167;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_4 = const_long_pos_4294967295;
        tmp_args_element_name_2 = BINARY_OPERATION( PyNumber_And, tmp_left_name_4, tmp_right_name_4 );
        Py_DECREF( tmp_left_name_4 );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_return_value );

            exception_lineno = 2167;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_08fcd993c7b81e47169ff1e3992e9c4b->m_frame.f_lineno = 2167;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_tuple_element_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_return_value );

            exception_lineno = 2167;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM( tmp_return_value, 1, tmp_tuple_element_1 );
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_08fcd993c7b81e47169ff1e3992e9c4b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_08fcd993c7b81e47169ff1e3992e9c4b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_08fcd993c7b81e47169ff1e3992e9c4b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_08fcd993c7b81e47169ff1e3992e9c4b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_08fcd993c7b81e47169ff1e3992e9c4b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_08fcd993c7b81e47169ff1e3992e9c4b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_08fcd993c7b81e47169ff1e3992e9c4b,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_08fcd993c7b81e47169ff1e3992e9c4b == cache_frame_08fcd993c7b81e47169ff1e3992e9c4b )
    {
        Py_DECREF( frame_08fcd993c7b81e47169ff1e3992e9c4b );
    }
    cache_frame_08fcd993c7b81e47169ff1e3992e9c4b = NULL;

    assertFrameObject( frame_08fcd993c7b81e47169ff1e3992e9c4b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_129_teredo );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_129_teredo );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_130_sixtofour( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_e2bdbfa49ffc502fdd64c2afed334e8d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_e2bdbfa49ffc502fdd64c2afed334e8d = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e2bdbfa49ffc502fdd64c2afed334e8d, codeobj_e2bdbfa49ffc502fdd64c2afed334e8d, module_ipaddress, sizeof(void *) );
    frame_e2bdbfa49ffc502fdd64c2afed334e8d = cache_frame_e2bdbfa49ffc502fdd64c2afed334e8d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e2bdbfa49ffc502fdd64c2afed334e8d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e2bdbfa49ffc502fdd64c2afed334e8d ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_right_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_left_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__ip );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2178;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_1 = const_int_pos_112;
        tmp_compexpr_left_1 = BINARY_OPERATION( PyNumber_Rshift, tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_left_name_1 );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2178;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = const_int_pos_8194;
        tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_INT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2178;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_None;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_left_name_3;
        PyObject *tmp_source_name_2;
        PyObject *tmp_right_name_2;
        PyObject *tmp_right_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Address );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Address );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv4Address" );
            exception_tb = NULL;

            exception_lineno = 2180;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_left_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ip );
        if ( tmp_left_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2180;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_2 = const_int_pos_80;
        tmp_left_name_2 = BINARY_OPERATION( PyNumber_Rshift, tmp_left_name_3, tmp_right_name_2 );
        Py_DECREF( tmp_left_name_3 );
        if ( tmp_left_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2180;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_3 = const_long_pos_4294967295;
        tmp_args_element_name_1 = BINARY_OPERATION( PyNumber_And, tmp_left_name_2, tmp_right_name_3 );
        Py_DECREF( tmp_left_name_2 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2180;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_e2bdbfa49ffc502fdd64c2afed334e8d->m_frame.f_lineno = 2180;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2180;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e2bdbfa49ffc502fdd64c2afed334e8d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_e2bdbfa49ffc502fdd64c2afed334e8d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e2bdbfa49ffc502fdd64c2afed334e8d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e2bdbfa49ffc502fdd64c2afed334e8d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e2bdbfa49ffc502fdd64c2afed334e8d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e2bdbfa49ffc502fdd64c2afed334e8d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e2bdbfa49ffc502fdd64c2afed334e8d,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_e2bdbfa49ffc502fdd64c2afed334e8d == cache_frame_e2bdbfa49ffc502fdd64c2afed334e8d )
    {
        Py_DECREF( frame_e2bdbfa49ffc502fdd64c2afed334e8d );
    }
    cache_frame_e2bdbfa49ffc502fdd64c2afed334e8d = NULL;

    assertFrameObject( frame_e2bdbfa49ffc502fdd64c2afed334e8d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_130_sixtofour );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_130_sixtofour );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_131___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_address = python_pars[ 1 ];
    PyObject *var_addr = NULL;
    struct Nuitka_FrameObject *frame_76720fec7c04811ad2bb6263663e1452;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_76720fec7c04811ad2bb6263663e1452 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_76720fec7c04811ad2bb6263663e1452, codeobj_76720fec7c04811ad2bb6263663e1452, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_76720fec7c04811ad2bb6263663e1452 = cache_frame_76720fec7c04811ad2bb6263663e1452;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_76720fec7c04811ad2bb6263663e1452 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_76720fec7c04811ad2bb6263663e1452 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_address );
        tmp_isinstance_inst_1 = par_address;
        tmp_tuple_element_1 = (PyObject *)&PyString_Type;
        tmp_isinstance_cls_1 = PyTuple_New( 2 );
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_isinstance_cls_1, 0, tmp_tuple_element_1 );
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_int_types );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__compat_int_types );
        }

        if ( tmp_mvar_value_1 == NULL )
        {
            Py_DECREF( tmp_isinstance_cls_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_compat_int_types" );
            exception_tb = NULL;

            exception_lineno = 2186;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_tuple_element_1 = tmp_mvar_value_1;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_isinstance_cls_1, 1, tmp_tuple_element_1 );
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        Py_DECREF( tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2186;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_mvar_value_2;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Address );

            if (unlikely( tmp_mvar_value_2 == NULL ))
            {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Address );
            }

            if ( tmp_mvar_value_2 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv6Address" );
                exception_tb = NULL;

                exception_lineno = 2187;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_1 = tmp_mvar_value_2;
            CHECK_OBJECT( par_self );
            tmp_args_element_name_1 = par_self;
            CHECK_OBJECT( par_address );
            tmp_args_element_name_2 = par_address;
            frame_76720fec7c04811ad2bb6263663e1452->m_frame.f_lineno = 2187;
            {
                PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
                tmp_call_result_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain___init__, call_args );
            }

            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2187;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        {
            PyObject *tmp_assattr_name_1;
            PyObject *tmp_called_name_1;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_args_element_name_3;
            PyObject *tmp_source_name_1;
            PyObject *tmp_assattr_target_1;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Network );

            if (unlikely( tmp_mvar_value_3 == NULL ))
            {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Network );
            }

            if ( tmp_mvar_value_3 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv6Network" );
                exception_tb = NULL;

                exception_lineno = 2188;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_1 = tmp_mvar_value_3;
            CHECK_OBJECT( par_self );
            tmp_source_name_1 = par_self;
            tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__ip );
            if ( tmp_args_element_name_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2188;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            frame_76720fec7c04811ad2bb6263663e1452->m_frame.f_lineno = 2188;
            {
                PyObject *call_args[] = { tmp_args_element_name_3 };
                tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
            }

            Py_DECREF( tmp_args_element_name_3 );
            if ( tmp_assattr_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2188;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_assattr_target_1 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_network, tmp_assattr_name_1 );
            Py_DECREF( tmp_assattr_name_1 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2188;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
        }
        {
            PyObject *tmp_assattr_name_2;
            PyObject *tmp_source_name_2;
            PyObject *tmp_assattr_target_2;
            CHECK_OBJECT( par_self );
            tmp_source_name_2 = par_self;
            tmp_assattr_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__max_prefixlen );
            if ( tmp_assattr_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2189;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_assattr_target_2 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__prefixlen, tmp_assattr_name_2 );
            Py_DECREF( tmp_assattr_name_2 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2189;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
        }
        tmp_return_value = Py_None;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_isinstance_inst_2;
        PyObject *tmp_isinstance_cls_2;
        CHECK_OBJECT( par_address );
        tmp_isinstance_inst_2 = par_address;
        tmp_isinstance_cls_2 = (PyObject *)&PyTuple_Type;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2191;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_3;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_call_result_2;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_args_element_name_5;
            PyObject *tmp_subscribed_name_1;
            PyObject *tmp_subscript_name_1;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Address );

            if (unlikely( tmp_mvar_value_4 == NULL ))
            {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Address );
            }

            if ( tmp_mvar_value_4 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv6Address" );
                exception_tb = NULL;

                exception_lineno = 2192;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_3 = tmp_mvar_value_4;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain___init__ );
            if ( tmp_called_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2192;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_args_element_name_4 = par_self;
            CHECK_OBJECT( par_address );
            tmp_subscribed_name_1 = par_address;
            tmp_subscript_name_1 = const_int_0;
            tmp_args_element_name_5 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_1, tmp_subscript_name_1, 0 );
            if ( tmp_args_element_name_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_2 );

                exception_lineno = 2192;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            frame_76720fec7c04811ad2bb6263663e1452->m_frame.f_lineno = 2192;
            {
                PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
                tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
            }

            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_5 );
            if ( tmp_call_result_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2192;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_2 );
        }
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_compexpr_left_1;
            PyObject *tmp_compexpr_right_1;
            PyObject *tmp_len_arg_1;
            CHECK_OBJECT( par_address );
            tmp_len_arg_1 = par_address;
            tmp_compexpr_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
            if ( tmp_compexpr_left_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2193;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_compexpr_right_1 = const_int_pos_1;
            tmp_res = RICH_COMPARE_BOOL_GT_OBJECT_INT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
            Py_DECREF( tmp_compexpr_left_1 );
            assert( !(tmp_res == -1) );
            tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_3;
            }
            else
            {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_assattr_name_3;
                PyObject *tmp_int_arg_1;
                PyObject *tmp_subscribed_name_2;
                PyObject *tmp_subscript_name_2;
                PyObject *tmp_assattr_target_3;
                CHECK_OBJECT( par_address );
                tmp_subscribed_name_2 = par_address;
                tmp_subscript_name_2 = const_int_pos_1;
                tmp_int_arg_1 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_2, tmp_subscript_name_2, 1 );
                if ( tmp_int_arg_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2194;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
                tmp_assattr_name_3 = PyNumber_Int( tmp_int_arg_1 );
                Py_DECREF( tmp_int_arg_1 );
                if ( tmp_assattr_name_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2194;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
                CHECK_OBJECT( par_self );
                tmp_assattr_target_3 = par_self;
                tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain__prefixlen, tmp_assattr_name_3 );
                Py_DECREF( tmp_assattr_name_3 );
                if ( tmp_result == false )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2194;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
            }
            goto branch_end_3;
            branch_no_3:;
            {
                PyObject *tmp_assattr_name_4;
                PyObject *tmp_source_name_4;
                PyObject *tmp_assattr_target_4;
                CHECK_OBJECT( par_self );
                tmp_source_name_4 = par_self;
                tmp_assattr_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__max_prefixlen );
                if ( tmp_assattr_name_4 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2196;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
                CHECK_OBJECT( par_self );
                tmp_assattr_target_4 = par_self;
                tmp_result = SET_ATTRIBUTE( tmp_assattr_target_4, const_str_plain__prefixlen, tmp_assattr_name_4 );
                Py_DECREF( tmp_assattr_name_4 );
                if ( tmp_result == false )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2196;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
            }
            branch_end_3:;
        }
        {
            PyObject *tmp_assattr_name_5;
            PyObject *tmp_called_name_3;
            PyObject *tmp_mvar_value_5;
            PyObject *tmp_args_name_1;
            PyObject *tmp_tuple_element_2;
            PyObject *tmp_kw_name_1;
            PyObject *tmp_assattr_target_5;
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Network );

            if (unlikely( tmp_mvar_value_5 == NULL ))
            {
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Network );
            }

            if ( tmp_mvar_value_5 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv6Network" );
                exception_tb = NULL;

                exception_lineno = 2197;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_3 = tmp_mvar_value_5;
            CHECK_OBJECT( par_address );
            tmp_tuple_element_2 = par_address;
            tmp_args_name_1 = PyTuple_New( 1 );
            Py_INCREF( tmp_tuple_element_2 );
            PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_2 );
            tmp_kw_name_1 = PyDict_Copy( const_dict_23947da529d495c5b5d02e68c2d46c17 );
            frame_76720fec7c04811ad2bb6263663e1452->m_frame.f_lineno = 2197;
            tmp_assattr_name_5 = CALL_FUNCTION( tmp_called_name_3, tmp_args_name_1, tmp_kw_name_1 );
            Py_DECREF( tmp_args_name_1 );
            Py_DECREF( tmp_kw_name_1 );
            if ( tmp_assattr_name_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2197;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_assattr_target_5 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_5, const_str_plain_network, tmp_assattr_name_5 );
            Py_DECREF( tmp_assattr_name_5 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2197;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
        }
        {
            PyObject *tmp_assattr_name_6;
            PyObject *tmp_source_name_5;
            PyObject *tmp_source_name_6;
            PyObject *tmp_assattr_target_6;
            CHECK_OBJECT( par_self );
            tmp_source_name_6 = par_self;
            tmp_source_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_network );
            if ( tmp_source_name_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2198;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_assattr_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_netmask );
            Py_DECREF( tmp_source_name_5 );
            if ( tmp_assattr_name_6 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2198;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_assattr_target_6 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_6, const_str_plain_netmask, tmp_assattr_name_6 );
            Py_DECREF( tmp_assattr_name_6 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2198;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
        }
        {
            PyObject *tmp_assattr_name_7;
            PyObject *tmp_source_name_7;
            PyObject *tmp_source_name_8;
            PyObject *tmp_assattr_target_7;
            CHECK_OBJECT( par_self );
            tmp_source_name_8 = par_self;
            tmp_source_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_network );
            if ( tmp_source_name_7 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2199;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_assattr_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_hostmask );
            Py_DECREF( tmp_source_name_7 );
            if ( tmp_assattr_name_7 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2199;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_assattr_target_7 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_7, const_str_plain_hostmask, tmp_assattr_name_7 );
            Py_DECREF( tmp_assattr_name_7 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2199;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
        }
        tmp_return_value = Py_None;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_2:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_4;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_args_element_name_6;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__split_optional_netmask );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__split_optional_netmask );
        }

        if ( tmp_mvar_value_6 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_split_optional_netmask" );
            exception_tb = NULL;

            exception_lineno = 2202;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_4 = tmp_mvar_value_6;
        CHECK_OBJECT( par_address );
        tmp_args_element_name_6 = par_address;
        frame_76720fec7c04811ad2bb6263663e1452->m_frame.f_lineno = 2202;
        {
            PyObject *call_args[] = { tmp_args_element_name_6 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2202;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_addr == NULL );
        var_addr = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_5;
        PyObject *tmp_source_name_9;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_call_result_3;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_subscribed_name_3;
        PyObject *tmp_subscript_name_3;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Address );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Address );
        }

        if ( tmp_mvar_value_7 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv6Address" );
            exception_tb = NULL;

            exception_lineno = 2203;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_9 = tmp_mvar_value_7;
        tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain___init__ );
        if ( tmp_called_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2203;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_args_element_name_7 = par_self;
        CHECK_OBJECT( var_addr );
        tmp_subscribed_name_3 = var_addr;
        tmp_subscript_name_3 = const_int_0;
        tmp_args_element_name_8 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_3, tmp_subscript_name_3, 0 );
        if ( tmp_args_element_name_8 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_5 );

            exception_lineno = 2203;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_76720fec7c04811ad2bb6263663e1452->m_frame.f_lineno = 2203;
        {
            PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8 };
            tmp_call_result_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_5, call_args );
        }

        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_args_element_name_8 );
        if ( tmp_call_result_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2203;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_3 );
    }
    {
        PyObject *tmp_assattr_name_8;
        PyObject *tmp_called_name_6;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_args_name_2;
        PyObject *tmp_tuple_element_3;
        PyObject *tmp_kw_name_2;
        PyObject *tmp_assattr_target_8;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Network );

        if (unlikely( tmp_mvar_value_8 == NULL ))
        {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Network );
        }

        if ( tmp_mvar_value_8 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv6Network" );
            exception_tb = NULL;

            exception_lineno = 2204;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_6 = tmp_mvar_value_8;
        CHECK_OBJECT( par_address );
        tmp_tuple_element_3 = par_address;
        tmp_args_name_2 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_3 );
        PyTuple_SET_ITEM( tmp_args_name_2, 0, tmp_tuple_element_3 );
        tmp_kw_name_2 = PyDict_Copy( const_dict_23947da529d495c5b5d02e68c2d46c17 );
        frame_76720fec7c04811ad2bb6263663e1452->m_frame.f_lineno = 2204;
        tmp_assattr_name_8 = CALL_FUNCTION( tmp_called_name_6, tmp_args_name_2, tmp_kw_name_2 );
        Py_DECREF( tmp_args_name_2 );
        Py_DECREF( tmp_kw_name_2 );
        if ( tmp_assattr_name_8 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2204;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_8 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_8, const_str_plain_network, tmp_assattr_name_8 );
        Py_DECREF( tmp_assattr_name_8 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2204;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_9;
        PyObject *tmp_source_name_10;
        PyObject *tmp_source_name_11;
        PyObject *tmp_assattr_target_9;
        CHECK_OBJECT( par_self );
        tmp_source_name_11 = par_self;
        tmp_source_name_10 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain_network );
        if ( tmp_source_name_10 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2205;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_assattr_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_netmask );
        Py_DECREF( tmp_source_name_10 );
        if ( tmp_assattr_name_9 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2205;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_9 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_9, const_str_plain_netmask, tmp_assattr_name_9 );
        Py_DECREF( tmp_assattr_name_9 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2205;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_10;
        PyObject *tmp_source_name_12;
        PyObject *tmp_source_name_13;
        PyObject *tmp_assattr_target_10;
        CHECK_OBJECT( par_self );
        tmp_source_name_13 = par_self;
        tmp_source_name_12 = LOOKUP_ATTRIBUTE( tmp_source_name_13, const_str_plain_network );
        if ( tmp_source_name_12 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2206;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_assattr_name_10 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain__prefixlen );
        Py_DECREF( tmp_source_name_12 );
        if ( tmp_assattr_name_10 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2206;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_10 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_10, const_str_plain__prefixlen, tmp_assattr_name_10 );
        Py_DECREF( tmp_assattr_name_10 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2206;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_11;
        PyObject *tmp_source_name_14;
        PyObject *tmp_source_name_15;
        PyObject *tmp_assattr_target_11;
        CHECK_OBJECT( par_self );
        tmp_source_name_15 = par_self;
        tmp_source_name_14 = LOOKUP_ATTRIBUTE( tmp_source_name_15, const_str_plain_network );
        if ( tmp_source_name_14 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2207;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_assattr_name_11 = LOOKUP_ATTRIBUTE( tmp_source_name_14, const_str_plain_hostmask );
        Py_DECREF( tmp_source_name_14 );
        if ( tmp_assattr_name_11 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2207;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_11 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_11, const_str_plain_hostmask, tmp_assattr_name_11 );
        Py_DECREF( tmp_assattr_name_11 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2207;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_76720fec7c04811ad2bb6263663e1452 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_76720fec7c04811ad2bb6263663e1452 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_76720fec7c04811ad2bb6263663e1452 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_76720fec7c04811ad2bb6263663e1452, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_76720fec7c04811ad2bb6263663e1452->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_76720fec7c04811ad2bb6263663e1452, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_76720fec7c04811ad2bb6263663e1452,
        type_description_1,
        par_self,
        par_address,
        var_addr
    );


    // Release cached frame.
    if ( frame_76720fec7c04811ad2bb6263663e1452 == cache_frame_76720fec7c04811ad2bb6263663e1452 )
    {
        Py_DECREF( frame_76720fec7c04811ad2bb6263663e1452 );
    }
    cache_frame_76720fec7c04811ad2bb6263663e1452 = NULL;

    assertFrameObject( frame_76720fec7c04811ad2bb6263663e1452 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_131___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_addr );
    var_addr = NULL;

    CHECK_OBJECT( (PyObject *)par_address );
    Py_DECREF( par_address );
    par_address = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_addr );
    var_addr = NULL;

    CHECK_OBJECT( (PyObject *)par_address );
    Py_DECREF( par_address );
    par_address = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_131___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_132___str__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_bbb4b9c00fafbe54124665f1f4641832;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_bbb4b9c00fafbe54124665f1f4641832 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_bbb4b9c00fafbe54124665f1f4641832, codeobj_bbb4b9c00fafbe54124665f1f4641832, module_ipaddress, sizeof(void *) );
    frame_bbb4b9c00fafbe54124665f1f4641832 = cache_frame_bbb4b9c00fafbe54124665f1f4641832;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_bbb4b9c00fafbe54124665f1f4641832 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_bbb4b9c00fafbe54124665f1f4641832 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_source_name_4;
        tmp_left_name_1 = const_unicode_digest_6a98397c0892ba5e9c29046762cbb9d8;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__string_from_ip_int );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2210;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ip );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2210;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_bbb4b9c00fafbe54124665f1f4641832->m_frame.f_lineno = 2210;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_tuple_element_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2210;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_1 = PyTuple_New( 2 );
        PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( par_self );
        tmp_source_name_4 = par_self;
        tmp_source_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_network );
        if ( tmp_source_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_right_name_1 );

            exception_lineno = 2211;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_prefixlen );
        Py_DECREF( tmp_source_name_3 );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_right_name_1 );

            exception_lineno = 2211;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM( tmp_right_name_1, 1, tmp_tuple_element_1 );
        tmp_return_value = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_right_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2210;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_bbb4b9c00fafbe54124665f1f4641832 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_bbb4b9c00fafbe54124665f1f4641832 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_bbb4b9c00fafbe54124665f1f4641832 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_bbb4b9c00fafbe54124665f1f4641832, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_bbb4b9c00fafbe54124665f1f4641832->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_bbb4b9c00fafbe54124665f1f4641832, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_bbb4b9c00fafbe54124665f1f4641832,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_bbb4b9c00fafbe54124665f1f4641832 == cache_frame_bbb4b9c00fafbe54124665f1f4641832 )
    {
        Py_DECREF( frame_bbb4b9c00fafbe54124665f1f4641832 );
    }
    cache_frame_bbb4b9c00fafbe54124665f1f4641832 = NULL;

    assertFrameObject( frame_bbb4b9c00fafbe54124665f1f4641832 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_132___str__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_132___str__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_133___eq__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *var_address_equal = NULL;
    struct Nuitka_FrameObject *frame_6b1370f0a4d4f18f0cf4ced6f6f5f56b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_6b1370f0a4d4f18f0cf4ced6f6f5f56b = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6b1370f0a4d4f18f0cf4ced6f6f5f56b, codeobj_6b1370f0a4d4f18f0cf4ced6f6f5f56b, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_6b1370f0a4d4f18f0cf4ced6f6f5f56b = cache_frame_6b1370f0a4d4f18f0cf4ced6f6f5f56b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6b1370f0a4d4f18f0cf4ced6f6f5f56b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6b1370f0a4d4f18f0cf4ced6f6f5f56b ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Address );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Address );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv6Address" );
            exception_tb = NULL;

            exception_lineno = 2214;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_self );
        tmp_args_element_name_1 = par_self;
        CHECK_OBJECT( par_other );
        tmp_args_element_name_2 = par_other;
        frame_6b1370f0a4d4f18f0cf4ced6f6f5f56b->m_frame.f_lineno = 2214;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain___eq__, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2214;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_address_equal == NULL );
        var_address_equal = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_or_left_truth_1;
        nuitka_bool tmp_or_left_value_1;
        nuitka_bool tmp_or_right_value_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( var_address_equal );
        tmp_operand_name_1 = var_address_equal;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2215;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_or_left_value_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_or_left_truth_1 = tmp_or_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_or_left_truth_1 == 1 )
        {
            goto or_left_1;
        }
        else
        {
            goto or_right_1;
        }
        or_right_1:;
        CHECK_OBJECT( var_address_equal );
        tmp_compexpr_left_1 = var_address_equal;
        tmp_compexpr_right_1 = Py_NotImplemented;
        tmp_or_right_value_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_condition_result_1 = tmp_or_right_value_1;
        goto or_end_1;
        or_left_1:;
        tmp_condition_result_1 = tmp_or_left_value_1;
        or_end_1:;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        CHECK_OBJECT( var_address_equal );
        tmp_return_value = var_address_equal;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_1:;
    }
    // Tried code:
    {
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_network );
        if ( tmp_compexpr_left_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2218;
            type_description_1 = "ooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( par_other );
        tmp_source_name_2 = par_other;
        tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_network );
        if ( tmp_compexpr_right_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_2 );

            exception_lineno = 2218;
            type_description_1 = "ooo";
            goto try_except_handler_2;
        }
        tmp_return_value = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        Py_DECREF( tmp_compexpr_left_2 );
        Py_DECREF( tmp_compexpr_right_2 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2218;
            type_description_1 = "ooo";
            goto try_except_handler_2;
        }
        goto frame_return_exit_1;
    }
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_133___eq__ );
    return NULL;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_6b1370f0a4d4f18f0cf4ced6f6f5f56b );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_6b1370f0a4d4f18f0cf4ced6f6f5f56b, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_6b1370f0a4d4f18f0cf4ced6f6f5f56b, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        tmp_compexpr_left_3 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_3 = PyExc_AttributeError;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_3, tmp_compexpr_right_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2219;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        tmp_return_value = Py_False;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        goto branch_end_2;
        branch_no_2:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 2217;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_6b1370f0a4d4f18f0cf4ced6f6f5f56b->m_frame) frame_6b1370f0a4d4f18f0cf4ced6f6f5f56b->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
        branch_end_2:;
    }
    // End of try:

#if 1
    RESTORE_FRAME_EXCEPTION( frame_6b1370f0a4d4f18f0cf4ced6f6f5f56b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_6b1370f0a4d4f18f0cf4ced6f6f5f56b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_6b1370f0a4d4f18f0cf4ced6f6f5f56b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6b1370f0a4d4f18f0cf4ced6f6f5f56b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6b1370f0a4d4f18f0cf4ced6f6f5f56b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6b1370f0a4d4f18f0cf4ced6f6f5f56b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6b1370f0a4d4f18f0cf4ced6f6f5f56b,
        type_description_1,
        par_self,
        par_other,
        var_address_equal
    );


    // Release cached frame.
    if ( frame_6b1370f0a4d4f18f0cf4ced6f6f5f56b == cache_frame_6b1370f0a4d4f18f0cf4ced6f6f5f56b )
    {
        Py_DECREF( frame_6b1370f0a4d4f18f0cf4ced6f6f5f56b );
    }
    cache_frame_6b1370f0a4d4f18f0cf4ced6f6f5f56b = NULL;

    assertFrameObject( frame_6b1370f0a4d4f18f0cf4ced6f6f5f56b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_133___eq__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_address_equal );
    Py_DECREF( var_address_equal );
    var_address_equal = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_address_equal );
    var_address_equal = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_133___eq__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_134___lt__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *var_address_less = NULL;
    struct Nuitka_FrameObject *frame_e912ba0bfe133f34c669723d31be939b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_e912ba0bfe133f34c669723d31be939b = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e912ba0bfe133f34c669723d31be939b, codeobj_e912ba0bfe133f34c669723d31be939b, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_e912ba0bfe133f34c669723d31be939b = cache_frame_e912ba0bfe133f34c669723d31be939b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e912ba0bfe133f34c669723d31be939b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e912ba0bfe133f34c669723d31be939b ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Address );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Address );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv6Address" );
            exception_tb = NULL;

            exception_lineno = 2226;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_self );
        tmp_args_element_name_1 = par_self;
        CHECK_OBJECT( par_other );
        tmp_args_element_name_2 = par_other;
        frame_e912ba0bfe133f34c669723d31be939b->m_frame.f_lineno = 2226;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain___lt__, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2226;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_address_less == NULL );
        var_address_less = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( var_address_less );
        tmp_compexpr_left_1 = var_address_less;
        tmp_compexpr_right_1 = Py_NotImplemented;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_NotImplemented;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_1:;
    }
    // Tried code:
    {
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_network );
        if ( tmp_compexpr_left_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2230;
            type_description_1 = "ooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( par_other );
        tmp_source_name_2 = par_other;
        tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_network );
        if ( tmp_compexpr_right_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_2 );

            exception_lineno = 2230;
            type_description_1 = "ooo";
            goto try_except_handler_2;
        }
        tmp_return_value = RICH_COMPARE_LT_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        Py_DECREF( tmp_compexpr_left_2 );
        Py_DECREF( tmp_compexpr_right_2 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2230;
            type_description_1 = "ooo";
            goto try_except_handler_2;
        }
        goto frame_return_exit_1;
    }
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_134___lt__ );
    return NULL;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_e912ba0bfe133f34c669723d31be939b );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_e912ba0bfe133f34c669723d31be939b, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_e912ba0bfe133f34c669723d31be939b, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        tmp_compexpr_left_3 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_3 = PyExc_AttributeError;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_3, tmp_compexpr_right_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2231;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        tmp_return_value = Py_False;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        goto branch_end_2;
        branch_no_2:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 2229;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_e912ba0bfe133f34c669723d31be939b->m_frame) frame_e912ba0bfe133f34c669723d31be939b->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
        branch_end_2:;
    }
    // End of try:

#if 1
    RESTORE_FRAME_EXCEPTION( frame_e912ba0bfe133f34c669723d31be939b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_e912ba0bfe133f34c669723d31be939b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_e912ba0bfe133f34c669723d31be939b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e912ba0bfe133f34c669723d31be939b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e912ba0bfe133f34c669723d31be939b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e912ba0bfe133f34c669723d31be939b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e912ba0bfe133f34c669723d31be939b,
        type_description_1,
        par_self,
        par_other,
        var_address_less
    );


    // Release cached frame.
    if ( frame_e912ba0bfe133f34c669723d31be939b == cache_frame_e912ba0bfe133f34c669723d31be939b )
    {
        Py_DECREF( frame_e912ba0bfe133f34c669723d31be939b );
    }
    cache_frame_e912ba0bfe133f34c669723d31be939b = NULL;

    assertFrameObject( frame_e912ba0bfe133f34c669723d31be939b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_134___lt__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    CHECK_OBJECT( (PyObject *)var_address_less );
    Py_DECREF( var_address_less );
    var_address_less = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    Py_XDECREF( var_address_less );
    var_address_less = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_134___lt__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_135___hash__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_40609662a1dd4462655d9c04cd6ccf15;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_40609662a1dd4462655d9c04cd6ccf15 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_40609662a1dd4462655d9c04cd6ccf15, codeobj_40609662a1dd4462655d9c04cd6ccf15, module_ipaddress, sizeof(void *) );
    frame_40609662a1dd4462655d9c04cd6ccf15 = cache_frame_40609662a1dd4462655d9c04cd6ccf15;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_40609662a1dd4462655d9c04cd6ccf15 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_40609662a1dd4462655d9c04cd6ccf15 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_right_name_2;
        PyObject *tmp_int_arg_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_source_name_4;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_left_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__ip );
        if ( tmp_left_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2237;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_right_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__prefixlen );
        if ( tmp_right_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_left_name_2 );

            exception_lineno = 2237;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = BINARY_OPERATION( PyNumber_Xor, tmp_left_name_2, tmp_right_name_1 );
        Py_DECREF( tmp_left_name_2 );
        Py_DECREF( tmp_right_name_1 );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2237;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_4 = par_self;
        tmp_source_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_network );
        if ( tmp_source_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_left_name_1 );

            exception_lineno = 2237;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_int_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_network_address );
        Py_DECREF( tmp_source_name_3 );
        if ( tmp_int_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_left_name_1 );

            exception_lineno = 2237;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_2 = PyNumber_Int( tmp_int_arg_1 );
        Py_DECREF( tmp_int_arg_1 );
        if ( tmp_right_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_left_name_1 );

            exception_lineno = 2237;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = BINARY_OPERATION( PyNumber_Xor, tmp_left_name_1, tmp_right_name_2 );
        Py_DECREF( tmp_left_name_1 );
        Py_DECREF( tmp_right_name_2 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2237;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_40609662a1dd4462655d9c04cd6ccf15 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_40609662a1dd4462655d9c04cd6ccf15 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_40609662a1dd4462655d9c04cd6ccf15 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_40609662a1dd4462655d9c04cd6ccf15, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_40609662a1dd4462655d9c04cd6ccf15->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_40609662a1dd4462655d9c04cd6ccf15, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_40609662a1dd4462655d9c04cd6ccf15,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_40609662a1dd4462655d9c04cd6ccf15 == cache_frame_40609662a1dd4462655d9c04cd6ccf15 )
    {
        Py_DECREF( frame_40609662a1dd4462655d9c04cd6ccf15 );
    }
    cache_frame_40609662a1dd4462655d9c04cd6ccf15 = NULL;

    assertFrameObject( frame_40609662a1dd4462655d9c04cd6ccf15 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_135___hash__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_135___hash__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_136_ip( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_5fa2e0f0c94e079165acf06a3e2b0103;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_5fa2e0f0c94e079165acf06a3e2b0103 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5fa2e0f0c94e079165acf06a3e2b0103, codeobj_5fa2e0f0c94e079165acf06a3e2b0103, module_ipaddress, sizeof(void *) );
    frame_5fa2e0f0c94e079165acf06a3e2b0103 = cache_frame_5fa2e0f0c94e079165acf06a3e2b0103;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5fa2e0f0c94e079165acf06a3e2b0103 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5fa2e0f0c94e079165acf06a3e2b0103 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Address );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Address );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv6Address" );
            exception_tb = NULL;

            exception_lineno = 2243;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__ip );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2243;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_5fa2e0f0c94e079165acf06a3e2b0103->m_frame.f_lineno = 2243;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2243;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5fa2e0f0c94e079165acf06a3e2b0103 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_5fa2e0f0c94e079165acf06a3e2b0103 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5fa2e0f0c94e079165acf06a3e2b0103 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5fa2e0f0c94e079165acf06a3e2b0103, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5fa2e0f0c94e079165acf06a3e2b0103->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5fa2e0f0c94e079165acf06a3e2b0103, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5fa2e0f0c94e079165acf06a3e2b0103,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_5fa2e0f0c94e079165acf06a3e2b0103 == cache_frame_5fa2e0f0c94e079165acf06a3e2b0103 )
    {
        Py_DECREF( frame_5fa2e0f0c94e079165acf06a3e2b0103 );
    }
    cache_frame_5fa2e0f0c94e079165acf06a3e2b0103 = NULL;

    assertFrameObject( frame_5fa2e0f0c94e079165acf06a3e2b0103 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_136_ip );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_136_ip );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_137_with_prefixlen( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_1370e8ed5db9ed96af59bd81a5809fb0;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_1370e8ed5db9ed96af59bd81a5809fb0 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1370e8ed5db9ed96af59bd81a5809fb0, codeobj_1370e8ed5db9ed96af59bd81a5809fb0, module_ipaddress, sizeof(void *) );
    frame_1370e8ed5db9ed96af59bd81a5809fb0 = cache_frame_1370e8ed5db9ed96af59bd81a5809fb0;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1370e8ed5db9ed96af59bd81a5809fb0 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1370e8ed5db9ed96af59bd81a5809fb0 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_source_name_3;
        tmp_left_name_1 = const_unicode_digest_3f6240938cc8b4c3691344def7c310a8;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__string_from_ip_int );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2247;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ip );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2247;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_1370e8ed5db9ed96af59bd81a5809fb0->m_frame.f_lineno = 2247;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_tuple_element_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2247;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_1 = PyTuple_New( 2 );
        PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__prefixlen );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_right_name_1 );

            exception_lineno = 2248;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM( tmp_right_name_1, 1, tmp_tuple_element_1 );
        tmp_return_value = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_right_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2247;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1370e8ed5db9ed96af59bd81a5809fb0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_1370e8ed5db9ed96af59bd81a5809fb0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1370e8ed5db9ed96af59bd81a5809fb0 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1370e8ed5db9ed96af59bd81a5809fb0, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1370e8ed5db9ed96af59bd81a5809fb0->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1370e8ed5db9ed96af59bd81a5809fb0, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1370e8ed5db9ed96af59bd81a5809fb0,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_1370e8ed5db9ed96af59bd81a5809fb0 == cache_frame_1370e8ed5db9ed96af59bd81a5809fb0 )
    {
        Py_DECREF( frame_1370e8ed5db9ed96af59bd81a5809fb0 );
    }
    cache_frame_1370e8ed5db9ed96af59bd81a5809fb0 = NULL;

    assertFrameObject( frame_1370e8ed5db9ed96af59bd81a5809fb0 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_137_with_prefixlen );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_137_with_prefixlen );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_138_with_netmask( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_ec9028b7009e5af16c10d0a9cc3c34f2;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_ec9028b7009e5af16c10d0a9cc3c34f2 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ec9028b7009e5af16c10d0a9cc3c34f2, codeobj_ec9028b7009e5af16c10d0a9cc3c34f2, module_ipaddress, sizeof(void *) );
    frame_ec9028b7009e5af16c10d0a9cc3c34f2 = cache_frame_ec9028b7009e5af16c10d0a9cc3c34f2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ec9028b7009e5af16c10d0a9cc3c34f2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ec9028b7009e5af16c10d0a9cc3c34f2 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_source_name_3;
        tmp_left_name_1 = const_unicode_digest_3f6240938cc8b4c3691344def7c310a8;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__string_from_ip_int );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2252;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ip );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2252;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_ec9028b7009e5af16c10d0a9cc3c34f2->m_frame.f_lineno = 2252;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_tuple_element_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2252;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_1 = PyTuple_New( 2 );
        PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_netmask );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_right_name_1 );

            exception_lineno = 2253;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM( tmp_right_name_1, 1, tmp_tuple_element_1 );
        tmp_return_value = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_right_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2252;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ec9028b7009e5af16c10d0a9cc3c34f2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_ec9028b7009e5af16c10d0a9cc3c34f2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ec9028b7009e5af16c10d0a9cc3c34f2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ec9028b7009e5af16c10d0a9cc3c34f2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ec9028b7009e5af16c10d0a9cc3c34f2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ec9028b7009e5af16c10d0a9cc3c34f2, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ec9028b7009e5af16c10d0a9cc3c34f2,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_ec9028b7009e5af16c10d0a9cc3c34f2 == cache_frame_ec9028b7009e5af16c10d0a9cc3c34f2 )
    {
        Py_DECREF( frame_ec9028b7009e5af16c10d0a9cc3c34f2 );
    }
    cache_frame_ec9028b7009e5af16c10d0a9cc3c34f2 = NULL;

    assertFrameObject( frame_ec9028b7009e5af16c10d0a9cc3c34f2 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_138_with_netmask );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_138_with_netmask );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_139_with_hostmask( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_84242c2f8814b6ec54d58e169ead4095;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_84242c2f8814b6ec54d58e169ead4095 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_84242c2f8814b6ec54d58e169ead4095, codeobj_84242c2f8814b6ec54d58e169ead4095, module_ipaddress, sizeof(void *) );
    frame_84242c2f8814b6ec54d58e169ead4095 = cache_frame_84242c2f8814b6ec54d58e169ead4095;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_84242c2f8814b6ec54d58e169ead4095 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_84242c2f8814b6ec54d58e169ead4095 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_source_name_3;
        tmp_left_name_1 = const_unicode_digest_3f6240938cc8b4c3691344def7c310a8;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__string_from_ip_int );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2257;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ip );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2257;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_84242c2f8814b6ec54d58e169ead4095->m_frame.f_lineno = 2257;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_tuple_element_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2257;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_1 = PyTuple_New( 2 );
        PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_hostmask );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_right_name_1 );

            exception_lineno = 2258;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM( tmp_right_name_1, 1, tmp_tuple_element_1 );
        tmp_return_value = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_right_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2257;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_84242c2f8814b6ec54d58e169ead4095 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_84242c2f8814b6ec54d58e169ead4095 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_84242c2f8814b6ec54d58e169ead4095 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_84242c2f8814b6ec54d58e169ead4095, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_84242c2f8814b6ec54d58e169ead4095->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_84242c2f8814b6ec54d58e169ead4095, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_84242c2f8814b6ec54d58e169ead4095,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_84242c2f8814b6ec54d58e169ead4095 == cache_frame_84242c2f8814b6ec54d58e169ead4095 )
    {
        Py_DECREF( frame_84242c2f8814b6ec54d58e169ead4095 );
    }
    cache_frame_84242c2f8814b6ec54d58e169ead4095 = NULL;

    assertFrameObject( frame_84242c2f8814b6ec54d58e169ead4095 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_139_with_hostmask );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_139_with_hostmask );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_140_is_unspecified( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_966fe35e427b37714c22ebe086cb0fa7;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_966fe35e427b37714c22ebe086cb0fa7 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_966fe35e427b37714c22ebe086cb0fa7, codeobj_966fe35e427b37714c22ebe086cb0fa7, module_ipaddress, sizeof(void *) );
    frame_966fe35e427b37714c22ebe086cb0fa7 = cache_frame_966fe35e427b37714c22ebe086cb0fa7;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_966fe35e427b37714c22ebe086cb0fa7 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_966fe35e427b37714c22ebe086cb0fa7 ) == 2 ); // Frame stack

    // Framed code:
    {
        int tmp_and_left_truth_1;
        PyObject *tmp_and_left_value_1;
        PyObject *tmp_and_right_value_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_source_name_3;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__ip );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2262;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = const_int_0;
        tmp_and_left_value_1 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_and_left_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2262;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
        if ( tmp_and_left_truth_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_and_left_value_1 );

            exception_lineno = 2262;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        if ( tmp_and_left_truth_1 == 1 )
        {
            goto and_right_1;
        }
        else
        {
            goto and_left_1;
        }
        and_right_1:;
        Py_DECREF( tmp_and_left_value_1 );
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_source_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_network );
        if ( tmp_source_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2262;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_is_unspecified );
        Py_DECREF( tmp_source_name_2 );
        if ( tmp_and_right_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2262;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_return_value = tmp_and_left_value_1;
        and_end_1:;
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_966fe35e427b37714c22ebe086cb0fa7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_966fe35e427b37714c22ebe086cb0fa7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_966fe35e427b37714c22ebe086cb0fa7 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_966fe35e427b37714c22ebe086cb0fa7, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_966fe35e427b37714c22ebe086cb0fa7->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_966fe35e427b37714c22ebe086cb0fa7, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_966fe35e427b37714c22ebe086cb0fa7,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_966fe35e427b37714c22ebe086cb0fa7 == cache_frame_966fe35e427b37714c22ebe086cb0fa7 )
    {
        Py_DECREF( frame_966fe35e427b37714c22ebe086cb0fa7 );
    }
    cache_frame_966fe35e427b37714c22ebe086cb0fa7 = NULL;

    assertFrameObject( frame_966fe35e427b37714c22ebe086cb0fa7 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_140_is_unspecified );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_140_is_unspecified );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_141_is_loopback( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_05ec6fd01eb342b10aaf820f0f88358b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_05ec6fd01eb342b10aaf820f0f88358b = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_05ec6fd01eb342b10aaf820f0f88358b, codeobj_05ec6fd01eb342b10aaf820f0f88358b, module_ipaddress, sizeof(void *) );
    frame_05ec6fd01eb342b10aaf820f0f88358b = cache_frame_05ec6fd01eb342b10aaf820f0f88358b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_05ec6fd01eb342b10aaf820f0f88358b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_05ec6fd01eb342b10aaf820f0f88358b ) == 2 ); // Frame stack

    // Framed code:
    {
        int tmp_and_left_truth_1;
        PyObject *tmp_and_left_value_1;
        PyObject *tmp_and_right_value_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_source_name_3;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__ip );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2266;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = const_int_pos_1;
        tmp_and_left_value_1 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_and_left_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2266;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
        if ( tmp_and_left_truth_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_and_left_value_1 );

            exception_lineno = 2266;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        if ( tmp_and_left_truth_1 == 1 )
        {
            goto and_right_1;
        }
        else
        {
            goto and_left_1;
        }
        and_right_1:;
        Py_DECREF( tmp_and_left_value_1 );
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_source_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_network );
        if ( tmp_source_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2266;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_is_loopback );
        Py_DECREF( tmp_source_name_2 );
        if ( tmp_and_right_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2266;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_return_value = tmp_and_left_value_1;
        and_end_1:;
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_05ec6fd01eb342b10aaf820f0f88358b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_05ec6fd01eb342b10aaf820f0f88358b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_05ec6fd01eb342b10aaf820f0f88358b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_05ec6fd01eb342b10aaf820f0f88358b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_05ec6fd01eb342b10aaf820f0f88358b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_05ec6fd01eb342b10aaf820f0f88358b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_05ec6fd01eb342b10aaf820f0f88358b,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_05ec6fd01eb342b10aaf820f0f88358b == cache_frame_05ec6fd01eb342b10aaf820f0f88358b )
    {
        Py_DECREF( frame_05ec6fd01eb342b10aaf820f0f88358b );
    }
    cache_frame_05ec6fd01eb342b10aaf820f0f88358b = NULL;

    assertFrameObject( frame_05ec6fd01eb342b10aaf820f0f88358b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_141_is_loopback );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_141_is_loopback );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_142___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_address = python_pars[ 1 ];
    PyObject *par_strict = python_pars[ 2 ];
    PyObject *var_addr = NULL;
    PyObject *var_arg = NULL;
    PyObject *var_packed = NULL;
    PyObject *tmp_tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_tuple_unpack_1__source_iter = NULL;
    PyObject *tmp_tuple_unpack_2__element_1 = NULL;
    PyObject *tmp_tuple_unpack_2__element_2 = NULL;
    PyObject *tmp_tuple_unpack_2__source_iter = NULL;
    PyObject *tmp_tuple_unpack_3__element_1 = NULL;
    PyObject *tmp_tuple_unpack_3__element_2 = NULL;
    PyObject *tmp_tuple_unpack_3__source_iter = NULL;
    struct Nuitka_FrameObject *frame_cd86ecb14e7f6f0ffe0a002e37a7e37a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_iterator_attempt;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;
    PyObject *exception_keeper_type_6;
    PyObject *exception_keeper_value_6;
    PyTracebackObject *exception_keeper_tb_6;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_6;
    static struct Nuitka_FrameObject *cache_frame_cd86ecb14e7f6f0ffe0a002e37a7e37a = NULL;
    PyObject *exception_keeper_type_7;
    PyObject *exception_keeper_value_7;
    PyTracebackObject *exception_keeper_tb_7;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_7;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_cd86ecb14e7f6f0ffe0a002e37a7e37a, codeobj_cd86ecb14e7f6f0ffe0a002e37a7e37a, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_cd86ecb14e7f6f0ffe0a002e37a7e37a = cache_frame_cd86ecb14e7f6f0ffe0a002e37a7e37a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_cd86ecb14e7f6f0ffe0a002e37a7e37a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_cd86ecb14e7f6f0ffe0a002e37a7e37a ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__BaseNetwork );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__BaseNetwork );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_BaseNetwork" );
            exception_tb = NULL;

            exception_lineno = 2317;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_self );
        tmp_args_element_name_1 = par_self;
        CHECK_OBJECT( par_address );
        tmp_args_element_name_2 = par_address;
        frame_cd86ecb14e7f6f0ffe0a002e37a7e37a->m_frame.f_lineno = 2317;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain___init__, call_args );
        }

        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2317;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT( par_address );
        tmp_isinstance_inst_1 = par_address;
        tmp_tuple_element_1 = (PyObject *)&PyString_Type;
        tmp_isinstance_cls_1 = PyTuple_New( 2 );
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_isinstance_cls_1, 0, tmp_tuple_element_1 );
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_int_types );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__compat_int_types );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_isinstance_cls_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_compat_int_types" );
            exception_tb = NULL;

            exception_lineno = 2320;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_tuple_element_1 = tmp_mvar_value_2;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_isinstance_cls_1, 1, tmp_tuple_element_1 );
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        Py_DECREF( tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2320;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assattr_name_1;
            PyObject *tmp_called_name_1;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_args_element_name_3;
            PyObject *tmp_assattr_target_1;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Address );

            if (unlikely( tmp_mvar_value_3 == NULL ))
            {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Address );
            }

            if ( tmp_mvar_value_3 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv6Address" );
                exception_tb = NULL;

                exception_lineno = 2321;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_1 = tmp_mvar_value_3;
            CHECK_OBJECT( par_address );
            tmp_args_element_name_3 = par_address;
            frame_cd86ecb14e7f6f0ffe0a002e37a7e37a->m_frame.f_lineno = 2321;
            {
                PyObject *call_args[] = { tmp_args_element_name_3 };
                tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
            }

            if ( tmp_assattr_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2321;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_assattr_target_1 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_network_address, tmp_assattr_name_1 );
            Py_DECREF( tmp_assattr_name_1 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2321;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
        }
        // Tried code:
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_iter_arg_1;
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_1;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_source_name_2;
            CHECK_OBJECT( par_self );
            tmp_source_name_1 = par_self;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__make_netmask );
            if ( tmp_called_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2322;
                type_description_1 = "oooooo";
                goto try_except_handler_2;
            }
            CHECK_OBJECT( par_self );
            tmp_source_name_2 = par_self;
            tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__max_prefixlen );
            if ( tmp_args_element_name_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_2 );

                exception_lineno = 2323;
                type_description_1 = "oooooo";
                goto try_except_handler_2;
            }
            frame_cd86ecb14e7f6f0ffe0a002e37a7e37a->m_frame.f_lineno = 2322;
            {
                PyObject *call_args[] = { tmp_args_element_name_4 };
                tmp_iter_arg_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
            }

            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_4 );
            if ( tmp_iter_arg_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2322;
                type_description_1 = "oooooo";
                goto try_except_handler_2;
            }
            tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
            Py_DECREF( tmp_iter_arg_1 );
            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2322;
                type_description_1 = "oooooo";
                goto try_except_handler_2;
            }
            assert( tmp_tuple_unpack_1__source_iter == NULL );
            tmp_tuple_unpack_1__source_iter = tmp_assign_source_1;
        }
        // Tried code:
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_unpack_1;
            CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
            tmp_unpack_1 = tmp_tuple_unpack_1__source_iter;
            tmp_assign_source_2 = UNPACK_NEXT( tmp_unpack_1, 0 );
            if ( tmp_assign_source_2 == NULL )
            {
                if ( !ERROR_OCCURRED() )
                {
                    exception_type = PyExc_StopIteration;
                    Py_INCREF( exception_type );
                    exception_value = NULL;
                    exception_tb = NULL;
                }
                else
                {
                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                }


                type_description_1 = "oooooo";
                exception_lineno = 2322;
                goto try_except_handler_3;
            }
            assert( tmp_tuple_unpack_1__element_1 == NULL );
            tmp_tuple_unpack_1__element_1 = tmp_assign_source_2;
        }
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_unpack_2;
            CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
            tmp_unpack_2 = tmp_tuple_unpack_1__source_iter;
            tmp_assign_source_3 = UNPACK_NEXT( tmp_unpack_2, 1 );
            if ( tmp_assign_source_3 == NULL )
            {
                if ( !ERROR_OCCURRED() )
                {
                    exception_type = PyExc_StopIteration;
                    Py_INCREF( exception_type );
                    exception_value = NULL;
                    exception_tb = NULL;
                }
                else
                {
                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                }


                type_description_1 = "oooooo";
                exception_lineno = 2322;
                goto try_except_handler_3;
            }
            assert( tmp_tuple_unpack_1__element_2 == NULL );
            tmp_tuple_unpack_1__element_2 = tmp_assign_source_3;
        }
        {
            PyObject *tmp_iterator_name_1;
            CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
            tmp_iterator_name_1 = tmp_tuple_unpack_1__source_iter;
            // Check if iterator has left-over elements.
            CHECK_OBJECT( tmp_iterator_name_1 ); assert( HAS_ITERNEXT( tmp_iterator_name_1 ) );

            tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_1 )->tp_iternext)( tmp_iterator_name_1 );

            if (likely( tmp_iterator_attempt == NULL ))
            {
                PyObject *error = GET_ERROR_OCCURRED();

                if ( error != NULL )
                {
                    if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
                    {
                        CLEAR_ERROR_OCCURRED();
                    }
                    else
                    {
                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                        type_description_1 = "oooooo";
                        exception_lineno = 2322;
                        goto try_except_handler_3;
                    }
                }
            }
            else
            {
                Py_DECREF( tmp_iterator_attempt );

                // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
                PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
                PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 2)" );
#endif
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                type_description_1 = "oooooo";
                exception_lineno = 2322;
                goto try_except_handler_3;
            }
        }
        goto try_end_1;
        // Exception handler code:
        try_except_handler_3:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
        Py_DECREF( tmp_tuple_unpack_1__source_iter );
        tmp_tuple_unpack_1__source_iter = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto try_except_handler_2;
        // End of try:
        try_end_1:;
        CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
        Py_DECREF( tmp_tuple_unpack_1__source_iter );
        tmp_tuple_unpack_1__source_iter = NULL;

        {
            PyObject *tmp_assattr_name_2;
            PyObject *tmp_assattr_target_2;
            CHECK_OBJECT( tmp_tuple_unpack_1__element_1 );
            tmp_assattr_name_2 = tmp_tuple_unpack_1__element_1;
            CHECK_OBJECT( par_self );
            tmp_assattr_target_2 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain_netmask, tmp_assattr_name_2 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2322;
                type_description_1 = "oooooo";
                goto try_except_handler_2;
            }
        }
        Py_XDECREF( tmp_tuple_unpack_1__element_1 );
        tmp_tuple_unpack_1__element_1 = NULL;

        {
            PyObject *tmp_assattr_name_3;
            PyObject *tmp_assattr_target_3;
            CHECK_OBJECT( tmp_tuple_unpack_1__element_2 );
            tmp_assattr_name_3 = tmp_tuple_unpack_1__element_2;
            CHECK_OBJECT( par_self );
            tmp_assattr_target_3 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain__prefixlen, tmp_assattr_name_3 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2322;
                type_description_1 = "oooooo";
                goto try_except_handler_2;
            }
        }
        goto try_end_2;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_2 = exception_type;
        exception_keeper_value_2 = exception_value;
        exception_keeper_tb_2 = exception_tb;
        exception_keeper_lineno_2 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF( tmp_tuple_unpack_1__element_1 );
        tmp_tuple_unpack_1__element_1 = NULL;

        Py_XDECREF( tmp_tuple_unpack_1__element_2 );
        tmp_tuple_unpack_1__element_2 = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_2;
        exception_value = exception_keeper_value_2;
        exception_tb = exception_keeper_tb_2;
        exception_lineno = exception_keeper_lineno_2;

        goto frame_exception_exit_1;
        // End of try:
        try_end_2:;
        Py_XDECREF( tmp_tuple_unpack_1__element_2 );
        tmp_tuple_unpack_1__element_2 = NULL;

        tmp_return_value = Py_None;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_isinstance_inst_2;
        PyObject *tmp_isinstance_cls_2;
        CHECK_OBJECT( par_address );
        tmp_isinstance_inst_2 = par_address;
        tmp_isinstance_cls_2 = (PyObject *)&PyTuple_Type;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2326;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_compexpr_left_1;
            PyObject *tmp_compexpr_right_1;
            PyObject *tmp_len_arg_1;
            CHECK_OBJECT( par_address );
            tmp_len_arg_1 = par_address;
            tmp_compexpr_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
            if ( tmp_compexpr_left_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2327;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            tmp_compexpr_right_1 = const_int_pos_1;
            tmp_res = RICH_COMPARE_BOOL_GT_OBJECT_INT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
            Py_DECREF( tmp_compexpr_left_1 );
            assert( !(tmp_res == -1) );
            tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_3;
            }
            else
            {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_assign_source_4;
                PyObject *tmp_subscribed_name_1;
                PyObject *tmp_subscript_name_1;
                CHECK_OBJECT( par_address );
                tmp_subscribed_name_1 = par_address;
                tmp_subscript_name_1 = const_int_pos_1;
                tmp_assign_source_4 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_1, tmp_subscript_name_1, 1 );
                if ( tmp_assign_source_4 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2328;
                    type_description_1 = "oooooo";
                    goto frame_exception_exit_1;
                }
                assert( var_arg == NULL );
                var_arg = tmp_assign_source_4;
            }
            goto branch_end_3;
            branch_no_3:;
            {
                PyObject *tmp_assign_source_5;
                PyObject *tmp_source_name_3;
                CHECK_OBJECT( par_self );
                tmp_source_name_3 = par_self;
                tmp_assign_source_5 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__max_prefixlen );
                if ( tmp_assign_source_5 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2330;
                    type_description_1 = "oooooo";
                    goto frame_exception_exit_1;
                }
                assert( var_arg == NULL );
                var_arg = tmp_assign_source_5;
            }
            branch_end_3:;
        }
        // Tried code:
        {
            PyObject *tmp_assign_source_6;
            PyObject *tmp_iter_arg_2;
            PyObject *tmp_called_instance_2;
            PyObject *tmp_args_element_name_5;
            CHECK_OBJECT( par_self );
            tmp_called_instance_2 = par_self;
            CHECK_OBJECT( var_arg );
            tmp_args_element_name_5 = var_arg;
            frame_cd86ecb14e7f6f0ffe0a002e37a7e37a->m_frame.f_lineno = 2331;
            {
                PyObject *call_args[] = { tmp_args_element_name_5 };
                tmp_iter_arg_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain__make_netmask, call_args );
            }

            if ( tmp_iter_arg_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2331;
                type_description_1 = "oooooo";
                goto try_except_handler_4;
            }
            tmp_assign_source_6 = MAKE_ITERATOR( tmp_iter_arg_2 );
            Py_DECREF( tmp_iter_arg_2 );
            if ( tmp_assign_source_6 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2331;
                type_description_1 = "oooooo";
                goto try_except_handler_4;
            }
            assert( tmp_tuple_unpack_2__source_iter == NULL );
            tmp_tuple_unpack_2__source_iter = tmp_assign_source_6;
        }
        // Tried code:
        {
            PyObject *tmp_assign_source_7;
            PyObject *tmp_unpack_3;
            CHECK_OBJECT( tmp_tuple_unpack_2__source_iter );
            tmp_unpack_3 = tmp_tuple_unpack_2__source_iter;
            tmp_assign_source_7 = UNPACK_NEXT( tmp_unpack_3, 0 );
            if ( tmp_assign_source_7 == NULL )
            {
                if ( !ERROR_OCCURRED() )
                {
                    exception_type = PyExc_StopIteration;
                    Py_INCREF( exception_type );
                    exception_value = NULL;
                    exception_tb = NULL;
                }
                else
                {
                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                }


                type_description_1 = "oooooo";
                exception_lineno = 2331;
                goto try_except_handler_5;
            }
            assert( tmp_tuple_unpack_2__element_1 == NULL );
            tmp_tuple_unpack_2__element_1 = tmp_assign_source_7;
        }
        {
            PyObject *tmp_assign_source_8;
            PyObject *tmp_unpack_4;
            CHECK_OBJECT( tmp_tuple_unpack_2__source_iter );
            tmp_unpack_4 = tmp_tuple_unpack_2__source_iter;
            tmp_assign_source_8 = UNPACK_NEXT( tmp_unpack_4, 1 );
            if ( tmp_assign_source_8 == NULL )
            {
                if ( !ERROR_OCCURRED() )
                {
                    exception_type = PyExc_StopIteration;
                    Py_INCREF( exception_type );
                    exception_value = NULL;
                    exception_tb = NULL;
                }
                else
                {
                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                }


                type_description_1 = "oooooo";
                exception_lineno = 2331;
                goto try_except_handler_5;
            }
            assert( tmp_tuple_unpack_2__element_2 == NULL );
            tmp_tuple_unpack_2__element_2 = tmp_assign_source_8;
        }
        {
            PyObject *tmp_iterator_name_2;
            CHECK_OBJECT( tmp_tuple_unpack_2__source_iter );
            tmp_iterator_name_2 = tmp_tuple_unpack_2__source_iter;
            // Check if iterator has left-over elements.
            CHECK_OBJECT( tmp_iterator_name_2 ); assert( HAS_ITERNEXT( tmp_iterator_name_2 ) );

            tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_2 )->tp_iternext)( tmp_iterator_name_2 );

            if (likely( tmp_iterator_attempt == NULL ))
            {
                PyObject *error = GET_ERROR_OCCURRED();

                if ( error != NULL )
                {
                    if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
                    {
                        CLEAR_ERROR_OCCURRED();
                    }
                    else
                    {
                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                        type_description_1 = "oooooo";
                        exception_lineno = 2331;
                        goto try_except_handler_5;
                    }
                }
            }
            else
            {
                Py_DECREF( tmp_iterator_attempt );

                // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
                PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
                PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 2)" );
#endif
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                type_description_1 = "oooooo";
                exception_lineno = 2331;
                goto try_except_handler_5;
            }
        }
        goto try_end_3;
        // Exception handler code:
        try_except_handler_5:;
        exception_keeper_type_3 = exception_type;
        exception_keeper_value_3 = exception_value;
        exception_keeper_tb_3 = exception_tb;
        exception_keeper_lineno_3 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_2__source_iter );
        Py_DECREF( tmp_tuple_unpack_2__source_iter );
        tmp_tuple_unpack_2__source_iter = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_3;
        exception_value = exception_keeper_value_3;
        exception_tb = exception_keeper_tb_3;
        exception_lineno = exception_keeper_lineno_3;

        goto try_except_handler_4;
        // End of try:
        try_end_3:;
        CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_2__source_iter );
        Py_DECREF( tmp_tuple_unpack_2__source_iter );
        tmp_tuple_unpack_2__source_iter = NULL;

        {
            PyObject *tmp_assattr_name_4;
            PyObject *tmp_assattr_target_4;
            CHECK_OBJECT( tmp_tuple_unpack_2__element_1 );
            tmp_assattr_name_4 = tmp_tuple_unpack_2__element_1;
            CHECK_OBJECT( par_self );
            tmp_assattr_target_4 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_4, const_str_plain_netmask, tmp_assattr_name_4 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2331;
                type_description_1 = "oooooo";
                goto try_except_handler_4;
            }
        }
        Py_XDECREF( tmp_tuple_unpack_2__element_1 );
        tmp_tuple_unpack_2__element_1 = NULL;

        {
            PyObject *tmp_assattr_name_5;
            PyObject *tmp_assattr_target_5;
            CHECK_OBJECT( tmp_tuple_unpack_2__element_2 );
            tmp_assattr_name_5 = tmp_tuple_unpack_2__element_2;
            CHECK_OBJECT( par_self );
            tmp_assattr_target_5 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_5, const_str_plain__prefixlen, tmp_assattr_name_5 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2331;
                type_description_1 = "oooooo";
                goto try_except_handler_4;
            }
        }
        goto try_end_4;
        // Exception handler code:
        try_except_handler_4:;
        exception_keeper_type_4 = exception_type;
        exception_keeper_value_4 = exception_value;
        exception_keeper_tb_4 = exception_tb;
        exception_keeper_lineno_4 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF( tmp_tuple_unpack_2__element_1 );
        tmp_tuple_unpack_2__element_1 = NULL;

        Py_XDECREF( tmp_tuple_unpack_2__element_2 );
        tmp_tuple_unpack_2__element_2 = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_4;
        exception_value = exception_keeper_value_4;
        exception_tb = exception_keeper_tb_4;
        exception_lineno = exception_keeper_lineno_4;

        goto frame_exception_exit_1;
        // End of try:
        try_end_4:;
        Py_XDECREF( tmp_tuple_unpack_2__element_2 );
        tmp_tuple_unpack_2__element_2 = NULL;

        {
            PyObject *tmp_assattr_name_6;
            PyObject *tmp_called_name_3;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_args_element_name_6;
            PyObject *tmp_subscribed_name_2;
            PyObject *tmp_subscript_name_2;
            PyObject *tmp_assattr_target_6;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Address );

            if (unlikely( tmp_mvar_value_4 == NULL ))
            {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Address );
            }

            if ( tmp_mvar_value_4 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv6Address" );
                exception_tb = NULL;

                exception_lineno = 2332;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_3 = tmp_mvar_value_4;
            CHECK_OBJECT( par_address );
            tmp_subscribed_name_2 = par_address;
            tmp_subscript_name_2 = const_int_0;
            tmp_args_element_name_6 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_2, tmp_subscript_name_2, 0 );
            if ( tmp_args_element_name_6 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2332;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            frame_cd86ecb14e7f6f0ffe0a002e37a7e37a->m_frame.f_lineno = 2332;
            {
                PyObject *call_args[] = { tmp_args_element_name_6 };
                tmp_assattr_name_6 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
            }

            Py_DECREF( tmp_args_element_name_6 );
            if ( tmp_assattr_name_6 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2332;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_assattr_target_6 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_6, const_str_plain_network_address, tmp_assattr_name_6 );
            Py_DECREF( tmp_assattr_name_6 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2332;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
        }
        {
            PyObject *tmp_assign_source_9;
            PyObject *tmp_int_arg_1;
            PyObject *tmp_source_name_4;
            CHECK_OBJECT( par_self );
            tmp_source_name_4 = par_self;
            tmp_int_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_network_address );
            if ( tmp_int_arg_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2333;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            tmp_assign_source_9 = PyNumber_Int( tmp_int_arg_1 );
            Py_DECREF( tmp_int_arg_1 );
            if ( tmp_assign_source_9 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2333;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            assert( var_packed == NULL );
            var_packed = tmp_assign_source_9;
        }
        {
            nuitka_bool tmp_condition_result_4;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            PyObject *tmp_int_arg_2;
            PyObject *tmp_source_name_5;
            CHECK_OBJECT( var_packed );
            tmp_left_name_1 = var_packed;
            CHECK_OBJECT( par_self );
            tmp_source_name_5 = par_self;
            tmp_int_arg_2 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_netmask );
            if ( tmp_int_arg_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2334;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            tmp_right_name_1 = PyNumber_Int( tmp_int_arg_2 );
            Py_DECREF( tmp_int_arg_2 );
            if ( tmp_right_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2334;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            tmp_compexpr_left_2 = BINARY_OPERATION( PyNumber_And, tmp_left_name_1, tmp_right_name_1 );
            Py_DECREF( tmp_right_name_1 );
            if ( tmp_compexpr_left_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2334;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_packed );
            tmp_compexpr_right_2 = var_packed;
            tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
            Py_DECREF( tmp_compexpr_left_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2334;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_4 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_4;
            }
            else
            {
                goto branch_no_4;
            }
            branch_yes_4:;
            {
                nuitka_bool tmp_condition_result_5;
                int tmp_truth_name_1;
                CHECK_OBJECT( par_strict );
                tmp_truth_name_1 = CHECK_IF_TRUE( par_strict );
                if ( tmp_truth_name_1 == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2335;
                    type_description_1 = "oooooo";
                    goto frame_exception_exit_1;
                }
                tmp_condition_result_5 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
                {
                    goto branch_yes_5;
                }
                else
                {
                    goto branch_no_5;
                }
                branch_yes_5:;
                {
                    PyObject *tmp_raise_type_1;
                    PyObject *tmp_make_exception_arg_1;
                    PyObject *tmp_left_name_2;
                    PyObject *tmp_right_name_2;
                    tmp_left_name_2 = const_unicode_digest_9cdf3b748ac1a53affbd72eda589ecda;
                    CHECK_OBJECT( par_self );
                    tmp_right_name_2 = par_self;
                    tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_2, tmp_right_name_2 );
                    if ( tmp_make_exception_arg_1 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 2336;
                        type_description_1 = "oooooo";
                        goto frame_exception_exit_1;
                    }
                    frame_cd86ecb14e7f6f0ffe0a002e37a7e37a->m_frame.f_lineno = 2336;
                    {
                        PyObject *call_args[] = { tmp_make_exception_arg_1 };
                        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
                    }

                    Py_DECREF( tmp_make_exception_arg_1 );
                    assert( !(tmp_raise_type_1 == NULL) );
                    exception_type = tmp_raise_type_1;
                    exception_lineno = 2336;
                    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                    type_description_1 = "oooooo";
                    goto frame_exception_exit_1;
                }
                goto branch_end_5;
                branch_no_5:;
                {
                    PyObject *tmp_assattr_name_7;
                    PyObject *tmp_called_name_4;
                    PyObject *tmp_mvar_value_5;
                    PyObject *tmp_args_element_name_7;
                    PyObject *tmp_left_name_3;
                    PyObject *tmp_right_name_3;
                    PyObject *tmp_int_arg_3;
                    PyObject *tmp_source_name_6;
                    PyObject *tmp_assattr_target_7;
                    tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Address );

                    if (unlikely( tmp_mvar_value_5 == NULL ))
                    {
                        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Address );
                    }

                    if ( tmp_mvar_value_5 == NULL )
                    {

                        exception_type = PyExc_NameError;
                        Py_INCREF( exception_type );
                        exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv6Address" );
                        exception_tb = NULL;

                        exception_lineno = 2338;
                        type_description_1 = "oooooo";
                        goto frame_exception_exit_1;
                    }

                    tmp_called_name_4 = tmp_mvar_value_5;
                    CHECK_OBJECT( var_packed );
                    tmp_left_name_3 = var_packed;
                    CHECK_OBJECT( par_self );
                    tmp_source_name_6 = par_self;
                    tmp_int_arg_3 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_netmask );
                    if ( tmp_int_arg_3 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 2339;
                        type_description_1 = "oooooo";
                        goto frame_exception_exit_1;
                    }
                    tmp_right_name_3 = PyNumber_Int( tmp_int_arg_3 );
                    Py_DECREF( tmp_int_arg_3 );
                    if ( tmp_right_name_3 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 2339;
                        type_description_1 = "oooooo";
                        goto frame_exception_exit_1;
                    }
                    tmp_args_element_name_7 = BINARY_OPERATION( PyNumber_And, tmp_left_name_3, tmp_right_name_3 );
                    Py_DECREF( tmp_right_name_3 );
                    if ( tmp_args_element_name_7 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 2338;
                        type_description_1 = "oooooo";
                        goto frame_exception_exit_1;
                    }
                    frame_cd86ecb14e7f6f0ffe0a002e37a7e37a->m_frame.f_lineno = 2338;
                    {
                        PyObject *call_args[] = { tmp_args_element_name_7 };
                        tmp_assattr_name_7 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
                    }

                    Py_DECREF( tmp_args_element_name_7 );
                    if ( tmp_assattr_name_7 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 2338;
                        type_description_1 = "oooooo";
                        goto frame_exception_exit_1;
                    }
                    CHECK_OBJECT( par_self );
                    tmp_assattr_target_7 = par_self;
                    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_7, const_str_plain_network_address, tmp_assattr_name_7 );
                    Py_DECREF( tmp_assattr_name_7 );
                    if ( tmp_result == false )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 2338;
                        type_description_1 = "oooooo";
                        goto frame_exception_exit_1;
                    }
                }
                branch_end_5:;
            }
            branch_no_4:;
        }
        tmp_return_value = Py_None;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_2:;
    }
    {
        PyObject *tmp_assign_source_10;
        PyObject *tmp_called_name_5;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_args_element_name_8;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__split_optional_netmask );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__split_optional_netmask );
        }

        if ( tmp_mvar_value_6 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_split_optional_netmask" );
            exception_tb = NULL;

            exception_lineno = 2344;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_5 = tmp_mvar_value_6;
        CHECK_OBJECT( par_address );
        tmp_args_element_name_8 = par_address;
        frame_cd86ecb14e7f6f0ffe0a002e37a7e37a->m_frame.f_lineno = 2344;
        {
            PyObject *call_args[] = { tmp_args_element_name_8 };
            tmp_assign_source_10 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
        }

        if ( tmp_assign_source_10 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2344;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        assert( var_addr == NULL );
        var_addr = tmp_assign_source_10;
    }
    {
        PyObject *tmp_assattr_name_8;
        PyObject *tmp_called_name_6;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_called_name_7;
        PyObject *tmp_source_name_7;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_subscribed_name_3;
        PyObject *tmp_subscript_name_3;
        PyObject *tmp_assattr_target_8;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Address );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Address );
        }

        if ( tmp_mvar_value_7 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv6Address" );
            exception_tb = NULL;

            exception_lineno = 2346;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_6 = tmp_mvar_value_7;
        CHECK_OBJECT( par_self );
        tmp_source_name_7 = par_self;
        tmp_called_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__ip_int_from_string );
        if ( tmp_called_name_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2346;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_addr );
        tmp_subscribed_name_3 = var_addr;
        tmp_subscript_name_3 = const_int_0;
        tmp_args_element_name_10 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_3, tmp_subscript_name_3, 0 );
        if ( tmp_args_element_name_10 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_7 );

            exception_lineno = 2346;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_cd86ecb14e7f6f0ffe0a002e37a7e37a->m_frame.f_lineno = 2346;
        {
            PyObject *call_args[] = { tmp_args_element_name_10 };
            tmp_args_element_name_9 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_7, call_args );
        }

        Py_DECREF( tmp_called_name_7 );
        Py_DECREF( tmp_args_element_name_10 );
        if ( tmp_args_element_name_9 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2346;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_cd86ecb14e7f6f0ffe0a002e37a7e37a->m_frame.f_lineno = 2346;
        {
            PyObject *call_args[] = { tmp_args_element_name_9 };
            tmp_assattr_name_8 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, call_args );
        }

        Py_DECREF( tmp_args_element_name_9 );
        if ( tmp_assattr_name_8 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2346;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_8 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_8, const_str_plain_network_address, tmp_assattr_name_8 );
        Py_DECREF( tmp_assattr_name_8 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2346;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        nuitka_bool tmp_condition_result_6;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_len_arg_2;
        CHECK_OBJECT( var_addr );
        tmp_len_arg_2 = var_addr;
        tmp_compexpr_left_3 = BUILTIN_LEN( tmp_len_arg_2 );
        if ( tmp_compexpr_left_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2348;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_3 = const_int_pos_2;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_INT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
        Py_DECREF( tmp_compexpr_left_3 );
        assert( !(tmp_res == -1) );
        tmp_condition_result_6 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_6 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_6;
        }
        else
        {
            goto branch_no_6;
        }
        branch_yes_6:;
        {
            PyObject *tmp_assign_source_11;
            PyObject *tmp_subscribed_name_4;
            PyObject *tmp_subscript_name_4;
            CHECK_OBJECT( var_addr );
            tmp_subscribed_name_4 = var_addr;
            tmp_subscript_name_4 = const_int_pos_1;
            tmp_assign_source_11 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_4, tmp_subscript_name_4, 1 );
            if ( tmp_assign_source_11 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2349;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            assert( var_arg == NULL );
            var_arg = tmp_assign_source_11;
        }
        goto branch_end_6;
        branch_no_6:;
        {
            PyObject *tmp_assign_source_12;
            PyObject *tmp_source_name_8;
            CHECK_OBJECT( par_self );
            tmp_source_name_8 = par_self;
            tmp_assign_source_12 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain__max_prefixlen );
            if ( tmp_assign_source_12 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2351;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            assert( var_arg == NULL );
            var_arg = tmp_assign_source_12;
        }
        branch_end_6:;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_13;
        PyObject *tmp_iter_arg_3;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_args_element_name_11;
        CHECK_OBJECT( par_self );
        tmp_called_instance_3 = par_self;
        CHECK_OBJECT( var_arg );
        tmp_args_element_name_11 = var_arg;
        frame_cd86ecb14e7f6f0ffe0a002e37a7e37a->m_frame.f_lineno = 2352;
        {
            PyObject *call_args[] = { tmp_args_element_name_11 };
            tmp_iter_arg_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain__make_netmask, call_args );
        }

        if ( tmp_iter_arg_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2352;
            type_description_1 = "oooooo";
            goto try_except_handler_6;
        }
        tmp_assign_source_13 = MAKE_ITERATOR( tmp_iter_arg_3 );
        Py_DECREF( tmp_iter_arg_3 );
        if ( tmp_assign_source_13 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2352;
            type_description_1 = "oooooo";
            goto try_except_handler_6;
        }
        assert( tmp_tuple_unpack_3__source_iter == NULL );
        tmp_tuple_unpack_3__source_iter = tmp_assign_source_13;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_14;
        PyObject *tmp_unpack_5;
        CHECK_OBJECT( tmp_tuple_unpack_3__source_iter );
        tmp_unpack_5 = tmp_tuple_unpack_3__source_iter;
        tmp_assign_source_14 = UNPACK_NEXT( tmp_unpack_5, 0 );
        if ( tmp_assign_source_14 == NULL )
        {
            if ( !ERROR_OCCURRED() )
            {
                exception_type = PyExc_StopIteration;
                Py_INCREF( exception_type );
                exception_value = NULL;
                exception_tb = NULL;
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            }


            type_description_1 = "oooooo";
            exception_lineno = 2352;
            goto try_except_handler_7;
        }
        assert( tmp_tuple_unpack_3__element_1 == NULL );
        tmp_tuple_unpack_3__element_1 = tmp_assign_source_14;
    }
    {
        PyObject *tmp_assign_source_15;
        PyObject *tmp_unpack_6;
        CHECK_OBJECT( tmp_tuple_unpack_3__source_iter );
        tmp_unpack_6 = tmp_tuple_unpack_3__source_iter;
        tmp_assign_source_15 = UNPACK_NEXT( tmp_unpack_6, 1 );
        if ( tmp_assign_source_15 == NULL )
        {
            if ( !ERROR_OCCURRED() )
            {
                exception_type = PyExc_StopIteration;
                Py_INCREF( exception_type );
                exception_value = NULL;
                exception_tb = NULL;
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            }


            type_description_1 = "oooooo";
            exception_lineno = 2352;
            goto try_except_handler_7;
        }
        assert( tmp_tuple_unpack_3__element_2 == NULL );
        tmp_tuple_unpack_3__element_2 = tmp_assign_source_15;
    }
    {
        PyObject *tmp_iterator_name_3;
        CHECK_OBJECT( tmp_tuple_unpack_3__source_iter );
        tmp_iterator_name_3 = tmp_tuple_unpack_3__source_iter;
        // Check if iterator has left-over elements.
        CHECK_OBJECT( tmp_iterator_name_3 ); assert( HAS_ITERNEXT( tmp_iterator_name_3 ) );

        tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_3 )->tp_iternext)( tmp_iterator_name_3 );

        if (likely( tmp_iterator_attempt == NULL ))
        {
            PyObject *error = GET_ERROR_OCCURRED();

            if ( error != NULL )
            {
                if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
                {
                    CLEAR_ERROR_OCCURRED();
                }
                else
                {
                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                    type_description_1 = "oooooo";
                    exception_lineno = 2352;
                    goto try_except_handler_7;
                }
            }
        }
        else
        {
            Py_DECREF( tmp_iterator_attempt );

            // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
            PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 2)" );
#endif
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

            type_description_1 = "oooooo";
            exception_lineno = 2352;
            goto try_except_handler_7;
        }
    }
    goto try_end_5;
    // Exception handler code:
    try_except_handler_7:;
    exception_keeper_type_5 = exception_type;
    exception_keeper_value_5 = exception_value;
    exception_keeper_tb_5 = exception_tb;
    exception_keeper_lineno_5 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_3__source_iter );
    Py_DECREF( tmp_tuple_unpack_3__source_iter );
    tmp_tuple_unpack_3__source_iter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_5;
    exception_value = exception_keeper_value_5;
    exception_tb = exception_keeper_tb_5;
    exception_lineno = exception_keeper_lineno_5;

    goto try_except_handler_6;
    // End of try:
    try_end_5:;
    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_3__source_iter );
    Py_DECREF( tmp_tuple_unpack_3__source_iter );
    tmp_tuple_unpack_3__source_iter = NULL;

    {
        PyObject *tmp_assattr_name_9;
        PyObject *tmp_assattr_target_9;
        CHECK_OBJECT( tmp_tuple_unpack_3__element_1 );
        tmp_assattr_name_9 = tmp_tuple_unpack_3__element_1;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_9 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_9, const_str_plain_netmask, tmp_assattr_name_9 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2352;
            type_description_1 = "oooooo";
            goto try_except_handler_6;
        }
    }
    Py_XDECREF( tmp_tuple_unpack_3__element_1 );
    tmp_tuple_unpack_3__element_1 = NULL;

    {
        PyObject *tmp_assattr_name_10;
        PyObject *tmp_assattr_target_10;
        CHECK_OBJECT( tmp_tuple_unpack_3__element_2 );
        tmp_assattr_name_10 = tmp_tuple_unpack_3__element_2;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_10 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_10, const_str_plain__prefixlen, tmp_assattr_name_10 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2352;
            type_description_1 = "oooooo";
            goto try_except_handler_6;
        }
    }
    goto try_end_6;
    // Exception handler code:
    try_except_handler_6:;
    exception_keeper_type_6 = exception_type;
    exception_keeper_value_6 = exception_value;
    exception_keeper_tb_6 = exception_tb;
    exception_keeper_lineno_6 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_tuple_unpack_3__element_1 );
    tmp_tuple_unpack_3__element_1 = NULL;

    Py_XDECREF( tmp_tuple_unpack_3__element_2 );
    tmp_tuple_unpack_3__element_2 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_6;
    exception_value = exception_keeper_value_6;
    exception_tb = exception_keeper_tb_6;
    exception_lineno = exception_keeper_lineno_6;

    goto frame_exception_exit_1;
    // End of try:
    try_end_6:;
    Py_XDECREF( tmp_tuple_unpack_3__element_2 );
    tmp_tuple_unpack_3__element_2 = NULL;

    {
        nuitka_bool tmp_condition_result_7;
        int tmp_truth_name_2;
        CHECK_OBJECT( par_strict );
        tmp_truth_name_2 = CHECK_IF_TRUE( par_strict );
        if ( tmp_truth_name_2 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2354;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_7 = tmp_truth_name_2 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_7 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_7;
        }
        else
        {
            goto branch_no_7;
        }
        branch_yes_7:;
        {
            nuitka_bool tmp_condition_result_8;
            PyObject *tmp_compexpr_left_4;
            PyObject *tmp_compexpr_right_4;
            PyObject *tmp_called_name_8;
            PyObject *tmp_mvar_value_8;
            PyObject *tmp_args_element_name_12;
            PyObject *tmp_left_name_4;
            PyObject *tmp_int_arg_4;
            PyObject *tmp_source_name_9;
            PyObject *tmp_right_name_4;
            PyObject *tmp_int_arg_5;
            PyObject *tmp_source_name_10;
            PyObject *tmp_source_name_11;
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Address );

            if (unlikely( tmp_mvar_value_8 == NULL ))
            {
                tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Address );
            }

            if ( tmp_mvar_value_8 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv6Address" );
                exception_tb = NULL;

                exception_lineno = 2355;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_8 = tmp_mvar_value_8;
            CHECK_OBJECT( par_self );
            tmp_source_name_9 = par_self;
            tmp_int_arg_4 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_network_address );
            if ( tmp_int_arg_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2355;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            tmp_left_name_4 = PyNumber_Int( tmp_int_arg_4 );
            Py_DECREF( tmp_int_arg_4 );
            if ( tmp_left_name_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2355;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_source_name_10 = par_self;
            tmp_int_arg_5 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_netmask );
            if ( tmp_int_arg_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_left_name_4 );

                exception_lineno = 2355;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            tmp_right_name_4 = PyNumber_Int( tmp_int_arg_5 );
            Py_DECREF( tmp_int_arg_5 );
            if ( tmp_right_name_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_left_name_4 );

                exception_lineno = 2355;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            tmp_args_element_name_12 = BINARY_OPERATION( PyNumber_And, tmp_left_name_4, tmp_right_name_4 );
            Py_DECREF( tmp_left_name_4 );
            Py_DECREF( tmp_right_name_4 );
            if ( tmp_args_element_name_12 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2355;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            frame_cd86ecb14e7f6f0ffe0a002e37a7e37a->m_frame.f_lineno = 2355;
            {
                PyObject *call_args[] = { tmp_args_element_name_12 };
                tmp_compexpr_left_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_8, call_args );
            }

            Py_DECREF( tmp_args_element_name_12 );
            if ( tmp_compexpr_left_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2355;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_source_name_11 = par_self;
            tmp_compexpr_right_4 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain_network_address );
            if ( tmp_compexpr_right_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_compexpr_left_4 );

                exception_lineno = 2356;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_4, tmp_compexpr_right_4 );
            Py_DECREF( tmp_compexpr_left_4 );
            Py_DECREF( tmp_compexpr_right_4 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2355;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_8 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_8 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_8;
            }
            else
            {
                goto branch_no_8;
            }
            branch_yes_8:;
            {
                PyObject *tmp_raise_type_2;
                PyObject *tmp_make_exception_arg_2;
                PyObject *tmp_left_name_5;
                PyObject *tmp_right_name_5;
                tmp_left_name_5 = const_unicode_digest_9cdf3b748ac1a53affbd72eda589ecda;
                CHECK_OBJECT( par_self );
                tmp_right_name_5 = par_self;
                tmp_make_exception_arg_2 = BINARY_OPERATION_REMAINDER( tmp_left_name_5, tmp_right_name_5 );
                if ( tmp_make_exception_arg_2 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2357;
                    type_description_1 = "oooooo";
                    goto frame_exception_exit_1;
                }
                frame_cd86ecb14e7f6f0ffe0a002e37a7e37a->m_frame.f_lineno = 2357;
                {
                    PyObject *call_args[] = { tmp_make_exception_arg_2 };
                    tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
                }

                Py_DECREF( tmp_make_exception_arg_2 );
                assert( !(tmp_raise_type_2 == NULL) );
                exception_type = tmp_raise_type_2;
                exception_lineno = 2357;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            branch_no_8:;
        }
        branch_no_7:;
    }
    {
        PyObject *tmp_assattr_name_11;
        PyObject *tmp_called_name_9;
        PyObject *tmp_mvar_value_9;
        PyObject *tmp_args_element_name_13;
        PyObject *tmp_left_name_6;
        PyObject *tmp_int_arg_6;
        PyObject *tmp_source_name_12;
        PyObject *tmp_right_name_6;
        PyObject *tmp_int_arg_7;
        PyObject *tmp_source_name_13;
        PyObject *tmp_assattr_target_11;
        tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Address );

        if (unlikely( tmp_mvar_value_9 == NULL ))
        {
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Address );
        }

        if ( tmp_mvar_value_9 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "IPv6Address" );
            exception_tb = NULL;

            exception_lineno = 2358;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_9 = tmp_mvar_value_9;
        CHECK_OBJECT( par_self );
        tmp_source_name_12 = par_self;
        tmp_int_arg_6 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain_network_address );
        if ( tmp_int_arg_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2358;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_6 = PyNumber_Int( tmp_int_arg_6 );
        Py_DECREF( tmp_int_arg_6 );
        if ( tmp_left_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2358;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_13 = par_self;
        tmp_int_arg_7 = LOOKUP_ATTRIBUTE( tmp_source_name_13, const_str_plain_netmask );
        if ( tmp_int_arg_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_left_name_6 );

            exception_lineno = 2359;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_right_name_6 = PyNumber_Int( tmp_int_arg_7 );
        Py_DECREF( tmp_int_arg_7 );
        if ( tmp_right_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_left_name_6 );

            exception_lineno = 2359;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_13 = BINARY_OPERATION( PyNumber_And, tmp_left_name_6, tmp_right_name_6 );
        Py_DECREF( tmp_left_name_6 );
        Py_DECREF( tmp_right_name_6 );
        if ( tmp_args_element_name_13 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2358;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_cd86ecb14e7f6f0ffe0a002e37a7e37a->m_frame.f_lineno = 2358;
        {
            PyObject *call_args[] = { tmp_args_element_name_13 };
            tmp_assattr_name_11 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_9, call_args );
        }

        Py_DECREF( tmp_args_element_name_13 );
        if ( tmp_assattr_name_11 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2358;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_11 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_11, const_str_plain_network_address, tmp_assattr_name_11 );
        Py_DECREF( tmp_assattr_name_11 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2358;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        nuitka_bool tmp_condition_result_9;
        PyObject *tmp_compexpr_left_5;
        PyObject *tmp_compexpr_right_5;
        PyObject *tmp_source_name_14;
        PyObject *tmp_left_name_7;
        PyObject *tmp_source_name_15;
        PyObject *tmp_right_name_7;
        CHECK_OBJECT( par_self );
        tmp_source_name_14 = par_self;
        tmp_compexpr_left_5 = LOOKUP_ATTRIBUTE( tmp_source_name_14, const_str_plain__prefixlen );
        if ( tmp_compexpr_left_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2361;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_15 = par_self;
        tmp_left_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_15, const_str_plain__max_prefixlen );
        if ( tmp_left_name_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_5 );

            exception_lineno = 2361;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_right_name_7 = const_int_pos_1;
        tmp_compexpr_right_5 = BINARY_OPERATION_SUB( tmp_left_name_7, tmp_right_name_7 );
        Py_DECREF( tmp_left_name_7 );
        if ( tmp_compexpr_right_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_5 );

            exception_lineno = 2361;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_5, tmp_compexpr_right_5 );
        Py_DECREF( tmp_compexpr_left_5 );
        Py_DECREF( tmp_compexpr_right_5 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2361;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_9 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_9 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_9;
        }
        else
        {
            goto branch_no_9;
        }
        branch_yes_9:;
        {
            PyObject *tmp_assattr_name_12;
            PyObject *tmp_source_name_16;
            PyObject *tmp_assattr_target_12;
            CHECK_OBJECT( par_self );
            tmp_source_name_16 = par_self;
            tmp_assattr_name_12 = LOOKUP_ATTRIBUTE( tmp_source_name_16, const_str_plain___iter__ );
            if ( tmp_assattr_name_12 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2362;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_assattr_target_12 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_12, const_str_plain_hosts, tmp_assattr_name_12 );
            Py_DECREF( tmp_assattr_name_12 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2362;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
        }
        branch_no_9:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_cd86ecb14e7f6f0ffe0a002e37a7e37a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_cd86ecb14e7f6f0ffe0a002e37a7e37a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_cd86ecb14e7f6f0ffe0a002e37a7e37a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_cd86ecb14e7f6f0ffe0a002e37a7e37a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_cd86ecb14e7f6f0ffe0a002e37a7e37a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_cd86ecb14e7f6f0ffe0a002e37a7e37a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_cd86ecb14e7f6f0ffe0a002e37a7e37a,
        type_description_1,
        par_self,
        par_address,
        par_strict,
        var_addr,
        var_arg,
        var_packed
    );


    // Release cached frame.
    if ( frame_cd86ecb14e7f6f0ffe0a002e37a7e37a == cache_frame_cd86ecb14e7f6f0ffe0a002e37a7e37a )
    {
        Py_DECREF( frame_cd86ecb14e7f6f0ffe0a002e37a7e37a );
    }
    cache_frame_cd86ecb14e7f6f0ffe0a002e37a7e37a = NULL;

    assertFrameObject( frame_cd86ecb14e7f6f0ffe0a002e37a7e37a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_142___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_addr );
    var_addr = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_address );
    Py_DECREF( par_address );
    par_address = NULL;

    CHECK_OBJECT( (PyObject *)par_strict );
    Py_DECREF( par_strict );
    par_strict = NULL;

    Py_XDECREF( var_arg );
    var_arg = NULL;

    Py_XDECREF( var_packed );
    var_packed = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_7 = exception_type;
    exception_keeper_value_7 = exception_value;
    exception_keeper_tb_7 = exception_tb;
    exception_keeper_lineno_7 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_addr );
    var_addr = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_address );
    Py_DECREF( par_address );
    par_address = NULL;

    CHECK_OBJECT( (PyObject *)par_strict );
    Py_DECREF( par_strict );
    par_strict = NULL;

    Py_XDECREF( var_arg );
    var_arg = NULL;

    Py_XDECREF( var_packed );
    var_packed = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_7;
    exception_value = exception_keeper_value_7;
    exception_tb = exception_keeper_tb_7;
    exception_lineno = exception_keeper_lineno_7;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_142___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ipaddress$$$function_143_hosts( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1( python_pars[ 0 ] );
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    // Tried code:
    tmp_return_value = ipaddress$$$function_143_hosts$$$genobj_1_hosts_maker();

    ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[0] = par_self;
    Py_INCREF( ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[0] );


    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_143_hosts );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_143_hosts );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}



struct ipaddress$$$function_143_hosts$$$genobj_1_hosts_locals {
    PyObject *var_broadcast;
    PyObject *var_x;
    PyObject *var_network;
    PyObject *tmp_for_loop_1__for_iterator;
    PyObject *tmp_for_loop_1__iter_value;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
};

static PyObject *ipaddress$$$function_143_hosts$$$genobj_1_hosts_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Heap access if used.
    struct ipaddress$$$function_143_hosts$$$genobj_1_hosts_locals *generator_heap = (struct ipaddress$$$function_143_hosts$$$genobj_1_hosts_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_broadcast = NULL;
    generator_heap->var_x = NULL;
    generator_heap->var_network = NULL;
    generator_heap->tmp_for_loop_1__for_iterator = NULL;
    generator_heap->tmp_for_loop_1__iter_value = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_m_frame, codeobj_0ecc96483cf2638c04c31ede5f32d12f, module_ipaddress, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

#if PYTHON_VERSION < 370
        generator->m_frame->m_frame.f_exc_type = EXC_TYPE( thread_state );
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
        Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#else
        generator->m_exc_state.exc_type = EXC_TYPE( thread_state );
        if ( generator->m_exc_state.exc_type == Py_None ) generator->m_exc_state.exc_type = NULL;
        Py_XINCREF( generator->m_exc_state.exc_type );
        generator->m_exc_state.exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_value );
        generator->m_exc_state.exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_traceback );
#endif
    }

#endif

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_int_arg_1;
        PyObject *tmp_source_name_1;
        if ( PyCell_GET( generator->m_closure[0] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 2371;
            generator_heap->type_description_1 = "cooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = PyCell_GET( generator->m_closure[0] );
        tmp_int_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_network_address );
        if ( tmp_int_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 2371;
            generator_heap->type_description_1 = "cooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_1 = PyNumber_Int( tmp_int_arg_1 );
        Py_DECREF( tmp_int_arg_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 2371;
            generator_heap->type_description_1 = "cooo";
            goto frame_exception_exit_1;
        }
        assert( generator_heap->var_network == NULL );
        generator_heap->var_network = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_int_arg_2;
        PyObject *tmp_source_name_2;
        if ( PyCell_GET( generator->m_closure[0] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 2372;
            generator_heap->type_description_1 = "cooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = PyCell_GET( generator->m_closure[0] );
        tmp_int_arg_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_broadcast_address );
        if ( tmp_int_arg_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 2372;
            generator_heap->type_description_1 = "cooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_2 = PyNumber_Int( tmp_int_arg_2 );
        Py_DECREF( tmp_int_arg_2 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 2372;
            generator_heap->type_description_1 = "cooo";
            goto frame_exception_exit_1;
        }
        assert( generator_heap->var_broadcast == NULL );
        generator_heap->var_broadcast = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_range );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__compat_range );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "global name '%s' is not defined", "_compat_range" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 2373;
            generator_heap->type_description_1 = "cooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( generator_heap->var_network );
        tmp_left_name_1 = generator_heap->var_network;
        tmp_right_name_1 = const_int_pos_1;
        tmp_args_element_name_1 = BINARY_OPERATION_ADD_OBJECT_INT( tmp_left_name_1, tmp_right_name_1 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 2373;
            generator_heap->type_description_1 = "cooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( generator_heap->var_broadcast );
        tmp_left_name_2 = generator_heap->var_broadcast;
        tmp_right_name_2 = const_int_pos_1;
        tmp_args_element_name_2 = BINARY_OPERATION_ADD_OBJECT_INT( tmp_left_name_2, tmp_right_name_2 );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
            Py_DECREF( tmp_args_element_name_1 );

            generator_heap->exception_lineno = 2373;
            generator_heap->type_description_1 = "cooo";
            goto frame_exception_exit_1;
        }
        generator->m_frame->m_frame.f_lineno = 2373;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_iter_arg_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_iter_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 2373;
            generator_heap->type_description_1 = "cooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_3 = MAKE_ITERATOR( tmp_iter_arg_1 );
        Py_DECREF( tmp_iter_arg_1 );
        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 2373;
            generator_heap->type_description_1 = "cooo";
            goto frame_exception_exit_1;
        }
        assert( generator_heap->tmp_for_loop_1__for_iterator == NULL );
        generator_heap->tmp_for_loop_1__for_iterator = tmp_assign_source_3;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_4;
        CHECK_OBJECT( generator_heap->tmp_for_loop_1__for_iterator );
        tmp_next_source_1 = generator_heap->tmp_for_loop_1__for_iterator;
        tmp_assign_source_4 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_4 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
                generator_heap->type_description_1 = "cooo";
                generator_heap->exception_lineno = 2373;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_for_loop_1__iter_value;
            generator_heap->tmp_for_loop_1__iter_value = tmp_assign_source_4;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_5;
        CHECK_OBJECT( generator_heap->tmp_for_loop_1__iter_value );
        tmp_assign_source_5 = generator_heap->tmp_for_loop_1__iter_value;
        {
            PyObject *old = generator_heap->var_x;
            generator_heap->var_x = tmp_assign_source_5;
            Py_INCREF( generator_heap->var_x );
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_expression_name_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_3;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        if ( PyCell_GET( generator->m_closure[0] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 2374;
            generator_heap->type_description_1 = "cooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_1 = PyCell_GET( generator->m_closure[0] );
        CHECK_OBJECT( generator_heap->var_x );
        tmp_args_element_name_3 = generator_heap->var_x;
        generator->m_frame->m_frame.f_lineno = 2374;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_expression_name_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain__address_class, call_args );
        }

        if ( tmp_expression_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 2374;
            generator_heap->type_description_1 = "cooo";
            goto try_except_handler_2;
        }
        Nuitka_PreserveHeap( generator_heap->yield_tmps, &tmp_called_instance_1, sizeof(PyObject *), &tmp_args_element_name_3, sizeof(PyObject *), NULL );
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        Nuitka_RestoreHeap( generator_heap->yield_tmps, &tmp_called_instance_1, sizeof(PyObject *), &tmp_args_element_name_3, sizeof(PyObject *), NULL );
        if ( yield_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 2374;
            generator_heap->type_description_1 = "cooo";
            goto try_except_handler_2;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


        generator_heap->exception_lineno = 2373;
        generator_heap->type_description_1 = "cooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->tmp_for_loop_1__iter_value );
    generator_heap->tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)generator_heap->tmp_for_loop_1__for_iterator );
    Py_DECREF( generator_heap->tmp_for_loop_1__for_iterator );
    generator_heap->tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( generator_heap->exception_type ) )
    {
        if ( generator_heap->exception_tb == NULL )
        {
            generator_heap->exception_tb = MAKE_TRACEBACK( generator->m_frame, generator_heap->exception_lineno );
        }
        else if ( generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            generator_heap->exception_tb = ADD_TRACEBACK( generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            generator->m_closure[0],
            generator_heap->var_broadcast,
            generator_heap->var_x,
            generator_heap->var_network
        );


        // Release cached frame.
        if ( generator->m_frame == cache_m_frame )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_m_frame = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->var_broadcast );
    generator_heap->var_broadcast = NULL;

    Py_XDECREF( generator_heap->var_x );
    generator_heap->var_x = NULL;

    Py_XDECREF( generator_heap->var_network );
    generator_heap->var_network = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:
    try_end_2:;
    Py_XDECREF( generator_heap->tmp_for_loop_1__iter_value );
    generator_heap->tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)generator_heap->tmp_for_loop_1__for_iterator );
    Py_DECREF( generator_heap->tmp_for_loop_1__for_iterator );
    generator_heap->tmp_for_loop_1__for_iterator = NULL;

    CHECK_OBJECT( (PyObject *)generator_heap->var_broadcast );
    Py_DECREF( generator_heap->var_broadcast );
    generator_heap->var_broadcast = NULL;

    Py_XDECREF( generator_heap->var_x );
    generator_heap->var_x = NULL;

    CHECK_OBJECT( (PyObject *)generator_heap->var_network );
    Py_DECREF( generator_heap->var_network );
    generator_heap->var_network = NULL;



    return NULL;

    function_exception_exit:
    assert( generator_heap->exception_type );
    RESTORE_ERROR_OCCURRED( generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb );

    return NULL;

}

static PyObject *ipaddress$$$function_143_hosts$$$genobj_1_hosts_maker( void )
{
    return Nuitka_Generator_New(
        ipaddress$$$function_143_hosts$$$genobj_1_hosts_context,
        module_ipaddress,
        const_str_plain_hosts,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_0ecc96483cf2638c04c31ede5f32d12f,
        1,
        sizeof(struct ipaddress$$$function_143_hosts$$$genobj_1_hosts_locals)
    );
}


static PyObject *impl_ipaddress$$$function_144_is_site_local( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_f3fc95762b22ba9ceab359a9934b5168;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_f3fc95762b22ba9ceab359a9934b5168 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f3fc95762b22ba9ceab359a9934b5168, codeobj_f3fc95762b22ba9ceab359a9934b5168, module_ipaddress, sizeof(void *) );
    frame_f3fc95762b22ba9ceab359a9934b5168 = cache_frame_f3fc95762b22ba9ceab359a9934b5168;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f3fc95762b22ba9ceab359a9934b5168 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f3fc95762b22ba9ceab359a9934b5168 ) == 2 ); // Frame stack

    // Framed code:
    {
        int tmp_and_left_truth_1;
        PyObject *tmp_and_left_value_1;
        PyObject *tmp_and_right_value_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_source_name_4;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_network_address );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2388;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_is_site_local );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_and_left_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2388;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
        if ( tmp_and_left_truth_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_and_left_value_1 );

            exception_lineno = 2389;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        if ( tmp_and_left_truth_1 == 1 )
        {
            goto and_right_1;
        }
        else
        {
            goto and_left_1;
        }
        and_right_1:;
        Py_DECREF( tmp_and_left_value_1 );
        CHECK_OBJECT( par_self );
        tmp_source_name_4 = par_self;
        tmp_source_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_broadcast_address );
        if ( tmp_source_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2389;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_is_site_local );
        Py_DECREF( tmp_source_name_3 );
        if ( tmp_and_right_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2389;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_return_value = tmp_and_left_value_1;
        and_end_1:;
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f3fc95762b22ba9ceab359a9934b5168 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_f3fc95762b22ba9ceab359a9934b5168 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f3fc95762b22ba9ceab359a9934b5168 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f3fc95762b22ba9ceab359a9934b5168, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f3fc95762b22ba9ceab359a9934b5168->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f3fc95762b22ba9ceab359a9934b5168, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f3fc95762b22ba9ceab359a9934b5168,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_f3fc95762b22ba9ceab359a9934b5168 == cache_frame_f3fc95762b22ba9ceab359a9934b5168 )
    {
        Py_DECREF( frame_f3fc95762b22ba9ceab359a9934b5168 );
    }
    cache_frame_f3fc95762b22ba9ceab359a9934b5168 = NULL;

    assertFrameObject( frame_f3fc95762b22ba9ceab359a9934b5168 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_144_is_site_local );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ipaddress$$$function_144_is_site_local );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_100___eq__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_100___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_b79d16e0a05c525ce1a86e8fc3c4bd76,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_101___lt__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_101___lt__,
        const_str_plain___lt__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_93e6fc29e52e68bb6ff597277c93b709,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_102___hash__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_102___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_5ab60d4e3551fabd11cba7f0c5ccf9ef,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_103_ip(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_103_ip,
        const_str_plain_ip,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_efc26b80524c8071b2ab77bc15354df5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_104_with_prefixlen(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_104_with_prefixlen,
        const_str_plain_with_prefixlen,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_625df4c5b3b8890b0a4145c1af1d8553,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_105_with_netmask(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_105_with_netmask,
        const_str_plain_with_netmask,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_031b9ad4d720268768a4bf8633c574fc,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_106_with_hostmask(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_106_with_hostmask,
        const_str_plain_with_hostmask,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_f5cf93a3617c153acb8c04a6ee43a9e3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_107___init__( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_107___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_fee12ae33446c0d7b04e9fde4e87b023,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_a2d4646a8cc0fa37c20d1bd32a19571f,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_108_is_global(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_108_is_global,
        const_str_plain_is_global,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_8f233debdccbd7f23dd58687a18eb3c8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_7e2f39ab56e1398f630fda41c7d495e6,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_109__make_netmask(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_109__make_netmask,
        const_str_plain__make_netmask,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_ab75866f99bb0b58bdf97c9c49b3680d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_6d039f42f7b89c8dc0c9eb3f203555ab,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_10___le__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_10___le__,
        const_str_plain___le__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_a4f6648fef564b16884f557db0779374,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_110__ip_int_from_string(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_110__ip_int_from_string,
        const_str_plain__ip_int_from_string,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_f90b0be0f90a66a29fbcc60d47edce81,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_b75fb6a47d7489ff4ba1e06eb56d2178,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_111__parse_hextet(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_111__parse_hextet,
        const_str_plain__parse_hextet,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_5cec4f1aab659e4de38ef9afc8d48e47,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_29df0a9c7866e00435cc16fa8f0aec14,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_112__compress_hextets(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_112__compress_hextets,
        const_str_plain__compress_hextets,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_ad30372b73c3d36542e3a940af829ee7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_92c107dbe635b4b79a97075dcd49ce3d,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_113__string_from_ip_int( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_113__string_from_ip_int,
        const_str_plain__string_from_ip_int,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_124ad0b848fffa9587184710249546c6,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_10cfd1ff9fa2b2c1de094f0f58ee69fd,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_114__explode_shorthand_ip_string(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_114__explode_shorthand_ip_string,
        const_str_plain__explode_shorthand_ip_string,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_025da757111325499181d0330a4934f2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_e58d37c1cbee6b52618f84115bc05cfc,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_115__reverse_pointer(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_115__reverse_pointer,
        const_str_plain__reverse_pointer,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_35b05f2076f28f93f5a20a6e91d03cdf,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_a6ef81b4dc8d6ca51bcc72d4b8e50fda,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_116_max_prefixlen(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_116_max_prefixlen,
        const_str_plain_max_prefixlen,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_f4b494f9d651886073c73f6a413cb5bc,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_117_version(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_117_version,
        const_str_plain_version,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_df20c4ec324ad955944c40cd6e9c34ee,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_118___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_118___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_2f7e7db6799399502d6940e3245a34c6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_0d4549e3c9ba6b05a7194583ebe788ee,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_119_packed(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_119_packed,
        const_str_plain_packed,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_21ddc125364ef772bcb1aad81be1d95e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_283a86aa738f016354d4630f6f9478f9,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_11___gt__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_11___gt__,
        const_str_plain___gt__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c8b388385f1f9f775ba4daa3e7c06d3b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_120_is_multicast(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_120_is_multicast,
        const_str_plain_is_multicast,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_77bf576a262d37c8647e73432c32b9e8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_da1818644dfbad301b75eda6d440ddac,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_121_is_reserved(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_121_is_reserved,
        const_str_plain_is_reserved,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_df336f9f31d2c5b6ff8f38a70df38b5c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_2d8623d8a6589c5a67c27cdfbfcf46e3,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_122_is_link_local(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_122_is_link_local,
        const_str_plain_is_link_local,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_b26421f87f4a69b7ea20133c9f845414,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_54697220435798be94259c75534ddc2b,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_123_is_site_local(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_123_is_site_local,
        const_str_plain_is_site_local,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_fce6ccb47dffbdcbdaa4a8ce79489a77,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_cd26fcb2639894908f2563203d484a92,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_124_is_private(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_124_is_private,
        const_str_plain_is_private,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_9c71824c4bdb84129e3146d7ba81701a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_566097bb8b2b191c9db35f0ec86b0f33,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_125_is_global(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_125_is_global,
        const_str_plain_is_global,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_58f69ddfab375b10f28d409ed4e35d2f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_e05179e2703db9ae8abe267335566873,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_126_is_unspecified(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_126_is_unspecified,
        const_str_plain_is_unspecified,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_b605231cd1026aa555c929e5b01f6bc1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_8ae547298da00f3e03c0a262558b355e,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_127_is_loopback(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_127_is_loopback,
        const_str_plain_is_loopback,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_ddad72e202b73cfe919e21d5cf44518f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_dce79371adf00f5e6de2f2d426c56f59,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_128_ipv4_mapped(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_128_ipv4_mapped,
        const_str_plain_ipv4_mapped,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_e78bc76a4d1feac8d2458c32bc8aaf3d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_f4190d022dc40f14076f71730abf2fd3,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_129_teredo(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_129_teredo,
        const_str_plain_teredo,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_08fcd993c7b81e47169ff1e3992e9c4b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_59e693b3e55c03cdfbf51d3bfd2ecbbe,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_12___ge__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_12___ge__,
        const_str_plain___ge__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0c15792d81d3f3f629d0aa7ac6cf19a4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_130_sixtofour(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_130_sixtofour,
        const_str_plain_sixtofour,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_e2bdbfa49ffc502fdd64c2afed334e8d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_d5a1201fe07f6f7e80d19f19f44f0cfb,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_131___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_131___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_76720fec7c04811ad2bb6263663e1452,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_132___str__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_132___str__,
        const_str_plain___str__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_bbb4b9c00fafbe54124665f1f4641832,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_133___eq__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_133___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_6b1370f0a4d4f18f0cf4ced6f6f5f56b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_134___lt__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_134___lt__,
        const_str_plain___lt__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_e912ba0bfe133f34c669723d31be939b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_135___hash__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_135___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_40609662a1dd4462655d9c04cd6ccf15,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_136_ip(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_136_ip,
        const_str_plain_ip,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_5fa2e0f0c94e079165acf06a3e2b0103,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_137_with_prefixlen(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_137_with_prefixlen,
        const_str_plain_with_prefixlen,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_1370e8ed5db9ed96af59bd81a5809fb0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_138_with_netmask(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_138_with_netmask,
        const_str_plain_with_netmask,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_ec9028b7009e5af16c10d0a9cc3c34f2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_139_with_hostmask(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_139_with_hostmask,
        const_str_plain_with_hostmask,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_84242c2f8814b6ec54d58e169ead4095,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_13_ip_address(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_13_ip_address,
        const_str_plain_ip_address,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_90469e3b518446adc4eedffd44ffe52a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_d34b52cbd25eb67200141aed7e8a5928,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_140_is_unspecified(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_140_is_unspecified,
        const_str_plain_is_unspecified,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_966fe35e427b37714c22ebe086cb0fa7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_141_is_loopback(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_141_is_loopback,
        const_str_plain_is_loopback,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_05ec6fd01eb342b10aaf820f0f88358b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_142___init__( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_142___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_cd86ecb14e7f6f0ffe0a002e37a7e37a,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_f70fd07d18881f54cf18de3ff6348c33,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_143_hosts(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_143_hosts,
        const_str_plain_hosts,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0ecc96483cf2638c04c31ede5f32d12f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_9ccf09593a54d4a7dcc17d246e4f9cea,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_144_is_site_local(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_144_is_site_local,
        const_str_plain_is_site_local,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_f3fc95762b22ba9ceab359a9934b5168,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_cd26fcb2639894908f2563203d484a92,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_14_ip_network( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_14_ip_network,
        const_str_plain_ip_network,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_08dacecb2456e05693d19a8e92c1c5d3,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_fbf09f2b8368dad5ab4255c739a502ac,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_15_ip_interface(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_15_ip_interface,
        const_str_plain_ip_interface,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_8f5d37f073b7a64c59b07aa21d264e87,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_fc69aaef3eb8f00317a1c6cf63cf6f1e,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_16_v4_int_to_packed(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_16_v4_int_to_packed,
        const_str_plain_v4_int_to_packed,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_238d4641bef942b70ad192a34b24ce43,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_f77aa8bd91c4bb866a3ac2b2f1ae555f,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_17_v6_int_to_packed(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_17_v6_int_to_packed,
        const_str_plain_v6_int_to_packed,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_124b766cd28bbd519eab91237988348d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_572d7cc1bd08b37563d1969e4898e12a,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_18__split_optional_netmask(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_18__split_optional_netmask,
        const_str_plain__split_optional_netmask,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_e4457ed056c53cf95f24b187fd8e10b8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_da5f25ffc686d67b336b34206396de7f,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_19__find_address_range(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_19__find_address_range,
        const_str_plain__find_address_range,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_af2a5c10f47089b7ca07ac0f61f0ee94,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_4fad13736690efbbfb886f1de29a5548,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_1__compat_bytes_to_byte_vals(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_1__compat_bytes_to_byte_vals,
        const_str_plain__compat_bytes_to_byte_vals,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_ddaf032ca36ff3666d4667ec7ee75bbe,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_20__count_righthand_zero_bits(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_20__count_righthand_zero_bits,
        const_str_plain__count_righthand_zero_bits,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_1d375206df9e3c3637ab9124f31b1a59,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_4e11e045f071f5745153d71dc21282d3,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_21_summarize_address_range(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_21_summarize_address_range,
        const_str_plain_summarize_address_range,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_b1fe0f75950a86c7a08048741a3f59da,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_2ad4c551e3bacbb3a65998acbd70fdf9,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_22__collapse_addresses_internal(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_22__collapse_addresses_internal,
        const_str_plain__collapse_addresses_internal,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_3aa7b3b68ced212bf157a71f3cb41b24,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_eddf7f22fedb80dd2c5a5c8cec1a1c87,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_23_collapse_addresses(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_23_collapse_addresses,
        const_str_plain_collapse_addresses,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_60a11b2dd91b774c274871d35d983f3a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_289cab06588645bfabb37c3778356771,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_24_get_mixed_type_key(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_24_get_mixed_type_key,
        const_str_plain_get_mixed_type_key,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_8d3c219bed018f80d348d948e64e2a26,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_c844160122a9f5474c7a0c0184598e9b,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_25_exploded(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_25_exploded,
        const_str_plain_exploded,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_e93d5bcbbebcc474c506583b2262be27,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_3feec7dafafbe9a5e0ca70f8d344b308,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_26_compressed(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_26_compressed,
        const_str_plain_compressed,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_93f2eac4eb7c93371ce23e334a4e29f2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_40b73348e084c4c5959abc33f03bc16b,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_27_reverse_pointer(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_27_reverse_pointer,
        const_str_plain_reverse_pointer,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0049438ffc60200b97a4b97bbed5f67d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_d83a1159969df2ac8ecaadc60ffc52aa,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_28_version(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_28_version,
        const_str_plain_version,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_ca89dae17c23af9c1e2595574e987d31,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_29__check_int_address(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_29__check_int_address,
        const_str_plain__check_int_address,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_67e26f96837097bd24506e72e861d756,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_2__compat_int_from_byte_vals(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_2__compat_int_from_byte_vals,
        const_str_plain__compat_int_from_byte_vals,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_63f7a410e2fb3e552200f2a82a5285db,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_30__check_packed_address(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_30__check_packed_address,
        const_str_plain__check_packed_address,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_2f1cce2dd9f99f279577e205f1e726fe,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_31__ip_int_from_prefix(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_31__ip_int_from_prefix,
        const_str_plain__ip_int_from_prefix,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_66965efd84eb1c5142457e86e95209e3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_ab75335520e250f0caebe75ed640b3fc,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_32__prefix_from_ip_int(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_32__prefix_from_ip_int,
        const_str_plain__prefix_from_ip_int,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_81a497c5e641cb3dbfc1edaf5d4d15ad,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_32c5b15b8e2cae0f60549ea8196894b5,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_33__report_invalid_netmask(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_33__report_invalid_netmask,
        const_str_plain__report_invalid_netmask,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_00ee5b6806ca20bcda5fb1846ff2fa87,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_34__prefix_from_prefix_string(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_34__prefix_from_prefix_string,
        const_str_plain__prefix_from_prefix_string,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_bb1e2ac1f2a08510058031fa56cc95e9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_bd8ac84a857b4ed91963d33543ce504a,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_35__prefix_from_ip_string(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_35__prefix_from_ip_string,
        const_str_plain__prefix_from_ip_string,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_475e33420705710913bc618cb12cdaaa,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_24de17cd9f039f640eb11d2c2ddbd04c,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_36___reduce__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_36___reduce__,
        const_str_plain___reduce__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_ed741ffdf26796e0ff1e303ebfd19808,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_37___int__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_37___int__,
        const_str_plain___int__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_d6198731425720bf74b62a3c85594e44,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_38___eq__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_38___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_b2f94a1328d96c44d4a82b1e3c4b6114,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_39___lt__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_39___lt__,
        const_str_plain___lt__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_85d0c509283f96c21d0470148697e1c2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_3__compat_to_bytes(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_3__compat_to_bytes,
        const_str_plain__compat_to_bytes,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_6c48ac6d4f9732d2aa38e88a2fc8b8c0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_40___add__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_40___add__,
        const_str_plain___add__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_9abed9769104b337e842b37b29bc8335,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_41___sub__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_41___sub__,
        const_str_plain___sub__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_2cfe51702bf97b246bfe200e1420b757,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_42___repr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_42___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_1f09a9f606fe746196d89cb184d5e7c0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_43___str__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_43___str__,
        const_str_plain___str__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_1b1050c7cbb3699227e50b9e996a2d3f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_44___hash__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_44___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_a802e13262f2f1adf825e3a244d35ad0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_45__get_address_key(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_45__get_address_key,
        const_str_plain__get_address_key,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_21dad7c185498a4193f7a59a5bcd26b9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_46___reduce__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_46___reduce__,
        const_str_plain___reduce__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_7d2642b77ac278ef54f940cfcbf38077,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_47___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_47___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_7f0f3df5e6d1653dd48befa6bc77ac64,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_48___repr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_48___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_81fb079e76541adf9e8bfbe35414892c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_49___str__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_49___str__,
        const_str_plain___str__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_1af72631d4ce0035edf15f8f172d5fc2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_4__compat_bit_length(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_4__compat_bit_length,
        const_str_plain__compat_bit_length,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_ef713967755f9970e25b35c37c0ef9d1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_50_hosts(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_50_hosts,
        const_str_plain_hosts,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_7294db2a9216f390dfeaedea67d0ffcf,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_19653372c9d87d543bd1a3a25c524778,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_51___iter__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_51___iter__,
        const_str_plain___iter__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_a9c87da975507046d881307a08716b6a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_52___getitem__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_52___getitem__,
        const_str_plain___getitem__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_f7f38e383ec02fe43d0b472cb99f0b76,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_53___lt__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_53___lt__,
        const_str_plain___lt__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_fa3a1065a48af6021c6b23a77663b3d5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_54___eq__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_54___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_f9185ed1a170c02330bb8fd2e8d972c3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_55___hash__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_55___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_4b9e696776a8e3a1391c605ab86d1016,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_56___contains__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_56___contains__,
        const_str_plain___contains__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_75cfc528ffb67ea8d2c84948eee1df0b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_57_overlaps(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_57_overlaps,
        const_str_plain_overlaps,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_65a481757749f9bfb65fbb716f6aa9b0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_dec03ab398d5a59037dd890fd3350705,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_58_broadcast_address(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_58_broadcast_address,
        const_str_plain_broadcast_address,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_39e15cae3809f0757e14fe4a7c9b7fa2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_59_hostmask(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_59_hostmask,
        const_str_plain_hostmask,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_9be0c556551336fa7c7c00a3df4577e6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_5__compat_bit_length(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_5__compat_bit_length,
        const_str_plain__compat_bit_length,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_1d55304974863c80f8deb17902b6612b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_60_with_prefixlen(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_60_with_prefixlen,
        const_str_plain_with_prefixlen,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_e20490aef3e0cf3e11cbb7c3de926018,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_61_with_netmask(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_61_with_netmask,
        const_str_plain_with_netmask,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_a77ea2ed442180f359e7236fa03ce30e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_62_with_hostmask(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_62_with_hostmask,
        const_str_plain_with_hostmask,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_558a53c8ca1440f3014f54f358619139,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_63_num_addresses(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_63_num_addresses,
        const_str_plain_num_addresses,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_35f2f0b4833eb4d15fba0bdc439d87e6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_74272e9e6b29f827a4600cd9d4bfe9d6,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_64__address_class(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_64__address_class,
        const_str_plain__address_class,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_f78f9052a3f53d3f5f58402f6adb4944,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_65_prefixlen(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_65_prefixlen,
        const_str_plain_prefixlen,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_02eb5158aaf36af6a20d27401bd96db3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_66_address_exclude(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_66_address_exclude,
        const_str_plain_address_exclude,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_3769b2c4ffdc7c3f9f9b4dbc1cef7e71,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_7ed15216d64208508e99692b4f3b95c2,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_67_compare_networks(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_67_compare_networks,
        const_str_plain_compare_networks,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c45d853a29dec1f0248c5e593abb118c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_fcd0b976a07f817f01888853a28920d5,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_68__get_networks_key(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_68__get_networks_key,
        const_str_plain__get_networks_key,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_8f1a1dcf125472cc5e5562ccf9d75921,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_f9bc333483c82191ecd263b25cbcf60d,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_69_subnets( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_69_subnets,
        const_str_plain_subnets,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_afd3bfdaef11bbc48af0b7dfa76ee499,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_a334f37feab916326bca0b7fe2402491,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_6__compat_range( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_6__compat_range,
        const_str_plain__compat_range,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_9e6ebf7db345152cd0b801fe8b7dd4ce,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_70_supernet( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_70_supernet,
        const_str_plain_supernet,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_40865f494124bd7ebca7599fd819457c,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_b53e8ff97e86469747c016cbda8b6b82,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_71_is_multicast(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_71_is_multicast,
        const_str_plain_is_multicast,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_1f58a578c801456122b311c4e070e4c5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_da1818644dfbad301b75eda6d440ddac,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_72_subnet_of(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_72_subnet_of,
        const_str_plain_subnet_of,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c403847f283cf7a81a7cf711a02170ce,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_73_supernet_of(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_73_supernet_of,
        const_str_plain_supernet_of,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_1f679a65df6468242fd0f036feae969e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_74_is_reserved(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_74_is_reserved,
        const_str_plain_is_reserved,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_7a258d001059db6f4e3d220e0e99a1a2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_2d8623d8a6589c5a67c27cdfbfcf46e3,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_75_is_link_local(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_75_is_link_local,
        const_str_plain_is_link_local,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_1e777b2cca1fdd718c4873963deb0023,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_54697220435798be94259c75534ddc2b,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_76_is_private(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_76_is_private,
        const_str_plain_is_private,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_adc6579a2d3fee5fb2a17b97524c1b54,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_e44f916e3d7ef9d976f7d25c6c24f69c,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_77_is_global(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_77_is_global,
        const_str_plain_is_global,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_797202885290d9baeb7f5a55e4fd22c5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_87af500436080f92b2724f59f56f083f,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_78_is_unspecified(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_78_is_unspecified,
        const_str_plain_is_unspecified,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_f8fcc3c4ac09b355399d18350c5a9f23,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_8ae547298da00f3e03c0a262558b355e,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_79_is_loopback(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_79_is_loopback,
        const_str_plain_is_loopback,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c66eb78bb605c988fc86c10da130d5b9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_dce79371adf00f5e6de2f2d426c56f59,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_7___eq__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_7___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0186f03ed402b8f930ca7c2461b98230,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_80__explode_shorthand_ip_string(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_80__explode_shorthand_ip_string,
        const_str_plain__explode_shorthand_ip_string,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_73951747500cefaada7ce57eac2afc74,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_81__make_netmask(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_81__make_netmask,
        const_str_plain__make_netmask,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_f6ab1da534820a295432dc985ea5c721,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_6d039f42f7b89c8dc0c9eb3f203555ab,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_82__ip_int_from_string(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_82__ip_int_from_string,
        const_str_plain__ip_int_from_string,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_aef582dae391f517bebe2068da97cde0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_32cd97b7f60de6dc3859a99c1b5562c5,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_83__parse_octet(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_83__parse_octet,
        const_str_plain__parse_octet,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_779fd7a0aab1f3b76d0239378711294e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_4d7919668db95bf4651353bc6dceea2a,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_84__string_from_ip_int(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_84__string_from_ip_int,
        const_str_plain__string_from_ip_int,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_965a59153c45ade1eb4421df6ac0207d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_2bc0198930fe74059a20349326880c0a,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_85__is_hostmask(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_85__is_hostmask,
        const_str_plain__is_hostmask,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0acab394733e19c6ca20d33f8286a543,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_a6071b8f181f3ae395076bdc2a3c343f,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_86__reverse_pointer(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_86__reverse_pointer,
        const_str_plain__reverse_pointer,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_65bdf21fa4f2995d9cbc9d64b9242437,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_caccb9a882e33dc7cad6440d3039a297,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_87_max_prefixlen(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_87_max_prefixlen,
        const_str_plain_max_prefixlen,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_daa648eaba38dc7c040c161e27018597,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_88_version(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_88_version,
        const_str_plain_version,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_5beb6c0ecef6d2e4a9b887e5a1d874fe,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_89___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_89___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_ce30d14ef98e4b5fb4f1bbda17cb1b5e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_edea999b5d5c2e617dee49e550687c1b,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_8___ne__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_8___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_ecf3b750663a962c8345413a0f92b14f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_90_packed(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_90_packed,
        const_str_plain_packed,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_74f67d01bd167da0756775c14a3a8bb0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_283a86aa738f016354d4630f6f9478f9,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_91_is_reserved(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_91_is_reserved,
        const_str_plain_is_reserved,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_b87026341f70c04f9c8a27abe812549e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_b72048f1b66f9fdd2e7e82925d13c1d2,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_92_is_private(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_92_is_private,
        const_str_plain_is_private,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c3b901b102aeaad9d46e4c7384759f59,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_a903554c9d4eb1e89ecedb79be4218d2,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_93_is_global(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_93_is_global,
        const_str_plain_is_global,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_6ef12be487ba919b62bfd71122d13134,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_94_is_multicast(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_94_is_multicast,
        const_str_plain_is_multicast,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_9884b10659aa16fb451f94aef6e0d207,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_577627ae9fd0ef6e23ffee5af41f536a,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_95_is_unspecified(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_95_is_unspecified,
        const_str_plain_is_unspecified,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_2e57bd4f793084e6678d8088b4db5110,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_a8976dae4f4cb6a171c90676e02e7864,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_96_is_loopback(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_96_is_loopback,
        const_str_plain_is_loopback,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0f3c3c5183ea0c46a59155086c6f7125,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_de2bfe1831dccdb3c6a1c35e78a8cfff,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_97_is_link_local(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_97_is_link_local,
        const_str_plain_is_link_local,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0c6b9c33eb0e964d2f2830e571976109,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        const_unicode_digest_9d31f3ec37b1a08172a39ca753627f89,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_98___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_98___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_bc7f8586f62fb3cbf6c042b03e688d28,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_99___str__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_99___str__,
        const_str_plain___str__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_625cfb563c75cb0b49bcc7b223caabc6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ipaddress$$$function_9___lt__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ipaddress$$$function_9___lt__,
        const_str_plain___lt__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0025b9efe3ddf8d01e63fbed9660773a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ipaddress,
        NULL,
        0
    );

    return (PyObject *)result;
}



#if PYTHON_VERSION >= 300
static struct PyModuleDef mdef_ipaddress =
{
    PyModuleDef_HEAD_INIT,
    "ipaddress",
    NULL,                /* m_doc */
    -1,                  /* m_size */
    NULL,                /* m_methods */
    NULL,                /* m_reload */
    NULL,                /* m_traverse */
    NULL,                /* m_clear */
    NULL,                /* m_free */
  };
#endif

extern PyObject *const_str_plain___package__;

#if PYTHON_VERSION >= 300
extern PyObject *const_str_dot;

extern PyObject *const_str_plain___loader__;
#endif

#if PYTHON_VERSION >= 340
extern PyObject *const_str_plain___spec__;
extern PyObject *const_str_plain__initializing;
extern PyObject *const_str_plain_submodule_search_locations;
#endif

extern void _initCompiledCellType();
extern void _initCompiledGeneratorType();
extern void _initCompiledFunctionType();
extern void _initCompiledMethodType();
extern void _initCompiledFrameType();
#if PYTHON_VERSION >= 350
extern void _initCompiledCoroutineTypes();
#endif
#if PYTHON_VERSION >= 360
extern void _initCompiledAsyncgenTypes();
#endif

extern PyTypeObject Nuitka_Loader_Type;

// The exported interface to CPython. On import of the module, this function
// gets called. It has to have an exact function name, in cases it's a shared
// library export. This is hidden behind the MOD_INIT_DECL.

MOD_INIT_DECL( ipaddress )
{
#if defined(_NUITKA_EXE) || PYTHON_VERSION >= 300
    static bool _init_done = false;

    // Modules might be imported repeatedly, which is to be ignored.
    if ( _init_done )
    {
        return MOD_RETURN_VALUE( module_ipaddress );
    }
    else
    {
        _init_done = true;
    }
#endif

#ifdef _NUITKA_MODULE
    // In case of a stand alone extension module, need to call initialization
    // the init here because that's the first and only time we are going to get
    // called here.

    // Initialize the constant values used.
    _initBuiltinModule();
    createGlobalConstants();

    /* Initialize the compiled types of Nuitka. */
    _initCompiledCellType();
    _initCompiledGeneratorType();
    _initCompiledFunctionType();
    _initCompiledMethodType();
    _initCompiledFrameType();
#if PYTHON_VERSION >= 350
    _initCompiledCoroutineTypes();
#endif
#if PYTHON_VERSION >= 360
    _initCompiledAsyncgenTypes();
#endif

#if PYTHON_VERSION < 300
    _initSlotCompare();
#endif
#if PYTHON_VERSION >= 270
    _initSlotIternext();
#endif

    patchBuiltinModule();
    patchTypeComparison();

    // Enable meta path based loader if not already done.
#ifdef _NUITKA_TRACE
    puts("ipaddress: Calling setupMetaPathBasedLoader().");
#endif
    setupMetaPathBasedLoader();

#if PYTHON_VERSION >= 300
    patchInspectModule();
#endif

#endif

    /* The constants only used by this module are created now. */
#ifdef _NUITKA_TRACE
    puts("ipaddress: Calling createModuleConstants().");
#endif
    createModuleConstants();

    /* The code objects used by this module are created now. */
#ifdef _NUITKA_TRACE
    puts("ipaddress: Calling createModuleCodeObjects().");
#endif
    createModuleCodeObjects();

    // puts( "in initipaddress" );

    // Create the module object first. There are no methods initially, all are
    // added dynamically in actual code only.  Also no "__doc__" is initially
    // set at this time, as it could not contain NUL characters this way, they
    // are instead set in early module code.  No "self" for modules, we have no
    // use for it.
#if PYTHON_VERSION < 300
    module_ipaddress = Py_InitModule4(
        "ipaddress",       // Module Name
        NULL,                    // No methods initially, all are added
                                 // dynamically in actual module code only.
        NULL,                    // No "__doc__" is initially set, as it could
                                 // not contain NUL this way, added early in
                                 // actual code.
        NULL,                    // No self for modules, we don't use it.
        PYTHON_API_VERSION
    );
#else

    module_ipaddress = PyModule_Create( &mdef_ipaddress );
#endif

    moduledict_ipaddress = MODULE_DICT( module_ipaddress );

    // Update "__package__" value to what it ought to be.
    {
#if 0
        PyObject *module_name = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain___name__ );

        UPDATE_STRING_DICT1(
            moduledict_ipaddress,
            (Nuitka_StringObject *)const_str_plain___package__,
            module_name
        );
#else

#if PYTHON_VERSION < 300
        PyObject *module_name = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain___name__ );
        char const *module_name_cstr = PyString_AS_STRING( module_name );

        char const *last_dot = strrchr( module_name_cstr, '.' );

        if ( last_dot != NULL )
        {
            UPDATE_STRING_DICT1(
                moduledict_ipaddress,
                (Nuitka_StringObject *)const_str_plain___package__,
                PyString_FromStringAndSize( module_name_cstr, last_dot - module_name_cstr )
            );
        }
#else
        PyObject *module_name = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain___name__ );
        Py_ssize_t dot_index = PyUnicode_Find( module_name, const_str_dot, 0, PyUnicode_GetLength( module_name ), -1 );

        if ( dot_index != -1 )
        {
            UPDATE_STRING_DICT1(
                moduledict_ipaddress,
                (Nuitka_StringObject *)const_str_plain___package__,
                PyUnicode_Substring( module_name, 0, dot_index )
            );
        }
#endif
#endif
    }

    CHECK_OBJECT( module_ipaddress );

// Seems to work for Python2.7 out of the box, but for Python3, the module
// doesn't automatically enter "sys.modules", so do it manually.
#if PYTHON_VERSION >= 300
    {
        int r = PyObject_SetItem( PyImport_GetModuleDict(), const_str_plain_ipaddress, module_ipaddress );

        assert( r != -1 );
    }
#endif

    // For deep importing of a module we need to have "__builtins__", so we set
    // it ourselves in the same way than CPython does. Note: This must be done
    // before the frame object is allocated, or else it may fail.

    if ( GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain___builtins__ ) == NULL )
    {
        PyObject *value = (PyObject *)builtin_module;

        // Check if main module, not a dict then but the module itself.
#if !defined(_NUITKA_EXE) || !0
        value = PyModule_GetDict( value );
#endif

        UPDATE_STRING_DICT0( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain___builtins__, value );
    }

#if PYTHON_VERSION >= 300
    UPDATE_STRING_DICT0( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain___loader__, (PyObject *)&Nuitka_Loader_Type );
#endif

#if PYTHON_VERSION >= 340
// Set the "__spec__" value

#if 0
    // Main modules just get "None" as spec.
    UPDATE_STRING_DICT0( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain___spec__, Py_None );
#else
    // Other modules get a "ModuleSpec" from the standard mechanism.
    {
        PyObject *bootstrap_module = PyImport_ImportModule("importlib._bootstrap");
        CHECK_OBJECT( bootstrap_module );
        PyObject *module_spec_class = PyObject_GetAttrString( bootstrap_module, "ModuleSpec" );
        Py_DECREF( bootstrap_module );

        PyObject *args[] = {
            GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain___name__ ),
            (PyObject *)&Nuitka_Loader_Type
        };

        PyObject *spec_value = CALL_FUNCTION_WITH_ARGS2(
            module_spec_class,
            args
        );
        Py_DECREF( module_spec_class );

        // We can assume this to never fail, or else we are in trouble anyway.
        CHECK_OBJECT( spec_value );

// For packages set the submodule search locations as well, even if to empty
// list, so investigating code will consider it a package.
#if 0
        SET_ATTRIBUTE( spec_value, const_str_plain_submodule_search_locations, PyList_New(0) );
#endif

// Mark the execution in the "__spec__" value.
        SET_ATTRIBUTE( spec_value, const_str_plain__initializing, Py_True );

        UPDATE_STRING_DICT1( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain___spec__, spec_value );
    }
#endif
#endif

    // Temp variables if any
    PyObject *tmp_class_creation_10__bases = NULL;
    PyObject *tmp_class_creation_10__class = NULL;
    PyObject *tmp_class_creation_10__class_dict = NULL;
    PyObject *tmp_class_creation_10__metaclass = NULL;
    PyObject *tmp_class_creation_11__class = NULL;
    PyObject *tmp_class_creation_11__class_dict = NULL;
    PyObject *tmp_class_creation_11__metaclass = NULL;
    PyObject *tmp_class_creation_12__class = NULL;
    PyObject *tmp_class_creation_12__class_dict = NULL;
    PyObject *tmp_class_creation_12__metaclass = NULL;
    PyObject *tmp_class_creation_13__bases = NULL;
    PyObject *tmp_class_creation_13__class = NULL;
    PyObject *tmp_class_creation_13__class_dict = NULL;
    PyObject *tmp_class_creation_13__metaclass = NULL;
    PyObject *tmp_class_creation_14__bases = NULL;
    PyObject *tmp_class_creation_14__class = NULL;
    PyObject *tmp_class_creation_14__class_dict = NULL;
    PyObject *tmp_class_creation_14__metaclass = NULL;
    PyObject *tmp_class_creation_15__bases = NULL;
    PyObject *tmp_class_creation_15__class = NULL;
    PyObject *tmp_class_creation_15__class_dict = NULL;
    PyObject *tmp_class_creation_15__metaclass = NULL;
    PyObject *tmp_class_creation_16__class = NULL;
    PyObject *tmp_class_creation_16__class_dict = NULL;
    PyObject *tmp_class_creation_16__metaclass = NULL;
    PyObject *tmp_class_creation_1__class = NULL;
    PyObject *tmp_class_creation_1__class_dict = NULL;
    PyObject *tmp_class_creation_1__metaclass = NULL;
    PyObject *tmp_class_creation_2__class = NULL;
    PyObject *tmp_class_creation_2__class_dict = NULL;
    PyObject *tmp_class_creation_2__metaclass = NULL;
    PyObject *tmp_class_creation_3__class = NULL;
    PyObject *tmp_class_creation_3__class_dict = NULL;
    PyObject *tmp_class_creation_3__metaclass = NULL;
    PyObject *tmp_class_creation_4__bases = NULL;
    PyObject *tmp_class_creation_4__class = NULL;
    PyObject *tmp_class_creation_4__class_dict = NULL;
    PyObject *tmp_class_creation_4__metaclass = NULL;
    PyObject *tmp_class_creation_5__bases = NULL;
    PyObject *tmp_class_creation_5__class = NULL;
    PyObject *tmp_class_creation_5__class_dict = NULL;
    PyObject *tmp_class_creation_5__metaclass = NULL;
    PyObject *tmp_class_creation_6__bases = NULL;
    PyObject *tmp_class_creation_6__class = NULL;
    PyObject *tmp_class_creation_6__class_dict = NULL;
    PyObject *tmp_class_creation_6__metaclass = NULL;
    PyObject *tmp_class_creation_7__class = NULL;
    PyObject *tmp_class_creation_7__class_dict = NULL;
    PyObject *tmp_class_creation_7__metaclass = NULL;
    PyObject *tmp_class_creation_8__bases = NULL;
    PyObject *tmp_class_creation_8__class = NULL;
    PyObject *tmp_class_creation_8__class_dict = NULL;
    PyObject *tmp_class_creation_8__metaclass = NULL;
    PyObject *tmp_class_creation_9__bases = NULL;
    PyObject *tmp_class_creation_9__class = NULL;
    PyObject *tmp_class_creation_9__class_dict = NULL;
    PyObject *tmp_class_creation_9__metaclass = NULL;
    PyObject *tmp_locals_ipaddress_80_key___eq__ = NULL;
    PyObject *tmp_locals_ipaddress_80_key___ge__ = NULL;
    PyObject *tmp_locals_ipaddress_80_key___gt__ = NULL;
    PyObject *tmp_locals_ipaddress_80_key___le__ = NULL;
    PyObject *tmp_locals_ipaddress_80_key___lt__ = NULL;
    PyObject *tmp_locals_ipaddress_80_key___ne__ = NULL;
    PyObject *tmp_select_metaclass_10__base = NULL;
    PyObject *tmp_select_metaclass_13__base = NULL;
    PyObject *tmp_select_metaclass_14__base = NULL;
    PyObject *tmp_select_metaclass_15__base = NULL;
    PyObject *tmp_select_metaclass_4__base = NULL;
    PyObject *tmp_select_metaclass_5__base = NULL;
    PyObject *tmp_select_metaclass_6__base = NULL;
    PyObject *tmp_select_metaclass_8__base = NULL;
    PyObject *tmp_select_metaclass_9__base = NULL;
    struct Nuitka_FrameObject *frame_a10b4ee15c0763ecce4ab0022f0f5fa7;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_res;
    bool tmp_result;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *locals_ipaddress_503 = NULL;
    PyObject *tmp_dictset_value;
    struct Nuitka_FrameObject *frame_dbc69dab8fd6a224013718cb1cbf5cd4_2;
    NUITKA_MAY_BE_UNUSED char const *type_description_2 = NULL;
    static struct Nuitka_FrameObject *cache_frame_dbc69dab8fd6a224013718cb1cbf5cd4_2 = NULL;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;
    PyObject *exception_keeper_type_6;
    PyObject *exception_keeper_value_6;
    PyTracebackObject *exception_keeper_tb_6;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_6;
    PyObject *exception_keeper_type_7;
    PyObject *exception_keeper_value_7;
    PyTracebackObject *exception_keeper_tb_7;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_7;
    PyObject *locals_ipaddress_661 = NULL;
    PyObject *exception_keeper_type_8;
    PyObject *exception_keeper_value_8;
    PyTracebackObject *exception_keeper_tb_8;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_8;
    PyObject *exception_keeper_type_9;
    PyObject *exception_keeper_value_9;
    PyTracebackObject *exception_keeper_tb_9;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_9;
    PyObject *locals_ipaddress_722 = NULL;
    struct Nuitka_FrameObject *frame_039fb0cc98fcd1d5734f80fb0973e949_3;
    NUITKA_MAY_BE_UNUSED char const *type_description_3 = NULL;
    static struct Nuitka_FrameObject *cache_frame_039fb0cc98fcd1d5734f80fb0973e949_3 = NULL;
    PyObject *exception_keeper_type_10;
    PyObject *exception_keeper_value_10;
    PyTracebackObject *exception_keeper_tb_10;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_10;
    PyObject *exception_keeper_type_11;
    PyObject *exception_keeper_value_11;
    PyTracebackObject *exception_keeper_tb_11;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_11;
    PyObject *exception_keeper_type_12;
    PyObject *exception_keeper_value_12;
    PyTracebackObject *exception_keeper_tb_12;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_12;
    PyObject *locals_ipaddress_1200 = NULL;
    struct Nuitka_FrameObject *frame_f77fa86b0ce46b949fc4657d215efecb_4;
    NUITKA_MAY_BE_UNUSED char const *type_description_4 = NULL;
    static struct Nuitka_FrameObject *cache_frame_f77fa86b0ce46b949fc4657d215efecb_4 = NULL;
    PyObject *exception_keeper_type_13;
    PyObject *exception_keeper_value_13;
    PyTracebackObject *exception_keeper_tb_13;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_13;
    PyObject *exception_keeper_type_14;
    PyObject *exception_keeper_value_14;
    PyTracebackObject *exception_keeper_tb_14;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_14;
    PyObject *locals_ipaddress_1369 = NULL;
    struct Nuitka_FrameObject *frame_1a9921f46deeb2eb6639b77a939ad874_5;
    NUITKA_MAY_BE_UNUSED char const *type_description_5 = NULL;
    static struct Nuitka_FrameObject *cache_frame_1a9921f46deeb2eb6639b77a939ad874_5 = NULL;
    PyObject *exception_keeper_type_15;
    PyObject *exception_keeper_value_15;
    PyTracebackObject *exception_keeper_tb_15;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_15;
    PyObject *exception_keeper_type_16;
    PyObject *exception_keeper_value_16;
    PyTracebackObject *exception_keeper_tb_16;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_16;
    PyObject *exception_keeper_type_17;
    PyObject *exception_keeper_value_17;
    PyTracebackObject *exception_keeper_tb_17;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_17;
    PyObject *locals_ipaddress_1487 = NULL;
    struct Nuitka_FrameObject *frame_8c5b956ab97dc62e74ac053cc531b3e0_6;
    NUITKA_MAY_BE_UNUSED char const *type_description_6 = NULL;
    static struct Nuitka_FrameObject *cache_frame_8c5b956ab97dc62e74ac053cc531b3e0_6 = NULL;
    PyObject *exception_keeper_type_18;
    PyObject *exception_keeper_value_18;
    PyTracebackObject *exception_keeper_tb_18;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_18;
    PyObject *exception_keeper_type_19;
    PyObject *exception_keeper_value_19;
    PyTracebackObject *exception_keeper_tb_19;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_19;
    PyObject *exception_keeper_type_20;
    PyObject *exception_keeper_value_20;
    PyTracebackObject *exception_keeper_tb_20;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_20;
    PyObject *locals_ipaddress_1569 = NULL;
    struct Nuitka_FrameObject *frame_1b6fd3360f8022d9f0452f99d3cf6fba_7;
    NUITKA_MAY_BE_UNUSED char const *type_description_7 = NULL;
    static struct Nuitka_FrameObject *cache_frame_1b6fd3360f8022d9f0452f99d3cf6fba_7 = NULL;
    PyObject *exception_keeper_type_21;
    PyObject *exception_keeper_value_21;
    PyTracebackObject *exception_keeper_tb_21;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_21;
    PyObject *exception_keeper_type_22;
    PyObject *exception_keeper_value_22;
    PyTracebackObject *exception_keeper_tb_22;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_22;
    PyObject *exception_keeper_type_23;
    PyObject *exception_keeper_value_23;
    PyTracebackObject *exception_keeper_tb_23;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_23;
    PyObject *locals_ipaddress_1683 = NULL;
    struct Nuitka_FrameObject *frame_1831ffa3cc2fcf6156ebd1cfb8c343f4_8;
    NUITKA_MAY_BE_UNUSED char const *type_description_8 = NULL;
    static struct Nuitka_FrameObject *cache_frame_1831ffa3cc2fcf6156ebd1cfb8c343f4_8 = NULL;
    PyObject *exception_keeper_type_24;
    PyObject *exception_keeper_value_24;
    PyTracebackObject *exception_keeper_tb_24;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_24;
    PyObject *exception_keeper_type_25;
    PyObject *exception_keeper_value_25;
    PyTracebackObject *exception_keeper_tb_25;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_25;
    PyObject *locals_ipaddress_1718 = NULL;
    struct Nuitka_FrameObject *frame_366e7e4afc4c79b4f2de94c1a936dae7_9;
    NUITKA_MAY_BE_UNUSED char const *type_description_9 = NULL;
    static struct Nuitka_FrameObject *cache_frame_366e7e4afc4c79b4f2de94c1a936dae7_9 = NULL;
    PyObject *exception_keeper_type_26;
    PyObject *exception_keeper_value_26;
    PyTracebackObject *exception_keeper_tb_26;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_26;
    PyObject *exception_keeper_type_27;
    PyObject *exception_keeper_value_27;
    PyTracebackObject *exception_keeper_tb_27;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_27;
    PyObject *locals_ipaddress_2003 = NULL;
    struct Nuitka_FrameObject *frame_e3100639ef7adfb1b91bea0685b2bda9_10;
    NUITKA_MAY_BE_UNUSED char const *type_description_10 = NULL;
    static struct Nuitka_FrameObject *cache_frame_e3100639ef7adfb1b91bea0685b2bda9_10 = NULL;
    PyObject *exception_keeper_type_28;
    PyObject *exception_keeper_value_28;
    PyTracebackObject *exception_keeper_tb_28;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_28;
    PyObject *exception_keeper_type_29;
    PyObject *exception_keeper_value_29;
    PyTracebackObject *exception_keeper_tb_29;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_29;
    PyObject *exception_keeper_type_30;
    PyObject *exception_keeper_value_30;
    PyTracebackObject *exception_keeper_tb_30;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_30;
    PyObject *locals_ipaddress_2183 = NULL;
    struct Nuitka_FrameObject *frame_978c64aaac40067740426a6582d720f1_11;
    NUITKA_MAY_BE_UNUSED char const *type_description_11 = NULL;
    static struct Nuitka_FrameObject *cache_frame_978c64aaac40067740426a6582d720f1_11 = NULL;
    PyObject *exception_keeper_type_31;
    PyObject *exception_keeper_value_31;
    PyTracebackObject *exception_keeper_tb_31;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_31;
    PyObject *exception_keeper_type_32;
    PyObject *exception_keeper_value_32;
    PyTracebackObject *exception_keeper_tb_32;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_32;
    PyObject *exception_keeper_type_33;
    PyObject *exception_keeper_value_33;
    PyTracebackObject *exception_keeper_tb_33;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_33;
    PyObject *locals_ipaddress_2269 = NULL;
    struct Nuitka_FrameObject *frame_eede468f789883f6726171dca68e049c_12;
    NUITKA_MAY_BE_UNUSED char const *type_description_12 = NULL;
    static struct Nuitka_FrameObject *cache_frame_eede468f789883f6726171dca68e049c_12 = NULL;
    PyObject *exception_keeper_type_34;
    PyObject *exception_keeper_value_34;
    PyTracebackObject *exception_keeper_tb_34;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_34;
    PyObject *exception_keeper_type_35;
    PyObject *exception_keeper_value_35;
    PyTracebackObject *exception_keeper_tb_35;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_35;
    PyObject *exception_keeper_type_36;
    PyObject *exception_keeper_value_36;
    PyTracebackObject *exception_keeper_tb_36;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_36;
    PyObject *locals_ipaddress_2392 = NULL;
    struct Nuitka_FrameObject *frame_e4f047505da49281bb85f001a8969afe_13;
    NUITKA_MAY_BE_UNUSED char const *type_description_13 = NULL;
    static struct Nuitka_FrameObject *cache_frame_e4f047505da49281bb85f001a8969afe_13 = NULL;
    PyObject *exception_keeper_type_37;
    PyObject *exception_keeper_value_37;
    PyTracebackObject *exception_keeper_tb_37;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_37;
    PyObject *exception_keeper_type_38;
    PyObject *exception_keeper_value_38;
    PyTracebackObject *exception_keeper_tb_38;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_38;

    // Module code.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = const_unicode_digest_53d80a3eb0c1ac5fe323045fd90a38ac;
        UPDATE_STRING_DICT0( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain___doc__, tmp_assign_source_1 );
    }
    {
        PyObject *tmp_assign_source_2;
        tmp_assign_source_2 = const_str_digest_a25a001858b466f6be5039bbd12f63ef;
        UPDATE_STRING_DICT0( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain___file__, tmp_assign_source_2 );
    }
    // Frame without reuse.
    frame_a10b4ee15c0763ecce4ab0022f0f5fa7 = MAKE_MODULE_FRAME( codeobj_a10b4ee15c0763ecce4ab0022f0f5fa7, module_ipaddress );

    // Push the new frame as the currently active one, and we should be exclusively
    // owning it.
    pushFrameStack( frame_a10b4ee15c0763ecce4ab0022f0f5fa7 );
    assert( Py_REFCNT( frame_a10b4ee15c0763ecce4ab0022f0f5fa7 ) == 2 );

    // Framed code:
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_import_name_from_1;
        frame_a10b4ee15c0763ecce4ab0022f0f5fa7->m_frame.f_lineno = 11;
        tmp_import_name_from_1 = PyImport_ImportModule("__future__");
        assert( !(tmp_import_name_from_1 == NULL) );
        tmp_assign_source_3 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_unicode_literals );
        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 11;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_unicode_literals, tmp_assign_source_3 );
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_name_name_1;
        PyObject *tmp_globals_name_1;
        PyObject *tmp_locals_name_1;
        PyObject *tmp_fromlist_name_1;
        tmp_name_name_1 = const_str_plain_itertools;
        tmp_globals_name_1 = (PyObject *)moduledict_ipaddress;
        tmp_locals_name_1 = Py_None;
        tmp_fromlist_name_1 = Py_None;
        frame_a10b4ee15c0763ecce4ab0022f0f5fa7->m_frame.f_lineno = 14;
        tmp_assign_source_4 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
        assert( !(tmp_assign_source_4 == NULL) );
        UPDATE_STRING_DICT1( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_itertools, tmp_assign_source_4 );
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_name_name_2;
        PyObject *tmp_globals_name_2;
        PyObject *tmp_locals_name_2;
        PyObject *tmp_fromlist_name_2;
        tmp_name_name_2 = const_str_plain_struct;
        tmp_globals_name_2 = (PyObject *)moduledict_ipaddress;
        tmp_locals_name_2 = Py_None;
        tmp_fromlist_name_2 = Py_None;
        frame_a10b4ee15c0763ecce4ab0022f0f5fa7->m_frame.f_lineno = 15;
        tmp_assign_source_5 = IMPORT_MODULE4( tmp_name_name_2, tmp_globals_name_2, tmp_locals_name_2, tmp_fromlist_name_2 );
        if ( tmp_assign_source_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 15;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_struct, tmp_assign_source_5 );
    }
    {
        PyObject *tmp_assign_source_6;
        tmp_assign_source_6 = const_unicode_digest_db0e07051873ab67bfbeddf5326d1061;
        UPDATE_STRING_DICT0( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain___version__, tmp_assign_source_6 );
    }
    {
        PyObject *tmp_assign_source_7;
        tmp_assign_source_7 = const_tuple_type_int_tuple;
        UPDATE_STRING_DICT0( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_int_types, tmp_assign_source_7 );
    }
    {
        PyObject *tmp_assign_source_8;
        tmp_assign_source_8 = const_tuple_type_int_type_long_tuple;
        UPDATE_STRING_DICT0( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_int_types, tmp_assign_source_8 );
    }
    {
        PyObject *tmp_assign_source_9;
        tmp_assign_source_9 = (PyObject *)&PyUnicode_Type;
        UPDATE_STRING_DICT0( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_str, tmp_assign_source_9 );
    }
    {
        PyObject *tmp_assign_source_10;
        tmp_assign_source_10 = MAKE_FUNCTION_ipaddress$$$function_1__compat_bytes_to_byte_vals(  );



        UPDATE_STRING_DICT1( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_bytes_to_byte_vals, tmp_assign_source_10 );
    }
    // Tried code:
    {
        PyObject *tmp_raise_type_1;
        PyObject *tmp_raise_value_1;
        tmp_raise_type_1 = PyExc_AttributeError;
        tmp_raise_value_1 = const_str_digest_b1ef207a7bd9f620d0198dc6c7356419;
        exception_type = tmp_raise_type_1;
        Py_INCREF( tmp_raise_type_1 );
        exception_value = tmp_raise_value_1;
        Py_INCREF( tmp_raise_value_1 );
        exception_lineno = 37;
        RAISE_EXCEPTION_IMPLICIT( &exception_type, &exception_value, &exception_tb );

        goto try_except_handler_1;
    }
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress );
    return MOD_RETURN_VALUE( NULL );
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_a10b4ee15c0763ecce4ab0022f0f5fa7 );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_a10b4ee15c0763ecce4ab0022f0f5fa7, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_a10b4ee15c0763ecce4ab0022f0f5fa7, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_compexpr_left_1 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_1 = PyExc_AttributeError;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 38;

            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_11;
            tmp_assign_source_11 = MAKE_FUNCTION_ipaddress$$$function_2__compat_int_from_byte_vals(  );



            UPDATE_STRING_DICT1( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_int_from_byte_vals, tmp_assign_source_11 );
        }
        goto branch_end_1;
        branch_no_1:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 36;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_a10b4ee15c0763ecce4ab0022f0f5fa7->m_frame) frame_a10b4ee15c0763ecce4ab0022f0f5fa7->m_frame.f_lineno = exception_tb->tb_lineno;

        goto frame_exception_exit_1;
        branch_end_1:;
    }
    goto try_end_1;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ipaddress );
    return MOD_RETURN_VALUE( NULL );
    // End of try:
    try_end_1:;
    {
        PyObject *tmp_assign_source_12;
        tmp_assign_source_12 = MAKE_FUNCTION_ipaddress$$$function_3__compat_to_bytes(  );



        UPDATE_STRING_DICT1( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_to_bytes, tmp_assign_source_12 );
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_attribute_name_1;
        tmp_source_name_1 = (PyObject *)&PyInt_Type;
        tmp_attribute_name_1 = const_unicode_plain_bit_length;
        tmp_res = BUILTIN_HASATTR_BOOL( tmp_source_name_1, tmp_attribute_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 61;

            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_13;
            tmp_assign_source_13 = MAKE_FUNCTION_ipaddress$$$function_4__compat_bit_length(  );



            UPDATE_STRING_DICT1( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_bit_length, tmp_assign_source_13 );
        }
        goto branch_end_2;
        branch_no_2:;
        {
            PyObject *tmp_assign_source_14;
            tmp_assign_source_14 = MAKE_FUNCTION_ipaddress$$$function_5__compat_bit_length(  );



            UPDATE_STRING_DICT1( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_bit_length, tmp_assign_source_14 );
        }
        branch_end_2:;
    }
    {
        PyObject *tmp_assign_source_15;
        PyObject *tmp_defaults_1;
        tmp_defaults_1 = const_tuple_int_pos_1_tuple;
        Py_INCREF( tmp_defaults_1 );
        tmp_assign_source_15 = MAKE_FUNCTION_ipaddress$$$function_6__compat_range( tmp_defaults_1 );



        UPDATE_STRING_DICT1( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__compat_range, tmp_assign_source_15 );
    }
    {
        PyObject *tmp_assign_source_16;
        {
            PyObject *tmp_assign_source_17;
            tmp_assign_source_17 = MAKE_FUNCTION_ipaddress$$$function_7___eq__(  );



            assert( tmp_locals_ipaddress_80_key___eq__ == NULL );
            tmp_locals_ipaddress_80_key___eq__ = tmp_assign_source_17;
        }
        {
            PyObject *tmp_assign_source_18;
            tmp_assign_source_18 = MAKE_FUNCTION_ipaddress$$$function_8___ne__(  );



            assert( tmp_locals_ipaddress_80_key___ne__ == NULL );
            tmp_locals_ipaddress_80_key___ne__ = tmp_assign_source_18;
        }
        {
            PyObject *tmp_assign_source_19;
            tmp_assign_source_19 = MAKE_FUNCTION_ipaddress$$$function_9___lt__(  );



            assert( tmp_locals_ipaddress_80_key___lt__ == NULL );
            tmp_locals_ipaddress_80_key___lt__ = tmp_assign_source_19;
        }
        {
            PyObject *tmp_assign_source_20;
            tmp_assign_source_20 = MAKE_FUNCTION_ipaddress$$$function_10___le__(  );



            assert( tmp_locals_ipaddress_80_key___le__ == NULL );
            tmp_locals_ipaddress_80_key___le__ = tmp_assign_source_20;
        }
        {
            PyObject *tmp_assign_source_21;
            tmp_assign_source_21 = MAKE_FUNCTION_ipaddress$$$function_11___gt__(  );



            assert( tmp_locals_ipaddress_80_key___gt__ == NULL );
            tmp_locals_ipaddress_80_key___gt__ = tmp_assign_source_21;
        }
        {
            PyObject *tmp_assign_source_22;
            tmp_assign_source_22 = MAKE_FUNCTION_ipaddress$$$function_12___ge__(  );



            assert( tmp_locals_ipaddress_80_key___ge__ == NULL );
            tmp_locals_ipaddress_80_key___ge__ = tmp_assign_source_22;
        }
        // Tried code:
        {
            PyObject *tmp_dict_key_1;
            PyObject *tmp_dict_value_1;
            PyObject *tmp_dict_key_2;
            PyObject *tmp_dict_value_2;
            PyObject *tmp_dict_key_3;
            PyObject *tmp_dict_value_3;
            PyObject *tmp_dict_key_4;
            PyObject *tmp_dict_value_4;
            PyObject *tmp_dict_key_5;
            PyObject *tmp_dict_value_5;
            PyObject *tmp_dict_key_6;
            PyObject *tmp_dict_value_6;
            PyObject *tmp_dict_key_7;
            PyObject *tmp_dict_value_7;
            PyObject *tmp_dict_key_8;
            PyObject *tmp_dict_value_8;
            tmp_dict_value_1 = const_str_plain_ipaddress;
            tmp_dict_key_1 = const_str_plain___module__;
            tmp_assign_source_16 = _PyDict_NewPresized( 8 );
            tmp_res = PyDict_SetItem( tmp_assign_source_16, tmp_dict_key_1, tmp_dict_value_1 );
            assert( !(tmp_res != 0) );
            tmp_dict_value_2 = const_tuple_empty;
            tmp_dict_key_2 = const_str_plain___slots__;
            tmp_res = PyDict_SetItem( tmp_assign_source_16, tmp_dict_key_2, tmp_dict_value_2 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_ipaddress_80_key___eq__ );
            tmp_dict_value_3 = tmp_locals_ipaddress_80_key___eq__;
            tmp_dict_key_3 = const_str_plain___eq__;
            tmp_res = PyDict_SetItem( tmp_assign_source_16, tmp_dict_key_3, tmp_dict_value_3 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_ipaddress_80_key___ne__ );
            tmp_dict_value_4 = tmp_locals_ipaddress_80_key___ne__;
            tmp_dict_key_4 = const_str_plain___ne__;
            tmp_res = PyDict_SetItem( tmp_assign_source_16, tmp_dict_key_4, tmp_dict_value_4 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_ipaddress_80_key___lt__ );
            tmp_dict_value_5 = tmp_locals_ipaddress_80_key___lt__;
            tmp_dict_key_5 = const_str_plain___lt__;
            tmp_res = PyDict_SetItem( tmp_assign_source_16, tmp_dict_key_5, tmp_dict_value_5 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_ipaddress_80_key___le__ );
            tmp_dict_value_6 = tmp_locals_ipaddress_80_key___le__;
            tmp_dict_key_6 = const_str_plain___le__;
            tmp_res = PyDict_SetItem( tmp_assign_source_16, tmp_dict_key_6, tmp_dict_value_6 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_ipaddress_80_key___gt__ );
            tmp_dict_value_7 = tmp_locals_ipaddress_80_key___gt__;
            tmp_dict_key_7 = const_str_plain___gt__;
            tmp_res = PyDict_SetItem( tmp_assign_source_16, tmp_dict_key_7, tmp_dict_value_7 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_ipaddress_80_key___ge__ );
            tmp_dict_value_8 = tmp_locals_ipaddress_80_key___ge__;
            tmp_dict_key_8 = const_str_plain___ge__;
            tmp_res = PyDict_SetItem( tmp_assign_source_16, tmp_dict_key_8, tmp_dict_value_8 );
            assert( !(tmp_res != 0) );
            goto try_return_handler_2;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_2:;
        CHECK_OBJECT( (PyObject *)tmp_locals_ipaddress_80_key___eq__ );
        Py_DECREF( tmp_locals_ipaddress_80_key___eq__ );
        tmp_locals_ipaddress_80_key___eq__ = NULL;

        CHECK_OBJECT( (PyObject *)tmp_locals_ipaddress_80_key___ne__ );
        Py_DECREF( tmp_locals_ipaddress_80_key___ne__ );
        tmp_locals_ipaddress_80_key___ne__ = NULL;

        CHECK_OBJECT( (PyObject *)tmp_locals_ipaddress_80_key___lt__ );
        Py_DECREF( tmp_locals_ipaddress_80_key___lt__ );
        tmp_locals_ipaddress_80_key___lt__ = NULL;

        CHECK_OBJECT( (PyObject *)tmp_locals_ipaddress_80_key___le__ );
        Py_DECREF( tmp_locals_ipaddress_80_key___le__ );
        tmp_locals_ipaddress_80_key___le__ = NULL;

        CHECK_OBJECT( (PyObject *)tmp_locals_ipaddress_80_key___gt__ );
        Py_DECREF( tmp_locals_ipaddress_80_key___gt__ );
        tmp_locals_ipaddress_80_key___gt__ = NULL;

        CHECK_OBJECT( (PyObject *)tmp_locals_ipaddress_80_key___ge__ );
        Py_DECREF( tmp_locals_ipaddress_80_key___ge__ );
        tmp_locals_ipaddress_80_key___ge__ = NULL;

        goto outline_result_1;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        outline_result_1:;
        assert( tmp_class_creation_1__class_dict == NULL );
        tmp_class_creation_1__class_dict = tmp_assign_source_16;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_23;
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_key_name_1;
        PyObject *tmp_dict_name_1;
        PyObject *tmp_dict_name_2;
        PyObject *tmp_key_name_2;
        tmp_key_name_1 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_1__class_dict );
        tmp_dict_name_1 = tmp_class_creation_1__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_1, tmp_key_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 80;

            goto try_except_handler_3;
        }
        tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_1;
        }
        else
        {
            goto condexpr_false_1;
        }
        condexpr_true_1:;
        CHECK_OBJECT( tmp_class_creation_1__class_dict );
        tmp_dict_name_2 = tmp_class_creation_1__class_dict;
        tmp_key_name_2 = const_str_plain___metaclass__;
        tmp_assign_source_23 = DICT_GET_ITEM( tmp_dict_name_2, tmp_key_name_2 );
        if ( tmp_assign_source_23 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 80;

            goto try_except_handler_3;
        }
        goto condexpr_end_1;
        condexpr_false_1:;
        tmp_assign_source_23 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_assign_source_23 );
        condexpr_end_1:;
        assert( tmp_class_creation_1__metaclass == NULL );
        tmp_class_creation_1__metaclass = tmp_assign_source_23;
    }
    {
        PyObject *tmp_assign_source_24;
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        CHECK_OBJECT( tmp_class_creation_1__metaclass );
        tmp_called_name_1 = tmp_class_creation_1__metaclass;
        tmp_args_element_name_1 = const_str_plain__TotalOrderingMixin;
        tmp_args_element_name_2 = const_tuple_type_object_tuple;
        CHECK_OBJECT( tmp_class_creation_1__class_dict );
        tmp_args_element_name_3 = tmp_class_creation_1__class_dict;
        frame_a10b4ee15c0763ecce4ab0022f0f5fa7->m_frame.f_lineno = 80;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_assign_source_24 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
        }

        if ( tmp_assign_source_24 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 80;

            goto try_except_handler_3;
        }
        assert( tmp_class_creation_1__class == NULL );
        tmp_class_creation_1__class = tmp_assign_source_24;
    }
    goto try_end_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__class_dict );
    Py_DECREF( tmp_class_creation_1__class_dict );
    tmp_class_creation_1__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_1__metaclass );
    tmp_class_creation_1__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    {
        PyObject *tmp_assign_source_25;
        CHECK_OBJECT( tmp_class_creation_1__class );
        tmp_assign_source_25 = tmp_class_creation_1__class;
        UPDATE_STRING_DICT0( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__TotalOrderingMixin, tmp_assign_source_25 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__class );
    Py_DECREF( tmp_class_creation_1__class );
    tmp_class_creation_1__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__class_dict );
    Py_DECREF( tmp_class_creation_1__class_dict );
    tmp_class_creation_1__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__metaclass );
    Py_DECREF( tmp_class_creation_1__metaclass );
    tmp_class_creation_1__metaclass = NULL;

    {
        PyObject *tmp_assign_source_26;
        tmp_assign_source_26 = const_int_pos_32;
        UPDATE_STRING_DICT0( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPV4LENGTH, tmp_assign_source_26 );
    }
    {
        PyObject *tmp_assign_source_27;
        tmp_assign_source_27 = const_int_pos_128;
        UPDATE_STRING_DICT0( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPV6LENGTH, tmp_assign_source_27 );
    }
    {
        PyObject *tmp_assign_source_28;
        tmp_assign_source_28 = PyDict_Copy( const_dict_b84735d462e535bfd6f6cd43e07133d4 );
        assert( tmp_class_creation_2__class_dict == NULL );
        tmp_class_creation_2__class_dict = tmp_assign_source_28;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_29;
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_key_name_3;
        PyObject *tmp_dict_name_3;
        PyObject *tmp_dict_name_4;
        PyObject *tmp_key_name_4;
        tmp_key_name_3 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_2__class_dict );
        tmp_dict_name_3 = tmp_class_creation_2__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_3, tmp_key_name_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 125;

            goto try_except_handler_4;
        }
        tmp_condition_result_4 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_2;
        }
        else
        {
            goto condexpr_false_2;
        }
        condexpr_true_2:;
        CHECK_OBJECT( tmp_class_creation_2__class_dict );
        tmp_dict_name_4 = tmp_class_creation_2__class_dict;
        tmp_key_name_4 = const_str_plain___metaclass__;
        tmp_assign_source_29 = DICT_GET_ITEM( tmp_dict_name_4, tmp_key_name_4 );
        if ( tmp_assign_source_29 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 125;

            goto try_except_handler_4;
        }
        goto condexpr_end_2;
        condexpr_false_2:;
        tmp_assign_source_29 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_assign_source_29 );
        condexpr_end_2:;
        assert( tmp_class_creation_2__metaclass == NULL );
        tmp_class_creation_2__metaclass = tmp_assign_source_29;
    }
    {
        PyObject *tmp_assign_source_30;
        PyObject *tmp_called_name_2;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_args_element_name_6;
        CHECK_OBJECT( tmp_class_creation_2__metaclass );
        tmp_called_name_2 = tmp_class_creation_2__metaclass;
        tmp_args_element_name_4 = const_str_plain_AddressValueError;
        tmp_args_element_name_5 = const_tuple_type_ValueError_tuple;
        CHECK_OBJECT( tmp_class_creation_2__class_dict );
        tmp_args_element_name_6 = tmp_class_creation_2__class_dict;
        frame_a10b4ee15c0763ecce4ab0022f0f5fa7->m_frame.f_lineno = 125;
        {
            PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5, tmp_args_element_name_6 };
            tmp_assign_source_30 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_2, call_args );
        }

        if ( tmp_assign_source_30 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 125;

            goto try_except_handler_4;
        }
        assert( tmp_class_creation_2__class == NULL );
        tmp_class_creation_2__class = tmp_assign_source_30;
    }
    goto try_end_3;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__class_dict );
    Py_DECREF( tmp_class_creation_2__class_dict );
    tmp_class_creation_2__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_2__metaclass );
    tmp_class_creation_2__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    try_end_3:;
    {
        PyObject *tmp_assign_source_31;
        CHECK_OBJECT( tmp_class_creation_2__class );
        tmp_assign_source_31 = tmp_class_creation_2__class;
        UPDATE_STRING_DICT0( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_AddressValueError, tmp_assign_source_31 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__class );
    Py_DECREF( tmp_class_creation_2__class );
    tmp_class_creation_2__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__class_dict );
    Py_DECREF( tmp_class_creation_2__class_dict );
    tmp_class_creation_2__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__metaclass );
    Py_DECREF( tmp_class_creation_2__metaclass );
    tmp_class_creation_2__metaclass = NULL;

    {
        PyObject *tmp_assign_source_32;
        tmp_assign_source_32 = PyDict_Copy( const_dict_722093ea3cb4d742ab031ea9dda12a84 );
        assert( tmp_class_creation_3__class_dict == NULL );
        tmp_class_creation_3__class_dict = tmp_assign_source_32;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_33;
        nuitka_bool tmp_condition_result_5;
        PyObject *tmp_key_name_5;
        PyObject *tmp_dict_name_5;
        PyObject *tmp_dict_name_6;
        PyObject *tmp_key_name_6;
        tmp_key_name_5 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_3__class_dict );
        tmp_dict_name_5 = tmp_class_creation_3__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_5, tmp_key_name_5 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 129;

            goto try_except_handler_5;
        }
        tmp_condition_result_5 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_3;
        }
        else
        {
            goto condexpr_false_3;
        }
        condexpr_true_3:;
        CHECK_OBJECT( tmp_class_creation_3__class_dict );
        tmp_dict_name_6 = tmp_class_creation_3__class_dict;
        tmp_key_name_6 = const_str_plain___metaclass__;
        tmp_assign_source_33 = DICT_GET_ITEM( tmp_dict_name_6, tmp_key_name_6 );
        if ( tmp_assign_source_33 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 129;

            goto try_except_handler_5;
        }
        goto condexpr_end_3;
        condexpr_false_3:;
        tmp_assign_source_33 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_assign_source_33 );
        condexpr_end_3:;
        assert( tmp_class_creation_3__metaclass == NULL );
        tmp_class_creation_3__metaclass = tmp_assign_source_33;
    }
    {
        PyObject *tmp_assign_source_34;
        PyObject *tmp_called_name_3;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_args_element_name_9;
        CHECK_OBJECT( tmp_class_creation_3__metaclass );
        tmp_called_name_3 = tmp_class_creation_3__metaclass;
        tmp_args_element_name_7 = const_str_plain_NetmaskValueError;
        tmp_args_element_name_8 = const_tuple_type_ValueError_tuple;
        CHECK_OBJECT( tmp_class_creation_3__class_dict );
        tmp_args_element_name_9 = tmp_class_creation_3__class_dict;
        frame_a10b4ee15c0763ecce4ab0022f0f5fa7->m_frame.f_lineno = 129;
        {
            PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8, tmp_args_element_name_9 };
            tmp_assign_source_34 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_3, call_args );
        }

        if ( tmp_assign_source_34 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 129;

            goto try_except_handler_5;
        }
        assert( tmp_class_creation_3__class == NULL );
        tmp_class_creation_3__class = tmp_assign_source_34;
    }
    goto try_end_4;
    // Exception handler code:
    try_except_handler_5:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_3__class_dict );
    Py_DECREF( tmp_class_creation_3__class_dict );
    tmp_class_creation_3__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_3__metaclass );
    tmp_class_creation_3__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto frame_exception_exit_1;
    // End of try:
    try_end_4:;
    {
        PyObject *tmp_assign_source_35;
        CHECK_OBJECT( tmp_class_creation_3__class );
        tmp_assign_source_35 = tmp_class_creation_3__class;
        UPDATE_STRING_DICT0( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_NetmaskValueError, tmp_assign_source_35 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_3__class );
    Py_DECREF( tmp_class_creation_3__class );
    tmp_class_creation_3__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_3__class_dict );
    Py_DECREF( tmp_class_creation_3__class_dict );
    tmp_class_creation_3__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_3__metaclass );
    Py_DECREF( tmp_class_creation_3__metaclass );
    tmp_class_creation_3__metaclass = NULL;

    {
        PyObject *tmp_assign_source_36;
        tmp_assign_source_36 = MAKE_FUNCTION_ipaddress$$$function_13_ip_address(  );



        UPDATE_STRING_DICT1( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_ip_address, tmp_assign_source_36 );
    }
    {
        PyObject *tmp_assign_source_37;
        PyObject *tmp_defaults_2;
        tmp_defaults_2 = const_tuple_true_tuple;
        Py_INCREF( tmp_defaults_2 );
        tmp_assign_source_37 = MAKE_FUNCTION_ipaddress$$$function_14_ip_network( tmp_defaults_2 );



        UPDATE_STRING_DICT1( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_ip_network, tmp_assign_source_37 );
    }
    {
        PyObject *tmp_assign_source_38;
        tmp_assign_source_38 = MAKE_FUNCTION_ipaddress$$$function_15_ip_interface(  );



        UPDATE_STRING_DICT1( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_ip_interface, tmp_assign_source_38 );
    }
    {
        PyObject *tmp_assign_source_39;
        tmp_assign_source_39 = MAKE_FUNCTION_ipaddress$$$function_16_v4_int_to_packed(  );



        UPDATE_STRING_DICT1( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_v4_int_to_packed, tmp_assign_source_39 );
    }
    {
        PyObject *tmp_assign_source_40;
        tmp_assign_source_40 = MAKE_FUNCTION_ipaddress$$$function_17_v6_int_to_packed(  );



        UPDATE_STRING_DICT1( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_v6_int_to_packed, tmp_assign_source_40 );
    }
    {
        PyObject *tmp_assign_source_41;
        tmp_assign_source_41 = MAKE_FUNCTION_ipaddress$$$function_18__split_optional_netmask(  );



        UPDATE_STRING_DICT1( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__split_optional_netmask, tmp_assign_source_41 );
    }
    {
        PyObject *tmp_assign_source_42;
        tmp_assign_source_42 = MAKE_FUNCTION_ipaddress$$$function_19__find_address_range(  );



        UPDATE_STRING_DICT1( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__find_address_range, tmp_assign_source_42 );
    }
    {
        PyObject *tmp_assign_source_43;
        tmp_assign_source_43 = MAKE_FUNCTION_ipaddress$$$function_20__count_righthand_zero_bits(  );



        UPDATE_STRING_DICT1( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__count_righthand_zero_bits, tmp_assign_source_43 );
    }
    {
        PyObject *tmp_assign_source_44;
        tmp_assign_source_44 = MAKE_FUNCTION_ipaddress$$$function_21_summarize_address_range(  );



        UPDATE_STRING_DICT1( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_summarize_address_range, tmp_assign_source_44 );
    }
    {
        PyObject *tmp_assign_source_45;
        tmp_assign_source_45 = MAKE_FUNCTION_ipaddress$$$function_22__collapse_addresses_internal(  );



        UPDATE_STRING_DICT1( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__collapse_addresses_internal, tmp_assign_source_45 );
    }
    {
        PyObject *tmp_assign_source_46;
        tmp_assign_source_46 = MAKE_FUNCTION_ipaddress$$$function_23_collapse_addresses(  );



        UPDATE_STRING_DICT1( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_collapse_addresses, tmp_assign_source_46 );
    }
    {
        PyObject *tmp_assign_source_47;
        tmp_assign_source_47 = MAKE_FUNCTION_ipaddress$$$function_24_get_mixed_type_key(  );



        UPDATE_STRING_DICT1( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_get_mixed_type_key, tmp_assign_source_47 );
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_48;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__TotalOrderingMixin );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__TotalOrderingMixin );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_TotalOrderingMixin" );
            exception_tb = NULL;

            exception_lineno = 503;

            goto try_except_handler_6;
        }

        tmp_tuple_element_1 = tmp_mvar_value_1;
        tmp_assign_source_48 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_assign_source_48, 0, tmp_tuple_element_1 );
        assert( tmp_class_creation_4__bases == NULL );
        tmp_class_creation_4__bases = tmp_assign_source_48;
    }
    {
        PyObject *tmp_assign_source_49;
        {
            PyObject *tmp_set_locals_1;
            tmp_set_locals_1 = PyDict_New();
            locals_ipaddress_503 = tmp_set_locals_1;
        }
        tmp_dictset_value = const_str_plain_ipaddress;
        tmp_res = PyDict_SetItem( locals_ipaddress_503, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_unicode_digest_23a8e74f4b615fbfc9e5a160a861c61a;
        tmp_res = PyDict_SetItem( locals_ipaddress_503, const_str_plain___doc__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_tuple_empty;
        tmp_res = PyDict_SetItem( locals_ipaddress_503, const_str_plain___slots__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        MAKE_OR_REUSE_FRAME( cache_frame_dbc69dab8fd6a224013718cb1cbf5cd4_2, codeobj_dbc69dab8fd6a224013718cb1cbf5cd4, module_ipaddress, 0 );
        frame_dbc69dab8fd6a224013718cb1cbf5cd4_2 = cache_frame_dbc69dab8fd6a224013718cb1cbf5cd4_2;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_dbc69dab8fd6a224013718cb1cbf5cd4_2 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_dbc69dab8fd6a224013718cb1cbf5cd4_2 ) == 2 ); // Frame stack

        // Framed code:
        {
            PyObject *tmp_called_name_4;
            PyObject *tmp_args_element_name_10;
            tmp_called_name_4 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_10 = MAKE_FUNCTION_ipaddress$$$function_25_exploded(  );



            frame_dbc69dab8fd6a224013718cb1cbf5cd4_2->m_frame.f_lineno = 509;
            {
                PyObject *call_args[] = { tmp_args_element_name_10 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
            }

            Py_DECREF( tmp_args_element_name_10 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 509;

                goto frame_exception_exit_2;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_503, const_str_plain_exploded, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 509;

                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_called_name_5;
            PyObject *tmp_args_element_name_11;
            tmp_called_name_5 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_11 = MAKE_FUNCTION_ipaddress$$$function_26_compressed(  );



            frame_dbc69dab8fd6a224013718cb1cbf5cd4_2->m_frame.f_lineno = 514;
            {
                PyObject *call_args[] = { tmp_args_element_name_11 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
            }

            Py_DECREF( tmp_args_element_name_11 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 514;

                goto frame_exception_exit_2;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_503, const_str_plain_compressed, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 514;

                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_called_name_6;
            PyObject *tmp_args_element_name_12;
            tmp_called_name_6 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_12 = MAKE_FUNCTION_ipaddress$$$function_27_reverse_pointer(  );



            frame_dbc69dab8fd6a224013718cb1cbf5cd4_2->m_frame.f_lineno = 519;
            {
                PyObject *call_args[] = { tmp_args_element_name_12 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, call_args );
            }

            Py_DECREF( tmp_args_element_name_12 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 519;

                goto frame_exception_exit_2;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_503, const_str_plain_reverse_pointer, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 519;

                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_called_name_7;
            PyObject *tmp_args_element_name_13;
            tmp_called_name_7 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_13 = MAKE_FUNCTION_ipaddress$$$function_28_version(  );



            frame_dbc69dab8fd6a224013718cb1cbf5cd4_2->m_frame.f_lineno = 530;
            {
                PyObject *call_args[] = { tmp_args_element_name_13 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_7, call_args );
            }

            Py_DECREF( tmp_args_element_name_13 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 530;

                goto frame_exception_exit_2;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_503, const_str_plain_version, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 530;

                goto frame_exception_exit_2;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_29__check_int_address(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_503, const_str_plain__check_int_address, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_30__check_packed_address(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_503, const_str_plain__check_packed_address, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_classmethod_arg_1;
            tmp_classmethod_arg_1 = MAKE_FUNCTION_ipaddress$$$function_31__ip_int_from_prefix(  );



            tmp_dictset_value = BUILTIN_CLASSMETHOD( tmp_classmethod_arg_1 );
            Py_DECREF( tmp_classmethod_arg_1 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 555;

                goto frame_exception_exit_2;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_503, const_str_plain__ip_int_from_prefix, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 555;

                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_classmethod_arg_2;
            tmp_classmethod_arg_2 = MAKE_FUNCTION_ipaddress$$$function_32__prefix_from_ip_int(  );



            tmp_dictset_value = BUILTIN_CLASSMETHOD( tmp_classmethod_arg_2 );
            Py_DECREF( tmp_classmethod_arg_2 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 568;

                goto frame_exception_exit_2;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_503, const_str_plain__prefix_from_ip_int, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 568;

                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_classmethod_arg_3;
            tmp_classmethod_arg_3 = MAKE_FUNCTION_ipaddress$$$function_33__report_invalid_netmask(  );



            tmp_dictset_value = BUILTIN_CLASSMETHOD( tmp_classmethod_arg_3 );
            Py_DECREF( tmp_classmethod_arg_3 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 593;

                goto frame_exception_exit_2;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_503, const_str_plain__report_invalid_netmask, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 593;

                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_classmethod_arg_4;
            tmp_classmethod_arg_4 = MAKE_FUNCTION_ipaddress$$$function_34__prefix_from_prefix_string(  );



            tmp_dictset_value = BUILTIN_CLASSMETHOD( tmp_classmethod_arg_4 );
            Py_DECREF( tmp_classmethod_arg_4 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 598;

                goto frame_exception_exit_2;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_503, const_str_plain__prefix_from_prefix_string, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 598;

                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_classmethod_arg_5;
            tmp_classmethod_arg_5 = MAKE_FUNCTION_ipaddress$$$function_35__prefix_from_ip_string(  );



            tmp_dictset_value = BUILTIN_CLASSMETHOD( tmp_classmethod_arg_5 );
            Py_DECREF( tmp_classmethod_arg_5 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 623;

                goto frame_exception_exit_2;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_503, const_str_plain__prefix_from_ip_string, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 623;

                goto frame_exception_exit_2;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_dbc69dab8fd6a224013718cb1cbf5cd4_2 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_1;

        frame_exception_exit_2:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_dbc69dab8fd6a224013718cb1cbf5cd4_2 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_dbc69dab8fd6a224013718cb1cbf5cd4_2, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_dbc69dab8fd6a224013718cb1cbf5cd4_2->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_dbc69dab8fd6a224013718cb1cbf5cd4_2, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_dbc69dab8fd6a224013718cb1cbf5cd4_2,
            type_description_2
        );


        // Release cached frame.
        if ( frame_dbc69dab8fd6a224013718cb1cbf5cd4_2 == cache_frame_dbc69dab8fd6a224013718cb1cbf5cd4_2 )
        {
            Py_DECREF( frame_dbc69dab8fd6a224013718cb1cbf5cd4_2 );
        }
        cache_frame_dbc69dab8fd6a224013718cb1cbf5cd4_2 = NULL;

        assertFrameObject( frame_dbc69dab8fd6a224013718cb1cbf5cd4_2 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_1;

        frame_no_exception_1:;
        goto skip_nested_handling_1;
        nested_frame_exit_1:;

        goto try_except_handler_7;
        skip_nested_handling_1:;
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_36___reduce__(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_503, const_str_plain___reduce__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_assign_source_49 = locals_ipaddress_503;
        Py_INCREF( tmp_assign_source_49 );
        goto try_return_handler_7;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_7:;
        Py_DECREF( locals_ipaddress_503 );
        locals_ipaddress_503 = NULL;
        goto outline_result_2;
        // Exception handler code:
        try_except_handler_7:;
        exception_keeper_type_5 = exception_type;
        exception_keeper_value_5 = exception_value;
        exception_keeper_tb_5 = exception_tb;
        exception_keeper_lineno_5 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_ipaddress_503 );
        locals_ipaddress_503 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_5;
        exception_value = exception_keeper_value_5;
        exception_tb = exception_keeper_tb_5;
        exception_lineno = exception_keeper_lineno_5;

        goto outline_exception_1;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_1:;
        exception_lineno = 503;
        goto try_except_handler_6;
        outline_result_2:;
        assert( tmp_class_creation_4__class_dict == NULL );
        tmp_class_creation_4__class_dict = tmp_assign_source_49;
    }
    {
        PyObject *tmp_assign_source_50;
        nuitka_bool tmp_condition_result_6;
        PyObject *tmp_key_name_7;
        PyObject *tmp_dict_name_7;
        PyObject *tmp_dict_name_8;
        PyObject *tmp_key_name_8;
        tmp_key_name_7 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_4__class_dict );
        tmp_dict_name_7 = tmp_class_creation_4__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_7, tmp_key_name_7 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 503;

            goto try_except_handler_6;
        }
        tmp_condition_result_6 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_6 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_4;
        }
        else
        {
            goto condexpr_false_4;
        }
        condexpr_true_4:;
        CHECK_OBJECT( tmp_class_creation_4__class_dict );
        tmp_dict_name_8 = tmp_class_creation_4__class_dict;
        tmp_key_name_8 = const_str_plain___metaclass__;
        tmp_assign_source_50 = DICT_GET_ITEM( tmp_dict_name_8, tmp_key_name_8 );
        if ( tmp_assign_source_50 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 503;

            goto try_except_handler_6;
        }
        goto condexpr_end_4;
        condexpr_false_4:;
        {
            PyObject *tmp_assign_source_51;
            PyObject *tmp_subscribed_name_1;
            PyObject *tmp_subscript_name_1;
            CHECK_OBJECT( tmp_class_creation_4__bases );
            tmp_subscribed_name_1 = tmp_class_creation_4__bases;
            tmp_subscript_name_1 = const_int_0;
            tmp_assign_source_51 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_1, tmp_subscript_name_1, 0 );
            if ( tmp_assign_source_51 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 503;

                goto try_except_handler_6;
            }
            assert( tmp_select_metaclass_4__base == NULL );
            tmp_select_metaclass_4__base = tmp_assign_source_51;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_2;
            CHECK_OBJECT( tmp_select_metaclass_4__base );
            tmp_source_name_2 = tmp_select_metaclass_4__base;
            tmp_assign_source_50 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_2 );
            if ( tmp_assign_source_50 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 503;

                goto try_except_handler_9;
            }
            goto try_return_handler_8;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        // Exception handler code:
        try_except_handler_9:;
        exception_keeper_type_6 = exception_type;
        exception_keeper_value_6 = exception_value;
        exception_keeper_tb_6 = exception_tb;
        exception_keeper_lineno_6 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_1;
            Py_DECREF( exception_keeper_type_6 );
            Py_XDECREF( exception_keeper_value_6 );
            Py_XDECREF( exception_keeper_tb_6 );
            CHECK_OBJECT( tmp_select_metaclass_4__base );
            tmp_type_arg_1 = tmp_select_metaclass_4__base;
            tmp_assign_source_50 = BUILTIN_TYPE1( tmp_type_arg_1 );
            assert( !(tmp_assign_source_50 == NULL) );
            goto try_return_handler_8;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_8:;
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_4__base );
        Py_DECREF( tmp_select_metaclass_4__base );
        tmp_select_metaclass_4__base = NULL;

        goto outline_result_3;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_4__base );
        Py_DECREF( tmp_select_metaclass_4__base );
        tmp_select_metaclass_4__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        outline_result_3:;
        condexpr_end_4:;
        assert( tmp_class_creation_4__metaclass == NULL );
        tmp_class_creation_4__metaclass = tmp_assign_source_50;
    }
    {
        PyObject *tmp_assign_source_52;
        PyObject *tmp_called_name_8;
        PyObject *tmp_args_element_name_14;
        PyObject *tmp_args_element_name_15;
        PyObject *tmp_args_element_name_16;
        CHECK_OBJECT( tmp_class_creation_4__metaclass );
        tmp_called_name_8 = tmp_class_creation_4__metaclass;
        tmp_args_element_name_14 = const_str_plain__IPAddressBase;
        CHECK_OBJECT( tmp_class_creation_4__bases );
        tmp_args_element_name_15 = tmp_class_creation_4__bases;
        CHECK_OBJECT( tmp_class_creation_4__class_dict );
        tmp_args_element_name_16 = tmp_class_creation_4__class_dict;
        frame_a10b4ee15c0763ecce4ab0022f0f5fa7->m_frame.f_lineno = 503;
        {
            PyObject *call_args[] = { tmp_args_element_name_14, tmp_args_element_name_15, tmp_args_element_name_16 };
            tmp_assign_source_52 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_8, call_args );
        }

        if ( tmp_assign_source_52 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 503;

            goto try_except_handler_6;
        }
        assert( tmp_class_creation_4__class == NULL );
        tmp_class_creation_4__class = tmp_assign_source_52;
    }
    goto try_end_5;
    // Exception handler code:
    try_except_handler_6:;
    exception_keeper_type_7 = exception_type;
    exception_keeper_value_7 = exception_value;
    exception_keeper_tb_7 = exception_tb;
    exception_keeper_lineno_7 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_4__bases );
    tmp_class_creation_4__bases = NULL;

    Py_XDECREF( tmp_class_creation_4__class_dict );
    tmp_class_creation_4__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_4__metaclass );
    tmp_class_creation_4__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_7;
    exception_value = exception_keeper_value_7;
    exception_tb = exception_keeper_tb_7;
    exception_lineno = exception_keeper_lineno_7;

    goto frame_exception_exit_1;
    // End of try:
    try_end_5:;
    {
        PyObject *tmp_assign_source_53;
        CHECK_OBJECT( tmp_class_creation_4__class );
        tmp_assign_source_53 = tmp_class_creation_4__class;
        UPDATE_STRING_DICT0( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__IPAddressBase, tmp_assign_source_53 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_4__class );
    Py_DECREF( tmp_class_creation_4__class );
    tmp_class_creation_4__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_4__bases );
    Py_DECREF( tmp_class_creation_4__bases );
    tmp_class_creation_4__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_4__class_dict );
    Py_DECREF( tmp_class_creation_4__class_dict );
    tmp_class_creation_4__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_4__metaclass );
    Py_DECREF( tmp_class_creation_4__metaclass );
    tmp_class_creation_4__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_54;
        PyObject *tmp_tuple_element_2;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__IPAddressBase );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__IPAddressBase );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_IPAddressBase" );
            exception_tb = NULL;

            exception_lineno = 661;

            goto try_except_handler_10;
        }

        tmp_tuple_element_2 = tmp_mvar_value_2;
        tmp_assign_source_54 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_2 );
        PyTuple_SET_ITEM( tmp_assign_source_54, 0, tmp_tuple_element_2 );
        assert( tmp_class_creation_5__bases == NULL );
        tmp_class_creation_5__bases = tmp_assign_source_54;
    }
    {
        PyObject *tmp_assign_source_55;
        {
            PyObject *tmp_set_locals_2;
            tmp_set_locals_2 = PyDict_New();
            locals_ipaddress_661 = tmp_set_locals_2;
        }
        tmp_dictset_value = const_str_plain_ipaddress;
        tmp_res = PyDict_SetItem( locals_ipaddress_661, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_unicode_digest_04311a35f70305eb6ef19122d29249c2;
        tmp_res = PyDict_SetItem( locals_ipaddress_661, const_str_plain___doc__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_tuple_empty;
        tmp_res = PyDict_SetItem( locals_ipaddress_661, const_str_plain___slots__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_37___int__(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_661, const_str_plain___int__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_38___eq__(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_661, const_str_plain___eq__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_39___lt__(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_661, const_str_plain___lt__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_40___add__(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_661, const_str_plain___add__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_41___sub__(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_661, const_str_plain___sub__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_42___repr__(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_661, const_str_plain___repr__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_43___str__(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_661, const_str_plain___str__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_44___hash__(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_661, const_str_plain___hash__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_45__get_address_key(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_661, const_str_plain__get_address_key, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_46___reduce__(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_661, const_str_plain___reduce__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        tmp_assign_source_55 = locals_ipaddress_661;
        Py_INCREF( tmp_assign_source_55 );
        goto try_return_handler_11;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_11:;
        Py_DECREF( locals_ipaddress_661 );
        locals_ipaddress_661 = NULL;
        goto outline_result_4;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        outline_result_4:;
        assert( tmp_class_creation_5__class_dict == NULL );
        tmp_class_creation_5__class_dict = tmp_assign_source_55;
    }
    {
        PyObject *tmp_assign_source_56;
        nuitka_bool tmp_condition_result_7;
        PyObject *tmp_key_name_9;
        PyObject *tmp_dict_name_9;
        PyObject *tmp_dict_name_10;
        PyObject *tmp_key_name_10;
        tmp_key_name_9 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_5__class_dict );
        tmp_dict_name_9 = tmp_class_creation_5__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_9, tmp_key_name_9 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 661;

            goto try_except_handler_10;
        }
        tmp_condition_result_7 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_7 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_5;
        }
        else
        {
            goto condexpr_false_5;
        }
        condexpr_true_5:;
        CHECK_OBJECT( tmp_class_creation_5__class_dict );
        tmp_dict_name_10 = tmp_class_creation_5__class_dict;
        tmp_key_name_10 = const_str_plain___metaclass__;
        tmp_assign_source_56 = DICT_GET_ITEM( tmp_dict_name_10, tmp_key_name_10 );
        if ( tmp_assign_source_56 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 661;

            goto try_except_handler_10;
        }
        goto condexpr_end_5;
        condexpr_false_5:;
        {
            PyObject *tmp_assign_source_57;
            PyObject *tmp_subscribed_name_2;
            PyObject *tmp_subscript_name_2;
            CHECK_OBJECT( tmp_class_creation_5__bases );
            tmp_subscribed_name_2 = tmp_class_creation_5__bases;
            tmp_subscript_name_2 = const_int_0;
            tmp_assign_source_57 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_2, tmp_subscript_name_2, 0 );
            if ( tmp_assign_source_57 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 661;

                goto try_except_handler_10;
            }
            assert( tmp_select_metaclass_5__base == NULL );
            tmp_select_metaclass_5__base = tmp_assign_source_57;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_3;
            CHECK_OBJECT( tmp_select_metaclass_5__base );
            tmp_source_name_3 = tmp_select_metaclass_5__base;
            tmp_assign_source_56 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_3 );
            if ( tmp_assign_source_56 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 661;

                goto try_except_handler_13;
            }
            goto try_return_handler_12;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        // Exception handler code:
        try_except_handler_13:;
        exception_keeper_type_8 = exception_type;
        exception_keeper_value_8 = exception_value;
        exception_keeper_tb_8 = exception_tb;
        exception_keeper_lineno_8 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_2;
            Py_DECREF( exception_keeper_type_8 );
            Py_XDECREF( exception_keeper_value_8 );
            Py_XDECREF( exception_keeper_tb_8 );
            CHECK_OBJECT( tmp_select_metaclass_5__base );
            tmp_type_arg_2 = tmp_select_metaclass_5__base;
            tmp_assign_source_56 = BUILTIN_TYPE1( tmp_type_arg_2 );
            assert( !(tmp_assign_source_56 == NULL) );
            goto try_return_handler_12;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_12:;
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_5__base );
        Py_DECREF( tmp_select_metaclass_5__base );
        tmp_select_metaclass_5__base = NULL;

        goto outline_result_5;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_5__base );
        Py_DECREF( tmp_select_metaclass_5__base );
        tmp_select_metaclass_5__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        outline_result_5:;
        condexpr_end_5:;
        assert( tmp_class_creation_5__metaclass == NULL );
        tmp_class_creation_5__metaclass = tmp_assign_source_56;
    }
    {
        PyObject *tmp_assign_source_58;
        PyObject *tmp_called_name_9;
        PyObject *tmp_args_element_name_17;
        PyObject *tmp_args_element_name_18;
        PyObject *tmp_args_element_name_19;
        CHECK_OBJECT( tmp_class_creation_5__metaclass );
        tmp_called_name_9 = tmp_class_creation_5__metaclass;
        tmp_args_element_name_17 = const_str_plain__BaseAddress;
        CHECK_OBJECT( tmp_class_creation_5__bases );
        tmp_args_element_name_18 = tmp_class_creation_5__bases;
        CHECK_OBJECT( tmp_class_creation_5__class_dict );
        tmp_args_element_name_19 = tmp_class_creation_5__class_dict;
        frame_a10b4ee15c0763ecce4ab0022f0f5fa7->m_frame.f_lineno = 661;
        {
            PyObject *call_args[] = { tmp_args_element_name_17, tmp_args_element_name_18, tmp_args_element_name_19 };
            tmp_assign_source_58 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_9, call_args );
        }

        if ( tmp_assign_source_58 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 661;

            goto try_except_handler_10;
        }
        assert( tmp_class_creation_5__class == NULL );
        tmp_class_creation_5__class = tmp_assign_source_58;
    }
    goto try_end_6;
    // Exception handler code:
    try_except_handler_10:;
    exception_keeper_type_9 = exception_type;
    exception_keeper_value_9 = exception_value;
    exception_keeper_tb_9 = exception_tb;
    exception_keeper_lineno_9 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_5__bases );
    tmp_class_creation_5__bases = NULL;

    Py_XDECREF( tmp_class_creation_5__class_dict );
    tmp_class_creation_5__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_5__metaclass );
    tmp_class_creation_5__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_9;
    exception_value = exception_keeper_value_9;
    exception_tb = exception_keeper_tb_9;
    exception_lineno = exception_keeper_lineno_9;

    goto frame_exception_exit_1;
    // End of try:
    try_end_6:;
    {
        PyObject *tmp_assign_source_59;
        CHECK_OBJECT( tmp_class_creation_5__class );
        tmp_assign_source_59 = tmp_class_creation_5__class;
        UPDATE_STRING_DICT0( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__BaseAddress, tmp_assign_source_59 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_5__class );
    Py_DECREF( tmp_class_creation_5__class );
    tmp_class_creation_5__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_5__bases );
    Py_DECREF( tmp_class_creation_5__bases );
    tmp_class_creation_5__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_5__class_dict );
    Py_DECREF( tmp_class_creation_5__class_dict );
    tmp_class_creation_5__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_5__metaclass );
    Py_DECREF( tmp_class_creation_5__metaclass );
    tmp_class_creation_5__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_60;
        PyObject *tmp_tuple_element_3;
        PyObject *tmp_mvar_value_3;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__IPAddressBase );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__IPAddressBase );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_IPAddressBase" );
            exception_tb = NULL;

            exception_lineno = 722;

            goto try_except_handler_14;
        }

        tmp_tuple_element_3 = tmp_mvar_value_3;
        tmp_assign_source_60 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_3 );
        PyTuple_SET_ITEM( tmp_assign_source_60, 0, tmp_tuple_element_3 );
        assert( tmp_class_creation_6__bases == NULL );
        tmp_class_creation_6__bases = tmp_assign_source_60;
    }
    {
        PyObject *tmp_assign_source_61;
        {
            PyObject *tmp_set_locals_3;
            tmp_set_locals_3 = PyDict_New();
            locals_ipaddress_722 = tmp_set_locals_3;
        }
        tmp_dictset_value = const_str_plain_ipaddress;
        tmp_res = PyDict_SetItem( locals_ipaddress_722, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_unicode_digest_187d30b5b2f1b6be67346bce62c4882f;
        tmp_res = PyDict_SetItem( locals_ipaddress_722, const_str_plain___doc__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_47___init__(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_722, const_str_plain___init__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_48___repr__(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_722, const_str_plain___repr__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_49___str__(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_722, const_str_plain___str__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_50_hosts(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_722, const_str_plain_hosts, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_51___iter__(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_722, const_str_plain___iter__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_52___getitem__(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_722, const_str_plain___getitem__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_53___lt__(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_722, const_str_plain___lt__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_54___eq__(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_722, const_str_plain___eq__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_55___hash__(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_722, const_str_plain___hash__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_56___contains__(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_722, const_str_plain___contains__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_57_overlaps(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_722, const_str_plain_overlaps, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        MAKE_OR_REUSE_FRAME( cache_frame_039fb0cc98fcd1d5734f80fb0973e949_3, codeobj_039fb0cc98fcd1d5734f80fb0973e949, module_ipaddress, 0 );
        frame_039fb0cc98fcd1d5734f80fb0973e949_3 = cache_frame_039fb0cc98fcd1d5734f80fb0973e949_3;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_039fb0cc98fcd1d5734f80fb0973e949_3 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_039fb0cc98fcd1d5734f80fb0973e949_3 ) == 2 ); // Frame stack

        // Framed code:
        {
            PyObject *tmp_called_name_10;
            PyObject *tmp_args_element_name_20;
            tmp_called_name_10 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_20 = MAKE_FUNCTION_ipaddress$$$function_58_broadcast_address(  );



            frame_039fb0cc98fcd1d5734f80fb0973e949_3->m_frame.f_lineno = 816;
            {
                PyObject *call_args[] = { tmp_args_element_name_20 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_10, call_args );
            }

            Py_DECREF( tmp_args_element_name_20 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 816;

                goto frame_exception_exit_3;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_722, const_str_plain_broadcast_address, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 816;

                goto frame_exception_exit_3;
            }
        }
        {
            PyObject *tmp_called_name_11;
            PyObject *tmp_args_element_name_21;
            tmp_called_name_11 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_21 = MAKE_FUNCTION_ipaddress$$$function_59_hostmask(  );



            frame_039fb0cc98fcd1d5734f80fb0973e949_3->m_frame.f_lineno = 825;
            {
                PyObject *call_args[] = { tmp_args_element_name_21 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_11, call_args );
            }

            Py_DECREF( tmp_args_element_name_21 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 825;

                goto frame_exception_exit_3;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_722, const_str_plain_hostmask, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 825;

                goto frame_exception_exit_3;
            }
        }
        {
            PyObject *tmp_called_name_12;
            PyObject *tmp_args_element_name_22;
            tmp_called_name_12 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_22 = MAKE_FUNCTION_ipaddress$$$function_60_with_prefixlen(  );



            frame_039fb0cc98fcd1d5734f80fb0973e949_3->m_frame.f_lineno = 833;
            {
                PyObject *call_args[] = { tmp_args_element_name_22 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_12, call_args );
            }

            Py_DECREF( tmp_args_element_name_22 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 833;

                goto frame_exception_exit_3;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_722, const_str_plain_with_prefixlen, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 833;

                goto frame_exception_exit_3;
            }
        }
        {
            PyObject *tmp_called_name_13;
            PyObject *tmp_args_element_name_23;
            tmp_called_name_13 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_23 = MAKE_FUNCTION_ipaddress$$$function_61_with_netmask(  );



            frame_039fb0cc98fcd1d5734f80fb0973e949_3->m_frame.f_lineno = 837;
            {
                PyObject *call_args[] = { tmp_args_element_name_23 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_13, call_args );
            }

            Py_DECREF( tmp_args_element_name_23 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 837;

                goto frame_exception_exit_3;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_722, const_str_plain_with_netmask, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 837;

                goto frame_exception_exit_3;
            }
        }
        {
            PyObject *tmp_called_name_14;
            PyObject *tmp_args_element_name_24;
            tmp_called_name_14 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_24 = MAKE_FUNCTION_ipaddress$$$function_62_with_hostmask(  );



            frame_039fb0cc98fcd1d5734f80fb0973e949_3->m_frame.f_lineno = 841;
            {
                PyObject *call_args[] = { tmp_args_element_name_24 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_14, call_args );
            }

            Py_DECREF( tmp_args_element_name_24 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 841;

                goto frame_exception_exit_3;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_722, const_str_plain_with_hostmask, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 841;

                goto frame_exception_exit_3;
            }
        }
        {
            PyObject *tmp_called_name_15;
            PyObject *tmp_args_element_name_25;
            tmp_called_name_15 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_25 = MAKE_FUNCTION_ipaddress$$$function_63_num_addresses(  );



            frame_039fb0cc98fcd1d5734f80fb0973e949_3->m_frame.f_lineno = 845;
            {
                PyObject *call_args[] = { tmp_args_element_name_25 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_15, call_args );
            }

            Py_DECREF( tmp_args_element_name_25 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 845;

                goto frame_exception_exit_3;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_722, const_str_plain_num_addresses, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 845;

                goto frame_exception_exit_3;
            }
        }
        {
            PyObject *tmp_called_name_16;
            PyObject *tmp_args_element_name_26;
            tmp_called_name_16 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_26 = MAKE_FUNCTION_ipaddress$$$function_64__address_class(  );



            frame_039fb0cc98fcd1d5734f80fb0973e949_3->m_frame.f_lineno = 850;
            {
                PyObject *call_args[] = { tmp_args_element_name_26 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_16, call_args );
            }

            Py_DECREF( tmp_args_element_name_26 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 850;

                goto frame_exception_exit_3;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_722, const_str_plain__address_class, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 850;

                goto frame_exception_exit_3;
            }
        }
        {
            PyObject *tmp_called_name_17;
            PyObject *tmp_args_element_name_27;
            tmp_called_name_17 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_27 = MAKE_FUNCTION_ipaddress$$$function_65_prefixlen(  );



            frame_039fb0cc98fcd1d5734f80fb0973e949_3->m_frame.f_lineno = 858;
            {
                PyObject *call_args[] = { tmp_args_element_name_27 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_17, call_args );
            }

            Py_DECREF( tmp_args_element_name_27 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 858;

                goto frame_exception_exit_3;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_722, const_str_plain_prefixlen, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 858;

                goto frame_exception_exit_3;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_66_address_exclude(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_722, const_str_plain_address_exclude, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_67_compare_networks(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_722, const_str_plain_compare_networks, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_68__get_networks_key(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_722, const_str_plain__get_networks_key, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_defaults_3;
            tmp_defaults_3 = const_tuple_int_pos_1_none_tuple;
            Py_INCREF( tmp_defaults_3 );
            tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_69_subnets( tmp_defaults_3 );



            tmp_res = PyDict_SetItem( locals_ipaddress_722, const_str_plain_subnets, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            assert( !(tmp_res != 0) );
        }
        {
            PyObject *tmp_defaults_4;
            tmp_defaults_4 = const_tuple_int_pos_1_none_tuple;
            Py_INCREF( tmp_defaults_4 );
            tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_70_supernet( tmp_defaults_4 );



            tmp_res = PyDict_SetItem( locals_ipaddress_722, const_str_plain_supernet, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            assert( !(tmp_res != 0) );
        }
        {
            PyObject *tmp_called_name_18;
            PyObject *tmp_args_element_name_28;
            tmp_called_name_18 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_28 = MAKE_FUNCTION_ipaddress$$$function_71_is_multicast(  );



            frame_039fb0cc98fcd1d5734f80fb0973e949_3->m_frame.f_lineno = 1089;
            {
                PyObject *call_args[] = { tmp_args_element_name_28 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_18, call_args );
            }

            Py_DECREF( tmp_args_element_name_28 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1089;

                goto frame_exception_exit_3;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_722, const_str_plain_is_multicast, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1089;

                goto frame_exception_exit_3;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_72_subnet_of(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_722, const_str_plain_subnet_of, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_73_supernet_of(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_722, const_str_plain_supernet_of, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_called_name_19;
            PyObject *tmp_args_element_name_29;
            tmp_called_name_19 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_29 = MAKE_FUNCTION_ipaddress$$$function_74_is_reserved(  );



            frame_039fb0cc98fcd1d5734f80fb0973e949_3->m_frame.f_lineno = 1129;
            {
                PyObject *call_args[] = { tmp_args_element_name_29 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_19, call_args );
            }

            Py_DECREF( tmp_args_element_name_29 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1129;

                goto frame_exception_exit_3;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_722, const_str_plain_is_reserved, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1129;

                goto frame_exception_exit_3;
            }
        }
        {
            PyObject *tmp_called_name_20;
            PyObject *tmp_args_element_name_30;
            tmp_called_name_20 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_30 = MAKE_FUNCTION_ipaddress$$$function_75_is_link_local(  );



            frame_039fb0cc98fcd1d5734f80fb0973e949_3->m_frame.f_lineno = 1141;
            {
                PyObject *call_args[] = { tmp_args_element_name_30 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_20, call_args );
            }

            Py_DECREF( tmp_args_element_name_30 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1141;

                goto frame_exception_exit_3;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_722, const_str_plain_is_link_local, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1141;

                goto frame_exception_exit_3;
            }
        }
        {
            PyObject *tmp_called_name_21;
            PyObject *tmp_args_element_name_31;
            tmp_called_name_21 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_31 = MAKE_FUNCTION_ipaddress$$$function_76_is_private(  );



            frame_039fb0cc98fcd1d5734f80fb0973e949_3->m_frame.f_lineno = 1152;
            {
                PyObject *call_args[] = { tmp_args_element_name_31 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_21, call_args );
            }

            Py_DECREF( tmp_args_element_name_31 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1152;

                goto frame_exception_exit_3;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_722, const_str_plain_is_private, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1152;

                goto frame_exception_exit_3;
            }
        }
        {
            PyObject *tmp_called_name_22;
            PyObject *tmp_args_element_name_32;
            tmp_called_name_22 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_32 = MAKE_FUNCTION_ipaddress$$$function_77_is_global(  );



            frame_039fb0cc98fcd1d5734f80fb0973e949_3->m_frame.f_lineno = 1164;
            {
                PyObject *call_args[] = { tmp_args_element_name_32 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_22, call_args );
            }

            Py_DECREF( tmp_args_element_name_32 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1164;

                goto frame_exception_exit_3;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_722, const_str_plain_is_global, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1164;

                goto frame_exception_exit_3;
            }
        }
        {
            PyObject *tmp_called_name_23;
            PyObject *tmp_args_element_name_33;
            tmp_called_name_23 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_33 = MAKE_FUNCTION_ipaddress$$$function_78_is_unspecified(  );



            frame_039fb0cc98fcd1d5734f80fb0973e949_3->m_frame.f_lineno = 1175;
            {
                PyObject *call_args[] = { tmp_args_element_name_33 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_23, call_args );
            }

            Py_DECREF( tmp_args_element_name_33 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1175;

                goto frame_exception_exit_3;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_722, const_str_plain_is_unspecified, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1175;

                goto frame_exception_exit_3;
            }
        }
        {
            PyObject *tmp_called_name_24;
            PyObject *tmp_args_element_name_34;
            tmp_called_name_24 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_34 = MAKE_FUNCTION_ipaddress$$$function_79_is_loopback(  );



            frame_039fb0cc98fcd1d5734f80fb0973e949_3->m_frame.f_lineno = 1187;
            {
                PyObject *call_args[] = { tmp_args_element_name_34 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_24, call_args );
            }

            Py_DECREF( tmp_args_element_name_34 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1187;

                goto frame_exception_exit_3;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_722, const_str_plain_is_loopback, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1187;

                goto frame_exception_exit_3;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_039fb0cc98fcd1d5734f80fb0973e949_3 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_2;

        frame_exception_exit_3:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_039fb0cc98fcd1d5734f80fb0973e949_3 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_039fb0cc98fcd1d5734f80fb0973e949_3, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_039fb0cc98fcd1d5734f80fb0973e949_3->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_039fb0cc98fcd1d5734f80fb0973e949_3, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_039fb0cc98fcd1d5734f80fb0973e949_3,
            type_description_2
        );


        // Release cached frame.
        if ( frame_039fb0cc98fcd1d5734f80fb0973e949_3 == cache_frame_039fb0cc98fcd1d5734f80fb0973e949_3 )
        {
            Py_DECREF( frame_039fb0cc98fcd1d5734f80fb0973e949_3 );
        }
        cache_frame_039fb0cc98fcd1d5734f80fb0973e949_3 = NULL;

        assertFrameObject( frame_039fb0cc98fcd1d5734f80fb0973e949_3 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_2;

        frame_no_exception_2:;
        goto skip_nested_handling_2;
        nested_frame_exit_2:;

        goto try_except_handler_15;
        skip_nested_handling_2:;
        tmp_assign_source_61 = locals_ipaddress_722;
        Py_INCREF( tmp_assign_source_61 );
        goto try_return_handler_15;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_15:;
        Py_DECREF( locals_ipaddress_722 );
        locals_ipaddress_722 = NULL;
        goto outline_result_6;
        // Exception handler code:
        try_except_handler_15:;
        exception_keeper_type_10 = exception_type;
        exception_keeper_value_10 = exception_value;
        exception_keeper_tb_10 = exception_tb;
        exception_keeper_lineno_10 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_ipaddress_722 );
        locals_ipaddress_722 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_10;
        exception_value = exception_keeper_value_10;
        exception_tb = exception_keeper_tb_10;
        exception_lineno = exception_keeper_lineno_10;

        goto outline_exception_2;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_2:;
        exception_lineno = 722;
        goto try_except_handler_14;
        outline_result_6:;
        assert( tmp_class_creation_6__class_dict == NULL );
        tmp_class_creation_6__class_dict = tmp_assign_source_61;
    }
    {
        PyObject *tmp_assign_source_62;
        nuitka_bool tmp_condition_result_8;
        PyObject *tmp_key_name_11;
        PyObject *tmp_dict_name_11;
        PyObject *tmp_dict_name_12;
        PyObject *tmp_key_name_12;
        tmp_key_name_11 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_6__class_dict );
        tmp_dict_name_11 = tmp_class_creation_6__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_11, tmp_key_name_11 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 722;

            goto try_except_handler_14;
        }
        tmp_condition_result_8 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_8 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_6;
        }
        else
        {
            goto condexpr_false_6;
        }
        condexpr_true_6:;
        CHECK_OBJECT( tmp_class_creation_6__class_dict );
        tmp_dict_name_12 = tmp_class_creation_6__class_dict;
        tmp_key_name_12 = const_str_plain___metaclass__;
        tmp_assign_source_62 = DICT_GET_ITEM( tmp_dict_name_12, tmp_key_name_12 );
        if ( tmp_assign_source_62 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 722;

            goto try_except_handler_14;
        }
        goto condexpr_end_6;
        condexpr_false_6:;
        {
            PyObject *tmp_assign_source_63;
            PyObject *tmp_subscribed_name_3;
            PyObject *tmp_subscript_name_3;
            CHECK_OBJECT( tmp_class_creation_6__bases );
            tmp_subscribed_name_3 = tmp_class_creation_6__bases;
            tmp_subscript_name_3 = const_int_0;
            tmp_assign_source_63 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_3, tmp_subscript_name_3, 0 );
            if ( tmp_assign_source_63 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 722;

                goto try_except_handler_14;
            }
            assert( tmp_select_metaclass_6__base == NULL );
            tmp_select_metaclass_6__base = tmp_assign_source_63;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_4;
            CHECK_OBJECT( tmp_select_metaclass_6__base );
            tmp_source_name_4 = tmp_select_metaclass_6__base;
            tmp_assign_source_62 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_4 );
            if ( tmp_assign_source_62 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 722;

                goto try_except_handler_17;
            }
            goto try_return_handler_16;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        // Exception handler code:
        try_except_handler_17:;
        exception_keeper_type_11 = exception_type;
        exception_keeper_value_11 = exception_value;
        exception_keeper_tb_11 = exception_tb;
        exception_keeper_lineno_11 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_3;
            Py_DECREF( exception_keeper_type_11 );
            Py_XDECREF( exception_keeper_value_11 );
            Py_XDECREF( exception_keeper_tb_11 );
            CHECK_OBJECT( tmp_select_metaclass_6__base );
            tmp_type_arg_3 = tmp_select_metaclass_6__base;
            tmp_assign_source_62 = BUILTIN_TYPE1( tmp_type_arg_3 );
            assert( !(tmp_assign_source_62 == NULL) );
            goto try_return_handler_16;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_16:;
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_6__base );
        Py_DECREF( tmp_select_metaclass_6__base );
        tmp_select_metaclass_6__base = NULL;

        goto outline_result_7;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_6__base );
        Py_DECREF( tmp_select_metaclass_6__base );
        tmp_select_metaclass_6__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        outline_result_7:;
        condexpr_end_6:;
        assert( tmp_class_creation_6__metaclass == NULL );
        tmp_class_creation_6__metaclass = tmp_assign_source_62;
    }
    {
        PyObject *tmp_assign_source_64;
        PyObject *tmp_called_name_25;
        PyObject *tmp_args_element_name_35;
        PyObject *tmp_args_element_name_36;
        PyObject *tmp_args_element_name_37;
        CHECK_OBJECT( tmp_class_creation_6__metaclass );
        tmp_called_name_25 = tmp_class_creation_6__metaclass;
        tmp_args_element_name_35 = const_str_plain__BaseNetwork;
        CHECK_OBJECT( tmp_class_creation_6__bases );
        tmp_args_element_name_36 = tmp_class_creation_6__bases;
        CHECK_OBJECT( tmp_class_creation_6__class_dict );
        tmp_args_element_name_37 = tmp_class_creation_6__class_dict;
        frame_a10b4ee15c0763ecce4ab0022f0f5fa7->m_frame.f_lineno = 722;
        {
            PyObject *call_args[] = { tmp_args_element_name_35, tmp_args_element_name_36, tmp_args_element_name_37 };
            tmp_assign_source_64 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_25, call_args );
        }

        if ( tmp_assign_source_64 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 722;

            goto try_except_handler_14;
        }
        assert( tmp_class_creation_6__class == NULL );
        tmp_class_creation_6__class = tmp_assign_source_64;
    }
    goto try_end_7;
    // Exception handler code:
    try_except_handler_14:;
    exception_keeper_type_12 = exception_type;
    exception_keeper_value_12 = exception_value;
    exception_keeper_tb_12 = exception_tb;
    exception_keeper_lineno_12 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_6__bases );
    tmp_class_creation_6__bases = NULL;

    Py_XDECREF( tmp_class_creation_6__class_dict );
    tmp_class_creation_6__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_6__metaclass );
    tmp_class_creation_6__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_12;
    exception_value = exception_keeper_value_12;
    exception_tb = exception_keeper_tb_12;
    exception_lineno = exception_keeper_lineno_12;

    goto frame_exception_exit_1;
    // End of try:
    try_end_7:;
    {
        PyObject *tmp_assign_source_65;
        CHECK_OBJECT( tmp_class_creation_6__class );
        tmp_assign_source_65 = tmp_class_creation_6__class;
        UPDATE_STRING_DICT0( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__BaseNetwork, tmp_assign_source_65 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_6__class );
    Py_DECREF( tmp_class_creation_6__class );
    tmp_class_creation_6__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_6__bases );
    Py_DECREF( tmp_class_creation_6__bases );
    tmp_class_creation_6__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_6__class_dict );
    Py_DECREF( tmp_class_creation_6__class_dict );
    tmp_class_creation_6__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_6__metaclass );
    Py_DECREF( tmp_class_creation_6__metaclass );
    tmp_class_creation_6__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_66;
        {
            PyObject *tmp_set_locals_4;
            tmp_set_locals_4 = PyDict_New();
            locals_ipaddress_1200 = tmp_set_locals_4;
        }
        tmp_dictset_value = const_str_plain_ipaddress;
        tmp_res = PyDict_SetItem( locals_ipaddress_1200, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_unicode_digest_91f907426d1690d534d93dfdd7289bce;
        tmp_res = PyDict_SetItem( locals_ipaddress_1200, const_str_plain___doc__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_tuple_empty;
        tmp_res = PyDict_SetItem( locals_ipaddress_1200, const_str_plain___slots__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_int_pos_4;
        tmp_res = PyDict_SetItem( locals_ipaddress_1200, const_str_plain__version, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        MAKE_OR_REUSE_FRAME( cache_frame_f77fa86b0ce46b949fc4657d215efecb_4, codeobj_f77fa86b0ce46b949fc4657d215efecb, module_ipaddress, 0 );
        frame_f77fa86b0ce46b949fc4657d215efecb_4 = cache_frame_f77fa86b0ce46b949fc4657d215efecb_4;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_f77fa86b0ce46b949fc4657d215efecb_4 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_f77fa86b0ce46b949fc4657d215efecb_4 ) == 2 ); // Frame stack

        // Framed code:
        {
            PyObject *tmp_left_name_1;
            PyObject *tmp_left_name_2;
            PyObject *tmp_right_name_1;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_right_name_2;
            tmp_left_name_2 = const_int_pos_2;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPV4LENGTH );

            if (unlikely( tmp_mvar_value_4 == NULL ))
            {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPV4LENGTH );
            }

            if ( tmp_mvar_value_4 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPV4LENGTH" );
                exception_tb = NULL;

                exception_lineno = 1212;

                goto frame_exception_exit_4;
            }

            tmp_right_name_1 = tmp_mvar_value_4;
            tmp_left_name_1 = POWER_OPERATION( tmp_left_name_2, tmp_right_name_1 );
            if ( tmp_left_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1212;

                goto frame_exception_exit_4;
            }
            tmp_right_name_2 = const_int_pos_1;
            tmp_dictset_value = BINARY_OPERATION_SUB( tmp_left_name_1, tmp_right_name_2 );
            Py_DECREF( tmp_left_name_1 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1212;

                goto frame_exception_exit_4;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_1200, const_str_plain__ALL_ONES, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1212;

                goto frame_exception_exit_4;
            }
        }
        tmp_dictset_value = const_frozenset_66c1acb9d1286c78b6365c163e59bc78;
        tmp_res = PyDict_SetItem( locals_ipaddress_1200, const_str_plain__DECIMAL_DIGITS, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_frozenset_bcfae996d3e8c0199d3734036089d854;
        tmp_res = PyDict_SetItem( locals_ipaddress_1200, const_str_plain__valid_mask_octets, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_mvar_value_5;
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPV4LENGTH );

            if (unlikely( tmp_mvar_value_5 == NULL ))
            {
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPV4LENGTH );
            }

            if ( tmp_mvar_value_5 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPV4LENGTH" );
                exception_tb = NULL;

                exception_lineno = 1218;

                goto frame_exception_exit_4;
            }

            tmp_dictset_value = tmp_mvar_value_5;
            tmp_res = PyDict_SetItem( locals_ipaddress_1200, const_str_plain__max_prefixlen, tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1218;

                goto frame_exception_exit_4;
            }
        }
        tmp_dictset_value = PyDict_New();
        tmp_res = PyDict_SetItem( locals_ipaddress_1200, const_str_plain__netmask_cache, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_80__explode_shorthand_ip_string(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_1200, const_str_plain__explode_shorthand_ip_string, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_classmethod_arg_6;
            tmp_classmethod_arg_6 = MAKE_FUNCTION_ipaddress$$$function_81__make_netmask(  );



            tmp_dictset_value = BUILTIN_CLASSMETHOD( tmp_classmethod_arg_6 );
            Py_DECREF( tmp_classmethod_arg_6 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1226;

                goto frame_exception_exit_4;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_1200, const_str_plain__make_netmask, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1226;

                goto frame_exception_exit_4;
            }
        }
        {
            PyObject *tmp_classmethod_arg_7;
            tmp_classmethod_arg_7 = MAKE_FUNCTION_ipaddress$$$function_82__ip_int_from_string(  );



            tmp_dictset_value = BUILTIN_CLASSMETHOD( tmp_classmethod_arg_7 );
            Py_DECREF( tmp_classmethod_arg_7 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1250;

                goto frame_exception_exit_4;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_1200, const_str_plain__ip_int_from_string, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1250;

                goto frame_exception_exit_4;
            }
        }
        {
            PyObject *tmp_classmethod_arg_8;
            tmp_classmethod_arg_8 = MAKE_FUNCTION_ipaddress$$$function_83__parse_octet(  );



            tmp_dictset_value = BUILTIN_CLASSMETHOD( tmp_classmethod_arg_8 );
            Py_DECREF( tmp_classmethod_arg_8 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1277;

                goto frame_exception_exit_4;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_1200, const_str_plain__parse_octet, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1277;

                goto frame_exception_exit_4;
            }
        }
        {
            PyObject *tmp_classmethod_arg_9;
            tmp_classmethod_arg_9 = MAKE_FUNCTION_ipaddress$$$function_84__string_from_ip_int(  );



            tmp_dictset_value = BUILTIN_CLASSMETHOD( tmp_classmethod_arg_9 );
            Py_DECREF( tmp_classmethod_arg_9 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1314;

                goto frame_exception_exit_4;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_1200, const_str_plain__string_from_ip_int, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1314;

                goto frame_exception_exit_4;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_85__is_hostmask(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_1200, const_str_plain__is_hostmask, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_86__reverse_pointer(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_1200, const_str_plain__reverse_pointer, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_called_name_26;
            PyObject *tmp_args_element_name_38;
            tmp_called_name_26 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_38 = MAKE_FUNCTION_ipaddress$$$function_87_max_prefixlen(  );



            frame_f77fa86b0ce46b949fc4657d215efecb_4->m_frame.f_lineno = 1360;
            {
                PyObject *call_args[] = { tmp_args_element_name_38 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_26, call_args );
            }

            Py_DECREF( tmp_args_element_name_38 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1360;

                goto frame_exception_exit_4;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_1200, const_str_plain_max_prefixlen, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1360;

                goto frame_exception_exit_4;
            }
        }
        {
            PyObject *tmp_called_name_27;
            PyObject *tmp_args_element_name_39;
            tmp_called_name_27 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_39 = MAKE_FUNCTION_ipaddress$$$function_88_version(  );



            frame_f77fa86b0ce46b949fc4657d215efecb_4->m_frame.f_lineno = 1364;
            {
                PyObject *call_args[] = { tmp_args_element_name_39 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_27, call_args );
            }

            Py_DECREF( tmp_args_element_name_39 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1364;

                goto frame_exception_exit_4;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_1200, const_str_plain_version, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1364;

                goto frame_exception_exit_4;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_f77fa86b0ce46b949fc4657d215efecb_4 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_3;

        frame_exception_exit_4:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_f77fa86b0ce46b949fc4657d215efecb_4 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_f77fa86b0ce46b949fc4657d215efecb_4, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_f77fa86b0ce46b949fc4657d215efecb_4->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_f77fa86b0ce46b949fc4657d215efecb_4, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_f77fa86b0ce46b949fc4657d215efecb_4,
            type_description_2
        );


        // Release cached frame.
        if ( frame_f77fa86b0ce46b949fc4657d215efecb_4 == cache_frame_f77fa86b0ce46b949fc4657d215efecb_4 )
        {
            Py_DECREF( frame_f77fa86b0ce46b949fc4657d215efecb_4 );
        }
        cache_frame_f77fa86b0ce46b949fc4657d215efecb_4 = NULL;

        assertFrameObject( frame_f77fa86b0ce46b949fc4657d215efecb_4 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_3;

        frame_no_exception_3:;
        goto skip_nested_handling_3;
        nested_frame_exit_3:;

        goto try_except_handler_19;
        skip_nested_handling_3:;
        tmp_assign_source_66 = locals_ipaddress_1200;
        Py_INCREF( tmp_assign_source_66 );
        goto try_return_handler_19;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_19:;
        Py_DECREF( locals_ipaddress_1200 );
        locals_ipaddress_1200 = NULL;
        goto outline_result_8;
        // Exception handler code:
        try_except_handler_19:;
        exception_keeper_type_13 = exception_type;
        exception_keeper_value_13 = exception_value;
        exception_keeper_tb_13 = exception_tb;
        exception_keeper_lineno_13 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_ipaddress_1200 );
        locals_ipaddress_1200 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_13;
        exception_value = exception_keeper_value_13;
        exception_tb = exception_keeper_tb_13;
        exception_lineno = exception_keeper_lineno_13;

        goto outline_exception_3;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_3:;
        exception_lineno = 1200;
        goto try_except_handler_18;
        outline_result_8:;
        assert( tmp_class_creation_7__class_dict == NULL );
        tmp_class_creation_7__class_dict = tmp_assign_source_66;
    }
    {
        PyObject *tmp_assign_source_67;
        nuitka_bool tmp_condition_result_9;
        PyObject *tmp_key_name_13;
        PyObject *tmp_dict_name_13;
        PyObject *tmp_dict_name_14;
        PyObject *tmp_key_name_14;
        tmp_key_name_13 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_7__class_dict );
        tmp_dict_name_13 = tmp_class_creation_7__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_13, tmp_key_name_13 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1200;

            goto try_except_handler_18;
        }
        tmp_condition_result_9 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_9 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_7;
        }
        else
        {
            goto condexpr_false_7;
        }
        condexpr_true_7:;
        CHECK_OBJECT( tmp_class_creation_7__class_dict );
        tmp_dict_name_14 = tmp_class_creation_7__class_dict;
        tmp_key_name_14 = const_str_plain___metaclass__;
        tmp_assign_source_67 = DICT_GET_ITEM( tmp_dict_name_14, tmp_key_name_14 );
        if ( tmp_assign_source_67 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1200;

            goto try_except_handler_18;
        }
        goto condexpr_end_7;
        condexpr_false_7:;
        tmp_assign_source_67 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_assign_source_67 );
        condexpr_end_7:;
        assert( tmp_class_creation_7__metaclass == NULL );
        tmp_class_creation_7__metaclass = tmp_assign_source_67;
    }
    {
        PyObject *tmp_assign_source_68;
        PyObject *tmp_called_name_28;
        PyObject *tmp_args_element_name_40;
        PyObject *tmp_args_element_name_41;
        PyObject *tmp_args_element_name_42;
        CHECK_OBJECT( tmp_class_creation_7__metaclass );
        tmp_called_name_28 = tmp_class_creation_7__metaclass;
        tmp_args_element_name_40 = const_str_plain__BaseV4;
        tmp_args_element_name_41 = const_tuple_type_object_tuple;
        CHECK_OBJECT( tmp_class_creation_7__class_dict );
        tmp_args_element_name_42 = tmp_class_creation_7__class_dict;
        frame_a10b4ee15c0763ecce4ab0022f0f5fa7->m_frame.f_lineno = 1200;
        {
            PyObject *call_args[] = { tmp_args_element_name_40, tmp_args_element_name_41, tmp_args_element_name_42 };
            tmp_assign_source_68 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_28, call_args );
        }

        if ( tmp_assign_source_68 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1200;

            goto try_except_handler_18;
        }
        assert( tmp_class_creation_7__class == NULL );
        tmp_class_creation_7__class = tmp_assign_source_68;
    }
    goto try_end_8;
    // Exception handler code:
    try_except_handler_18:;
    exception_keeper_type_14 = exception_type;
    exception_keeper_value_14 = exception_value;
    exception_keeper_tb_14 = exception_tb;
    exception_keeper_lineno_14 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_7__class_dict );
    tmp_class_creation_7__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_7__metaclass );
    tmp_class_creation_7__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_14;
    exception_value = exception_keeper_value_14;
    exception_tb = exception_keeper_tb_14;
    exception_lineno = exception_keeper_lineno_14;

    goto frame_exception_exit_1;
    // End of try:
    try_end_8:;
    {
        PyObject *tmp_assign_source_69;
        CHECK_OBJECT( tmp_class_creation_7__class );
        tmp_assign_source_69 = tmp_class_creation_7__class;
        UPDATE_STRING_DICT0( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__BaseV4, tmp_assign_source_69 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_7__class );
    Py_DECREF( tmp_class_creation_7__class );
    tmp_class_creation_7__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_7__class_dict );
    Py_DECREF( tmp_class_creation_7__class_dict );
    tmp_class_creation_7__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_7__metaclass );
    Py_DECREF( tmp_class_creation_7__metaclass );
    tmp_class_creation_7__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_70;
        PyObject *tmp_tuple_element_4;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_mvar_value_7;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__BaseV4 );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__BaseV4 );
        }

        if ( tmp_mvar_value_6 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_BaseV4" );
            exception_tb = NULL;

            exception_lineno = 1369;

            goto try_except_handler_20;
        }

        tmp_tuple_element_4 = tmp_mvar_value_6;
        tmp_assign_source_70 = PyTuple_New( 2 );
        Py_INCREF( tmp_tuple_element_4 );
        PyTuple_SET_ITEM( tmp_assign_source_70, 0, tmp_tuple_element_4 );
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__BaseAddress );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__BaseAddress );
        }

        if ( tmp_mvar_value_7 == NULL )
        {
            Py_DECREF( tmp_assign_source_70 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_BaseAddress" );
            exception_tb = NULL;

            exception_lineno = 1369;

            goto try_except_handler_20;
        }

        tmp_tuple_element_4 = tmp_mvar_value_7;
        Py_INCREF( tmp_tuple_element_4 );
        PyTuple_SET_ITEM( tmp_assign_source_70, 1, tmp_tuple_element_4 );
        assert( tmp_class_creation_8__bases == NULL );
        tmp_class_creation_8__bases = tmp_assign_source_70;
    }
    {
        PyObject *tmp_assign_source_71;
        {
            PyObject *tmp_set_locals_5;
            tmp_set_locals_5 = PyDict_New();
            locals_ipaddress_1369 = tmp_set_locals_5;
        }
        tmp_dictset_value = const_str_plain_ipaddress;
        tmp_res = PyDict_SetItem( locals_ipaddress_1369, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_unicode_digest_dc01540d6d8926dde62d972412f10f57;
        tmp_res = PyDict_SetItem( locals_ipaddress_1369, const_str_plain___doc__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_tuple_unicode_plain__ip_unicode_plain___weakref___tuple;
        tmp_res = PyDict_SetItem( locals_ipaddress_1369, const_str_plain___slots__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_89___init__(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_1369, const_str_plain___init__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        MAKE_OR_REUSE_FRAME( cache_frame_1a9921f46deeb2eb6639b77a939ad874_5, codeobj_1a9921f46deeb2eb6639b77a939ad874, module_ipaddress, 0 );
        frame_1a9921f46deeb2eb6639b77a939ad874_5 = cache_frame_1a9921f46deeb2eb6639b77a939ad874_5;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_1a9921f46deeb2eb6639b77a939ad874_5 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_1a9921f46deeb2eb6639b77a939ad874_5 ) == 2 ); // Frame stack

        // Framed code:
        {
            PyObject *tmp_called_name_29;
            PyObject *tmp_args_element_name_43;
            tmp_called_name_29 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_43 = MAKE_FUNCTION_ipaddress$$$function_90_packed(  );



            frame_1a9921f46deeb2eb6639b77a939ad874_5->m_frame.f_lineno = 1411;
            {
                PyObject *call_args[] = { tmp_args_element_name_43 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_29, call_args );
            }

            Py_DECREF( tmp_args_element_name_43 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1411;

                goto frame_exception_exit_5;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_1369, const_str_plain_packed, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1411;

                goto frame_exception_exit_5;
            }
        }
        {
            PyObject *tmp_called_name_30;
            PyObject *tmp_args_element_name_44;
            tmp_called_name_30 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_44 = MAKE_FUNCTION_ipaddress$$$function_91_is_reserved(  );



            frame_1a9921f46deeb2eb6639b77a939ad874_5->m_frame.f_lineno = 1416;
            {
                PyObject *call_args[] = { tmp_args_element_name_44 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_30, call_args );
            }

            Py_DECREF( tmp_args_element_name_44 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1416;

                goto frame_exception_exit_5;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_1369, const_str_plain_is_reserved, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1416;

                goto frame_exception_exit_5;
            }
        }
        {
            PyObject *tmp_called_name_31;
            PyObject *tmp_args_element_name_45;
            tmp_called_name_31 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_45 = MAKE_FUNCTION_ipaddress$$$function_92_is_private(  );



            frame_1a9921f46deeb2eb6639b77a939ad874_5->m_frame.f_lineno = 1427;
            {
                PyObject *call_args[] = { tmp_args_element_name_45 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_31, call_args );
            }

            Py_DECREF( tmp_args_element_name_45 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1427;

                goto frame_exception_exit_5;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_1369, const_str_plain_is_private, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1427;

                goto frame_exception_exit_5;
            }
        }
        {
            PyObject *tmp_called_name_32;
            PyObject *tmp_args_element_name_46;
            tmp_called_name_32 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_46 = MAKE_FUNCTION_ipaddress$$$function_93_is_global(  );



            frame_1a9921f46deeb2eb6639b77a939ad874_5->m_frame.f_lineno = 1438;
            {
                PyObject *call_args[] = { tmp_args_element_name_46 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_32, call_args );
            }

            Py_DECREF( tmp_args_element_name_46 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1438;

                goto frame_exception_exit_5;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_1369, const_str_plain_is_global, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1438;

                goto frame_exception_exit_5;
            }
        }
        {
            PyObject *tmp_called_name_33;
            PyObject *tmp_args_element_name_47;
            tmp_called_name_33 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_47 = MAKE_FUNCTION_ipaddress$$$function_94_is_multicast(  );



            frame_1a9921f46deeb2eb6639b77a939ad874_5->m_frame.f_lineno = 1444;
            {
                PyObject *call_args[] = { tmp_args_element_name_47 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_33, call_args );
            }

            Py_DECREF( tmp_args_element_name_47 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1444;

                goto frame_exception_exit_5;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_1369, const_str_plain_is_multicast, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1444;

                goto frame_exception_exit_5;
            }
        }
        {
            PyObject *tmp_called_name_34;
            PyObject *tmp_args_element_name_48;
            tmp_called_name_34 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_48 = MAKE_FUNCTION_ipaddress$$$function_95_is_unspecified(  );



            frame_1a9921f46deeb2eb6639b77a939ad874_5->m_frame.f_lineno = 1455;
            {
                PyObject *call_args[] = { tmp_args_element_name_48 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_34, call_args );
            }

            Py_DECREF( tmp_args_element_name_48 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1455;

                goto frame_exception_exit_5;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_1369, const_str_plain_is_unspecified, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1455;

                goto frame_exception_exit_5;
            }
        }
        {
            PyObject *tmp_called_name_35;
            PyObject *tmp_args_element_name_49;
            tmp_called_name_35 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_49 = MAKE_FUNCTION_ipaddress$$$function_96_is_loopback(  );



            frame_1a9921f46deeb2eb6639b77a939ad874_5->m_frame.f_lineno = 1466;
            {
                PyObject *call_args[] = { tmp_args_element_name_49 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_35, call_args );
            }

            Py_DECREF( tmp_args_element_name_49 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1466;

                goto frame_exception_exit_5;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_1369, const_str_plain_is_loopback, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1466;

                goto frame_exception_exit_5;
            }
        }
        {
            PyObject *tmp_called_name_36;
            PyObject *tmp_args_element_name_50;
            tmp_called_name_36 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_50 = MAKE_FUNCTION_ipaddress$$$function_97_is_link_local(  );



            frame_1a9921f46deeb2eb6639b77a939ad874_5->m_frame.f_lineno = 1476;
            {
                PyObject *call_args[] = { tmp_args_element_name_50 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_36, call_args );
            }

            Py_DECREF( tmp_args_element_name_50 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1476;

                goto frame_exception_exit_5;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_1369, const_str_plain_is_link_local, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1476;

                goto frame_exception_exit_5;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_1a9921f46deeb2eb6639b77a939ad874_5 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_4;

        frame_exception_exit_5:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_1a9921f46deeb2eb6639b77a939ad874_5 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_1a9921f46deeb2eb6639b77a939ad874_5, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_1a9921f46deeb2eb6639b77a939ad874_5->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_1a9921f46deeb2eb6639b77a939ad874_5, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_1a9921f46deeb2eb6639b77a939ad874_5,
            type_description_2
        );


        // Release cached frame.
        if ( frame_1a9921f46deeb2eb6639b77a939ad874_5 == cache_frame_1a9921f46deeb2eb6639b77a939ad874_5 )
        {
            Py_DECREF( frame_1a9921f46deeb2eb6639b77a939ad874_5 );
        }
        cache_frame_1a9921f46deeb2eb6639b77a939ad874_5 = NULL;

        assertFrameObject( frame_1a9921f46deeb2eb6639b77a939ad874_5 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_4;

        frame_no_exception_4:;
        goto skip_nested_handling_4;
        nested_frame_exit_4:;

        goto try_except_handler_21;
        skip_nested_handling_4:;
        tmp_assign_source_71 = locals_ipaddress_1369;
        Py_INCREF( tmp_assign_source_71 );
        goto try_return_handler_21;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_21:;
        Py_DECREF( locals_ipaddress_1369 );
        locals_ipaddress_1369 = NULL;
        goto outline_result_9;
        // Exception handler code:
        try_except_handler_21:;
        exception_keeper_type_15 = exception_type;
        exception_keeper_value_15 = exception_value;
        exception_keeper_tb_15 = exception_tb;
        exception_keeper_lineno_15 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_ipaddress_1369 );
        locals_ipaddress_1369 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_15;
        exception_value = exception_keeper_value_15;
        exception_tb = exception_keeper_tb_15;
        exception_lineno = exception_keeper_lineno_15;

        goto outline_exception_4;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_4:;
        exception_lineno = 1369;
        goto try_except_handler_20;
        outline_result_9:;
        assert( tmp_class_creation_8__class_dict == NULL );
        tmp_class_creation_8__class_dict = tmp_assign_source_71;
    }
    {
        PyObject *tmp_assign_source_72;
        nuitka_bool tmp_condition_result_10;
        PyObject *tmp_key_name_15;
        PyObject *tmp_dict_name_15;
        PyObject *tmp_dict_name_16;
        PyObject *tmp_key_name_16;
        tmp_key_name_15 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_8__class_dict );
        tmp_dict_name_15 = tmp_class_creation_8__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_15, tmp_key_name_15 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1369;

            goto try_except_handler_20;
        }
        tmp_condition_result_10 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_10 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_8;
        }
        else
        {
            goto condexpr_false_8;
        }
        condexpr_true_8:;
        CHECK_OBJECT( tmp_class_creation_8__class_dict );
        tmp_dict_name_16 = tmp_class_creation_8__class_dict;
        tmp_key_name_16 = const_str_plain___metaclass__;
        tmp_assign_source_72 = DICT_GET_ITEM( tmp_dict_name_16, tmp_key_name_16 );
        if ( tmp_assign_source_72 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1369;

            goto try_except_handler_20;
        }
        goto condexpr_end_8;
        condexpr_false_8:;
        {
            PyObject *tmp_assign_source_73;
            PyObject *tmp_subscribed_name_4;
            PyObject *tmp_subscript_name_4;
            CHECK_OBJECT( tmp_class_creation_8__bases );
            tmp_subscribed_name_4 = tmp_class_creation_8__bases;
            tmp_subscript_name_4 = const_int_0;
            tmp_assign_source_73 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_4, tmp_subscript_name_4, 0 );
            if ( tmp_assign_source_73 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1369;

                goto try_except_handler_20;
            }
            assert( tmp_select_metaclass_8__base == NULL );
            tmp_select_metaclass_8__base = tmp_assign_source_73;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_5;
            CHECK_OBJECT( tmp_select_metaclass_8__base );
            tmp_source_name_5 = tmp_select_metaclass_8__base;
            tmp_assign_source_72 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_5 );
            if ( tmp_assign_source_72 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1369;

                goto try_except_handler_23;
            }
            goto try_return_handler_22;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        // Exception handler code:
        try_except_handler_23:;
        exception_keeper_type_16 = exception_type;
        exception_keeper_value_16 = exception_value;
        exception_keeper_tb_16 = exception_tb;
        exception_keeper_lineno_16 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_4;
            Py_DECREF( exception_keeper_type_16 );
            Py_XDECREF( exception_keeper_value_16 );
            Py_XDECREF( exception_keeper_tb_16 );
            CHECK_OBJECT( tmp_select_metaclass_8__base );
            tmp_type_arg_4 = tmp_select_metaclass_8__base;
            tmp_assign_source_72 = BUILTIN_TYPE1( tmp_type_arg_4 );
            assert( !(tmp_assign_source_72 == NULL) );
            goto try_return_handler_22;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_22:;
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_8__base );
        Py_DECREF( tmp_select_metaclass_8__base );
        tmp_select_metaclass_8__base = NULL;

        goto outline_result_10;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_8__base );
        Py_DECREF( tmp_select_metaclass_8__base );
        tmp_select_metaclass_8__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        outline_result_10:;
        condexpr_end_8:;
        assert( tmp_class_creation_8__metaclass == NULL );
        tmp_class_creation_8__metaclass = tmp_assign_source_72;
    }
    {
        PyObject *tmp_assign_source_74;
        PyObject *tmp_called_name_37;
        PyObject *tmp_args_element_name_51;
        PyObject *tmp_args_element_name_52;
        PyObject *tmp_args_element_name_53;
        CHECK_OBJECT( tmp_class_creation_8__metaclass );
        tmp_called_name_37 = tmp_class_creation_8__metaclass;
        tmp_args_element_name_51 = const_str_plain_IPv4Address;
        CHECK_OBJECT( tmp_class_creation_8__bases );
        tmp_args_element_name_52 = tmp_class_creation_8__bases;
        CHECK_OBJECT( tmp_class_creation_8__class_dict );
        tmp_args_element_name_53 = tmp_class_creation_8__class_dict;
        frame_a10b4ee15c0763ecce4ab0022f0f5fa7->m_frame.f_lineno = 1369;
        {
            PyObject *call_args[] = { tmp_args_element_name_51, tmp_args_element_name_52, tmp_args_element_name_53 };
            tmp_assign_source_74 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_37, call_args );
        }

        if ( tmp_assign_source_74 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1369;

            goto try_except_handler_20;
        }
        assert( tmp_class_creation_8__class == NULL );
        tmp_class_creation_8__class = tmp_assign_source_74;
    }
    goto try_end_9;
    // Exception handler code:
    try_except_handler_20:;
    exception_keeper_type_17 = exception_type;
    exception_keeper_value_17 = exception_value;
    exception_keeper_tb_17 = exception_tb;
    exception_keeper_lineno_17 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_8__bases );
    tmp_class_creation_8__bases = NULL;

    Py_XDECREF( tmp_class_creation_8__class_dict );
    tmp_class_creation_8__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_8__metaclass );
    tmp_class_creation_8__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_17;
    exception_value = exception_keeper_value_17;
    exception_tb = exception_keeper_tb_17;
    exception_lineno = exception_keeper_lineno_17;

    goto frame_exception_exit_1;
    // End of try:
    try_end_9:;
    {
        PyObject *tmp_assign_source_75;
        CHECK_OBJECT( tmp_class_creation_8__class );
        tmp_assign_source_75 = tmp_class_creation_8__class;
        UPDATE_STRING_DICT0( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Address, tmp_assign_source_75 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_8__class );
    Py_DECREF( tmp_class_creation_8__class );
    tmp_class_creation_8__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_8__bases );
    Py_DECREF( tmp_class_creation_8__bases );
    tmp_class_creation_8__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_8__class_dict );
    Py_DECREF( tmp_class_creation_8__class_dict );
    tmp_class_creation_8__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_8__metaclass );
    Py_DECREF( tmp_class_creation_8__metaclass );
    tmp_class_creation_8__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_76;
        PyObject *tmp_tuple_element_5;
        PyObject *tmp_mvar_value_8;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Address );

        if (unlikely( tmp_mvar_value_8 == NULL ))
        {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Address );
        }

        if ( tmp_mvar_value_8 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv4Address" );
            exception_tb = NULL;

            exception_lineno = 1487;

            goto try_except_handler_24;
        }

        tmp_tuple_element_5 = tmp_mvar_value_8;
        tmp_assign_source_76 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_5 );
        PyTuple_SET_ITEM( tmp_assign_source_76, 0, tmp_tuple_element_5 );
        assert( tmp_class_creation_9__bases == NULL );
        tmp_class_creation_9__bases = tmp_assign_source_76;
    }
    {
        PyObject *tmp_assign_source_77;
        {
            PyObject *tmp_set_locals_6;
            tmp_set_locals_6 = PyDict_New();
            locals_ipaddress_1487 = tmp_set_locals_6;
        }
        tmp_dictset_value = const_str_plain_ipaddress;
        tmp_res = PyDict_SetItem( locals_ipaddress_1487, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_98___init__(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_1487, const_str_plain___init__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_99___str__(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_1487, const_str_plain___str__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_100___eq__(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_1487, const_str_plain___eq__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_101___lt__(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_1487, const_str_plain___lt__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_102___hash__(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_1487, const_str_plain___hash__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        MAKE_OR_REUSE_FRAME( cache_frame_8c5b956ab97dc62e74ac053cc531b3e0_6, codeobj_8c5b956ab97dc62e74ac053cc531b3e0, module_ipaddress, 0 );
        frame_8c5b956ab97dc62e74ac053cc531b3e0_6 = cache_frame_8c5b956ab97dc62e74ac053cc531b3e0_6;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_8c5b956ab97dc62e74ac053cc531b3e0_6 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_8c5b956ab97dc62e74ac053cc531b3e0_6 ) == 2 ); // Frame stack

        // Framed code:
        {
            PyObject *tmp_source_name_6;
            PyObject *tmp_mvar_value_9;
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__IPAddressBase );

            if (unlikely( tmp_mvar_value_9 == NULL ))
            {
                tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__IPAddressBase );
            }

            if ( tmp_mvar_value_9 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "_IPAddressBase" );
                exception_tb = NULL;

                exception_lineno = 1547;

                goto frame_exception_exit_6;
            }

            tmp_source_name_6 = tmp_mvar_value_9;
            tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain___reduce__ );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1547;

                goto frame_exception_exit_6;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_1487, const_str_plain___reduce__, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1547;

                goto frame_exception_exit_6;
            }
        }
        {
            PyObject *tmp_called_name_38;
            PyObject *tmp_args_element_name_54;
            tmp_called_name_38 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_54 = MAKE_FUNCTION_ipaddress$$$function_103_ip(  );



            frame_8c5b956ab97dc62e74ac053cc531b3e0_6->m_frame.f_lineno = 1549;
            {
                PyObject *call_args[] = { tmp_args_element_name_54 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_38, call_args );
            }

            Py_DECREF( tmp_args_element_name_54 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1549;

                goto frame_exception_exit_6;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_1487, const_str_plain_ip, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1549;

                goto frame_exception_exit_6;
            }
        }
        {
            PyObject *tmp_called_name_39;
            PyObject *tmp_args_element_name_55;
            tmp_called_name_39 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_55 = MAKE_FUNCTION_ipaddress$$$function_104_with_prefixlen(  );



            frame_8c5b956ab97dc62e74ac053cc531b3e0_6->m_frame.f_lineno = 1553;
            {
                PyObject *call_args[] = { tmp_args_element_name_55 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_39, call_args );
            }

            Py_DECREF( tmp_args_element_name_55 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1553;

                goto frame_exception_exit_6;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_1487, const_str_plain_with_prefixlen, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1553;

                goto frame_exception_exit_6;
            }
        }
        {
            PyObject *tmp_called_name_40;
            PyObject *tmp_args_element_name_56;
            tmp_called_name_40 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_56 = MAKE_FUNCTION_ipaddress$$$function_105_with_netmask(  );



            frame_8c5b956ab97dc62e74ac053cc531b3e0_6->m_frame.f_lineno = 1558;
            {
                PyObject *call_args[] = { tmp_args_element_name_56 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_40, call_args );
            }

            Py_DECREF( tmp_args_element_name_56 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1558;

                goto frame_exception_exit_6;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_1487, const_str_plain_with_netmask, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1558;

                goto frame_exception_exit_6;
            }
        }
        {
            PyObject *tmp_called_name_41;
            PyObject *tmp_args_element_name_57;
            tmp_called_name_41 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_57 = MAKE_FUNCTION_ipaddress$$$function_106_with_hostmask(  );



            frame_8c5b956ab97dc62e74ac053cc531b3e0_6->m_frame.f_lineno = 1563;
            {
                PyObject *call_args[] = { tmp_args_element_name_57 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_41, call_args );
            }

            Py_DECREF( tmp_args_element_name_57 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1563;

                goto frame_exception_exit_6;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_1487, const_str_plain_with_hostmask, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1563;

                goto frame_exception_exit_6;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_8c5b956ab97dc62e74ac053cc531b3e0_6 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_5;

        frame_exception_exit_6:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_8c5b956ab97dc62e74ac053cc531b3e0_6 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_8c5b956ab97dc62e74ac053cc531b3e0_6, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_8c5b956ab97dc62e74ac053cc531b3e0_6->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_8c5b956ab97dc62e74ac053cc531b3e0_6, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_8c5b956ab97dc62e74ac053cc531b3e0_6,
            type_description_2
        );


        // Release cached frame.
        if ( frame_8c5b956ab97dc62e74ac053cc531b3e0_6 == cache_frame_8c5b956ab97dc62e74ac053cc531b3e0_6 )
        {
            Py_DECREF( frame_8c5b956ab97dc62e74ac053cc531b3e0_6 );
        }
        cache_frame_8c5b956ab97dc62e74ac053cc531b3e0_6 = NULL;

        assertFrameObject( frame_8c5b956ab97dc62e74ac053cc531b3e0_6 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_5;

        frame_no_exception_5:;
        goto skip_nested_handling_5;
        nested_frame_exit_5:;

        goto try_except_handler_25;
        skip_nested_handling_5:;
        tmp_assign_source_77 = locals_ipaddress_1487;
        Py_INCREF( tmp_assign_source_77 );
        goto try_return_handler_25;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_25:;
        Py_DECREF( locals_ipaddress_1487 );
        locals_ipaddress_1487 = NULL;
        goto outline_result_11;
        // Exception handler code:
        try_except_handler_25:;
        exception_keeper_type_18 = exception_type;
        exception_keeper_value_18 = exception_value;
        exception_keeper_tb_18 = exception_tb;
        exception_keeper_lineno_18 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_ipaddress_1487 );
        locals_ipaddress_1487 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_18;
        exception_value = exception_keeper_value_18;
        exception_tb = exception_keeper_tb_18;
        exception_lineno = exception_keeper_lineno_18;

        goto outline_exception_5;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_5:;
        exception_lineno = 1487;
        goto try_except_handler_24;
        outline_result_11:;
        assert( tmp_class_creation_9__class_dict == NULL );
        tmp_class_creation_9__class_dict = tmp_assign_source_77;
    }
    {
        PyObject *tmp_assign_source_78;
        nuitka_bool tmp_condition_result_11;
        PyObject *tmp_key_name_17;
        PyObject *tmp_dict_name_17;
        PyObject *tmp_dict_name_18;
        PyObject *tmp_key_name_18;
        tmp_key_name_17 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_9__class_dict );
        tmp_dict_name_17 = tmp_class_creation_9__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_17, tmp_key_name_17 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1487;

            goto try_except_handler_24;
        }
        tmp_condition_result_11 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_11 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_9;
        }
        else
        {
            goto condexpr_false_9;
        }
        condexpr_true_9:;
        CHECK_OBJECT( tmp_class_creation_9__class_dict );
        tmp_dict_name_18 = tmp_class_creation_9__class_dict;
        tmp_key_name_18 = const_str_plain___metaclass__;
        tmp_assign_source_78 = DICT_GET_ITEM( tmp_dict_name_18, tmp_key_name_18 );
        if ( tmp_assign_source_78 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1487;

            goto try_except_handler_24;
        }
        goto condexpr_end_9;
        condexpr_false_9:;
        {
            PyObject *tmp_assign_source_79;
            PyObject *tmp_subscribed_name_5;
            PyObject *tmp_subscript_name_5;
            CHECK_OBJECT( tmp_class_creation_9__bases );
            tmp_subscribed_name_5 = tmp_class_creation_9__bases;
            tmp_subscript_name_5 = const_int_0;
            tmp_assign_source_79 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_5, tmp_subscript_name_5, 0 );
            if ( tmp_assign_source_79 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1487;

                goto try_except_handler_24;
            }
            assert( tmp_select_metaclass_9__base == NULL );
            tmp_select_metaclass_9__base = tmp_assign_source_79;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_7;
            CHECK_OBJECT( tmp_select_metaclass_9__base );
            tmp_source_name_7 = tmp_select_metaclass_9__base;
            tmp_assign_source_78 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_7 );
            if ( tmp_assign_source_78 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1487;

                goto try_except_handler_27;
            }
            goto try_return_handler_26;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        // Exception handler code:
        try_except_handler_27:;
        exception_keeper_type_19 = exception_type;
        exception_keeper_value_19 = exception_value;
        exception_keeper_tb_19 = exception_tb;
        exception_keeper_lineno_19 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_5;
            Py_DECREF( exception_keeper_type_19 );
            Py_XDECREF( exception_keeper_value_19 );
            Py_XDECREF( exception_keeper_tb_19 );
            CHECK_OBJECT( tmp_select_metaclass_9__base );
            tmp_type_arg_5 = tmp_select_metaclass_9__base;
            tmp_assign_source_78 = BUILTIN_TYPE1( tmp_type_arg_5 );
            assert( !(tmp_assign_source_78 == NULL) );
            goto try_return_handler_26;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_26:;
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_9__base );
        Py_DECREF( tmp_select_metaclass_9__base );
        tmp_select_metaclass_9__base = NULL;

        goto outline_result_12;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_9__base );
        Py_DECREF( tmp_select_metaclass_9__base );
        tmp_select_metaclass_9__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        outline_result_12:;
        condexpr_end_9:;
        assert( tmp_class_creation_9__metaclass == NULL );
        tmp_class_creation_9__metaclass = tmp_assign_source_78;
    }
    {
        PyObject *tmp_assign_source_80;
        PyObject *tmp_called_name_42;
        PyObject *tmp_args_element_name_58;
        PyObject *tmp_args_element_name_59;
        PyObject *tmp_args_element_name_60;
        CHECK_OBJECT( tmp_class_creation_9__metaclass );
        tmp_called_name_42 = tmp_class_creation_9__metaclass;
        tmp_args_element_name_58 = const_str_plain_IPv4Interface;
        CHECK_OBJECT( tmp_class_creation_9__bases );
        tmp_args_element_name_59 = tmp_class_creation_9__bases;
        CHECK_OBJECT( tmp_class_creation_9__class_dict );
        tmp_args_element_name_60 = tmp_class_creation_9__class_dict;
        frame_a10b4ee15c0763ecce4ab0022f0f5fa7->m_frame.f_lineno = 1487;
        {
            PyObject *call_args[] = { tmp_args_element_name_58, tmp_args_element_name_59, tmp_args_element_name_60 };
            tmp_assign_source_80 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_42, call_args );
        }

        if ( tmp_assign_source_80 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1487;

            goto try_except_handler_24;
        }
        assert( tmp_class_creation_9__class == NULL );
        tmp_class_creation_9__class = tmp_assign_source_80;
    }
    goto try_end_10;
    // Exception handler code:
    try_except_handler_24:;
    exception_keeper_type_20 = exception_type;
    exception_keeper_value_20 = exception_value;
    exception_keeper_tb_20 = exception_tb;
    exception_keeper_lineno_20 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_9__bases );
    tmp_class_creation_9__bases = NULL;

    Py_XDECREF( tmp_class_creation_9__class_dict );
    tmp_class_creation_9__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_9__metaclass );
    tmp_class_creation_9__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_20;
    exception_value = exception_keeper_value_20;
    exception_tb = exception_keeper_tb_20;
    exception_lineno = exception_keeper_lineno_20;

    goto frame_exception_exit_1;
    // End of try:
    try_end_10:;
    {
        PyObject *tmp_assign_source_81;
        CHECK_OBJECT( tmp_class_creation_9__class );
        tmp_assign_source_81 = tmp_class_creation_9__class;
        UPDATE_STRING_DICT0( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Interface, tmp_assign_source_81 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_9__class );
    Py_DECREF( tmp_class_creation_9__class );
    tmp_class_creation_9__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_9__bases );
    Py_DECREF( tmp_class_creation_9__bases );
    tmp_class_creation_9__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_9__class_dict );
    Py_DECREF( tmp_class_creation_9__class_dict );
    tmp_class_creation_9__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_9__metaclass );
    Py_DECREF( tmp_class_creation_9__metaclass );
    tmp_class_creation_9__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_82;
        PyObject *tmp_tuple_element_6;
        PyObject *tmp_mvar_value_10;
        PyObject *tmp_mvar_value_11;
        tmp_mvar_value_10 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__BaseV4 );

        if (unlikely( tmp_mvar_value_10 == NULL ))
        {
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__BaseV4 );
        }

        if ( tmp_mvar_value_10 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_BaseV4" );
            exception_tb = NULL;

            exception_lineno = 1569;

            goto try_except_handler_28;
        }

        tmp_tuple_element_6 = tmp_mvar_value_10;
        tmp_assign_source_82 = PyTuple_New( 2 );
        Py_INCREF( tmp_tuple_element_6 );
        PyTuple_SET_ITEM( tmp_assign_source_82, 0, tmp_tuple_element_6 );
        tmp_mvar_value_11 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__BaseNetwork );

        if (unlikely( tmp_mvar_value_11 == NULL ))
        {
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__BaseNetwork );
        }

        if ( tmp_mvar_value_11 == NULL )
        {
            Py_DECREF( tmp_assign_source_82 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_BaseNetwork" );
            exception_tb = NULL;

            exception_lineno = 1569;

            goto try_except_handler_28;
        }

        tmp_tuple_element_6 = tmp_mvar_value_11;
        Py_INCREF( tmp_tuple_element_6 );
        PyTuple_SET_ITEM( tmp_assign_source_82, 1, tmp_tuple_element_6 );
        assert( tmp_class_creation_10__bases == NULL );
        tmp_class_creation_10__bases = tmp_assign_source_82;
    }
    {
        PyObject *tmp_assign_source_83;
        {
            PyObject *tmp_set_locals_7;
            tmp_set_locals_7 = PyDict_New();
            locals_ipaddress_1569 = tmp_set_locals_7;
        }
        tmp_dictset_value = const_str_plain_ipaddress;
        tmp_res = PyDict_SetItem( locals_ipaddress_1569, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_unicode_digest_2c28e42f0eba3d090f3252a34ee21d01;
        tmp_res = PyDict_SetItem( locals_ipaddress_1569, const_str_plain___doc__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        MAKE_OR_REUSE_FRAME( cache_frame_1b6fd3360f8022d9f0452f99d3cf6fba_7, codeobj_1b6fd3360f8022d9f0452f99d3cf6fba, module_ipaddress, 0 );
        frame_1b6fd3360f8022d9f0452f99d3cf6fba_7 = cache_frame_1b6fd3360f8022d9f0452f99d3cf6fba_7;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_1b6fd3360f8022d9f0452f99d3cf6fba_7 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_1b6fd3360f8022d9f0452f99d3cf6fba_7 ) == 2 ); // Frame stack

        // Framed code:
        {
            PyObject *tmp_mvar_value_12;
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Address );

            if (unlikely( tmp_mvar_value_12 == NULL ))
            {
                tmp_mvar_value_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Address );
            }

            if ( tmp_mvar_value_12 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv4Address" );
                exception_tb = NULL;

                exception_lineno = 1582;

                goto frame_exception_exit_7;
            }

            tmp_dictset_value = tmp_mvar_value_12;
            tmp_res = PyDict_SetItem( locals_ipaddress_1569, const_str_plain__address_class, tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1582;

                goto frame_exception_exit_7;
            }
        }
        {
            PyObject *tmp_defaults_5;
            tmp_defaults_5 = const_tuple_true_tuple;
            Py_INCREF( tmp_defaults_5 );
            tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_107___init__( tmp_defaults_5 );



            tmp_res = PyDict_SetItem( locals_ipaddress_1569, const_str_plain___init__, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            assert( !(tmp_res != 0) );
        }
        {
            PyObject *tmp_called_name_43;
            PyObject *tmp_args_element_name_61;
            tmp_called_name_43 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_61 = MAKE_FUNCTION_ipaddress$$$function_108_is_global(  );



            frame_1b6fd3360f8022d9f0452f99d3cf6fba_7->m_frame.f_lineno = 1669;
            {
                PyObject *call_args[] = { tmp_args_element_name_61 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_43, call_args );
            }

            Py_DECREF( tmp_args_element_name_61 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1669;

                goto frame_exception_exit_7;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_1569, const_str_plain_is_global, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1669;

                goto frame_exception_exit_7;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_1b6fd3360f8022d9f0452f99d3cf6fba_7 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_6;

        frame_exception_exit_7:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_1b6fd3360f8022d9f0452f99d3cf6fba_7 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_1b6fd3360f8022d9f0452f99d3cf6fba_7, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_1b6fd3360f8022d9f0452f99d3cf6fba_7->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_1b6fd3360f8022d9f0452f99d3cf6fba_7, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_1b6fd3360f8022d9f0452f99d3cf6fba_7,
            type_description_2
        );


        // Release cached frame.
        if ( frame_1b6fd3360f8022d9f0452f99d3cf6fba_7 == cache_frame_1b6fd3360f8022d9f0452f99d3cf6fba_7 )
        {
            Py_DECREF( frame_1b6fd3360f8022d9f0452f99d3cf6fba_7 );
        }
        cache_frame_1b6fd3360f8022d9f0452f99d3cf6fba_7 = NULL;

        assertFrameObject( frame_1b6fd3360f8022d9f0452f99d3cf6fba_7 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_6;

        frame_no_exception_6:;
        goto skip_nested_handling_6;
        nested_frame_exit_6:;

        goto try_except_handler_29;
        skip_nested_handling_6:;
        tmp_assign_source_83 = locals_ipaddress_1569;
        Py_INCREF( tmp_assign_source_83 );
        goto try_return_handler_29;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_29:;
        Py_DECREF( locals_ipaddress_1569 );
        locals_ipaddress_1569 = NULL;
        goto outline_result_13;
        // Exception handler code:
        try_except_handler_29:;
        exception_keeper_type_21 = exception_type;
        exception_keeper_value_21 = exception_value;
        exception_keeper_tb_21 = exception_tb;
        exception_keeper_lineno_21 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_ipaddress_1569 );
        locals_ipaddress_1569 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_21;
        exception_value = exception_keeper_value_21;
        exception_tb = exception_keeper_tb_21;
        exception_lineno = exception_keeper_lineno_21;

        goto outline_exception_6;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_6:;
        exception_lineno = 1569;
        goto try_except_handler_28;
        outline_result_13:;
        assert( tmp_class_creation_10__class_dict == NULL );
        tmp_class_creation_10__class_dict = tmp_assign_source_83;
    }
    {
        PyObject *tmp_assign_source_84;
        nuitka_bool tmp_condition_result_12;
        PyObject *tmp_key_name_19;
        PyObject *tmp_dict_name_19;
        PyObject *tmp_dict_name_20;
        PyObject *tmp_key_name_20;
        tmp_key_name_19 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_10__class_dict );
        tmp_dict_name_19 = tmp_class_creation_10__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_19, tmp_key_name_19 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1569;

            goto try_except_handler_28;
        }
        tmp_condition_result_12 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_12 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_10;
        }
        else
        {
            goto condexpr_false_10;
        }
        condexpr_true_10:;
        CHECK_OBJECT( tmp_class_creation_10__class_dict );
        tmp_dict_name_20 = tmp_class_creation_10__class_dict;
        tmp_key_name_20 = const_str_plain___metaclass__;
        tmp_assign_source_84 = DICT_GET_ITEM( tmp_dict_name_20, tmp_key_name_20 );
        if ( tmp_assign_source_84 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1569;

            goto try_except_handler_28;
        }
        goto condexpr_end_10;
        condexpr_false_10:;
        {
            PyObject *tmp_assign_source_85;
            PyObject *tmp_subscribed_name_6;
            PyObject *tmp_subscript_name_6;
            CHECK_OBJECT( tmp_class_creation_10__bases );
            tmp_subscribed_name_6 = tmp_class_creation_10__bases;
            tmp_subscript_name_6 = const_int_0;
            tmp_assign_source_85 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_6, tmp_subscript_name_6, 0 );
            if ( tmp_assign_source_85 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1569;

                goto try_except_handler_28;
            }
            assert( tmp_select_metaclass_10__base == NULL );
            tmp_select_metaclass_10__base = tmp_assign_source_85;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_8;
            CHECK_OBJECT( tmp_select_metaclass_10__base );
            tmp_source_name_8 = tmp_select_metaclass_10__base;
            tmp_assign_source_84 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_8 );
            if ( tmp_assign_source_84 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1569;

                goto try_except_handler_31;
            }
            goto try_return_handler_30;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        // Exception handler code:
        try_except_handler_31:;
        exception_keeper_type_22 = exception_type;
        exception_keeper_value_22 = exception_value;
        exception_keeper_tb_22 = exception_tb;
        exception_keeper_lineno_22 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_6;
            Py_DECREF( exception_keeper_type_22 );
            Py_XDECREF( exception_keeper_value_22 );
            Py_XDECREF( exception_keeper_tb_22 );
            CHECK_OBJECT( tmp_select_metaclass_10__base );
            tmp_type_arg_6 = tmp_select_metaclass_10__base;
            tmp_assign_source_84 = BUILTIN_TYPE1( tmp_type_arg_6 );
            assert( !(tmp_assign_source_84 == NULL) );
            goto try_return_handler_30;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_30:;
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_10__base );
        Py_DECREF( tmp_select_metaclass_10__base );
        tmp_select_metaclass_10__base = NULL;

        goto outline_result_14;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_10__base );
        Py_DECREF( tmp_select_metaclass_10__base );
        tmp_select_metaclass_10__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        outline_result_14:;
        condexpr_end_10:;
        assert( tmp_class_creation_10__metaclass == NULL );
        tmp_class_creation_10__metaclass = tmp_assign_source_84;
    }
    {
        PyObject *tmp_assign_source_86;
        PyObject *tmp_called_name_44;
        PyObject *tmp_args_element_name_62;
        PyObject *tmp_args_element_name_63;
        PyObject *tmp_args_element_name_64;
        CHECK_OBJECT( tmp_class_creation_10__metaclass );
        tmp_called_name_44 = tmp_class_creation_10__metaclass;
        tmp_args_element_name_62 = const_str_plain_IPv4Network;
        CHECK_OBJECT( tmp_class_creation_10__bases );
        tmp_args_element_name_63 = tmp_class_creation_10__bases;
        CHECK_OBJECT( tmp_class_creation_10__class_dict );
        tmp_args_element_name_64 = tmp_class_creation_10__class_dict;
        frame_a10b4ee15c0763ecce4ab0022f0f5fa7->m_frame.f_lineno = 1569;
        {
            PyObject *call_args[] = { tmp_args_element_name_62, tmp_args_element_name_63, tmp_args_element_name_64 };
            tmp_assign_source_86 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_44, call_args );
        }

        if ( tmp_assign_source_86 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1569;

            goto try_except_handler_28;
        }
        assert( tmp_class_creation_10__class == NULL );
        tmp_class_creation_10__class = tmp_assign_source_86;
    }
    goto try_end_11;
    // Exception handler code:
    try_except_handler_28:;
    exception_keeper_type_23 = exception_type;
    exception_keeper_value_23 = exception_value;
    exception_keeper_tb_23 = exception_tb;
    exception_keeper_lineno_23 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_10__bases );
    tmp_class_creation_10__bases = NULL;

    Py_XDECREF( tmp_class_creation_10__class_dict );
    tmp_class_creation_10__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_10__metaclass );
    tmp_class_creation_10__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_23;
    exception_value = exception_keeper_value_23;
    exception_tb = exception_keeper_tb_23;
    exception_lineno = exception_keeper_lineno_23;

    goto frame_exception_exit_1;
    // End of try:
    try_end_11:;
    {
        PyObject *tmp_assign_source_87;
        CHECK_OBJECT( tmp_class_creation_10__class );
        tmp_assign_source_87 = tmp_class_creation_10__class;
        UPDATE_STRING_DICT0( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Network, tmp_assign_source_87 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_10__class );
    Py_DECREF( tmp_class_creation_10__class );
    tmp_class_creation_10__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_10__bases );
    Py_DECREF( tmp_class_creation_10__bases );
    tmp_class_creation_10__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_10__class_dict );
    Py_DECREF( tmp_class_creation_10__class_dict );
    tmp_class_creation_10__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_10__metaclass );
    Py_DECREF( tmp_class_creation_10__metaclass );
    tmp_class_creation_10__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_88;
        {
            PyObject *tmp_set_locals_8;
            tmp_set_locals_8 = PyDict_New();
            locals_ipaddress_1683 = tmp_set_locals_8;
        }
        tmp_dictset_value = const_str_plain_ipaddress;
        tmp_res = PyDict_SetItem( locals_ipaddress_1683, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        MAKE_OR_REUSE_FRAME( cache_frame_1831ffa3cc2fcf6156ebd1cfb8c343f4_8, codeobj_1831ffa3cc2fcf6156ebd1cfb8c343f4, module_ipaddress, 0 );
        frame_1831ffa3cc2fcf6156ebd1cfb8c343f4_8 = cache_frame_1831ffa3cc2fcf6156ebd1cfb8c343f4_8;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_1831ffa3cc2fcf6156ebd1cfb8c343f4_8 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_1831ffa3cc2fcf6156ebd1cfb8c343f4_8 ) == 2 ); // Frame stack

        // Framed code:
        {
            PyObject *tmp_called_name_45;
            PyObject *tmp_mvar_value_13;
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Network );

            if (unlikely( tmp_mvar_value_13 == NULL ))
            {
                tmp_mvar_value_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Network );
            }

            if ( tmp_mvar_value_13 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv4Network" );
                exception_tb = NULL;

                exception_lineno = 1685;

                goto frame_exception_exit_8;
            }

            tmp_called_name_45 = tmp_mvar_value_13;
            frame_1831ffa3cc2fcf6156ebd1cfb8c343f4_8->m_frame.f_lineno = 1685;
            tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_45, &PyTuple_GET_ITEM( const_tuple_unicode_digest_97a8ca337c0108210bc28d6fe8f8ec60_tuple, 0 ) );

            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1685;

                goto frame_exception_exit_8;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_1683, const_str_plain__linklocal_network, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1685;

                goto frame_exception_exit_8;
            }
        }
        {
            PyObject *tmp_called_name_46;
            PyObject *tmp_mvar_value_14;
            tmp_mvar_value_14 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Network );

            if (unlikely( tmp_mvar_value_14 == NULL ))
            {
                tmp_mvar_value_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Network );
            }

            if ( tmp_mvar_value_14 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv4Network" );
                exception_tb = NULL;

                exception_lineno = 1687;

                goto frame_exception_exit_8;
            }

            tmp_called_name_46 = tmp_mvar_value_14;
            frame_1831ffa3cc2fcf6156ebd1cfb8c343f4_8->m_frame.f_lineno = 1687;
            tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_46, &PyTuple_GET_ITEM( const_tuple_unicode_digest_9b517c1b35c5efe37b498ee36f2a46c2_tuple, 0 ) );

            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1687;

                goto frame_exception_exit_8;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_1683, const_str_plain__loopback_network, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1687;

                goto frame_exception_exit_8;
            }
        }
        {
            PyObject *tmp_called_name_47;
            PyObject *tmp_mvar_value_15;
            tmp_mvar_value_15 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Network );

            if (unlikely( tmp_mvar_value_15 == NULL ))
            {
                tmp_mvar_value_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Network );
            }

            if ( tmp_mvar_value_15 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv4Network" );
                exception_tb = NULL;

                exception_lineno = 1689;

                goto frame_exception_exit_8;
            }

            tmp_called_name_47 = tmp_mvar_value_15;
            frame_1831ffa3cc2fcf6156ebd1cfb8c343f4_8->m_frame.f_lineno = 1689;
            tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_47, &PyTuple_GET_ITEM( const_tuple_unicode_digest_fce80ade8999b448027d3bc78b9fd2e2_tuple, 0 ) );

            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1689;

                goto frame_exception_exit_8;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_1683, const_str_plain__multicast_network, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1689;

                goto frame_exception_exit_8;
            }
        }
        {
            PyObject *tmp_called_name_48;
            PyObject *tmp_mvar_value_16;
            tmp_mvar_value_16 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Network );

            if (unlikely( tmp_mvar_value_16 == NULL ))
            {
                tmp_mvar_value_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Network );
            }

            if ( tmp_mvar_value_16 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv4Network" );
                exception_tb = NULL;

                exception_lineno = 1691;

                goto frame_exception_exit_8;
            }

            tmp_called_name_48 = tmp_mvar_value_16;
            frame_1831ffa3cc2fcf6156ebd1cfb8c343f4_8->m_frame.f_lineno = 1691;
            tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_48, &PyTuple_GET_ITEM( const_tuple_unicode_digest_307b618e8fe3dea44ed44b7622abf36e_tuple, 0 ) );

            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1691;

                goto frame_exception_exit_8;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_1683, const_str_plain__public_network, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1691;

                goto frame_exception_exit_8;
            }
        }
        {
            PyObject *tmp_list_element_1;
            PyObject *tmp_called_name_49;
            PyObject *tmp_mvar_value_17;
            PyObject *tmp_called_name_50;
            PyObject *tmp_mvar_value_18;
            PyObject *tmp_called_name_51;
            PyObject *tmp_mvar_value_19;
            PyObject *tmp_called_name_52;
            PyObject *tmp_mvar_value_20;
            PyObject *tmp_called_name_53;
            PyObject *tmp_mvar_value_21;
            PyObject *tmp_called_name_54;
            PyObject *tmp_mvar_value_22;
            PyObject *tmp_called_name_55;
            PyObject *tmp_mvar_value_23;
            PyObject *tmp_called_name_56;
            PyObject *tmp_mvar_value_24;
            PyObject *tmp_called_name_57;
            PyObject *tmp_mvar_value_25;
            PyObject *tmp_called_name_58;
            PyObject *tmp_mvar_value_26;
            PyObject *tmp_called_name_59;
            PyObject *tmp_mvar_value_27;
            PyObject *tmp_called_name_60;
            PyObject *tmp_mvar_value_28;
            PyObject *tmp_called_name_61;
            PyObject *tmp_mvar_value_29;
            PyObject *tmp_called_name_62;
            PyObject *tmp_mvar_value_30;
            tmp_mvar_value_17 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Network );

            if (unlikely( tmp_mvar_value_17 == NULL ))
            {
                tmp_mvar_value_17 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Network );
            }

            if ( tmp_mvar_value_17 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv4Network" );
                exception_tb = NULL;

                exception_lineno = 1694;

                goto frame_exception_exit_8;
            }

            tmp_called_name_49 = tmp_mvar_value_17;
            frame_1831ffa3cc2fcf6156ebd1cfb8c343f4_8->m_frame.f_lineno = 1694;
            tmp_list_element_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_49, &PyTuple_GET_ITEM( const_tuple_unicode_digest_22dfacc211498343b7c4f5bc77b1999e_tuple, 0 ) );

            if ( tmp_list_element_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1694;

                goto frame_exception_exit_8;
            }
            tmp_dictset_value = PyList_New( 14 );
            PyList_SET_ITEM( tmp_dictset_value, 0, tmp_list_element_1 );
            tmp_mvar_value_18 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Network );

            if (unlikely( tmp_mvar_value_18 == NULL ))
            {
                tmp_mvar_value_18 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Network );
            }

            if ( tmp_mvar_value_18 == NULL )
            {
                Py_DECREF( tmp_dictset_value );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv4Network" );
                exception_tb = NULL;

                exception_lineno = 1695;

                goto frame_exception_exit_8;
            }

            tmp_called_name_50 = tmp_mvar_value_18;
            frame_1831ffa3cc2fcf6156ebd1cfb8c343f4_8->m_frame.f_lineno = 1695;
            tmp_list_element_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_50, &PyTuple_GET_ITEM( const_tuple_unicode_digest_d3e4ae64d5b27931433edd93be5fc695_tuple, 0 ) );

            if ( tmp_list_element_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 1695;

                goto frame_exception_exit_8;
            }
            PyList_SET_ITEM( tmp_dictset_value, 1, tmp_list_element_1 );
            tmp_mvar_value_19 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Network );

            if (unlikely( tmp_mvar_value_19 == NULL ))
            {
                tmp_mvar_value_19 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Network );
            }

            if ( tmp_mvar_value_19 == NULL )
            {
                Py_DECREF( tmp_dictset_value );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv4Network" );
                exception_tb = NULL;

                exception_lineno = 1696;

                goto frame_exception_exit_8;
            }

            tmp_called_name_51 = tmp_mvar_value_19;
            frame_1831ffa3cc2fcf6156ebd1cfb8c343f4_8->m_frame.f_lineno = 1696;
            tmp_list_element_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_51, &PyTuple_GET_ITEM( const_tuple_unicode_digest_9b517c1b35c5efe37b498ee36f2a46c2_tuple, 0 ) );

            if ( tmp_list_element_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 1696;

                goto frame_exception_exit_8;
            }
            PyList_SET_ITEM( tmp_dictset_value, 2, tmp_list_element_1 );
            tmp_mvar_value_20 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Network );

            if (unlikely( tmp_mvar_value_20 == NULL ))
            {
                tmp_mvar_value_20 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Network );
            }

            if ( tmp_mvar_value_20 == NULL )
            {
                Py_DECREF( tmp_dictset_value );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv4Network" );
                exception_tb = NULL;

                exception_lineno = 1697;

                goto frame_exception_exit_8;
            }

            tmp_called_name_52 = tmp_mvar_value_20;
            frame_1831ffa3cc2fcf6156ebd1cfb8c343f4_8->m_frame.f_lineno = 1697;
            tmp_list_element_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_52, &PyTuple_GET_ITEM( const_tuple_unicode_digest_97a8ca337c0108210bc28d6fe8f8ec60_tuple, 0 ) );

            if ( tmp_list_element_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 1697;

                goto frame_exception_exit_8;
            }
            PyList_SET_ITEM( tmp_dictset_value, 3, tmp_list_element_1 );
            tmp_mvar_value_21 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Network );

            if (unlikely( tmp_mvar_value_21 == NULL ))
            {
                tmp_mvar_value_21 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Network );
            }

            if ( tmp_mvar_value_21 == NULL )
            {
                Py_DECREF( tmp_dictset_value );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv4Network" );
                exception_tb = NULL;

                exception_lineno = 1698;

                goto frame_exception_exit_8;
            }

            tmp_called_name_53 = tmp_mvar_value_21;
            frame_1831ffa3cc2fcf6156ebd1cfb8c343f4_8->m_frame.f_lineno = 1698;
            tmp_list_element_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_53, &PyTuple_GET_ITEM( const_tuple_unicode_digest_b6c766f070c655516752216bf2bdd0c4_tuple, 0 ) );

            if ( tmp_list_element_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 1698;

                goto frame_exception_exit_8;
            }
            PyList_SET_ITEM( tmp_dictset_value, 4, tmp_list_element_1 );
            tmp_mvar_value_22 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Network );

            if (unlikely( tmp_mvar_value_22 == NULL ))
            {
                tmp_mvar_value_22 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Network );
            }

            if ( tmp_mvar_value_22 == NULL )
            {
                Py_DECREF( tmp_dictset_value );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv4Network" );
                exception_tb = NULL;

                exception_lineno = 1699;

                goto frame_exception_exit_8;
            }

            tmp_called_name_54 = tmp_mvar_value_22;
            frame_1831ffa3cc2fcf6156ebd1cfb8c343f4_8->m_frame.f_lineno = 1699;
            tmp_list_element_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_54, &PyTuple_GET_ITEM( const_tuple_unicode_digest_76b74f1a00da7c59fff7c9438dba7f09_tuple, 0 ) );

            if ( tmp_list_element_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 1699;

                goto frame_exception_exit_8;
            }
            PyList_SET_ITEM( tmp_dictset_value, 5, tmp_list_element_1 );
            tmp_mvar_value_23 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Network );

            if (unlikely( tmp_mvar_value_23 == NULL ))
            {
                tmp_mvar_value_23 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Network );
            }

            if ( tmp_mvar_value_23 == NULL )
            {
                Py_DECREF( tmp_dictset_value );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv4Network" );
                exception_tb = NULL;

                exception_lineno = 1700;

                goto frame_exception_exit_8;
            }

            tmp_called_name_55 = tmp_mvar_value_23;
            frame_1831ffa3cc2fcf6156ebd1cfb8c343f4_8->m_frame.f_lineno = 1700;
            tmp_list_element_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_55, &PyTuple_GET_ITEM( const_tuple_unicode_digest_8f4a5718a9f7024daab1c7cbc36c9839_tuple, 0 ) );

            if ( tmp_list_element_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 1700;

                goto frame_exception_exit_8;
            }
            PyList_SET_ITEM( tmp_dictset_value, 6, tmp_list_element_1 );
            tmp_mvar_value_24 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Network );

            if (unlikely( tmp_mvar_value_24 == NULL ))
            {
                tmp_mvar_value_24 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Network );
            }

            if ( tmp_mvar_value_24 == NULL )
            {
                Py_DECREF( tmp_dictset_value );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv4Network" );
                exception_tb = NULL;

                exception_lineno = 1701;

                goto frame_exception_exit_8;
            }

            tmp_called_name_56 = tmp_mvar_value_24;
            frame_1831ffa3cc2fcf6156ebd1cfb8c343f4_8->m_frame.f_lineno = 1701;
            tmp_list_element_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_56, &PyTuple_GET_ITEM( const_tuple_unicode_digest_2a285cd7527a5c5b855f32dfb8bbe6c3_tuple, 0 ) );

            if ( tmp_list_element_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 1701;

                goto frame_exception_exit_8;
            }
            PyList_SET_ITEM( tmp_dictset_value, 7, tmp_list_element_1 );
            tmp_mvar_value_25 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Network );

            if (unlikely( tmp_mvar_value_25 == NULL ))
            {
                tmp_mvar_value_25 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Network );
            }

            if ( tmp_mvar_value_25 == NULL )
            {
                Py_DECREF( tmp_dictset_value );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv4Network" );
                exception_tb = NULL;

                exception_lineno = 1702;

                goto frame_exception_exit_8;
            }

            tmp_called_name_57 = tmp_mvar_value_25;
            frame_1831ffa3cc2fcf6156ebd1cfb8c343f4_8->m_frame.f_lineno = 1702;
            tmp_list_element_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_57, &PyTuple_GET_ITEM( const_tuple_unicode_digest_f96a90c13f1d84402c514b6ee611aea1_tuple, 0 ) );

            if ( tmp_list_element_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 1702;

                goto frame_exception_exit_8;
            }
            PyList_SET_ITEM( tmp_dictset_value, 8, tmp_list_element_1 );
            tmp_mvar_value_26 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Network );

            if (unlikely( tmp_mvar_value_26 == NULL ))
            {
                tmp_mvar_value_26 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Network );
            }

            if ( tmp_mvar_value_26 == NULL )
            {
                Py_DECREF( tmp_dictset_value );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv4Network" );
                exception_tb = NULL;

                exception_lineno = 1703;

                goto frame_exception_exit_8;
            }

            tmp_called_name_58 = tmp_mvar_value_26;
            frame_1831ffa3cc2fcf6156ebd1cfb8c343f4_8->m_frame.f_lineno = 1703;
            tmp_list_element_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_58, &PyTuple_GET_ITEM( const_tuple_unicode_digest_eabcf4377ca85e7b53b572d3d3177fe1_tuple, 0 ) );

            if ( tmp_list_element_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 1703;

                goto frame_exception_exit_8;
            }
            PyList_SET_ITEM( tmp_dictset_value, 9, tmp_list_element_1 );
            tmp_mvar_value_27 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Network );

            if (unlikely( tmp_mvar_value_27 == NULL ))
            {
                tmp_mvar_value_27 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Network );
            }

            if ( tmp_mvar_value_27 == NULL )
            {
                Py_DECREF( tmp_dictset_value );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv4Network" );
                exception_tb = NULL;

                exception_lineno = 1704;

                goto frame_exception_exit_8;
            }

            tmp_called_name_59 = tmp_mvar_value_27;
            frame_1831ffa3cc2fcf6156ebd1cfb8c343f4_8->m_frame.f_lineno = 1704;
            tmp_list_element_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_59, &PyTuple_GET_ITEM( const_tuple_unicode_digest_1c66251700e583bec5e8354f1f3817f8_tuple, 0 ) );

            if ( tmp_list_element_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 1704;

                goto frame_exception_exit_8;
            }
            PyList_SET_ITEM( tmp_dictset_value, 10, tmp_list_element_1 );
            tmp_mvar_value_28 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Network );

            if (unlikely( tmp_mvar_value_28 == NULL ))
            {
                tmp_mvar_value_28 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Network );
            }

            if ( tmp_mvar_value_28 == NULL )
            {
                Py_DECREF( tmp_dictset_value );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv4Network" );
                exception_tb = NULL;

                exception_lineno = 1705;

                goto frame_exception_exit_8;
            }

            tmp_called_name_60 = tmp_mvar_value_28;
            frame_1831ffa3cc2fcf6156ebd1cfb8c343f4_8->m_frame.f_lineno = 1705;
            tmp_list_element_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_60, &PyTuple_GET_ITEM( const_tuple_unicode_digest_8de571133ab8b9176c149e4e2555e2e4_tuple, 0 ) );

            if ( tmp_list_element_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 1705;

                goto frame_exception_exit_8;
            }
            PyList_SET_ITEM( tmp_dictset_value, 11, tmp_list_element_1 );
            tmp_mvar_value_29 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Network );

            if (unlikely( tmp_mvar_value_29 == NULL ))
            {
                tmp_mvar_value_29 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Network );
            }

            if ( tmp_mvar_value_29 == NULL )
            {
                Py_DECREF( tmp_dictset_value );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv4Network" );
                exception_tb = NULL;

                exception_lineno = 1706;

                goto frame_exception_exit_8;
            }

            tmp_called_name_61 = tmp_mvar_value_29;
            frame_1831ffa3cc2fcf6156ebd1cfb8c343f4_8->m_frame.f_lineno = 1706;
            tmp_list_element_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_61, &PyTuple_GET_ITEM( const_tuple_unicode_digest_ab9c76df45bc1dd7612ee4e57cee2742_tuple, 0 ) );

            if ( tmp_list_element_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 1706;

                goto frame_exception_exit_8;
            }
            PyList_SET_ITEM( tmp_dictset_value, 12, tmp_list_element_1 );
            tmp_mvar_value_30 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Network );

            if (unlikely( tmp_mvar_value_30 == NULL ))
            {
                tmp_mvar_value_30 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Network );
            }

            if ( tmp_mvar_value_30 == NULL )
            {
                Py_DECREF( tmp_dictset_value );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv4Network" );
                exception_tb = NULL;

                exception_lineno = 1707;

                goto frame_exception_exit_8;
            }

            tmp_called_name_62 = tmp_mvar_value_30;
            frame_1831ffa3cc2fcf6156ebd1cfb8c343f4_8->m_frame.f_lineno = 1707;
            tmp_list_element_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_62, &PyTuple_GET_ITEM( const_tuple_unicode_digest_405ec5ff1c943cd273b0a0932b950391_tuple, 0 ) );

            if ( tmp_list_element_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 1707;

                goto frame_exception_exit_8;
            }
            PyList_SET_ITEM( tmp_dictset_value, 13, tmp_list_element_1 );
            tmp_res = PyDict_SetItem( locals_ipaddress_1683, const_str_plain__private_networks, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1693;

                goto frame_exception_exit_8;
            }
        }
        {
            PyObject *tmp_called_name_63;
            PyObject *tmp_mvar_value_31;
            tmp_mvar_value_31 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Network );

            if (unlikely( tmp_mvar_value_31 == NULL ))
            {
                tmp_mvar_value_31 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Network );
            }

            if ( tmp_mvar_value_31 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv4Network" );
                exception_tb = NULL;

                exception_lineno = 1710;

                goto frame_exception_exit_8;
            }

            tmp_called_name_63 = tmp_mvar_value_31;
            frame_1831ffa3cc2fcf6156ebd1cfb8c343f4_8->m_frame.f_lineno = 1710;
            tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_63, &PyTuple_GET_ITEM( const_tuple_unicode_digest_ab9c76df45bc1dd7612ee4e57cee2742_tuple, 0 ) );

            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1710;

                goto frame_exception_exit_8;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_1683, const_str_plain__reserved_network, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1710;

                goto frame_exception_exit_8;
            }
        }
        {
            PyObject *tmp_called_name_64;
            PyObject *tmp_mvar_value_32;
            tmp_mvar_value_32 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Address );

            if (unlikely( tmp_mvar_value_32 == NULL ))
            {
                tmp_mvar_value_32 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Address );
            }

            if ( tmp_mvar_value_32 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv4Address" );
                exception_tb = NULL;

                exception_lineno = 1712;

                goto frame_exception_exit_8;
            }

            tmp_called_name_64 = tmp_mvar_value_32;
            frame_1831ffa3cc2fcf6156ebd1cfb8c343f4_8->m_frame.f_lineno = 1712;
            tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_64, &PyTuple_GET_ITEM( const_tuple_unicode_digest_dadff6dd3651f30e8cbbdd26cdbce215_tuple, 0 ) );

            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1712;

                goto frame_exception_exit_8;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_1683, const_str_plain__unspecified_address, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1712;

                goto frame_exception_exit_8;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_1831ffa3cc2fcf6156ebd1cfb8c343f4_8 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_7;

        frame_exception_exit_8:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_1831ffa3cc2fcf6156ebd1cfb8c343f4_8 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_1831ffa3cc2fcf6156ebd1cfb8c343f4_8, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_1831ffa3cc2fcf6156ebd1cfb8c343f4_8->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_1831ffa3cc2fcf6156ebd1cfb8c343f4_8, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_1831ffa3cc2fcf6156ebd1cfb8c343f4_8,
            type_description_2
        );


        // Release cached frame.
        if ( frame_1831ffa3cc2fcf6156ebd1cfb8c343f4_8 == cache_frame_1831ffa3cc2fcf6156ebd1cfb8c343f4_8 )
        {
            Py_DECREF( frame_1831ffa3cc2fcf6156ebd1cfb8c343f4_8 );
        }
        cache_frame_1831ffa3cc2fcf6156ebd1cfb8c343f4_8 = NULL;

        assertFrameObject( frame_1831ffa3cc2fcf6156ebd1cfb8c343f4_8 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_7;

        frame_no_exception_7:;
        goto skip_nested_handling_7;
        nested_frame_exit_7:;

        goto try_except_handler_33;
        skip_nested_handling_7:;
        tmp_assign_source_88 = locals_ipaddress_1683;
        Py_INCREF( tmp_assign_source_88 );
        goto try_return_handler_33;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_33:;
        Py_DECREF( locals_ipaddress_1683 );
        locals_ipaddress_1683 = NULL;
        goto outline_result_15;
        // Exception handler code:
        try_except_handler_33:;
        exception_keeper_type_24 = exception_type;
        exception_keeper_value_24 = exception_value;
        exception_keeper_tb_24 = exception_tb;
        exception_keeper_lineno_24 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_ipaddress_1683 );
        locals_ipaddress_1683 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_24;
        exception_value = exception_keeper_value_24;
        exception_tb = exception_keeper_tb_24;
        exception_lineno = exception_keeper_lineno_24;

        goto outline_exception_7;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_7:;
        exception_lineno = 1683;
        goto try_except_handler_32;
        outline_result_15:;
        assert( tmp_class_creation_11__class_dict == NULL );
        tmp_class_creation_11__class_dict = tmp_assign_source_88;
    }
    {
        PyObject *tmp_assign_source_89;
        nuitka_bool tmp_condition_result_13;
        PyObject *tmp_key_name_21;
        PyObject *tmp_dict_name_21;
        PyObject *tmp_dict_name_22;
        PyObject *tmp_key_name_22;
        tmp_key_name_21 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_11__class_dict );
        tmp_dict_name_21 = tmp_class_creation_11__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_21, tmp_key_name_21 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1683;

            goto try_except_handler_32;
        }
        tmp_condition_result_13 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_13 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_11;
        }
        else
        {
            goto condexpr_false_11;
        }
        condexpr_true_11:;
        CHECK_OBJECT( tmp_class_creation_11__class_dict );
        tmp_dict_name_22 = tmp_class_creation_11__class_dict;
        tmp_key_name_22 = const_str_plain___metaclass__;
        tmp_assign_source_89 = DICT_GET_ITEM( tmp_dict_name_22, tmp_key_name_22 );
        if ( tmp_assign_source_89 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1683;

            goto try_except_handler_32;
        }
        goto condexpr_end_11;
        condexpr_false_11:;
        tmp_assign_source_89 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_assign_source_89 );
        condexpr_end_11:;
        assert( tmp_class_creation_11__metaclass == NULL );
        tmp_class_creation_11__metaclass = tmp_assign_source_89;
    }
    {
        PyObject *tmp_assign_source_90;
        PyObject *tmp_called_name_65;
        PyObject *tmp_args_element_name_65;
        PyObject *tmp_args_element_name_66;
        PyObject *tmp_args_element_name_67;
        CHECK_OBJECT( tmp_class_creation_11__metaclass );
        tmp_called_name_65 = tmp_class_creation_11__metaclass;
        tmp_args_element_name_65 = const_str_plain__IPv4Constants;
        tmp_args_element_name_66 = const_tuple_type_object_tuple;
        CHECK_OBJECT( tmp_class_creation_11__class_dict );
        tmp_args_element_name_67 = tmp_class_creation_11__class_dict;
        frame_a10b4ee15c0763ecce4ab0022f0f5fa7->m_frame.f_lineno = 1683;
        {
            PyObject *call_args[] = { tmp_args_element_name_65, tmp_args_element_name_66, tmp_args_element_name_67 };
            tmp_assign_source_90 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_65, call_args );
        }

        if ( tmp_assign_source_90 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1683;

            goto try_except_handler_32;
        }
        assert( tmp_class_creation_11__class == NULL );
        tmp_class_creation_11__class = tmp_assign_source_90;
    }
    goto try_end_12;
    // Exception handler code:
    try_except_handler_32:;
    exception_keeper_type_25 = exception_type;
    exception_keeper_value_25 = exception_value;
    exception_keeper_tb_25 = exception_tb;
    exception_keeper_lineno_25 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_11__class_dict );
    tmp_class_creation_11__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_11__metaclass );
    tmp_class_creation_11__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_25;
    exception_value = exception_keeper_value_25;
    exception_tb = exception_keeper_tb_25;
    exception_lineno = exception_keeper_lineno_25;

    goto frame_exception_exit_1;
    // End of try:
    try_end_12:;
    {
        PyObject *tmp_assign_source_91;
        CHECK_OBJECT( tmp_class_creation_11__class );
        tmp_assign_source_91 = tmp_class_creation_11__class;
        UPDATE_STRING_DICT0( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__IPv4Constants, tmp_assign_source_91 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_11__class );
    Py_DECREF( tmp_class_creation_11__class );
    tmp_class_creation_11__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_11__class_dict );
    Py_DECREF( tmp_class_creation_11__class_dict );
    tmp_class_creation_11__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_11__metaclass );
    Py_DECREF( tmp_class_creation_11__metaclass );
    tmp_class_creation_11__metaclass = NULL;

    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_mvar_value_33;
        PyObject *tmp_assattr_target_1;
        PyObject *tmp_mvar_value_34;
        tmp_mvar_value_33 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__IPv4Constants );

        if (unlikely( tmp_mvar_value_33 == NULL ))
        {
            tmp_mvar_value_33 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__IPv4Constants );
        }

        if ( tmp_mvar_value_33 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_IPv4Constants" );
            exception_tb = NULL;

            exception_lineno = 1715;

            goto frame_exception_exit_1;
        }

        tmp_assattr_name_1 = tmp_mvar_value_33;
        tmp_mvar_value_34 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv4Address );

        if (unlikely( tmp_mvar_value_34 == NULL ))
        {
            tmp_mvar_value_34 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv4Address );
        }

        if ( tmp_mvar_value_34 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv4Address" );
            exception_tb = NULL;

            exception_lineno = 1715;

            goto frame_exception_exit_1;
        }

        tmp_assattr_target_1 = tmp_mvar_value_34;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__constants, tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1715;

            goto frame_exception_exit_1;
        }
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_92;
        {
            PyObject *tmp_set_locals_9;
            tmp_set_locals_9 = PyDict_New();
            locals_ipaddress_1718 = tmp_set_locals_9;
        }
        tmp_dictset_value = const_str_plain_ipaddress;
        tmp_res = PyDict_SetItem( locals_ipaddress_1718, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_unicode_digest_7034ed78731a4da5e33c8be78a50d678;
        tmp_res = PyDict_SetItem( locals_ipaddress_1718, const_str_plain___doc__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_tuple_empty;
        tmp_res = PyDict_SetItem( locals_ipaddress_1718, const_str_plain___slots__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_int_pos_6;
        tmp_res = PyDict_SetItem( locals_ipaddress_1718, const_str_plain__version, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        MAKE_OR_REUSE_FRAME( cache_frame_366e7e4afc4c79b4f2de94c1a936dae7_9, codeobj_366e7e4afc4c79b4f2de94c1a936dae7, module_ipaddress, 0 );
        frame_366e7e4afc4c79b4f2de94c1a936dae7_9 = cache_frame_366e7e4afc4c79b4f2de94c1a936dae7_9;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_366e7e4afc4c79b4f2de94c1a936dae7_9 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_366e7e4afc4c79b4f2de94c1a936dae7_9 ) == 2 ); // Frame stack

        // Framed code:
        {
            PyObject *tmp_left_name_3;
            PyObject *tmp_left_name_4;
            PyObject *tmp_right_name_3;
            PyObject *tmp_mvar_value_35;
            PyObject *tmp_right_name_4;
            tmp_left_name_4 = const_int_pos_2;
            tmp_mvar_value_35 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPV6LENGTH );

            if (unlikely( tmp_mvar_value_35 == NULL ))
            {
                tmp_mvar_value_35 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPV6LENGTH );
            }

            if ( tmp_mvar_value_35 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPV6LENGTH" );
                exception_tb = NULL;

                exception_lineno = 1729;

                goto frame_exception_exit_9;
            }

            tmp_right_name_3 = tmp_mvar_value_35;
            tmp_left_name_3 = POWER_OPERATION( tmp_left_name_4, tmp_right_name_3 );
            if ( tmp_left_name_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1729;

                goto frame_exception_exit_9;
            }
            tmp_right_name_4 = const_int_pos_1;
            tmp_dictset_value = BINARY_OPERATION_SUB( tmp_left_name_3, tmp_right_name_4 );
            Py_DECREF( tmp_left_name_3 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1729;

                goto frame_exception_exit_9;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_1718, const_str_plain__ALL_ONES, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1729;

                goto frame_exception_exit_9;
            }
        }
        tmp_dictset_value = const_int_pos_8;
        tmp_res = PyDict_SetItem( locals_ipaddress_1718, const_str_plain__HEXTET_COUNT, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_frozenset_92edb4f75c5f6d7fbad23f3049445af9;
        tmp_res = PyDict_SetItem( locals_ipaddress_1718, const_str_plain__HEX_DIGITS, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_mvar_value_36;
            tmp_mvar_value_36 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPV6LENGTH );

            if (unlikely( tmp_mvar_value_36 == NULL ))
            {
                tmp_mvar_value_36 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPV6LENGTH );
            }

            if ( tmp_mvar_value_36 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPV6LENGTH" );
                exception_tb = NULL;

                exception_lineno = 1732;

                goto frame_exception_exit_9;
            }

            tmp_dictset_value = tmp_mvar_value_36;
            tmp_res = PyDict_SetItem( locals_ipaddress_1718, const_str_plain__max_prefixlen, tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1732;

                goto frame_exception_exit_9;
            }
        }
        tmp_dictset_value = PyDict_New();
        tmp_res = PyDict_SetItem( locals_ipaddress_1718, const_str_plain__netmask_cache, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_classmethod_arg_10;
            tmp_classmethod_arg_10 = MAKE_FUNCTION_ipaddress$$$function_109__make_netmask(  );



            tmp_dictset_value = BUILTIN_CLASSMETHOD( tmp_classmethod_arg_10 );
            Py_DECREF( tmp_classmethod_arg_10 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1738;

                goto frame_exception_exit_9;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_1718, const_str_plain__make_netmask, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1738;

                goto frame_exception_exit_9;
            }
        }
        {
            PyObject *tmp_classmethod_arg_11;
            tmp_classmethod_arg_11 = MAKE_FUNCTION_ipaddress$$$function_110__ip_int_from_string(  );



            tmp_dictset_value = BUILTIN_CLASSMETHOD( tmp_classmethod_arg_11 );
            Py_DECREF( tmp_classmethod_arg_11 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1756;

                goto frame_exception_exit_9;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_1718, const_str_plain__ip_int_from_string, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1756;

                goto frame_exception_exit_9;
            }
        }
        {
            PyObject *tmp_classmethod_arg_12;
            tmp_classmethod_arg_12 = MAKE_FUNCTION_ipaddress$$$function_111__parse_hextet(  );



            tmp_dictset_value = BUILTIN_CLASSMETHOD( tmp_classmethod_arg_12 );
            Py_DECREF( tmp_classmethod_arg_12 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1861;

                goto frame_exception_exit_9;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_1718, const_str_plain__parse_hextet, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1861;

                goto frame_exception_exit_9;
            }
        }
        {
            PyObject *tmp_classmethod_arg_13;
            tmp_classmethod_arg_13 = MAKE_FUNCTION_ipaddress$$$function_112__compress_hextets(  );



            tmp_dictset_value = BUILTIN_CLASSMETHOD( tmp_classmethod_arg_13 );
            Py_DECREF( tmp_classmethod_arg_13 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1887;

                goto frame_exception_exit_9;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_1718, const_str_plain__compress_hextets, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1887;

                goto frame_exception_exit_9;
            }
        }
        {
            PyObject *tmp_classmethod_arg_14;
            PyObject *tmp_defaults_6;
            tmp_defaults_6 = const_tuple_none_tuple;
            Py_INCREF( tmp_defaults_6 );
            tmp_classmethod_arg_14 = MAKE_FUNCTION_ipaddress$$$function_113__string_from_ip_int( tmp_defaults_6 );



            tmp_dictset_value = BUILTIN_CLASSMETHOD( tmp_classmethod_arg_14 );
            Py_DECREF( tmp_classmethod_arg_14 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1935;

                goto frame_exception_exit_9;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_1718, const_str_plain__string_from_ip_int, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1935;

                goto frame_exception_exit_9;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_114__explode_shorthand_ip_string(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_1718, const_str_plain__explode_shorthand_ip_string, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_115__reverse_pointer(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_1718, const_str_plain__reverse_pointer, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_called_name_66;
            PyObject *tmp_args_element_name_68;
            tmp_called_name_66 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_68 = MAKE_FUNCTION_ipaddress$$$function_116_max_prefixlen(  );



            frame_366e7e4afc4c79b4f2de94c1a936dae7_9->m_frame.f_lineno = 1994;
            {
                PyObject *call_args[] = { tmp_args_element_name_68 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_66, call_args );
            }

            Py_DECREF( tmp_args_element_name_68 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1994;

                goto frame_exception_exit_9;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_1718, const_str_plain_max_prefixlen, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1994;

                goto frame_exception_exit_9;
            }
        }
        {
            PyObject *tmp_called_name_67;
            PyObject *tmp_args_element_name_69;
            tmp_called_name_67 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_69 = MAKE_FUNCTION_ipaddress$$$function_117_version(  );



            frame_366e7e4afc4c79b4f2de94c1a936dae7_9->m_frame.f_lineno = 1998;
            {
                PyObject *call_args[] = { tmp_args_element_name_69 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_67, call_args );
            }

            Py_DECREF( tmp_args_element_name_69 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1998;

                goto frame_exception_exit_9;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_1718, const_str_plain_version, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1998;

                goto frame_exception_exit_9;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_366e7e4afc4c79b4f2de94c1a936dae7_9 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_8;

        frame_exception_exit_9:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_366e7e4afc4c79b4f2de94c1a936dae7_9 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_366e7e4afc4c79b4f2de94c1a936dae7_9, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_366e7e4afc4c79b4f2de94c1a936dae7_9->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_366e7e4afc4c79b4f2de94c1a936dae7_9, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_366e7e4afc4c79b4f2de94c1a936dae7_9,
            type_description_2
        );


        // Release cached frame.
        if ( frame_366e7e4afc4c79b4f2de94c1a936dae7_9 == cache_frame_366e7e4afc4c79b4f2de94c1a936dae7_9 )
        {
            Py_DECREF( frame_366e7e4afc4c79b4f2de94c1a936dae7_9 );
        }
        cache_frame_366e7e4afc4c79b4f2de94c1a936dae7_9 = NULL;

        assertFrameObject( frame_366e7e4afc4c79b4f2de94c1a936dae7_9 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_8;

        frame_no_exception_8:;
        goto skip_nested_handling_8;
        nested_frame_exit_8:;

        goto try_except_handler_35;
        skip_nested_handling_8:;
        tmp_assign_source_92 = locals_ipaddress_1718;
        Py_INCREF( tmp_assign_source_92 );
        goto try_return_handler_35;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_35:;
        Py_DECREF( locals_ipaddress_1718 );
        locals_ipaddress_1718 = NULL;
        goto outline_result_16;
        // Exception handler code:
        try_except_handler_35:;
        exception_keeper_type_26 = exception_type;
        exception_keeper_value_26 = exception_value;
        exception_keeper_tb_26 = exception_tb;
        exception_keeper_lineno_26 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_ipaddress_1718 );
        locals_ipaddress_1718 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_26;
        exception_value = exception_keeper_value_26;
        exception_tb = exception_keeper_tb_26;
        exception_lineno = exception_keeper_lineno_26;

        goto outline_exception_8;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_8:;
        exception_lineno = 1718;
        goto try_except_handler_34;
        outline_result_16:;
        assert( tmp_class_creation_12__class_dict == NULL );
        tmp_class_creation_12__class_dict = tmp_assign_source_92;
    }
    {
        PyObject *tmp_assign_source_93;
        nuitka_bool tmp_condition_result_14;
        PyObject *tmp_key_name_23;
        PyObject *tmp_dict_name_23;
        PyObject *tmp_dict_name_24;
        PyObject *tmp_key_name_24;
        tmp_key_name_23 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_12__class_dict );
        tmp_dict_name_23 = tmp_class_creation_12__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_23, tmp_key_name_23 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1718;

            goto try_except_handler_34;
        }
        tmp_condition_result_14 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_14 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_12;
        }
        else
        {
            goto condexpr_false_12;
        }
        condexpr_true_12:;
        CHECK_OBJECT( tmp_class_creation_12__class_dict );
        tmp_dict_name_24 = tmp_class_creation_12__class_dict;
        tmp_key_name_24 = const_str_plain___metaclass__;
        tmp_assign_source_93 = DICT_GET_ITEM( tmp_dict_name_24, tmp_key_name_24 );
        if ( tmp_assign_source_93 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1718;

            goto try_except_handler_34;
        }
        goto condexpr_end_12;
        condexpr_false_12:;
        tmp_assign_source_93 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_assign_source_93 );
        condexpr_end_12:;
        assert( tmp_class_creation_12__metaclass == NULL );
        tmp_class_creation_12__metaclass = tmp_assign_source_93;
    }
    {
        PyObject *tmp_assign_source_94;
        PyObject *tmp_called_name_68;
        PyObject *tmp_args_element_name_70;
        PyObject *tmp_args_element_name_71;
        PyObject *tmp_args_element_name_72;
        CHECK_OBJECT( tmp_class_creation_12__metaclass );
        tmp_called_name_68 = tmp_class_creation_12__metaclass;
        tmp_args_element_name_70 = const_str_plain__BaseV6;
        tmp_args_element_name_71 = const_tuple_type_object_tuple;
        CHECK_OBJECT( tmp_class_creation_12__class_dict );
        tmp_args_element_name_72 = tmp_class_creation_12__class_dict;
        frame_a10b4ee15c0763ecce4ab0022f0f5fa7->m_frame.f_lineno = 1718;
        {
            PyObject *call_args[] = { tmp_args_element_name_70, tmp_args_element_name_71, tmp_args_element_name_72 };
            tmp_assign_source_94 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_68, call_args );
        }

        if ( tmp_assign_source_94 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1718;

            goto try_except_handler_34;
        }
        assert( tmp_class_creation_12__class == NULL );
        tmp_class_creation_12__class = tmp_assign_source_94;
    }
    goto try_end_13;
    // Exception handler code:
    try_except_handler_34:;
    exception_keeper_type_27 = exception_type;
    exception_keeper_value_27 = exception_value;
    exception_keeper_tb_27 = exception_tb;
    exception_keeper_lineno_27 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_12__class_dict );
    tmp_class_creation_12__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_12__metaclass );
    tmp_class_creation_12__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_27;
    exception_value = exception_keeper_value_27;
    exception_tb = exception_keeper_tb_27;
    exception_lineno = exception_keeper_lineno_27;

    goto frame_exception_exit_1;
    // End of try:
    try_end_13:;
    {
        PyObject *tmp_assign_source_95;
        CHECK_OBJECT( tmp_class_creation_12__class );
        tmp_assign_source_95 = tmp_class_creation_12__class;
        UPDATE_STRING_DICT0( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__BaseV6, tmp_assign_source_95 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_12__class );
    Py_DECREF( tmp_class_creation_12__class );
    tmp_class_creation_12__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_12__class_dict );
    Py_DECREF( tmp_class_creation_12__class_dict );
    tmp_class_creation_12__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_12__metaclass );
    Py_DECREF( tmp_class_creation_12__metaclass );
    tmp_class_creation_12__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_96;
        PyObject *tmp_tuple_element_7;
        PyObject *tmp_mvar_value_37;
        PyObject *tmp_mvar_value_38;
        tmp_mvar_value_37 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__BaseV6 );

        if (unlikely( tmp_mvar_value_37 == NULL ))
        {
            tmp_mvar_value_37 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__BaseV6 );
        }

        if ( tmp_mvar_value_37 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_BaseV6" );
            exception_tb = NULL;

            exception_lineno = 2003;

            goto try_except_handler_36;
        }

        tmp_tuple_element_7 = tmp_mvar_value_37;
        tmp_assign_source_96 = PyTuple_New( 2 );
        Py_INCREF( tmp_tuple_element_7 );
        PyTuple_SET_ITEM( tmp_assign_source_96, 0, tmp_tuple_element_7 );
        tmp_mvar_value_38 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__BaseAddress );

        if (unlikely( tmp_mvar_value_38 == NULL ))
        {
            tmp_mvar_value_38 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__BaseAddress );
        }

        if ( tmp_mvar_value_38 == NULL )
        {
            Py_DECREF( tmp_assign_source_96 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_BaseAddress" );
            exception_tb = NULL;

            exception_lineno = 2003;

            goto try_except_handler_36;
        }

        tmp_tuple_element_7 = tmp_mvar_value_38;
        Py_INCREF( tmp_tuple_element_7 );
        PyTuple_SET_ITEM( tmp_assign_source_96, 1, tmp_tuple_element_7 );
        assert( tmp_class_creation_13__bases == NULL );
        tmp_class_creation_13__bases = tmp_assign_source_96;
    }
    {
        PyObject *tmp_assign_source_97;
        {
            PyObject *tmp_set_locals_10;
            tmp_set_locals_10 = PyDict_New();
            locals_ipaddress_2003 = tmp_set_locals_10;
        }
        tmp_dictset_value = const_str_plain_ipaddress;
        tmp_res = PyDict_SetItem( locals_ipaddress_2003, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_unicode_digest_47216010aeed65d4a29c64ed034fbfdb;
        tmp_res = PyDict_SetItem( locals_ipaddress_2003, const_str_plain___doc__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_tuple_unicode_plain__ip_unicode_plain___weakref___tuple;
        tmp_res = PyDict_SetItem( locals_ipaddress_2003, const_str_plain___slots__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_118___init__(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_2003, const_str_plain___init__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        MAKE_OR_REUSE_FRAME( cache_frame_e3100639ef7adfb1b91bea0685b2bda9_10, codeobj_e3100639ef7adfb1b91bea0685b2bda9, module_ipaddress, 0 );
        frame_e3100639ef7adfb1b91bea0685b2bda9_10 = cache_frame_e3100639ef7adfb1b91bea0685b2bda9_10;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_e3100639ef7adfb1b91bea0685b2bda9_10 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_e3100639ef7adfb1b91bea0685b2bda9_10 ) == 2 ); // Frame stack

        // Framed code:
        {
            PyObject *tmp_called_name_69;
            PyObject *tmp_args_element_name_73;
            tmp_called_name_69 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_73 = MAKE_FUNCTION_ipaddress$$$function_119_packed(  );



            frame_e3100639ef7adfb1b91bea0685b2bda9_10->m_frame.f_lineno = 2046;
            {
                PyObject *call_args[] = { tmp_args_element_name_73 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_69, call_args );
            }

            Py_DECREF( tmp_args_element_name_73 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2046;

                goto frame_exception_exit_10;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_2003, const_str_plain_packed, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2046;

                goto frame_exception_exit_10;
            }
        }
        {
            PyObject *tmp_called_name_70;
            PyObject *tmp_args_element_name_74;
            tmp_called_name_70 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_74 = MAKE_FUNCTION_ipaddress$$$function_120_is_multicast(  );



            frame_e3100639ef7adfb1b91bea0685b2bda9_10->m_frame.f_lineno = 2051;
            {
                PyObject *call_args[] = { tmp_args_element_name_74 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_70, call_args );
            }

            Py_DECREF( tmp_args_element_name_74 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2051;

                goto frame_exception_exit_10;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_2003, const_str_plain_is_multicast, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2051;

                goto frame_exception_exit_10;
            }
        }
        {
            PyObject *tmp_called_name_71;
            PyObject *tmp_args_element_name_75;
            tmp_called_name_71 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_75 = MAKE_FUNCTION_ipaddress$$$function_121_is_reserved(  );



            frame_e3100639ef7adfb1b91bea0685b2bda9_10->m_frame.f_lineno = 2062;
            {
                PyObject *call_args[] = { tmp_args_element_name_75 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_71, call_args );
            }

            Py_DECREF( tmp_args_element_name_75 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2062;

                goto frame_exception_exit_10;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_2003, const_str_plain_is_reserved, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2062;

                goto frame_exception_exit_10;
            }
        }
        {
            PyObject *tmp_called_name_72;
            PyObject *tmp_args_element_name_76;
            tmp_called_name_72 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_76 = MAKE_FUNCTION_ipaddress$$$function_122_is_link_local(  );



            frame_e3100639ef7adfb1b91bea0685b2bda9_10->m_frame.f_lineno = 2073;
            {
                PyObject *call_args[] = { tmp_args_element_name_76 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_72, call_args );
            }

            Py_DECREF( tmp_args_element_name_76 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2073;

                goto frame_exception_exit_10;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_2003, const_str_plain_is_link_local, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2073;

                goto frame_exception_exit_10;
            }
        }
        {
            PyObject *tmp_called_name_73;
            PyObject *tmp_args_element_name_77;
            tmp_called_name_73 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_77 = MAKE_FUNCTION_ipaddress$$$function_123_is_site_local(  );



            frame_e3100639ef7adfb1b91bea0685b2bda9_10->m_frame.f_lineno = 2083;
            {
                PyObject *call_args[] = { tmp_args_element_name_77 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_73, call_args );
            }

            Py_DECREF( tmp_args_element_name_77 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2083;

                goto frame_exception_exit_10;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_2003, const_str_plain_is_site_local, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2083;

                goto frame_exception_exit_10;
            }
        }
        {
            PyObject *tmp_called_name_74;
            PyObject *tmp_args_element_name_78;
            tmp_called_name_74 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_78 = MAKE_FUNCTION_ipaddress$$$function_124_is_private(  );



            frame_e3100639ef7adfb1b91bea0685b2bda9_10->m_frame.f_lineno = 2097;
            {
                PyObject *call_args[] = { tmp_args_element_name_78 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_74, call_args );
            }

            Py_DECREF( tmp_args_element_name_78 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2097;

                goto frame_exception_exit_10;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_2003, const_str_plain_is_private, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2097;

                goto frame_exception_exit_10;
            }
        }
        {
            PyObject *tmp_called_name_75;
            PyObject *tmp_args_element_name_79;
            tmp_called_name_75 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_79 = MAKE_FUNCTION_ipaddress$$$function_125_is_global(  );



            frame_e3100639ef7adfb1b91bea0685b2bda9_10->m_frame.f_lineno = 2108;
            {
                PyObject *call_args[] = { tmp_args_element_name_79 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_75, call_args );
            }

            Py_DECREF( tmp_args_element_name_79 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2108;

                goto frame_exception_exit_10;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_2003, const_str_plain_is_global, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2108;

                goto frame_exception_exit_10;
            }
        }
        {
            PyObject *tmp_called_name_76;
            PyObject *tmp_args_element_name_80;
            tmp_called_name_76 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_80 = MAKE_FUNCTION_ipaddress$$$function_126_is_unspecified(  );



            frame_e3100639ef7adfb1b91bea0685b2bda9_10->m_frame.f_lineno = 2119;
            {
                PyObject *call_args[] = { tmp_args_element_name_80 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_76, call_args );
            }

            Py_DECREF( tmp_args_element_name_80 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2119;

                goto frame_exception_exit_10;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_2003, const_str_plain_is_unspecified, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2119;

                goto frame_exception_exit_10;
            }
        }
        {
            PyObject *tmp_called_name_77;
            PyObject *tmp_args_element_name_81;
            tmp_called_name_77 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_81 = MAKE_FUNCTION_ipaddress$$$function_127_is_loopback(  );



            frame_e3100639ef7adfb1b91bea0685b2bda9_10->m_frame.f_lineno = 2130;
            {
                PyObject *call_args[] = { tmp_args_element_name_81 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_77, call_args );
            }

            Py_DECREF( tmp_args_element_name_81 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2130;

                goto frame_exception_exit_10;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_2003, const_str_plain_is_loopback, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2130;

                goto frame_exception_exit_10;
            }
        }
        {
            PyObject *tmp_called_name_78;
            PyObject *tmp_args_element_name_82;
            tmp_called_name_78 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_82 = MAKE_FUNCTION_ipaddress$$$function_128_ipv4_mapped(  );



            frame_e3100639ef7adfb1b91bea0685b2bda9_10->m_frame.f_lineno = 2141;
            {
                PyObject *call_args[] = { tmp_args_element_name_82 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_78, call_args );
            }

            Py_DECREF( tmp_args_element_name_82 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2141;

                goto frame_exception_exit_10;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_2003, const_str_plain_ipv4_mapped, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2141;

                goto frame_exception_exit_10;
            }
        }
        {
            PyObject *tmp_called_name_79;
            PyObject *tmp_args_element_name_83;
            tmp_called_name_79 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_83 = MAKE_FUNCTION_ipaddress$$$function_129_teredo(  );



            frame_e3100639ef7adfb1b91bea0685b2bda9_10->m_frame.f_lineno = 2154;
            {
                PyObject *call_args[] = { tmp_args_element_name_83 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_79, call_args );
            }

            Py_DECREF( tmp_args_element_name_83 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2154;

                goto frame_exception_exit_10;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_2003, const_str_plain_teredo, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2154;

                goto frame_exception_exit_10;
            }
        }
        {
            PyObject *tmp_called_name_80;
            PyObject *tmp_args_element_name_84;
            tmp_called_name_80 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_84 = MAKE_FUNCTION_ipaddress$$$function_130_sixtofour(  );



            frame_e3100639ef7adfb1b91bea0685b2bda9_10->m_frame.f_lineno = 2169;
            {
                PyObject *call_args[] = { tmp_args_element_name_84 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_80, call_args );
            }

            Py_DECREF( tmp_args_element_name_84 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2169;

                goto frame_exception_exit_10;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_2003, const_str_plain_sixtofour, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2169;

                goto frame_exception_exit_10;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_e3100639ef7adfb1b91bea0685b2bda9_10 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_9;

        frame_exception_exit_10:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_e3100639ef7adfb1b91bea0685b2bda9_10 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_e3100639ef7adfb1b91bea0685b2bda9_10, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_e3100639ef7adfb1b91bea0685b2bda9_10->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_e3100639ef7adfb1b91bea0685b2bda9_10, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_e3100639ef7adfb1b91bea0685b2bda9_10,
            type_description_2
        );


        // Release cached frame.
        if ( frame_e3100639ef7adfb1b91bea0685b2bda9_10 == cache_frame_e3100639ef7adfb1b91bea0685b2bda9_10 )
        {
            Py_DECREF( frame_e3100639ef7adfb1b91bea0685b2bda9_10 );
        }
        cache_frame_e3100639ef7adfb1b91bea0685b2bda9_10 = NULL;

        assertFrameObject( frame_e3100639ef7adfb1b91bea0685b2bda9_10 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_9;

        frame_no_exception_9:;
        goto skip_nested_handling_9;
        nested_frame_exit_9:;

        goto try_except_handler_37;
        skip_nested_handling_9:;
        tmp_assign_source_97 = locals_ipaddress_2003;
        Py_INCREF( tmp_assign_source_97 );
        goto try_return_handler_37;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_37:;
        Py_DECREF( locals_ipaddress_2003 );
        locals_ipaddress_2003 = NULL;
        goto outline_result_17;
        // Exception handler code:
        try_except_handler_37:;
        exception_keeper_type_28 = exception_type;
        exception_keeper_value_28 = exception_value;
        exception_keeper_tb_28 = exception_tb;
        exception_keeper_lineno_28 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_ipaddress_2003 );
        locals_ipaddress_2003 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_28;
        exception_value = exception_keeper_value_28;
        exception_tb = exception_keeper_tb_28;
        exception_lineno = exception_keeper_lineno_28;

        goto outline_exception_9;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_9:;
        exception_lineno = 2003;
        goto try_except_handler_36;
        outline_result_17:;
        assert( tmp_class_creation_13__class_dict == NULL );
        tmp_class_creation_13__class_dict = tmp_assign_source_97;
    }
    {
        PyObject *tmp_assign_source_98;
        nuitka_bool tmp_condition_result_15;
        PyObject *tmp_key_name_25;
        PyObject *tmp_dict_name_25;
        PyObject *tmp_dict_name_26;
        PyObject *tmp_key_name_26;
        tmp_key_name_25 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_13__class_dict );
        tmp_dict_name_25 = tmp_class_creation_13__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_25, tmp_key_name_25 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2003;

            goto try_except_handler_36;
        }
        tmp_condition_result_15 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_15 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_13;
        }
        else
        {
            goto condexpr_false_13;
        }
        condexpr_true_13:;
        CHECK_OBJECT( tmp_class_creation_13__class_dict );
        tmp_dict_name_26 = tmp_class_creation_13__class_dict;
        tmp_key_name_26 = const_str_plain___metaclass__;
        tmp_assign_source_98 = DICT_GET_ITEM( tmp_dict_name_26, tmp_key_name_26 );
        if ( tmp_assign_source_98 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2003;

            goto try_except_handler_36;
        }
        goto condexpr_end_13;
        condexpr_false_13:;
        {
            PyObject *tmp_assign_source_99;
            PyObject *tmp_subscribed_name_7;
            PyObject *tmp_subscript_name_7;
            CHECK_OBJECT( tmp_class_creation_13__bases );
            tmp_subscribed_name_7 = tmp_class_creation_13__bases;
            tmp_subscript_name_7 = const_int_0;
            tmp_assign_source_99 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_7, tmp_subscript_name_7, 0 );
            if ( tmp_assign_source_99 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2003;

                goto try_except_handler_36;
            }
            assert( tmp_select_metaclass_13__base == NULL );
            tmp_select_metaclass_13__base = tmp_assign_source_99;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_9;
            CHECK_OBJECT( tmp_select_metaclass_13__base );
            tmp_source_name_9 = tmp_select_metaclass_13__base;
            tmp_assign_source_98 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_9 );
            if ( tmp_assign_source_98 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2003;

                goto try_except_handler_39;
            }
            goto try_return_handler_38;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        // Exception handler code:
        try_except_handler_39:;
        exception_keeper_type_29 = exception_type;
        exception_keeper_value_29 = exception_value;
        exception_keeper_tb_29 = exception_tb;
        exception_keeper_lineno_29 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_7;
            Py_DECREF( exception_keeper_type_29 );
            Py_XDECREF( exception_keeper_value_29 );
            Py_XDECREF( exception_keeper_tb_29 );
            CHECK_OBJECT( tmp_select_metaclass_13__base );
            tmp_type_arg_7 = tmp_select_metaclass_13__base;
            tmp_assign_source_98 = BUILTIN_TYPE1( tmp_type_arg_7 );
            assert( !(tmp_assign_source_98 == NULL) );
            goto try_return_handler_38;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_38:;
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_13__base );
        Py_DECREF( tmp_select_metaclass_13__base );
        tmp_select_metaclass_13__base = NULL;

        goto outline_result_18;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_13__base );
        Py_DECREF( tmp_select_metaclass_13__base );
        tmp_select_metaclass_13__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        outline_result_18:;
        condexpr_end_13:;
        assert( tmp_class_creation_13__metaclass == NULL );
        tmp_class_creation_13__metaclass = tmp_assign_source_98;
    }
    {
        PyObject *tmp_assign_source_100;
        PyObject *tmp_called_name_81;
        PyObject *tmp_args_element_name_85;
        PyObject *tmp_args_element_name_86;
        PyObject *tmp_args_element_name_87;
        CHECK_OBJECT( tmp_class_creation_13__metaclass );
        tmp_called_name_81 = tmp_class_creation_13__metaclass;
        tmp_args_element_name_85 = const_str_plain_IPv6Address;
        CHECK_OBJECT( tmp_class_creation_13__bases );
        tmp_args_element_name_86 = tmp_class_creation_13__bases;
        CHECK_OBJECT( tmp_class_creation_13__class_dict );
        tmp_args_element_name_87 = tmp_class_creation_13__class_dict;
        frame_a10b4ee15c0763ecce4ab0022f0f5fa7->m_frame.f_lineno = 2003;
        {
            PyObject *call_args[] = { tmp_args_element_name_85, tmp_args_element_name_86, tmp_args_element_name_87 };
            tmp_assign_source_100 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_81, call_args );
        }

        if ( tmp_assign_source_100 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2003;

            goto try_except_handler_36;
        }
        assert( tmp_class_creation_13__class == NULL );
        tmp_class_creation_13__class = tmp_assign_source_100;
    }
    goto try_end_14;
    // Exception handler code:
    try_except_handler_36:;
    exception_keeper_type_30 = exception_type;
    exception_keeper_value_30 = exception_value;
    exception_keeper_tb_30 = exception_tb;
    exception_keeper_lineno_30 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_13__bases );
    tmp_class_creation_13__bases = NULL;

    Py_XDECREF( tmp_class_creation_13__class_dict );
    tmp_class_creation_13__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_13__metaclass );
    tmp_class_creation_13__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_30;
    exception_value = exception_keeper_value_30;
    exception_tb = exception_keeper_tb_30;
    exception_lineno = exception_keeper_lineno_30;

    goto frame_exception_exit_1;
    // End of try:
    try_end_14:;
    {
        PyObject *tmp_assign_source_101;
        CHECK_OBJECT( tmp_class_creation_13__class );
        tmp_assign_source_101 = tmp_class_creation_13__class;
        UPDATE_STRING_DICT0( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Address, tmp_assign_source_101 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_13__class );
    Py_DECREF( tmp_class_creation_13__class );
    tmp_class_creation_13__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_13__bases );
    Py_DECREF( tmp_class_creation_13__bases );
    tmp_class_creation_13__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_13__class_dict );
    Py_DECREF( tmp_class_creation_13__class_dict );
    tmp_class_creation_13__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_13__metaclass );
    Py_DECREF( tmp_class_creation_13__metaclass );
    tmp_class_creation_13__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_102;
        PyObject *tmp_tuple_element_8;
        PyObject *tmp_mvar_value_39;
        tmp_mvar_value_39 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Address );

        if (unlikely( tmp_mvar_value_39 == NULL ))
        {
            tmp_mvar_value_39 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Address );
        }

        if ( tmp_mvar_value_39 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv6Address" );
            exception_tb = NULL;

            exception_lineno = 2183;

            goto try_except_handler_40;
        }

        tmp_tuple_element_8 = tmp_mvar_value_39;
        tmp_assign_source_102 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_8 );
        PyTuple_SET_ITEM( tmp_assign_source_102, 0, tmp_tuple_element_8 );
        assert( tmp_class_creation_14__bases == NULL );
        tmp_class_creation_14__bases = tmp_assign_source_102;
    }
    {
        PyObject *tmp_assign_source_103;
        {
            PyObject *tmp_set_locals_11;
            tmp_set_locals_11 = PyDict_New();
            locals_ipaddress_2183 = tmp_set_locals_11;
        }
        tmp_dictset_value = const_str_plain_ipaddress;
        tmp_res = PyDict_SetItem( locals_ipaddress_2183, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_131___init__(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_2183, const_str_plain___init__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_132___str__(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_2183, const_str_plain___str__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_133___eq__(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_2183, const_str_plain___eq__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_134___lt__(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_2183, const_str_plain___lt__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_135___hash__(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_2183, const_str_plain___hash__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        MAKE_OR_REUSE_FRAME( cache_frame_978c64aaac40067740426a6582d720f1_11, codeobj_978c64aaac40067740426a6582d720f1, module_ipaddress, 0 );
        frame_978c64aaac40067740426a6582d720f1_11 = cache_frame_978c64aaac40067740426a6582d720f1_11;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_978c64aaac40067740426a6582d720f1_11 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_978c64aaac40067740426a6582d720f1_11 ) == 2 ); // Frame stack

        // Framed code:
        {
            PyObject *tmp_source_name_10;
            PyObject *tmp_mvar_value_40;
            tmp_mvar_value_40 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__IPAddressBase );

            if (unlikely( tmp_mvar_value_40 == NULL ))
            {
                tmp_mvar_value_40 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__IPAddressBase );
            }

            if ( tmp_mvar_value_40 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "_IPAddressBase" );
                exception_tb = NULL;

                exception_lineno = 2239;

                goto frame_exception_exit_11;
            }

            tmp_source_name_10 = tmp_mvar_value_40;
            tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain___reduce__ );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2239;

                goto frame_exception_exit_11;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_2183, const_str_plain___reduce__, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2239;

                goto frame_exception_exit_11;
            }
        }
        {
            PyObject *tmp_called_name_82;
            PyObject *tmp_args_element_name_88;
            tmp_called_name_82 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_88 = MAKE_FUNCTION_ipaddress$$$function_136_ip(  );



            frame_978c64aaac40067740426a6582d720f1_11->m_frame.f_lineno = 2241;
            {
                PyObject *call_args[] = { tmp_args_element_name_88 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_82, call_args );
            }

            Py_DECREF( tmp_args_element_name_88 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2241;

                goto frame_exception_exit_11;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_2183, const_str_plain_ip, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2241;

                goto frame_exception_exit_11;
            }
        }
        {
            PyObject *tmp_called_name_83;
            PyObject *tmp_args_element_name_89;
            tmp_called_name_83 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_89 = MAKE_FUNCTION_ipaddress$$$function_137_with_prefixlen(  );



            frame_978c64aaac40067740426a6582d720f1_11->m_frame.f_lineno = 2245;
            {
                PyObject *call_args[] = { tmp_args_element_name_89 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_83, call_args );
            }

            Py_DECREF( tmp_args_element_name_89 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2245;

                goto frame_exception_exit_11;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_2183, const_str_plain_with_prefixlen, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2245;

                goto frame_exception_exit_11;
            }
        }
        {
            PyObject *tmp_called_name_84;
            PyObject *tmp_args_element_name_90;
            tmp_called_name_84 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_90 = MAKE_FUNCTION_ipaddress$$$function_138_with_netmask(  );



            frame_978c64aaac40067740426a6582d720f1_11->m_frame.f_lineno = 2250;
            {
                PyObject *call_args[] = { tmp_args_element_name_90 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_84, call_args );
            }

            Py_DECREF( tmp_args_element_name_90 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2250;

                goto frame_exception_exit_11;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_2183, const_str_plain_with_netmask, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2250;

                goto frame_exception_exit_11;
            }
        }
        {
            PyObject *tmp_called_name_85;
            PyObject *tmp_args_element_name_91;
            tmp_called_name_85 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_91 = MAKE_FUNCTION_ipaddress$$$function_139_with_hostmask(  );



            frame_978c64aaac40067740426a6582d720f1_11->m_frame.f_lineno = 2255;
            {
                PyObject *call_args[] = { tmp_args_element_name_91 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_85, call_args );
            }

            Py_DECREF( tmp_args_element_name_91 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2255;

                goto frame_exception_exit_11;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_2183, const_str_plain_with_hostmask, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2255;

                goto frame_exception_exit_11;
            }
        }
        {
            PyObject *tmp_called_name_86;
            PyObject *tmp_args_element_name_92;
            tmp_called_name_86 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_92 = MAKE_FUNCTION_ipaddress$$$function_140_is_unspecified(  );



            frame_978c64aaac40067740426a6582d720f1_11->m_frame.f_lineno = 2260;
            {
                PyObject *call_args[] = { tmp_args_element_name_92 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_86, call_args );
            }

            Py_DECREF( tmp_args_element_name_92 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2260;

                goto frame_exception_exit_11;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_2183, const_str_plain_is_unspecified, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2260;

                goto frame_exception_exit_11;
            }
        }
        {
            PyObject *tmp_called_name_87;
            PyObject *tmp_args_element_name_93;
            tmp_called_name_87 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_93 = MAKE_FUNCTION_ipaddress$$$function_141_is_loopback(  );



            frame_978c64aaac40067740426a6582d720f1_11->m_frame.f_lineno = 2264;
            {
                PyObject *call_args[] = { tmp_args_element_name_93 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_87, call_args );
            }

            Py_DECREF( tmp_args_element_name_93 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2264;

                goto frame_exception_exit_11;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_2183, const_str_plain_is_loopback, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2264;

                goto frame_exception_exit_11;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_978c64aaac40067740426a6582d720f1_11 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_10;

        frame_exception_exit_11:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_978c64aaac40067740426a6582d720f1_11 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_978c64aaac40067740426a6582d720f1_11, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_978c64aaac40067740426a6582d720f1_11->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_978c64aaac40067740426a6582d720f1_11, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_978c64aaac40067740426a6582d720f1_11,
            type_description_2
        );


        // Release cached frame.
        if ( frame_978c64aaac40067740426a6582d720f1_11 == cache_frame_978c64aaac40067740426a6582d720f1_11 )
        {
            Py_DECREF( frame_978c64aaac40067740426a6582d720f1_11 );
        }
        cache_frame_978c64aaac40067740426a6582d720f1_11 = NULL;

        assertFrameObject( frame_978c64aaac40067740426a6582d720f1_11 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_10;

        frame_no_exception_10:;
        goto skip_nested_handling_10;
        nested_frame_exit_10:;

        goto try_except_handler_41;
        skip_nested_handling_10:;
        tmp_assign_source_103 = locals_ipaddress_2183;
        Py_INCREF( tmp_assign_source_103 );
        goto try_return_handler_41;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_41:;
        Py_DECREF( locals_ipaddress_2183 );
        locals_ipaddress_2183 = NULL;
        goto outline_result_19;
        // Exception handler code:
        try_except_handler_41:;
        exception_keeper_type_31 = exception_type;
        exception_keeper_value_31 = exception_value;
        exception_keeper_tb_31 = exception_tb;
        exception_keeper_lineno_31 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_ipaddress_2183 );
        locals_ipaddress_2183 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_31;
        exception_value = exception_keeper_value_31;
        exception_tb = exception_keeper_tb_31;
        exception_lineno = exception_keeper_lineno_31;

        goto outline_exception_10;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_10:;
        exception_lineno = 2183;
        goto try_except_handler_40;
        outline_result_19:;
        assert( tmp_class_creation_14__class_dict == NULL );
        tmp_class_creation_14__class_dict = tmp_assign_source_103;
    }
    {
        PyObject *tmp_assign_source_104;
        nuitka_bool tmp_condition_result_16;
        PyObject *tmp_key_name_27;
        PyObject *tmp_dict_name_27;
        PyObject *tmp_dict_name_28;
        PyObject *tmp_key_name_28;
        tmp_key_name_27 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_14__class_dict );
        tmp_dict_name_27 = tmp_class_creation_14__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_27, tmp_key_name_27 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2183;

            goto try_except_handler_40;
        }
        tmp_condition_result_16 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_16 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_14;
        }
        else
        {
            goto condexpr_false_14;
        }
        condexpr_true_14:;
        CHECK_OBJECT( tmp_class_creation_14__class_dict );
        tmp_dict_name_28 = tmp_class_creation_14__class_dict;
        tmp_key_name_28 = const_str_plain___metaclass__;
        tmp_assign_source_104 = DICT_GET_ITEM( tmp_dict_name_28, tmp_key_name_28 );
        if ( tmp_assign_source_104 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2183;

            goto try_except_handler_40;
        }
        goto condexpr_end_14;
        condexpr_false_14:;
        {
            PyObject *tmp_assign_source_105;
            PyObject *tmp_subscribed_name_8;
            PyObject *tmp_subscript_name_8;
            CHECK_OBJECT( tmp_class_creation_14__bases );
            tmp_subscribed_name_8 = tmp_class_creation_14__bases;
            tmp_subscript_name_8 = const_int_0;
            tmp_assign_source_105 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_8, tmp_subscript_name_8, 0 );
            if ( tmp_assign_source_105 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2183;

                goto try_except_handler_40;
            }
            assert( tmp_select_metaclass_14__base == NULL );
            tmp_select_metaclass_14__base = tmp_assign_source_105;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_11;
            CHECK_OBJECT( tmp_select_metaclass_14__base );
            tmp_source_name_11 = tmp_select_metaclass_14__base;
            tmp_assign_source_104 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_11 );
            if ( tmp_assign_source_104 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2183;

                goto try_except_handler_43;
            }
            goto try_return_handler_42;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        // Exception handler code:
        try_except_handler_43:;
        exception_keeper_type_32 = exception_type;
        exception_keeper_value_32 = exception_value;
        exception_keeper_tb_32 = exception_tb;
        exception_keeper_lineno_32 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_8;
            Py_DECREF( exception_keeper_type_32 );
            Py_XDECREF( exception_keeper_value_32 );
            Py_XDECREF( exception_keeper_tb_32 );
            CHECK_OBJECT( tmp_select_metaclass_14__base );
            tmp_type_arg_8 = tmp_select_metaclass_14__base;
            tmp_assign_source_104 = BUILTIN_TYPE1( tmp_type_arg_8 );
            assert( !(tmp_assign_source_104 == NULL) );
            goto try_return_handler_42;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_42:;
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_14__base );
        Py_DECREF( tmp_select_metaclass_14__base );
        tmp_select_metaclass_14__base = NULL;

        goto outline_result_20;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_14__base );
        Py_DECREF( tmp_select_metaclass_14__base );
        tmp_select_metaclass_14__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        outline_result_20:;
        condexpr_end_14:;
        assert( tmp_class_creation_14__metaclass == NULL );
        tmp_class_creation_14__metaclass = tmp_assign_source_104;
    }
    {
        PyObject *tmp_assign_source_106;
        PyObject *tmp_called_name_88;
        PyObject *tmp_args_element_name_94;
        PyObject *tmp_args_element_name_95;
        PyObject *tmp_args_element_name_96;
        CHECK_OBJECT( tmp_class_creation_14__metaclass );
        tmp_called_name_88 = tmp_class_creation_14__metaclass;
        tmp_args_element_name_94 = const_str_plain_IPv6Interface;
        CHECK_OBJECT( tmp_class_creation_14__bases );
        tmp_args_element_name_95 = tmp_class_creation_14__bases;
        CHECK_OBJECT( tmp_class_creation_14__class_dict );
        tmp_args_element_name_96 = tmp_class_creation_14__class_dict;
        frame_a10b4ee15c0763ecce4ab0022f0f5fa7->m_frame.f_lineno = 2183;
        {
            PyObject *call_args[] = { tmp_args_element_name_94, tmp_args_element_name_95, tmp_args_element_name_96 };
            tmp_assign_source_106 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_88, call_args );
        }

        if ( tmp_assign_source_106 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2183;

            goto try_except_handler_40;
        }
        assert( tmp_class_creation_14__class == NULL );
        tmp_class_creation_14__class = tmp_assign_source_106;
    }
    goto try_end_15;
    // Exception handler code:
    try_except_handler_40:;
    exception_keeper_type_33 = exception_type;
    exception_keeper_value_33 = exception_value;
    exception_keeper_tb_33 = exception_tb;
    exception_keeper_lineno_33 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_14__bases );
    tmp_class_creation_14__bases = NULL;

    Py_XDECREF( tmp_class_creation_14__class_dict );
    tmp_class_creation_14__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_14__metaclass );
    tmp_class_creation_14__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_33;
    exception_value = exception_keeper_value_33;
    exception_tb = exception_keeper_tb_33;
    exception_lineno = exception_keeper_lineno_33;

    goto frame_exception_exit_1;
    // End of try:
    try_end_15:;
    {
        PyObject *tmp_assign_source_107;
        CHECK_OBJECT( tmp_class_creation_14__class );
        tmp_assign_source_107 = tmp_class_creation_14__class;
        UPDATE_STRING_DICT0( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Interface, tmp_assign_source_107 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_14__class );
    Py_DECREF( tmp_class_creation_14__class );
    tmp_class_creation_14__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_14__bases );
    Py_DECREF( tmp_class_creation_14__bases );
    tmp_class_creation_14__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_14__class_dict );
    Py_DECREF( tmp_class_creation_14__class_dict );
    tmp_class_creation_14__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_14__metaclass );
    Py_DECREF( tmp_class_creation_14__metaclass );
    tmp_class_creation_14__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_108;
        PyObject *tmp_tuple_element_9;
        PyObject *tmp_mvar_value_41;
        PyObject *tmp_mvar_value_42;
        tmp_mvar_value_41 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__BaseV6 );

        if (unlikely( tmp_mvar_value_41 == NULL ))
        {
            tmp_mvar_value_41 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__BaseV6 );
        }

        if ( tmp_mvar_value_41 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_BaseV6" );
            exception_tb = NULL;

            exception_lineno = 2269;

            goto try_except_handler_44;
        }

        tmp_tuple_element_9 = tmp_mvar_value_41;
        tmp_assign_source_108 = PyTuple_New( 2 );
        Py_INCREF( tmp_tuple_element_9 );
        PyTuple_SET_ITEM( tmp_assign_source_108, 0, tmp_tuple_element_9 );
        tmp_mvar_value_42 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__BaseNetwork );

        if (unlikely( tmp_mvar_value_42 == NULL ))
        {
            tmp_mvar_value_42 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__BaseNetwork );
        }

        if ( tmp_mvar_value_42 == NULL )
        {
            Py_DECREF( tmp_assign_source_108 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_BaseNetwork" );
            exception_tb = NULL;

            exception_lineno = 2269;

            goto try_except_handler_44;
        }

        tmp_tuple_element_9 = tmp_mvar_value_42;
        Py_INCREF( tmp_tuple_element_9 );
        PyTuple_SET_ITEM( tmp_assign_source_108, 1, tmp_tuple_element_9 );
        assert( tmp_class_creation_15__bases == NULL );
        tmp_class_creation_15__bases = tmp_assign_source_108;
    }
    {
        PyObject *tmp_assign_source_109;
        {
            PyObject *tmp_set_locals_12;
            tmp_set_locals_12 = PyDict_New();
            locals_ipaddress_2269 = tmp_set_locals_12;
        }
        tmp_dictset_value = const_str_plain_ipaddress;
        tmp_res = PyDict_SetItem( locals_ipaddress_2269, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_unicode_digest_0210282788da1a1bc7085fe52fd6486f;
        tmp_res = PyDict_SetItem( locals_ipaddress_2269, const_str_plain___doc__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        MAKE_OR_REUSE_FRAME( cache_frame_eede468f789883f6726171dca68e049c_12, codeobj_eede468f789883f6726171dca68e049c, module_ipaddress, 0 );
        frame_eede468f789883f6726171dca68e049c_12 = cache_frame_eede468f789883f6726171dca68e049c_12;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_eede468f789883f6726171dca68e049c_12 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_eede468f789883f6726171dca68e049c_12 ) == 2 ); // Frame stack

        // Framed code:
        {
            PyObject *tmp_mvar_value_43;
            tmp_mvar_value_43 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Address );

            if (unlikely( tmp_mvar_value_43 == NULL ))
            {
                tmp_mvar_value_43 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Address );
            }

            if ( tmp_mvar_value_43 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv6Address" );
                exception_tb = NULL;

                exception_lineno = 2283;

                goto frame_exception_exit_12;
            }

            tmp_dictset_value = tmp_mvar_value_43;
            tmp_res = PyDict_SetItem( locals_ipaddress_2269, const_str_plain__address_class, tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2283;

                goto frame_exception_exit_12;
            }
        }
        {
            PyObject *tmp_defaults_7;
            tmp_defaults_7 = const_tuple_true_tuple;
            Py_INCREF( tmp_defaults_7 );
            tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_142___init__( tmp_defaults_7 );



            tmp_res = PyDict_SetItem( locals_ipaddress_2269, const_str_plain___init__, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            assert( !(tmp_res != 0) );
        }
        tmp_dictset_value = MAKE_FUNCTION_ipaddress$$$function_143_hosts(  );



        tmp_res = PyDict_SetItem( locals_ipaddress_2269, const_str_plain_hosts, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_called_name_89;
            PyObject *tmp_args_element_name_97;
            tmp_called_name_89 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_97 = MAKE_FUNCTION_ipaddress$$$function_144_is_site_local(  );



            frame_eede468f789883f6726171dca68e049c_12->m_frame.f_lineno = 2376;
            {
                PyObject *call_args[] = { tmp_args_element_name_97 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_89, call_args );
            }

            Py_DECREF( tmp_args_element_name_97 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2376;

                goto frame_exception_exit_12;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_2269, const_str_plain_is_site_local, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2376;

                goto frame_exception_exit_12;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_eede468f789883f6726171dca68e049c_12 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_11;

        frame_exception_exit_12:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_eede468f789883f6726171dca68e049c_12 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_eede468f789883f6726171dca68e049c_12, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_eede468f789883f6726171dca68e049c_12->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_eede468f789883f6726171dca68e049c_12, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_eede468f789883f6726171dca68e049c_12,
            type_description_2
        );


        // Release cached frame.
        if ( frame_eede468f789883f6726171dca68e049c_12 == cache_frame_eede468f789883f6726171dca68e049c_12 )
        {
            Py_DECREF( frame_eede468f789883f6726171dca68e049c_12 );
        }
        cache_frame_eede468f789883f6726171dca68e049c_12 = NULL;

        assertFrameObject( frame_eede468f789883f6726171dca68e049c_12 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_11;

        frame_no_exception_11:;
        goto skip_nested_handling_11;
        nested_frame_exit_11:;

        goto try_except_handler_45;
        skip_nested_handling_11:;
        tmp_assign_source_109 = locals_ipaddress_2269;
        Py_INCREF( tmp_assign_source_109 );
        goto try_return_handler_45;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_45:;
        Py_DECREF( locals_ipaddress_2269 );
        locals_ipaddress_2269 = NULL;
        goto outline_result_21;
        // Exception handler code:
        try_except_handler_45:;
        exception_keeper_type_34 = exception_type;
        exception_keeper_value_34 = exception_value;
        exception_keeper_tb_34 = exception_tb;
        exception_keeper_lineno_34 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_ipaddress_2269 );
        locals_ipaddress_2269 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_34;
        exception_value = exception_keeper_value_34;
        exception_tb = exception_keeper_tb_34;
        exception_lineno = exception_keeper_lineno_34;

        goto outline_exception_11;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_11:;
        exception_lineno = 2269;
        goto try_except_handler_44;
        outline_result_21:;
        assert( tmp_class_creation_15__class_dict == NULL );
        tmp_class_creation_15__class_dict = tmp_assign_source_109;
    }
    {
        PyObject *tmp_assign_source_110;
        nuitka_bool tmp_condition_result_17;
        PyObject *tmp_key_name_29;
        PyObject *tmp_dict_name_29;
        PyObject *tmp_dict_name_30;
        PyObject *tmp_key_name_30;
        tmp_key_name_29 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_15__class_dict );
        tmp_dict_name_29 = tmp_class_creation_15__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_29, tmp_key_name_29 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2269;

            goto try_except_handler_44;
        }
        tmp_condition_result_17 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_17 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_15;
        }
        else
        {
            goto condexpr_false_15;
        }
        condexpr_true_15:;
        CHECK_OBJECT( tmp_class_creation_15__class_dict );
        tmp_dict_name_30 = tmp_class_creation_15__class_dict;
        tmp_key_name_30 = const_str_plain___metaclass__;
        tmp_assign_source_110 = DICT_GET_ITEM( tmp_dict_name_30, tmp_key_name_30 );
        if ( tmp_assign_source_110 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2269;

            goto try_except_handler_44;
        }
        goto condexpr_end_15;
        condexpr_false_15:;
        {
            PyObject *tmp_assign_source_111;
            PyObject *tmp_subscribed_name_9;
            PyObject *tmp_subscript_name_9;
            CHECK_OBJECT( tmp_class_creation_15__bases );
            tmp_subscribed_name_9 = tmp_class_creation_15__bases;
            tmp_subscript_name_9 = const_int_0;
            tmp_assign_source_111 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_9, tmp_subscript_name_9, 0 );
            if ( tmp_assign_source_111 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2269;

                goto try_except_handler_44;
            }
            assert( tmp_select_metaclass_15__base == NULL );
            tmp_select_metaclass_15__base = tmp_assign_source_111;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_12;
            CHECK_OBJECT( tmp_select_metaclass_15__base );
            tmp_source_name_12 = tmp_select_metaclass_15__base;
            tmp_assign_source_110 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_12 );
            if ( tmp_assign_source_110 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2269;

                goto try_except_handler_47;
            }
            goto try_return_handler_46;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        // Exception handler code:
        try_except_handler_47:;
        exception_keeper_type_35 = exception_type;
        exception_keeper_value_35 = exception_value;
        exception_keeper_tb_35 = exception_tb;
        exception_keeper_lineno_35 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_9;
            Py_DECREF( exception_keeper_type_35 );
            Py_XDECREF( exception_keeper_value_35 );
            Py_XDECREF( exception_keeper_tb_35 );
            CHECK_OBJECT( tmp_select_metaclass_15__base );
            tmp_type_arg_9 = tmp_select_metaclass_15__base;
            tmp_assign_source_110 = BUILTIN_TYPE1( tmp_type_arg_9 );
            assert( !(tmp_assign_source_110 == NULL) );
            goto try_return_handler_46;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_46:;
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_15__base );
        Py_DECREF( tmp_select_metaclass_15__base );
        tmp_select_metaclass_15__base = NULL;

        goto outline_result_22;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_15__base );
        Py_DECREF( tmp_select_metaclass_15__base );
        tmp_select_metaclass_15__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        outline_result_22:;
        condexpr_end_15:;
        assert( tmp_class_creation_15__metaclass == NULL );
        tmp_class_creation_15__metaclass = tmp_assign_source_110;
    }
    {
        PyObject *tmp_assign_source_112;
        PyObject *tmp_called_name_90;
        PyObject *tmp_args_element_name_98;
        PyObject *tmp_args_element_name_99;
        PyObject *tmp_args_element_name_100;
        CHECK_OBJECT( tmp_class_creation_15__metaclass );
        tmp_called_name_90 = tmp_class_creation_15__metaclass;
        tmp_args_element_name_98 = const_str_plain_IPv6Network;
        CHECK_OBJECT( tmp_class_creation_15__bases );
        tmp_args_element_name_99 = tmp_class_creation_15__bases;
        CHECK_OBJECT( tmp_class_creation_15__class_dict );
        tmp_args_element_name_100 = tmp_class_creation_15__class_dict;
        frame_a10b4ee15c0763ecce4ab0022f0f5fa7->m_frame.f_lineno = 2269;
        {
            PyObject *call_args[] = { tmp_args_element_name_98, tmp_args_element_name_99, tmp_args_element_name_100 };
            tmp_assign_source_112 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_90, call_args );
        }

        if ( tmp_assign_source_112 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2269;

            goto try_except_handler_44;
        }
        assert( tmp_class_creation_15__class == NULL );
        tmp_class_creation_15__class = tmp_assign_source_112;
    }
    goto try_end_16;
    // Exception handler code:
    try_except_handler_44:;
    exception_keeper_type_36 = exception_type;
    exception_keeper_value_36 = exception_value;
    exception_keeper_tb_36 = exception_tb;
    exception_keeper_lineno_36 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_15__bases );
    tmp_class_creation_15__bases = NULL;

    Py_XDECREF( tmp_class_creation_15__class_dict );
    tmp_class_creation_15__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_15__metaclass );
    tmp_class_creation_15__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_36;
    exception_value = exception_keeper_value_36;
    exception_tb = exception_keeper_tb_36;
    exception_lineno = exception_keeper_lineno_36;

    goto frame_exception_exit_1;
    // End of try:
    try_end_16:;
    {
        PyObject *tmp_assign_source_113;
        CHECK_OBJECT( tmp_class_creation_15__class );
        tmp_assign_source_113 = tmp_class_creation_15__class;
        UPDATE_STRING_DICT0( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Network, tmp_assign_source_113 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_15__class );
    Py_DECREF( tmp_class_creation_15__class );
    tmp_class_creation_15__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_15__bases );
    Py_DECREF( tmp_class_creation_15__bases );
    tmp_class_creation_15__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_15__class_dict );
    Py_DECREF( tmp_class_creation_15__class_dict );
    tmp_class_creation_15__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_15__metaclass );
    Py_DECREF( tmp_class_creation_15__metaclass );
    tmp_class_creation_15__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_114;
        {
            PyObject *tmp_set_locals_13;
            tmp_set_locals_13 = PyDict_New();
            locals_ipaddress_2392 = tmp_set_locals_13;
        }
        tmp_dictset_value = const_str_plain_ipaddress;
        tmp_res = PyDict_SetItem( locals_ipaddress_2392, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        MAKE_OR_REUSE_FRAME( cache_frame_e4f047505da49281bb85f001a8969afe_13, codeobj_e4f047505da49281bb85f001a8969afe, module_ipaddress, 0 );
        frame_e4f047505da49281bb85f001a8969afe_13 = cache_frame_e4f047505da49281bb85f001a8969afe_13;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_e4f047505da49281bb85f001a8969afe_13 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_e4f047505da49281bb85f001a8969afe_13 ) == 2 ); // Frame stack

        // Framed code:
        {
            PyObject *tmp_called_name_91;
            PyObject *tmp_mvar_value_44;
            tmp_mvar_value_44 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Network );

            if (unlikely( tmp_mvar_value_44 == NULL ))
            {
                tmp_mvar_value_44 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Network );
            }

            if ( tmp_mvar_value_44 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv6Network" );
                exception_tb = NULL;

                exception_lineno = 2394;

                goto frame_exception_exit_13;
            }

            tmp_called_name_91 = tmp_mvar_value_44;
            frame_e4f047505da49281bb85f001a8969afe_13->m_frame.f_lineno = 2394;
            tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_91, &PyTuple_GET_ITEM( const_tuple_unicode_digest_aaa8df82589e3fcc3c5dc300a83c6345_tuple, 0 ) );

            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2394;

                goto frame_exception_exit_13;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_2392, const_str_plain__linklocal_network, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2394;

                goto frame_exception_exit_13;
            }
        }
        {
            PyObject *tmp_called_name_92;
            PyObject *tmp_mvar_value_45;
            tmp_mvar_value_45 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Network );

            if (unlikely( tmp_mvar_value_45 == NULL ))
            {
                tmp_mvar_value_45 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Network );
            }

            if ( tmp_mvar_value_45 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv6Network" );
                exception_tb = NULL;

                exception_lineno = 2396;

                goto frame_exception_exit_13;
            }

            tmp_called_name_92 = tmp_mvar_value_45;
            frame_e4f047505da49281bb85f001a8969afe_13->m_frame.f_lineno = 2396;
            tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_92, &PyTuple_GET_ITEM( const_tuple_unicode_digest_e4b0d176f96493dd1d5d8cbd14cab77e_tuple, 0 ) );

            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2396;

                goto frame_exception_exit_13;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_2392, const_str_plain__multicast_network, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2396;

                goto frame_exception_exit_13;
            }
        }
        {
            PyObject *tmp_list_element_2;
            PyObject *tmp_called_name_93;
            PyObject *tmp_mvar_value_46;
            PyObject *tmp_called_name_94;
            PyObject *tmp_mvar_value_47;
            PyObject *tmp_called_name_95;
            PyObject *tmp_mvar_value_48;
            PyObject *tmp_called_name_96;
            PyObject *tmp_mvar_value_49;
            PyObject *tmp_called_name_97;
            PyObject *tmp_mvar_value_50;
            PyObject *tmp_called_name_98;
            PyObject *tmp_mvar_value_51;
            PyObject *tmp_called_name_99;
            PyObject *tmp_mvar_value_52;
            PyObject *tmp_called_name_100;
            PyObject *tmp_mvar_value_53;
            PyObject *tmp_called_name_101;
            PyObject *tmp_mvar_value_54;
            PyObject *tmp_called_name_102;
            PyObject *tmp_mvar_value_55;
            tmp_mvar_value_46 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Network );

            if (unlikely( tmp_mvar_value_46 == NULL ))
            {
                tmp_mvar_value_46 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Network );
            }

            if ( tmp_mvar_value_46 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv6Network" );
                exception_tb = NULL;

                exception_lineno = 2399;

                goto frame_exception_exit_13;
            }

            tmp_called_name_93 = tmp_mvar_value_46;
            frame_e4f047505da49281bb85f001a8969afe_13->m_frame.f_lineno = 2399;
            tmp_list_element_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_93, &PyTuple_GET_ITEM( const_tuple_unicode_digest_55950b0245a58fcb76cb0333c18a4a6a_tuple, 0 ) );

            if ( tmp_list_element_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2399;

                goto frame_exception_exit_13;
            }
            tmp_dictset_value = PyList_New( 10 );
            PyList_SET_ITEM( tmp_dictset_value, 0, tmp_list_element_2 );
            tmp_mvar_value_47 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Network );

            if (unlikely( tmp_mvar_value_47 == NULL ))
            {
                tmp_mvar_value_47 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Network );
            }

            if ( tmp_mvar_value_47 == NULL )
            {
                Py_DECREF( tmp_dictset_value );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv6Network" );
                exception_tb = NULL;

                exception_lineno = 2400;

                goto frame_exception_exit_13;
            }

            tmp_called_name_94 = tmp_mvar_value_47;
            frame_e4f047505da49281bb85f001a8969afe_13->m_frame.f_lineno = 2400;
            tmp_list_element_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_94, &PyTuple_GET_ITEM( const_tuple_unicode_digest_f639d7203410adb553caafbcf683161e_tuple, 0 ) );

            if ( tmp_list_element_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 2400;

                goto frame_exception_exit_13;
            }
            PyList_SET_ITEM( tmp_dictset_value, 1, tmp_list_element_2 );
            tmp_mvar_value_48 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Network );

            if (unlikely( tmp_mvar_value_48 == NULL ))
            {
                tmp_mvar_value_48 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Network );
            }

            if ( tmp_mvar_value_48 == NULL )
            {
                Py_DECREF( tmp_dictset_value );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv6Network" );
                exception_tb = NULL;

                exception_lineno = 2401;

                goto frame_exception_exit_13;
            }

            tmp_called_name_95 = tmp_mvar_value_48;
            frame_e4f047505da49281bb85f001a8969afe_13->m_frame.f_lineno = 2401;
            tmp_list_element_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_95, &PyTuple_GET_ITEM( const_tuple_unicode_digest_6439cf0468d27650b3db2b06ff3a5dd1_tuple, 0 ) );

            if ( tmp_list_element_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 2401;

                goto frame_exception_exit_13;
            }
            PyList_SET_ITEM( tmp_dictset_value, 2, tmp_list_element_2 );
            tmp_mvar_value_49 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Network );

            if (unlikely( tmp_mvar_value_49 == NULL ))
            {
                tmp_mvar_value_49 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Network );
            }

            if ( tmp_mvar_value_49 == NULL )
            {
                Py_DECREF( tmp_dictset_value );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv6Network" );
                exception_tb = NULL;

                exception_lineno = 2402;

                goto frame_exception_exit_13;
            }

            tmp_called_name_96 = tmp_mvar_value_49;
            frame_e4f047505da49281bb85f001a8969afe_13->m_frame.f_lineno = 2402;
            tmp_list_element_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_96, &PyTuple_GET_ITEM( const_tuple_unicode_digest_ecd03ef7f28ff15afa162f4a843d1037_tuple, 0 ) );

            if ( tmp_list_element_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 2402;

                goto frame_exception_exit_13;
            }
            PyList_SET_ITEM( tmp_dictset_value, 3, tmp_list_element_2 );
            tmp_mvar_value_50 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Network );

            if (unlikely( tmp_mvar_value_50 == NULL ))
            {
                tmp_mvar_value_50 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Network );
            }

            if ( tmp_mvar_value_50 == NULL )
            {
                Py_DECREF( tmp_dictset_value );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv6Network" );
                exception_tb = NULL;

                exception_lineno = 2403;

                goto frame_exception_exit_13;
            }

            tmp_called_name_97 = tmp_mvar_value_50;
            frame_e4f047505da49281bb85f001a8969afe_13->m_frame.f_lineno = 2403;
            tmp_list_element_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_97, &PyTuple_GET_ITEM( const_tuple_unicode_digest_4e68733735a043f5abfd5c4521f17847_tuple, 0 ) );

            if ( tmp_list_element_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 2403;

                goto frame_exception_exit_13;
            }
            PyList_SET_ITEM( tmp_dictset_value, 4, tmp_list_element_2 );
            tmp_mvar_value_51 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Network );

            if (unlikely( tmp_mvar_value_51 == NULL ))
            {
                tmp_mvar_value_51 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Network );
            }

            if ( tmp_mvar_value_51 == NULL )
            {
                Py_DECREF( tmp_dictset_value );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv6Network" );
                exception_tb = NULL;

                exception_lineno = 2404;

                goto frame_exception_exit_13;
            }

            tmp_called_name_98 = tmp_mvar_value_51;
            frame_e4f047505da49281bb85f001a8969afe_13->m_frame.f_lineno = 2404;
            tmp_list_element_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_98, &PyTuple_GET_ITEM( const_tuple_unicode_digest_101ebce5f61c0ce299ab3ac572b746e7_tuple, 0 ) );

            if ( tmp_list_element_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 2404;

                goto frame_exception_exit_13;
            }
            PyList_SET_ITEM( tmp_dictset_value, 5, tmp_list_element_2 );
            tmp_mvar_value_52 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Network );

            if (unlikely( tmp_mvar_value_52 == NULL ))
            {
                tmp_mvar_value_52 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Network );
            }

            if ( tmp_mvar_value_52 == NULL )
            {
                Py_DECREF( tmp_dictset_value );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv6Network" );
                exception_tb = NULL;

                exception_lineno = 2405;

                goto frame_exception_exit_13;
            }

            tmp_called_name_99 = tmp_mvar_value_52;
            frame_e4f047505da49281bb85f001a8969afe_13->m_frame.f_lineno = 2405;
            tmp_list_element_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_99, &PyTuple_GET_ITEM( const_tuple_unicode_digest_194dc6db10ba74e52f6ef24612e5a44f_tuple, 0 ) );

            if ( tmp_list_element_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 2405;

                goto frame_exception_exit_13;
            }
            PyList_SET_ITEM( tmp_dictset_value, 6, tmp_list_element_2 );
            tmp_mvar_value_53 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Network );

            if (unlikely( tmp_mvar_value_53 == NULL ))
            {
                tmp_mvar_value_53 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Network );
            }

            if ( tmp_mvar_value_53 == NULL )
            {
                Py_DECREF( tmp_dictset_value );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv6Network" );
                exception_tb = NULL;

                exception_lineno = 2406;

                goto frame_exception_exit_13;
            }

            tmp_called_name_100 = tmp_mvar_value_53;
            frame_e4f047505da49281bb85f001a8969afe_13->m_frame.f_lineno = 2406;
            tmp_list_element_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_100, &PyTuple_GET_ITEM( const_tuple_unicode_digest_58df9bee7efa43c9df04a29b6b187894_tuple, 0 ) );

            if ( tmp_list_element_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 2406;

                goto frame_exception_exit_13;
            }
            PyList_SET_ITEM( tmp_dictset_value, 7, tmp_list_element_2 );
            tmp_mvar_value_54 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Network );

            if (unlikely( tmp_mvar_value_54 == NULL ))
            {
                tmp_mvar_value_54 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Network );
            }

            if ( tmp_mvar_value_54 == NULL )
            {
                Py_DECREF( tmp_dictset_value );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv6Network" );
                exception_tb = NULL;

                exception_lineno = 2407;

                goto frame_exception_exit_13;
            }

            tmp_called_name_101 = tmp_mvar_value_54;
            frame_e4f047505da49281bb85f001a8969afe_13->m_frame.f_lineno = 2407;
            tmp_list_element_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_101, &PyTuple_GET_ITEM( const_tuple_unicode_digest_e9b7b96fb2ce3038ca93557a305aee61_tuple, 0 ) );

            if ( tmp_list_element_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 2407;

                goto frame_exception_exit_13;
            }
            PyList_SET_ITEM( tmp_dictset_value, 8, tmp_list_element_2 );
            tmp_mvar_value_55 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Network );

            if (unlikely( tmp_mvar_value_55 == NULL ))
            {
                tmp_mvar_value_55 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Network );
            }

            if ( tmp_mvar_value_55 == NULL )
            {
                Py_DECREF( tmp_dictset_value );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv6Network" );
                exception_tb = NULL;

                exception_lineno = 2408;

                goto frame_exception_exit_13;
            }

            tmp_called_name_102 = tmp_mvar_value_55;
            frame_e4f047505da49281bb85f001a8969afe_13->m_frame.f_lineno = 2408;
            tmp_list_element_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_102, &PyTuple_GET_ITEM( const_tuple_unicode_digest_aaa8df82589e3fcc3c5dc300a83c6345_tuple, 0 ) );

            if ( tmp_list_element_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 2408;

                goto frame_exception_exit_13;
            }
            PyList_SET_ITEM( tmp_dictset_value, 9, tmp_list_element_2 );
            tmp_res = PyDict_SetItem( locals_ipaddress_2392, const_str_plain__private_networks, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2398;

                goto frame_exception_exit_13;
            }
        }
        {
            PyObject *tmp_list_element_3;
            PyObject *tmp_called_name_103;
            PyObject *tmp_mvar_value_56;
            PyObject *tmp_called_name_104;
            PyObject *tmp_mvar_value_57;
            PyObject *tmp_called_name_105;
            PyObject *tmp_mvar_value_58;
            PyObject *tmp_called_name_106;
            PyObject *tmp_mvar_value_59;
            PyObject *tmp_called_name_107;
            PyObject *tmp_mvar_value_60;
            PyObject *tmp_called_name_108;
            PyObject *tmp_mvar_value_61;
            PyObject *tmp_called_name_109;
            PyObject *tmp_mvar_value_62;
            PyObject *tmp_called_name_110;
            PyObject *tmp_mvar_value_63;
            PyObject *tmp_called_name_111;
            PyObject *tmp_mvar_value_64;
            PyObject *tmp_called_name_112;
            PyObject *tmp_mvar_value_65;
            PyObject *tmp_called_name_113;
            PyObject *tmp_mvar_value_66;
            PyObject *tmp_called_name_114;
            PyObject *tmp_mvar_value_67;
            PyObject *tmp_called_name_115;
            PyObject *tmp_mvar_value_68;
            PyObject *tmp_called_name_116;
            PyObject *tmp_mvar_value_69;
            PyObject *tmp_called_name_117;
            PyObject *tmp_mvar_value_70;
            tmp_mvar_value_56 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Network );

            if (unlikely( tmp_mvar_value_56 == NULL ))
            {
                tmp_mvar_value_56 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Network );
            }

            if ( tmp_mvar_value_56 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv6Network" );
                exception_tb = NULL;

                exception_lineno = 2412;

                goto frame_exception_exit_13;
            }

            tmp_called_name_103 = tmp_mvar_value_56;
            frame_e4f047505da49281bb85f001a8969afe_13->m_frame.f_lineno = 2412;
            tmp_list_element_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_103, &PyTuple_GET_ITEM( const_tuple_unicode_digest_509911ef653d68dc2d9e8bf72450b69f_tuple, 0 ) );

            if ( tmp_list_element_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2412;

                goto frame_exception_exit_13;
            }
            tmp_dictset_value = PyList_New( 15 );
            PyList_SET_ITEM( tmp_dictset_value, 0, tmp_list_element_3 );
            tmp_mvar_value_57 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Network );

            if (unlikely( tmp_mvar_value_57 == NULL ))
            {
                tmp_mvar_value_57 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Network );
            }

            if ( tmp_mvar_value_57 == NULL )
            {
                Py_DECREF( tmp_dictset_value );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv6Network" );
                exception_tb = NULL;

                exception_lineno = 2412;

                goto frame_exception_exit_13;
            }

            tmp_called_name_104 = tmp_mvar_value_57;
            frame_e4f047505da49281bb85f001a8969afe_13->m_frame.f_lineno = 2412;
            tmp_list_element_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_104, &PyTuple_GET_ITEM( const_tuple_unicode_digest_5685a0dd95ca231c7a311dcc298d847e_tuple, 0 ) );

            if ( tmp_list_element_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 2412;

                goto frame_exception_exit_13;
            }
            PyList_SET_ITEM( tmp_dictset_value, 1, tmp_list_element_3 );
            tmp_mvar_value_58 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Network );

            if (unlikely( tmp_mvar_value_58 == NULL ))
            {
                tmp_mvar_value_58 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Network );
            }

            if ( tmp_mvar_value_58 == NULL )
            {
                Py_DECREF( tmp_dictset_value );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv6Network" );
                exception_tb = NULL;

                exception_lineno = 2413;

                goto frame_exception_exit_13;
            }

            tmp_called_name_105 = tmp_mvar_value_58;
            frame_e4f047505da49281bb85f001a8969afe_13->m_frame.f_lineno = 2413;
            tmp_list_element_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_105, &PyTuple_GET_ITEM( const_tuple_unicode_digest_5eb59a83c37d07a28c39bc523d9a7e7b_tuple, 0 ) );

            if ( tmp_list_element_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 2413;

                goto frame_exception_exit_13;
            }
            PyList_SET_ITEM( tmp_dictset_value, 2, tmp_list_element_3 );
            tmp_mvar_value_59 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Network );

            if (unlikely( tmp_mvar_value_59 == NULL ))
            {
                tmp_mvar_value_59 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Network );
            }

            if ( tmp_mvar_value_59 == NULL )
            {
                Py_DECREF( tmp_dictset_value );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv6Network" );
                exception_tb = NULL;

                exception_lineno = 2413;

                goto frame_exception_exit_13;
            }

            tmp_called_name_106 = tmp_mvar_value_59;
            frame_e4f047505da49281bb85f001a8969afe_13->m_frame.f_lineno = 2413;
            tmp_list_element_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_106, &PyTuple_GET_ITEM( const_tuple_unicode_digest_25403b7f1a1d82d5241e55405508207f_tuple, 0 ) );

            if ( tmp_list_element_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 2413;

                goto frame_exception_exit_13;
            }
            PyList_SET_ITEM( tmp_dictset_value, 3, tmp_list_element_3 );
            tmp_mvar_value_60 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Network );

            if (unlikely( tmp_mvar_value_60 == NULL ))
            {
                tmp_mvar_value_60 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Network );
            }

            if ( tmp_mvar_value_60 == NULL )
            {
                Py_DECREF( tmp_dictset_value );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv6Network" );
                exception_tb = NULL;

                exception_lineno = 2414;

                goto frame_exception_exit_13;
            }

            tmp_called_name_107 = tmp_mvar_value_60;
            frame_e4f047505da49281bb85f001a8969afe_13->m_frame.f_lineno = 2414;
            tmp_list_element_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_107, &PyTuple_GET_ITEM( const_tuple_unicode_digest_5bbe393519c9f8f834b0e4362b7f4892_tuple, 0 ) );

            if ( tmp_list_element_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 2414;

                goto frame_exception_exit_13;
            }
            PyList_SET_ITEM( tmp_dictset_value, 4, tmp_list_element_3 );
            tmp_mvar_value_61 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Network );

            if (unlikely( tmp_mvar_value_61 == NULL ))
            {
                tmp_mvar_value_61 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Network );
            }

            if ( tmp_mvar_value_61 == NULL )
            {
                Py_DECREF( tmp_dictset_value );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv6Network" );
                exception_tb = NULL;

                exception_lineno = 2414;

                goto frame_exception_exit_13;
            }

            tmp_called_name_108 = tmp_mvar_value_61;
            frame_e4f047505da49281bb85f001a8969afe_13->m_frame.f_lineno = 2414;
            tmp_list_element_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_108, &PyTuple_GET_ITEM( const_tuple_unicode_digest_d399497e3404869de2f90bc4536c2cea_tuple, 0 ) );

            if ( tmp_list_element_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 2414;

                goto frame_exception_exit_13;
            }
            PyList_SET_ITEM( tmp_dictset_value, 5, tmp_list_element_3 );
            tmp_mvar_value_62 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Network );

            if (unlikely( tmp_mvar_value_62 == NULL ))
            {
                tmp_mvar_value_62 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Network );
            }

            if ( tmp_mvar_value_62 == NULL )
            {
                Py_DECREF( tmp_dictset_value );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv6Network" );
                exception_tb = NULL;

                exception_lineno = 2415;

                goto frame_exception_exit_13;
            }

            tmp_called_name_109 = tmp_mvar_value_62;
            frame_e4f047505da49281bb85f001a8969afe_13->m_frame.f_lineno = 2415;
            tmp_list_element_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_109, &PyTuple_GET_ITEM( const_tuple_unicode_digest_fdc180e651f53b5645d6e63208353e99_tuple, 0 ) );

            if ( tmp_list_element_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 2415;

                goto frame_exception_exit_13;
            }
            PyList_SET_ITEM( tmp_dictset_value, 6, tmp_list_element_3 );
            tmp_mvar_value_63 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Network );

            if (unlikely( tmp_mvar_value_63 == NULL ))
            {
                tmp_mvar_value_63 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Network );
            }

            if ( tmp_mvar_value_63 == NULL )
            {
                Py_DECREF( tmp_dictset_value );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv6Network" );
                exception_tb = NULL;

                exception_lineno = 2415;

                goto frame_exception_exit_13;
            }

            tmp_called_name_110 = tmp_mvar_value_63;
            frame_e4f047505da49281bb85f001a8969afe_13->m_frame.f_lineno = 2415;
            tmp_list_element_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_110, &PyTuple_GET_ITEM( const_tuple_unicode_digest_2e6e3f3d6b32093f8fc77c323d7c6fb9_tuple, 0 ) );

            if ( tmp_list_element_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 2415;

                goto frame_exception_exit_13;
            }
            PyList_SET_ITEM( tmp_dictset_value, 7, tmp_list_element_3 );
            tmp_mvar_value_64 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Network );

            if (unlikely( tmp_mvar_value_64 == NULL ))
            {
                tmp_mvar_value_64 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Network );
            }

            if ( tmp_mvar_value_64 == NULL )
            {
                Py_DECREF( tmp_dictset_value );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv6Network" );
                exception_tb = NULL;

                exception_lineno = 2416;

                goto frame_exception_exit_13;
            }

            tmp_called_name_111 = tmp_mvar_value_64;
            frame_e4f047505da49281bb85f001a8969afe_13->m_frame.f_lineno = 2416;
            tmp_list_element_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_111, &PyTuple_GET_ITEM( const_tuple_unicode_digest_e387280a229c9db974e6c776d288bba6_tuple, 0 ) );

            if ( tmp_list_element_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 2416;

                goto frame_exception_exit_13;
            }
            PyList_SET_ITEM( tmp_dictset_value, 8, tmp_list_element_3 );
            tmp_mvar_value_65 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Network );

            if (unlikely( tmp_mvar_value_65 == NULL ))
            {
                tmp_mvar_value_65 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Network );
            }

            if ( tmp_mvar_value_65 == NULL )
            {
                Py_DECREF( tmp_dictset_value );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv6Network" );
                exception_tb = NULL;

                exception_lineno = 2416;

                goto frame_exception_exit_13;
            }

            tmp_called_name_112 = tmp_mvar_value_65;
            frame_e4f047505da49281bb85f001a8969afe_13->m_frame.f_lineno = 2416;
            tmp_list_element_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_112, &PyTuple_GET_ITEM( const_tuple_unicode_digest_59b4c80820858f6425abaee2308ec366_tuple, 0 ) );

            if ( tmp_list_element_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 2416;

                goto frame_exception_exit_13;
            }
            PyList_SET_ITEM( tmp_dictset_value, 9, tmp_list_element_3 );
            tmp_mvar_value_66 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Network );

            if (unlikely( tmp_mvar_value_66 == NULL ))
            {
                tmp_mvar_value_66 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Network );
            }

            if ( tmp_mvar_value_66 == NULL )
            {
                Py_DECREF( tmp_dictset_value );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv6Network" );
                exception_tb = NULL;

                exception_lineno = 2417;

                goto frame_exception_exit_13;
            }

            tmp_called_name_113 = tmp_mvar_value_66;
            frame_e4f047505da49281bb85f001a8969afe_13->m_frame.f_lineno = 2417;
            tmp_list_element_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_113, &PyTuple_GET_ITEM( const_tuple_unicode_digest_320cdcbfee5f1bed6142c1ec68d8d1b4_tuple, 0 ) );

            if ( tmp_list_element_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 2417;

                goto frame_exception_exit_13;
            }
            PyList_SET_ITEM( tmp_dictset_value, 10, tmp_list_element_3 );
            tmp_mvar_value_67 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Network );

            if (unlikely( tmp_mvar_value_67 == NULL ))
            {
                tmp_mvar_value_67 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Network );
            }

            if ( tmp_mvar_value_67 == NULL )
            {
                Py_DECREF( tmp_dictset_value );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv6Network" );
                exception_tb = NULL;

                exception_lineno = 2417;

                goto frame_exception_exit_13;
            }

            tmp_called_name_114 = tmp_mvar_value_67;
            frame_e4f047505da49281bb85f001a8969afe_13->m_frame.f_lineno = 2417;
            tmp_list_element_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_114, &PyTuple_GET_ITEM( const_tuple_unicode_digest_5b7f2e4a3310487a05cd73dbdc2ec2d9_tuple, 0 ) );

            if ( tmp_list_element_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 2417;

                goto frame_exception_exit_13;
            }
            PyList_SET_ITEM( tmp_dictset_value, 11, tmp_list_element_3 );
            tmp_mvar_value_68 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Network );

            if (unlikely( tmp_mvar_value_68 == NULL ))
            {
                tmp_mvar_value_68 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Network );
            }

            if ( tmp_mvar_value_68 == NULL )
            {
                Py_DECREF( tmp_dictset_value );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv6Network" );
                exception_tb = NULL;

                exception_lineno = 2418;

                goto frame_exception_exit_13;
            }

            tmp_called_name_115 = tmp_mvar_value_68;
            frame_e4f047505da49281bb85f001a8969afe_13->m_frame.f_lineno = 2418;
            tmp_list_element_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_115, &PyTuple_GET_ITEM( const_tuple_unicode_digest_9462791757a5ac738cf1ca2dd1f09e95_tuple, 0 ) );

            if ( tmp_list_element_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 2418;

                goto frame_exception_exit_13;
            }
            PyList_SET_ITEM( tmp_dictset_value, 12, tmp_list_element_3 );
            tmp_mvar_value_69 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Network );

            if (unlikely( tmp_mvar_value_69 == NULL ))
            {
                tmp_mvar_value_69 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Network );
            }

            if ( tmp_mvar_value_69 == NULL )
            {
                Py_DECREF( tmp_dictset_value );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv6Network" );
                exception_tb = NULL;

                exception_lineno = 2418;

                goto frame_exception_exit_13;
            }

            tmp_called_name_116 = tmp_mvar_value_69;
            frame_e4f047505da49281bb85f001a8969afe_13->m_frame.f_lineno = 2418;
            tmp_list_element_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_116, &PyTuple_GET_ITEM( const_tuple_unicode_digest_ed7b60fe5be95741a2db22da8e4c1100_tuple, 0 ) );

            if ( tmp_list_element_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 2418;

                goto frame_exception_exit_13;
            }
            PyList_SET_ITEM( tmp_dictset_value, 13, tmp_list_element_3 );
            tmp_mvar_value_70 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Network );

            if (unlikely( tmp_mvar_value_70 == NULL ))
            {
                tmp_mvar_value_70 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Network );
            }

            if ( tmp_mvar_value_70 == NULL )
            {
                Py_DECREF( tmp_dictset_value );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv6Network" );
                exception_tb = NULL;

                exception_lineno = 2419;

                goto frame_exception_exit_13;
            }

            tmp_called_name_117 = tmp_mvar_value_70;
            frame_e4f047505da49281bb85f001a8969afe_13->m_frame.f_lineno = 2419;
            tmp_list_element_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_117, &PyTuple_GET_ITEM( const_tuple_unicode_digest_07222984af8a611c2d56ff1f58bcbed2_tuple, 0 ) );

            if ( tmp_list_element_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 2419;

                goto frame_exception_exit_13;
            }
            PyList_SET_ITEM( tmp_dictset_value, 14, tmp_list_element_3 );
            tmp_res = PyDict_SetItem( locals_ipaddress_2392, const_str_plain__reserved_networks, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2411;

                goto frame_exception_exit_13;
            }
        }
        {
            PyObject *tmp_called_name_118;
            PyObject *tmp_mvar_value_71;
            tmp_mvar_value_71 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Network );

            if (unlikely( tmp_mvar_value_71 == NULL ))
            {
                tmp_mvar_value_71 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Network );
            }

            if ( tmp_mvar_value_71 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv6Network" );
                exception_tb = NULL;

                exception_lineno = 2422;

                goto frame_exception_exit_13;
            }

            tmp_called_name_118 = tmp_mvar_value_71;
            frame_e4f047505da49281bb85f001a8969afe_13->m_frame.f_lineno = 2422;
            tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_118, &PyTuple_GET_ITEM( const_tuple_unicode_digest_dd933a225f1d557f2f9048900cc16f9b_tuple, 0 ) );

            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2422;

                goto frame_exception_exit_13;
            }
            tmp_res = PyDict_SetItem( locals_ipaddress_2392, const_str_plain__sitelocal_network, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2422;

                goto frame_exception_exit_13;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_e4f047505da49281bb85f001a8969afe_13 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_12;

        frame_exception_exit_13:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_e4f047505da49281bb85f001a8969afe_13 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_e4f047505da49281bb85f001a8969afe_13, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_e4f047505da49281bb85f001a8969afe_13->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_e4f047505da49281bb85f001a8969afe_13, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_e4f047505da49281bb85f001a8969afe_13,
            type_description_2
        );


        // Release cached frame.
        if ( frame_e4f047505da49281bb85f001a8969afe_13 == cache_frame_e4f047505da49281bb85f001a8969afe_13 )
        {
            Py_DECREF( frame_e4f047505da49281bb85f001a8969afe_13 );
        }
        cache_frame_e4f047505da49281bb85f001a8969afe_13 = NULL;

        assertFrameObject( frame_e4f047505da49281bb85f001a8969afe_13 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_12;

        frame_no_exception_12:;
        goto skip_nested_handling_12;
        nested_frame_exit_12:;

        goto try_except_handler_49;
        skip_nested_handling_12:;
        tmp_assign_source_114 = locals_ipaddress_2392;
        Py_INCREF( tmp_assign_source_114 );
        goto try_return_handler_49;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_49:;
        Py_DECREF( locals_ipaddress_2392 );
        locals_ipaddress_2392 = NULL;
        goto outline_result_23;
        // Exception handler code:
        try_except_handler_49:;
        exception_keeper_type_37 = exception_type;
        exception_keeper_value_37 = exception_value;
        exception_keeper_tb_37 = exception_tb;
        exception_keeper_lineno_37 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_ipaddress_2392 );
        locals_ipaddress_2392 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_37;
        exception_value = exception_keeper_value_37;
        exception_tb = exception_keeper_tb_37;
        exception_lineno = exception_keeper_lineno_37;

        goto outline_exception_12;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( ipaddress );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_12:;
        exception_lineno = 2392;
        goto try_except_handler_48;
        outline_result_23:;
        assert( tmp_class_creation_16__class_dict == NULL );
        tmp_class_creation_16__class_dict = tmp_assign_source_114;
    }
    {
        PyObject *tmp_assign_source_115;
        nuitka_bool tmp_condition_result_18;
        PyObject *tmp_key_name_31;
        PyObject *tmp_dict_name_31;
        PyObject *tmp_dict_name_32;
        PyObject *tmp_key_name_32;
        tmp_key_name_31 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_16__class_dict );
        tmp_dict_name_31 = tmp_class_creation_16__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_31, tmp_key_name_31 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2392;

            goto try_except_handler_48;
        }
        tmp_condition_result_18 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_18 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_16;
        }
        else
        {
            goto condexpr_false_16;
        }
        condexpr_true_16:;
        CHECK_OBJECT( tmp_class_creation_16__class_dict );
        tmp_dict_name_32 = tmp_class_creation_16__class_dict;
        tmp_key_name_32 = const_str_plain___metaclass__;
        tmp_assign_source_115 = DICT_GET_ITEM( tmp_dict_name_32, tmp_key_name_32 );
        if ( tmp_assign_source_115 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2392;

            goto try_except_handler_48;
        }
        goto condexpr_end_16;
        condexpr_false_16:;
        tmp_assign_source_115 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_assign_source_115 );
        condexpr_end_16:;
        assert( tmp_class_creation_16__metaclass == NULL );
        tmp_class_creation_16__metaclass = tmp_assign_source_115;
    }
    {
        PyObject *tmp_assign_source_116;
        PyObject *tmp_called_name_119;
        PyObject *tmp_args_element_name_101;
        PyObject *tmp_args_element_name_102;
        PyObject *tmp_args_element_name_103;
        CHECK_OBJECT( tmp_class_creation_16__metaclass );
        tmp_called_name_119 = tmp_class_creation_16__metaclass;
        tmp_args_element_name_101 = const_str_plain__IPv6Constants;
        tmp_args_element_name_102 = const_tuple_type_object_tuple;
        CHECK_OBJECT( tmp_class_creation_16__class_dict );
        tmp_args_element_name_103 = tmp_class_creation_16__class_dict;
        frame_a10b4ee15c0763ecce4ab0022f0f5fa7->m_frame.f_lineno = 2392;
        {
            PyObject *call_args[] = { tmp_args_element_name_101, tmp_args_element_name_102, tmp_args_element_name_103 };
            tmp_assign_source_116 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_119, call_args );
        }

        if ( tmp_assign_source_116 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2392;

            goto try_except_handler_48;
        }
        assert( tmp_class_creation_16__class == NULL );
        tmp_class_creation_16__class = tmp_assign_source_116;
    }
    goto try_end_17;
    // Exception handler code:
    try_except_handler_48:;
    exception_keeper_type_38 = exception_type;
    exception_keeper_value_38 = exception_value;
    exception_keeper_tb_38 = exception_tb;
    exception_keeper_lineno_38 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_16__class_dict );
    tmp_class_creation_16__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_16__metaclass );
    tmp_class_creation_16__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_38;
    exception_value = exception_keeper_value_38;
    exception_tb = exception_keeper_tb_38;
    exception_lineno = exception_keeper_lineno_38;

    goto frame_exception_exit_1;
    // End of try:
    try_end_17:;
    {
        PyObject *tmp_assign_source_117;
        CHECK_OBJECT( tmp_class_creation_16__class );
        tmp_assign_source_117 = tmp_class_creation_16__class;
        UPDATE_STRING_DICT0( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__IPv6Constants, tmp_assign_source_117 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_16__class );
    Py_DECREF( tmp_class_creation_16__class );
    tmp_class_creation_16__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_16__class_dict );
    Py_DECREF( tmp_class_creation_16__class_dict );
    tmp_class_creation_16__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_16__metaclass );
    Py_DECREF( tmp_class_creation_16__metaclass );
    tmp_class_creation_16__metaclass = NULL;

    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_mvar_value_72;
        PyObject *tmp_assattr_target_2;
        PyObject *tmp_mvar_value_73;
        tmp_mvar_value_72 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain__IPv6Constants );

        if (unlikely( tmp_mvar_value_72 == NULL ))
        {
            tmp_mvar_value_72 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__IPv6Constants );
        }

        if ( tmp_mvar_value_72 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_IPv6Constants" );
            exception_tb = NULL;

            exception_lineno = 2425;

            goto frame_exception_exit_1;
        }

        tmp_assattr_name_2 = tmp_mvar_value_72;
        tmp_mvar_value_73 = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain_IPv6Address );

        if (unlikely( tmp_mvar_value_73 == NULL ))
        {
            tmp_mvar_value_73 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_IPv6Address );
        }

        if ( tmp_mvar_value_73 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "IPv6Address" );
            exception_tb = NULL;

            exception_lineno = 2425;

            goto frame_exception_exit_1;
        }

        tmp_assattr_target_2 = tmp_mvar_value_73;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__constants, tmp_assattr_name_2 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2425;

            goto frame_exception_exit_1;
        }
    }

    // Restore frame exception if necessary.
#if 1
    RESTORE_FRAME_EXCEPTION( frame_a10b4ee15c0763ecce4ab0022f0f5fa7 );
#endif
    popFrameStack();

    assertFrameObject( frame_a10b4ee15c0763ecce4ab0022f0f5fa7 );

    goto frame_no_exception_13;

    frame_exception_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_a10b4ee15c0763ecce4ab0022f0f5fa7 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a10b4ee15c0763ecce4ab0022f0f5fa7, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a10b4ee15c0763ecce4ab0022f0f5fa7->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a10b4ee15c0763ecce4ab0022f0f5fa7, exception_lineno );
    }

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto module_exception_exit;

    frame_no_exception_13:;

#if _NUITKA_EXPERIMENTAL_PKGUTIL_ITERMODULES
#if 0 && 0
    {
        PyObject *path_value = GET_STRING_DICT_VALUE( moduledict_ipaddress, (Nuitka_StringObject *)const_str_plain___path__ );

        if (path_value && PyList_CheckExact(path_value) && PyList_Size(path_value) > 0)
        {
            PyObject *path_element = PyList_GetItem( path_value, 0 );

            PyObject *path_importer_cache = PySys_GetObject((char *)"path_importer_cache");
            CHECK_OBJECT( path_importer_cache );

            int res = PyDict_SetItem( path_importer_cache, path_element, (PyObject *)&Nuitka_Loader_Type );
            assert( res == 0 );
        }
    }
#endif
#endif

    return MOD_RETURN_VALUE( module_ipaddress );
    module_exception_exit:
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );
    return MOD_RETURN_VALUE( NULL );
}
